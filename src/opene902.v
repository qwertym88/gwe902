
/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
`define PRODUCT_ID 12'h000




`define RESET_VAL 16'hABCD




`define REVISION    4'd2
`define SUB_VERSION 6'd2
`define PATCH       6'd2




`define FPGA_MEM














































`define USER_MODE
`ifdef USER_MODE
  //`define MACHINE_SP
`endif




`define CLIC_MODE
















`define GPR_16









`define VEC_BASE





`define LOAD_FAST_RETIRE













`define MAD_SMALL



















`define IAHB_LITE


`ifdef IAHB_LITE
  //`define FLOP_OUT_IBUS
  //`define IBUS_16
  `define IBUS_32
`endif






`define SYS_AHB_LITE






`define BIU_32




`ifdef FLOP_OUT_BIU
`define FLOP_OUT_BUS
`else
  `ifdef FLOP_OUT_IBUS
  `define FLOP_OUT_BUS
  `else
    `ifdef FLOP_OUT_DBUS
    `define FLOP_OUT_BUS
    `else
    `endif
  `endif
`endif








`define PMP

`ifdef PMP
  //`define PMP_REGION_2
  //`define PMP_REGION_4
  `define PMP_REGION_8
  //`define PMP_REGION_16
`endif

`ifdef PMP_REGION_2
  `define REGION_ENTRY0
  `define REGION_ENTRY1
`endif

`ifdef PMP_REGION_4
  `define REGION_ENTRY0
  `define REGION_ENTRY1
  `define REGION_ENTRY2
  `define REGION_ENTRY3
`endif

`ifdef PMP_REGION_8
  `define REGION_ENTRY0
  `define REGION_ENTRY1
  `define REGION_ENTRY2
  `define REGION_ENTRY3
  `define REGION_ENTRY4
  `define REGION_ENTRY5
  `define REGION_ENTRY6
  `define REGION_ENTRY7
`endif

`ifdef PMP_REGION_16
  `define REGION_ENTRY0
  `define REGION_ENTRY1
  `define REGION_ENTRY2
  `define REGION_ENTRY3
  `define REGION_ENTRY4
  `define REGION_ENTRY5
  `define REGION_ENTRY6
  `define REGION_ENTRY7
  `define REGION_ENTRY8
  `define REGION_ENTRY9
  `define REGION_ENTRY10
  `define REGION_ENTRY11
  `define REGION_ENTRY12
  `define REGION_ENTRY13
  `define REGION_ENTRY14
  `define REGION_ENTRY15
`endif
















`define TCIPIF

`ifdef TCIPIF


  //`define CTIM     // Core Timer Hareware Implementation
  `ifdef CLIC_MODE
    `define CLIC      // Interrupt controller Configuration
  `endif

`endif

`ifdef CLIC
  // Attention:
  //   1. EXT_INT_NUM *MUST* > 0.
  //   2. If you don't want to use extensional clic int, use //`define EXT_INT_NUM rather than change EXT_INT_NUM to 0.
  //   3. If EXT_INT_NUM > 48, you need define CLIC_2_CYCLES unless the timing is loose.
  //   4. Don't change definition of CLIC_INTNUM.

  `define CLIC_INTCTLBITS      3
  `define EXT_INT_NUM          64

  `ifdef EXT_INT_NUM
    `define CLIC_INTNUM   `EXT_INT_NUM+16
  `else
    `define CLIC_INTNUM   16
    `define INT_NUM_16
  `endif
`endif






















`ifdef CACHE
  `define CACHE_2K
  //`define CACHE_4K
  //`define CACHE_8K
`endif

`ifdef CACHE
  `define CACHE_2WAY
  //`define CACHE_4WAY
`endif

`ifdef CACHE
  `define CACHE_LINE_16B
  //`define CACHE_LINE_32B
`endif

`ifdef CACHE
  //`define CACHE_REGION_1
  `define CACHE_REGION_2
  //`define CACHE_REGION_3
  //`define CACHE_REGION_4
`endif

`ifdef CACHE_REGION_4
  `define REGION_REG3
  `define REGION_REG2
  `define REGION_REG1
  `define REGION_REG0
`endif

`ifdef CACHE_REGION_3
  `define REGION_REG2
  `define REGION_REG1
  `define REGION_REG0
`endif

`ifdef CACHE_REGION_2
  `define REGION_REG1
  `define REGION_REG0
`endif

`ifdef CACHE_REGION_1
  `define REGION_REG0
`endif

`ifdef CACHE
  //`define CACHE_USER_DEFINED
`endif

`ifdef CACHE
  //`define CACHE_MBIST
`endif

`ifdef CACHE
  //`define CACHE_LFIDLE_REQ
`endif















`define HAD_IM

`ifdef HAD_IM
  //`define PCFIFO_FOR_DBG
  `define HAD_JTAG_2
  `define HAD_MBKPTB //now, MBKPTB indicates five breakpoints: A, B, C, D, E
  `ifdef HAD_MBKPTB
    //`define HAD_MBKPT_7 //indicates other four breakpoints: F, G
    //`define HAD_MBKPT_9 //indicates other four breakpoints: F, G, H, I
  `endif
  //`define HAD_INST_DEBUG_DISABLE
  //`define HAD_PROF_CNT
  //`define DDMA //debug direct memory access
  `ifdef TCIPIF
    //`define DBG_EXP // debug exception
    `define CSKY_DCC
  `endif
`endif


`define NO_PRE_DECODE
/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module clic_kid_golden_ports(
  pad_clic_int_vld
);

// &Wires; @3

// &Ports; @4
input   [63:0]  pad_clic_int_vld; 

// &Force("input", "pad_clic_int_vld"); &Force("bus", "pad_clic_int_vld", `CLIC_INTNUM-17, 0); @6
// &ModuleEnd; @8
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_ahbl_if(
  ahbLif_ahbl_haddr,
  ahbLif_ahbl_hburst,
  ahbLif_ahbl_hprot,
  ahbLif_ahbl_hsize,
  ahbLif_ahbl_htrans,
  ahbLif_ahbl_hwdata,
  ahbLif_ahbl_hwrite,
  ahbl_ahbLif_hrdata,
  ahbl_ahbLif_hready,
  ahbl_ahbLif_hresp,
  ahbl_clk_en,
  ahbl_gated_clk,
  ahblif_busy,
  ahblif_idle,
  ahblif_power_mask,
  cpu_acc_err,
  cpu_addr,
  cpu_data_vld,
  cpu_prot,
  cpu_rdata,
  cpu_req,
  cpu_req_grnt,
  cpu_req_power_masked,
  cpu_sec,
  cpu_size,
  cpu_trans_cmplt,
  cpu_vec_redirect,
  cpu_wdata_sel,
  cpu_wr_data,
  cpu_write,
  cpurst_b,
  pad_cpu_halt_ff2
);

// &Ports; @24
input   [31:0]  ahbl_ahbLif_hrdata;    
input           ahbl_ahbLif_hready;    
input           ahbl_ahbLif_hresp;     
input           ahbl_gated_clk;        
input           ahblif_power_mask;     
input   [31:0]  cpu_addr;              
input   [3 :0]  cpu_prot;              
input           cpu_req;               
input           cpu_req_power_masked;  
input   [1 :0]  cpu_size;              
input           cpu_vec_redirect;      
input   [31:0]  cpu_wr_data;           
input           cpu_write;             
input           cpurst_b;              
input           pad_cpu_halt_ff2;      
output  [31:0]  ahbLif_ahbl_haddr;     
output  [2 :0]  ahbLif_ahbl_hburst;    
output  [3 :0]  ahbLif_ahbl_hprot;     
output  [2 :0]  ahbLif_ahbl_hsize;     
output  [1 :0]  ahbLif_ahbl_htrans;    
output  [31:0]  ahbLif_ahbl_hwdata;    
output          ahbLif_ahbl_hwrite;    
output          ahbl_clk_en;           
output          ahblif_busy;           
output          ahblif_idle;           
output          cpu_acc_err;           
output          cpu_data_vld;          
output  [31:0]  cpu_rdata;             
output          cpu_req_grnt;          
output          cpu_sec;               
output          cpu_trans_cmplt;       
output          cpu_wdata_sel;         

// &Regs; @25
reg     [2 :0]  ahbLif_cur_state;      
reg     [2 :0]  ahbLif_nxt_state;      
reg             buf_write;             

// &Wires; @26
wire            acc_err;               
wire    [31:0]  ahbLif_ahbl_haddr;     
wire    [2 :0]  ahbLif_ahbl_hburst;    
wire    [3 :0]  ahbLif_ahbl_hprot;     
wire    [2 :0]  ahbLif_ahbl_hsize;     
wire    [1 :0]  ahbLif_ahbl_htrans;    
wire    [31:0]  ahbLif_ahbl_hwdata;    
wire            ahbLif_ahbl_hwrite;    
wire            ahbLif_ahbl_vec_redrct; 
wire    [31:0]  ahbl_ahbLif_hrdata;    
wire            ahbl_ahbLif_hready;    
wire            ahbl_ahbLif_hresp;     
wire            ahbl_ahbLif_hsec;      
wire            ahbl_clk_en;           
wire            ahbl_gated_clk;        
wire            ahblif_busy;           
wire            ahblif_idle;           
wire            ahblif_power_mask;     
wire    [31:0]  bus_rdata;             
wire            bus_ready;             
wire            bus_resp;              
wire            bus_sec;               
wire            cpu_acc_err;           
wire    [31:0]  cpu_addr;              
wire            cpu_data_vld;          
wire    [3 :0]  cpu_prot;              
wire    [31:0]  cpu_rdata;             
wire            cpu_req;               
wire            cpu_req_grnt;          
wire            cpu_req_power_masked;  
wire            cpu_sec;               
wire    [1 :0]  cpu_size;              
wire            cpu_trans_cmplt;       
wire            cpu_vec_redirect;      
wire            cpu_wdata_sel;         
wire    [31:0]  cpu_wr_data;           
wire            cpu_write;             
wire            cpurst_b;              
wire            data_vld;              
wire    [31:0]  hwdata;                
wire            pad_cpu_halt_ff2;      
wire            req_grnt;              
wire            trans_cmplt;           


parameter DATA_WIDTH = 32;
//==============================================================================
//
//                 AHB LITE master interface FSM
//
//==============================================================================
//1. control one transfer: SINGLE
//2. generate control signals for AHB LITE control signals: HTRANS, HCTRL

//===================================================================
//     parameter description
//IDLE  : wait for the cpu request; when cpu has request and hready, 
//        control information is put on the AHB LITE in this state.
//WFD   : wait for the data from the AHB LITE; if back-to-back 
//        transfer occur, the fsm will stay in the state.
//ERROR : wait for the second phase of the two signal error response.
//ERROR1: generate the error vld signal to cpu.
//===================================================================
parameter IDLE   = 3'b000,
          WFD    = 3'b001,
          WFG    = 3'b010,
          ERROR1 = 3'b110,
          ERROR2 = 3'b111;

//==========================================================
//     FSM main body
//==========================================================
always@(posedge ahbl_gated_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    ahbLif_cur_state[2:0] <= IDLE;
  else
  begin
      ahbLif_cur_state[2:0] <= ahbLif_nxt_state[2:0];
  end
end 

// &CombBeg; @65
always @( cpu_req_power_masked
       or bus_ready
       or ahbLif_cur_state
       or cpu_req
       or bus_resp
       or pad_cpu_halt_ff2)
begin
case(ahbLif_cur_state)
  IDLE: 
  begin
    if(cpu_req_power_masked && !pad_cpu_halt_ff2) 
      if(bus_ready)
        ahbLif_nxt_state = WFD;
      else //no ready
        ahbLif_nxt_state = WFG;
    else //no request
      ahbLif_nxt_state = IDLE;
  end
  WFG: 
  begin
    if(cpu_req)
      if(bus_ready)
        ahbLif_nxt_state = WFD;
      else //no ready
        ahbLif_nxt_state = WFG;
    else //no request
      ahbLif_nxt_state = IDLE;
  end
  WFD:   // in this state AHBL wait for the data.
  begin
    if(bus_resp) //resp is ERROR
      ahbLif_nxt_state = ERROR1;
    else if(!bus_ready) //resp == OK, hready == 0
      ahbLif_nxt_state = WFD;
    else //resp == OK, hready == 1
    begin
      if(cpu_req)
        ahbLif_nxt_state = WFD;
      else
        ahbLif_nxt_state = IDLE;
    end
  end
  ERROR1: // error occurs
  begin
    if(bus_resp)               // resp is ERROR
      if(!bus_ready)           // ready == 0
        ahbLif_nxt_state = ERROR1;
      else
        ahbLif_nxt_state = ERROR2; // bus resp is ERROR, hready == 1
    else
      ahbLif_nxt_state = ERROR2; // bus resp is ERROR, hready == 1
  end
  ERROR2: // error occurs
  begin
    ahbLif_nxt_state = IDLE; 
  end
  default:
    ahbLif_nxt_state = IDLE;
endcase
// &CombEnd; @118
end

//===========================================================
//     FSM output signal 
//===========================================================

always @( posedge ahbl_gated_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    buf_write <= 1'b0;
  else if(cpu_req && req_grnt)
    buf_write <= cpu_write;
end
assign cpu_wdata_sel = buf_write;

//==================================================
//            cpu grant singal
//==================================================
assign req_grnt = ((ahbLif_cur_state[2:0]==IDLE && !ahblif_power_mask && !pad_cpu_halt_ff2)
                 || ahbLif_cur_state[2:0]==WFG
                 || ahbLif_cur_state[2:0]==WFD)
                 && bus_ready && !bus_resp;

//==================================================
//            trans complete singal
//==================================================
assign trans_cmplt  = (ahbLif_cur_state[2:0]==WFD) &&  bus_ready && !bus_resp
                   || (ahbLif_cur_state[2:0]==ERROR2); //error vld
                    

//==================================================
//            data valid singal
//==================================================
assign data_vld = (ahbLif_cur_state[2:0]==WFD) && !buf_write
                && bus_ready && !bus_resp;

//==================================================
//            access error valid singal
//==================================================
assign acc_err = (ahbLif_cur_state[2:0]==ERROR2);


//==============================================================================
//
//                       AHB LITE BUS interface signal
//
//==============================================================================

//==============================================================================
//     AHB LITE -> AHBL signals
//==============================================================================
assign bus_ready        = ahbl_ahbLif_hready;
assign bus_resp         = ahbl_ahbLif_hresp;

assign bus_rdata[DATA_WIDTH-1:0] = ahbl_ahbLif_hrdata[DATA_WIDTH-1:0];

assign ahbl_ahbLif_hsec = 1'b0;


assign bus_sec                   = ahbl_ahbLif_hsec;



//==============================================================================
//     AHBL -> AHB LITE signals
//==============================================================================
//==========================================================
//     HADDR
//==========================================================
assign ahbLif_ahbl_haddr[31:0] = cpu_addr[31:0];

//==========================================================
//     HWDATA
//==========================================================

// &Instance("cr_beu_enc32", "x_cr_biu_wdata_enc"); @215
// &Connect(.data_in(cpu_wr_data), @216
//          .f_key0 (pad_biu_beu_key0), @217
//          .f_key1 (pad_biu_beu_key1), @218
//          .data_out(cpu_cwdata) @219
// ); @220
//   &Instance("cr_ahbl_scram", "x_cr_biu_wdata_scram"); @224
//   &Connect(.data_in(cpu_wr_data), @225
//            .f_key0 (pad_biu_beu_key0), @226
//            .f_key1 (pad_biu_beu_key1), @227
//            .data_out(cpu_cwdata) @228
//   ); @229
  assign hwdata[DATA_WIDTH-1:0] = cpu_wr_data[DATA_WIDTH-1:0];

assign ahbLif_ahbl_hwdata[DATA_WIDTH-1:0] = hwdata[DATA_WIDTH-1:0];

// BUS Polarity

// &Force("output","ahbLif_ahbl_hwdata"); @245


//==========================================================
//     HTRANS
//==========================================================

assign ahbLif_ahbl_htrans[1] = ahbLif_cur_state[2:0]==IDLE &&
                               !pad_cpu_halt_ff2 &&
                               cpu_req_power_masked || 
                              (ahbLif_cur_state[2:0]==WFG ||
                               ahbLif_cur_state[2:0]==WFD) &&
                               cpu_req; // && bus_ready;

assign ahbLif_ahbl_htrans[0] = 1'b0;

//==========================================================
//     HWRITE
//==========================================================
assign ahbLif_ahbl_hwrite = cpu_write;

//==========================================================
//     HSIZE
//==========================================================

assign ahbLif_ahbl_hsize[2:0] = { 1'b0, cpu_size[1:0]};

//==========================================================
//     HPROT
//==========================================================

assign ahbLif_ahbl_hprot[3:0] = cpu_prot[3:0];

//==========================================================
//     HBURST
//==========================================================

assign ahbLif_ahbl_hburst[2:0] = 3'b0;

//==========================================================
//     interface with EMMU
//==========================================================


//==========================================================
//     Vector Redirect Information
//==========================================================
// &Force("nonport", "ahbLif_ahbl_vec_redrct"); @307
assign ahbLif_ahbl_vec_redrct = cpu_vec_redirect;
//==============================================================================
//
//                            interface with CPU
//
//==============================================================================

//==========================================================
//     CPU_GNT
//==========================================================

assign cpu_req_grnt = req_grnt;

//==========================================================
//     TRANS COMPLETE
//==========================================================

assign cpu_trans_cmplt = trans_cmplt;

//==========================================================
//     DATA VALID
//==========================================================

assign cpu_data_vld = data_vld;

//==========================================================
//     LOAD DATA
//==========================================================
//   //&Force("output","cpu_rdata_pol"); @338
//   //&Connect(.data_in(bus_pol_rdata), @342
//   //         .f_key0 (pad_biu_beu_key1), @343
//   //         .f_key1 (pad_biu_beu_key0), @344
//   //         .data_out(bus_pdata) @345
//   //); @346
//   //&Connect(.data_in(bus_rdata), @351
//   //         .f_key0 (pad_biu_beu_key1), @352
//   //         .f_key1 (pad_biu_beu_key0), @353
//   //         .data_out(bus_pdata) @354
//   //); @355
//   &Instance("cr_beu_enc32", "x_cr_biu_rdata_dec"); @358
//   &Connect(.data_in(bus_rdata), @359
//            .f_key0 (pad_biu_beu_key1), @360
//            .f_key1 (pad_biu_beu_key0), @361
//            .data_out(bus_pdata) @362
//   ); @363
//   &Instance("cr_ahbl_descram", "x_cr_biu_rdata_descram"); @367
//   &Connect(.data_in(bus_rdata), @368
//            .f_key0 (pad_biu_beu_key0), @369
//            .f_key1 (pad_biu_beu_key1), @370
//            .data_out(bus_pdata) @371
//   ); @372
  assign cpu_rdata[DATA_WIDTH-1:0] = bus_rdata[DATA_WIDTH-1:0];

//==========================================================
//     LOAD_ERROR
//==========================================================

assign cpu_acc_err = acc_err;

assign cpu_sec     = bus_sec; 
//==========================================================
//     BIU CLK EN
//==========================================================

assign ahbl_clk_en = !(ahbLif_cur_state[2:0]==IDLE) || cpu_req;

assign ahblif_busy = !(ahbLif_cur_state[2:0]==IDLE);

assign ahblif_idle = ahbLif_cur_state[2:0]==IDLE;

// &ModuleEnd; @396
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_ahbl_req_arb(
  ahbl_bmu_dbus_acc_err,
  ahbl_bmu_dbus_data,
  ahbl_bmu_dbus_data_vld,
  ahbl_bmu_dbus_grnt,
  ahbl_bmu_dbus_trans_cmplt,
  ahbl_bmu_ibus_acc_err,
  ahbl_bmu_ibus_data,
  ahbl_bmu_ibus_data_vld,
  ahbl_bmu_ibus_grnt,
  ahbl_bmu_ibus_trans_cmplt,
  ahbl_gated_clk,
  bmu_ahbl_dbus_acc_deny,
  bmu_ahbl_dbus_addr,
  bmu_ahbl_dbus_chk_fail,
  bmu_ahbl_dbus_prot,
  bmu_ahbl_dbus_req,
  bmu_ahbl_dbus_req_without_cmplt,
  bmu_ahbl_dbus_req_without_deny_chk_fail,
  bmu_ahbl_dbus_size,
  bmu_ahbl_dbus_write,
  bmu_ahbl_ibus_acc_deny,
  bmu_ahbl_ibus_addr,
  bmu_ahbl_ibus_hit,
  bmu_ahbl_ibus_prot,
  bmu_ahbl_ibus_req,
  bmu_ahbl_ibus_req_no_hit,
  bmu_ahbl_ibus_size,
  bmu_ahbl_ibus_vec_redirect,
  bmu_ahbl_ibus_write,
  bmu_ahbl_wdata,
  cpu_acc_err,
  cpu_addr,
  cpu_data_vld,
  cpu_prot,
  cpu_rdata,
  cpu_req,
  cpu_req_for_grnt,
  cpu_req_for_peak_power,
  cpu_req_grnt,
  cpu_sec,
  cpu_size,
  cpu_trans_cmplt,
  cpu_vec_redirect,
  cpu_wdata,
  cpu_write,
  cpurst_b,
  ibus_not_granted
);

// &Ports; @23
input           ahbl_gated_clk;                         
input           bmu_ahbl_dbus_acc_deny;                 
input   [31:0]  bmu_ahbl_dbus_addr;                     
input           bmu_ahbl_dbus_chk_fail;                 
input   [3 :0]  bmu_ahbl_dbus_prot;                     
input           bmu_ahbl_dbus_req;                      
input           bmu_ahbl_dbus_req_without_cmplt;        
input           bmu_ahbl_dbus_req_without_deny_chk_fail; 
input   [1 :0]  bmu_ahbl_dbus_size;                     
input           bmu_ahbl_dbus_write;                    
input           bmu_ahbl_ibus_acc_deny;                 
input   [31:0]  bmu_ahbl_ibus_addr;                     
input           bmu_ahbl_ibus_hit;                      
input   [3 :0]  bmu_ahbl_ibus_prot;                     
input           bmu_ahbl_ibus_req;                      
input           bmu_ahbl_ibus_req_no_hit;               
input   [1 :0]  bmu_ahbl_ibus_size;                     
input           bmu_ahbl_ibus_vec_redirect;             
input           bmu_ahbl_ibus_write;                    
input   [31:0]  bmu_ahbl_wdata;                         
input           cpu_acc_err;                            
input           cpu_data_vld;                           
input   [31:0]  cpu_rdata;                              
input           cpu_req_grnt;                           
input           cpu_sec;                                
input           cpu_trans_cmplt;                        
input           cpurst_b;                               
output          ahbl_bmu_dbus_acc_err;                  
output  [31:0]  ahbl_bmu_dbus_data;                     
output          ahbl_bmu_dbus_data_vld;                 
output          ahbl_bmu_dbus_grnt;                     
output          ahbl_bmu_dbus_trans_cmplt;              
output          ahbl_bmu_ibus_acc_err;                  
output  [31:0]  ahbl_bmu_ibus_data;                     
output          ahbl_bmu_ibus_data_vld;                 
output          ahbl_bmu_ibus_grnt;                     
output          ahbl_bmu_ibus_trans_cmplt;              
output  [31:0]  cpu_addr;                               
output  [3 :0]  cpu_prot;                               
output          cpu_req;                                
output          cpu_req_for_grnt;                       
output          cpu_req_for_peak_power;                 
output  [1 :0]  cpu_size;                               
output          cpu_vec_redirect;                       
output  [31:0]  cpu_wdata;                              
output          cpu_write;                              
output          ibus_not_granted;                       

// &Regs; @24
reg     [1 :0]  cpu_req_bus_grnt;                       
reg     [1 :0]  cpu_req_type;                           
reg             ibus_not_granted;                       

// &Wires; @25
wire            ahbl_bmu_dbus_acc_err;                  
wire    [31:0]  ahbl_bmu_dbus_data;                     
wire            ahbl_bmu_dbus_data_vld;                 
wire            ahbl_bmu_dbus_grnt;                     
wire            ahbl_bmu_dbus_trans_cmplt;              
wire            ahbl_bmu_ibus_acc_err;                  
wire    [31:0]  ahbl_bmu_ibus_data;                     
wire            ahbl_bmu_ibus_data_vld;                 
wire            ahbl_bmu_ibus_grnt;                     
wire            ahbl_bmu_ibus_trans_cmplt;              
wire            ahbl_gated_clk;                         
wire            bmu_ahbl_dbus_acc_deny;                 
wire    [31:0]  bmu_ahbl_dbus_addr;                     
wire            bmu_ahbl_dbus_chk_fail;                 
wire    [3 :0]  bmu_ahbl_dbus_prot;                     
wire            bmu_ahbl_dbus_req;                      
wire            bmu_ahbl_dbus_req_without_cmplt;        
wire            bmu_ahbl_dbus_req_without_deny_chk_fail; 
wire    [1 :0]  bmu_ahbl_dbus_size;                     
wire            bmu_ahbl_dbus_write;                    
wire    [31:0]  bmu_ahbl_had_addr;                      
wire    [3 :0]  bmu_ahbl_had_prot;                      
wire    [1 :0]  bmu_ahbl_had_size;                      
wire    [31:0]  bmu_ahbl_had_wdata;                     
wire            bmu_ahbl_had_write;                     
wire            bmu_ahbl_ibus_acc_deny;                 
wire    [31:0]  bmu_ahbl_ibus_addr;                     
wire            bmu_ahbl_ibus_hit;                      
wire    [3 :0]  bmu_ahbl_ibus_prot;                     
wire            bmu_ahbl_ibus_req;                      
wire            bmu_ahbl_ibus_req_no_hit;               
wire    [1 :0]  bmu_ahbl_ibus_size;                     
wire            bmu_ahbl_ibus_vec_redirect;             
wire            bmu_ahbl_ibus_write;                    
wire    [31:0]  bmu_ahbl_wdata;                         
wire            cpu_acc_err;                            
wire    [31:0]  cpu_addr;                               
wire            cpu_data_vld;                           
wire    [3 :0]  cpu_prot;                               
wire    [31:0]  cpu_rdata;                              
wire            cpu_req;                                
wire            cpu_req_dbus_grnt;                      
wire            cpu_req_for_grnt;                       
wire            cpu_req_for_peak_power;                 
wire            cpu_req_grnt;                           
wire            cpu_req_ibus_grnt;                      
wire    [1 :0]  cpu_size;                               
wire            cpu_trans_cmplt;                        
wire            cpu_vec_redirect;                       
wire    [31:0]  cpu_wdata;                              
wire            cpu_write;                              
wire            cpurst_b;                               
wire            dbus_req;                               
wire            dbus_req_without_deny_chk_fail;         
wire            dbus_req_without_deny_chk_fail_cmplt;   
wire            dbus_sel;                               
wire            had_req;                                
wire            had_req_without_cmplt;                  
wire            had_sel;                                
wire            ibus_req;                               
wire            ibus_req_only;                          
wire            ibus_req_without_deny;                  
wire            ibus_sel;                               


//=============================================================
//
//       generate request to ahb interface by priority
//
//=============================================================
assign had_req = 1'b0;
assign had_req_without_cmplt = 1'b0;
assign had_sel = 1'b0;
assign bmu_ahbl_had_addr[31:0] = 32'b0;
assign bmu_ahbl_had_prot[3:0]  = 4'b0;
assign bmu_ahbl_had_size[1:0]  = 2'b0;
assign bmu_ahbl_had_wdata[31:0] = 32'b0;
assign bmu_ahbl_had_write = 1'b0;
assign ibus_req = bmu_ahbl_ibus_req && !bmu_ahbl_ibus_acc_deny;
assign ibus_req_without_deny = bmu_ahbl_ibus_req;
assign dbus_req = bmu_ahbl_dbus_req && !bmu_ahbl_dbus_acc_deny 
              && !bmu_ahbl_dbus_chk_fail && !ibus_not_granted;
assign dbus_req_without_deny_chk_fail = bmu_ahbl_dbus_req_without_deny_chk_fail 
                                    && !ibus_not_granted;

assign dbus_req_without_deny_chk_fail_cmplt = bmu_ahbl_dbus_req_without_cmplt 
                                          && !ibus_not_granted;

assign ibus_sel = bmu_ahbl_ibus_hit && !dbus_req_without_deny_chk_fail_cmplt && !had_req_without_cmplt;
//assign dbus_sel = dbus_req_without_deny_chk_fail_cmplt || !inst_bus && !ibus_req_without_deny;
assign dbus_sel = dbus_req_without_deny_chk_fail_cmplt && !had_req_without_cmplt;

assign cpu_req = (ibus_req && !dbus_req_without_deny_chk_fail_cmplt && !had_req_without_cmplt) 
                 || dbus_req && !had_req_without_cmplt || had_req;
assign cpu_req_for_grnt = ibus_req_without_deny || dbus_req_without_deny_chk_fail_cmplt || had_req_without_cmplt;
assign cpu_req_for_peak_power = bmu_ahbl_ibus_req_no_hit && bmu_ahbl_ibus_hit
                             || dbus_req_without_deny_chk_fail_cmplt
                             || had_req_without_cmplt;

assign cpu_addr[31:0]   = {32{dbus_sel}} & bmu_ahbl_dbus_addr[31:0]
                        | {32{ibus_sel}} & bmu_ahbl_ibus_addr[31:0]
                        | {32{had_sel}}  & bmu_ahbl_had_addr[31:0];

assign cpu_prot[3:0]    = {4{dbus_sel}}  & bmu_ahbl_dbus_prot[3:0]
                        | {4{ibus_sel}}  & bmu_ahbl_ibus_prot[3:0]
                        | {4{had_sel}}   & bmu_ahbl_had_prot[3:0];

assign cpu_size[1:0]    = {2{dbus_sel}}  & bmu_ahbl_dbus_size[1:0]
                        | {2{ibus_sel}}  & bmu_ahbl_ibus_size[1:0]
                        | {2{had_sel}}   & bmu_ahbl_had_size[1:0];

assign cpu_write        = dbus_sel       & bmu_ahbl_dbus_write
                        | ibus_sel       & bmu_ahbl_ibus_write
                        | had_sel        & bmu_ahbl_had_write; 
assign cpu_vec_redirect = bmu_ahbl_ibus_vec_redirect;

// write data has only one source, selected in top module
//assign cpu_wdata[31:0]  = {32{cpu_req_bus_grnt}} & bmu_ahbl_wdata[31:0];
assign cpu_wdata[31:0]  = (cpu_req_bus_grnt[1:0] == 2'b1) ?   bmu_ahbl_wdata[31:0] :
                                          bmu_ahbl_had_wdata[31:0];
//always @(posedge ahbl_gated_clk or negedge cpurst_b)
//begin
//  if(!cpurst_b)
//     dbus_sel_ff <= 1'b0;
//  else if(dbus_sel && cpu_req_grnt)
//     dbus_sel_ff <= 1'b1;
//  else
//     dbus_sel_ff <= 1'b0;
//end

//===================================================
//        record the current request to generate
//      the response singal to corresonding module
//===================================================
// &Force("output", "cpu_req"); @118
// &CombBeg; @119
always @( had_req
       or dbus_req
       or ibus_req)
begin
casez({had_req, dbus_req, ibus_req})
  3'b1?? : cpu_req_type[1:0] = 2'b10;
  3'b01? : cpu_req_type[1:0] = 2'b01;
  default: cpu_req_type[1:0] = 2'b0;
endcase
// &CombEnd; @125
end
//assign cpu_req_type = dbus_req || !ibus_req;
always @(posedge ahbl_gated_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    cpu_req_bus_grnt[1:0] <= 2'b0;
  else if(cpu_req && cpu_req_grnt)
    cpu_req_bus_grnt[1:0] <= cpu_req_type[1:0];
  else
    cpu_req_bus_grnt[1:0] <= cpu_req_bus_grnt[1:0];
end 

// mask dbus request grant when a previous ibus request 
// not granted by interface
// &Force("output", "ibus_not_granted"); @139
assign ibus_req_only = ibus_req && !dbus_req_without_deny_chk_fail_cmplt && !had_req_without_cmplt;
always @(posedge ahbl_gated_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    ibus_not_granted <= 1'b0;
  else if(ibus_req_only && !cpu_req_grnt)
    ibus_not_granted <= 1'b1;
  else if(cpu_req_grnt && ibus_not_granted)
    ibus_not_granted <= 1'b0;
end 


//=============================================================
//
//    generate response and data to corresponding module
//
//=============================================================

//===================================================
//              grant signal
//===================================================
assign ahbl_bmu_ibus_grnt = !dbus_req_without_deny_chk_fail_cmplt
                          && ibus_req_without_deny && cpu_req_grnt && !had_req_without_cmplt;
assign ahbl_bmu_dbus_grnt = dbus_req_without_deny_chk_fail && cpu_req_grnt && !had_req_without_cmplt;

//===================================================
//             trans compltete signal
//===================================================
assign cpu_req_ibus_grnt = (cpu_req_bus_grnt[1:0] == 2'b00);
assign cpu_req_dbus_grnt = (cpu_req_bus_grnt[1:0] == 2'b01);
assign ahbl_bmu_ibus_trans_cmplt = cpu_req_ibus_grnt && cpu_trans_cmplt;
assign ahbl_bmu_dbus_trans_cmplt = cpu_req_dbus_grnt && cpu_trans_cmplt;


//===================================================
//             data valid  signal
//===================================================
assign ahbl_bmu_ibus_data_vld = cpu_req_ibus_grnt && cpu_data_vld;
assign ahbl_bmu_dbus_data_vld = cpu_req_dbus_grnt && cpu_data_vld;


//===================================================
//             access error  signal
//===================================================
assign ahbl_bmu_ibus_acc_err = cpu_req_ibus_grnt && cpu_acc_err;
assign ahbl_bmu_dbus_acc_err = cpu_req_dbus_grnt && cpu_acc_err;


// &Force("input","cpu_sec"); @216
//===================================================
//               read data signal
//===================================================
assign ahbl_bmu_ibus_data[31:0] = cpu_rdata[31:0];
assign ahbl_bmu_dbus_data[31:0] = cpu_rdata[31:0];



// &ModuleEnd; @249
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_bmu_dbus_if(
  biu_bmu_dbus_acc_err,
  biu_bmu_dbus_data,
  biu_bmu_dbus_data_vld,
  biu_bmu_dbus_grnt,
  biu_bmu_dbus_trans_cmplt,
  bmu_biu_dbus_acc_deny,
  bmu_biu_dbus_addr,
  bmu_biu_dbus_chk_fail,
  bmu_biu_dbus_prot,
  bmu_biu_dbus_req,
  bmu_biu_dbus_req_without_cmplt,
  bmu_biu_dbus_size,
  bmu_biu_dbus_wdata,
  bmu_biu_dbus_write,
  bmu_iahbl_dbus_acc_deny,
  bmu_iahbl_dbus_addr,
  bmu_iahbl_dbus_chk_fail,
  bmu_iahbl_dbus_prot,
  bmu_iahbl_dbus_req,
  bmu_iahbl_dbus_req_without_cmplt,
  bmu_iahbl_dbus_size,
  bmu_iahbl_dbus_wdata,
  bmu_iahbl_dbus_write,
  bmu_lsu_acc_err,
  bmu_lsu_bstack_chk_fail,
  bmu_lsu_data,
  bmu_lsu_data_vld,
  bmu_lsu_grnt,
  bmu_lsu_trans_cmplt,
  bmu_tcipif_dbus_acc_deny,
  bmu_tcipif_dbus_addr,
  bmu_tcipif_dbus_chk_fail,
  bmu_tcipif_dbus_req,
  bmu_tcipif_dbus_size,
  bmu_tcipif_dbus_supv_mode,
  bmu_tcipif_dbus_wdata,
  bmu_tcipif_dbus_write,
  cp0_yy_machine_mode_aft_dbg,
  cpurst_b,
  dbus_deny_clk_en,
  deny_clk,
  iahbl_bmu_dbus_acc_err,
  iahbl_bmu_dbus_data,
  iahbl_bmu_dbus_data_vld,
  iahbl_bmu_dbus_grnt,
  iahbl_bmu_dbus_trans_cmplt,
  lsu_bmu_addr,
  lsu_bmu_addr_check_fail,
  lsu_bmu_idle,
  lsu_bmu_prot,
  lsu_bmu_req,
  lsu_bmu_req_without_cmplt,
  lsu_bmu_sg_chk_fail,
  lsu_bmu_size,
  lsu_bmu_store_error,
  lsu_bmu_wdata,
  lsu_bmu_wfd1,
  lsu_bmu_write,
  pad_bmu_iahbl_base,
  pad_bmu_iahbl_mask,
  pmp_bmu_dbus_acc_deny,
  tcipif_bmu_dbus_acc_err,
  tcipif_bmu_dbus_data,
  tcipif_bmu_dbus_data_vld,
  tcipif_bmu_dbus_grnt,
  tcipif_bmu_dbus_trans_cmplt
);

// &Ports; @25
input           biu_bmu_dbus_acc_err;            
input   [31:0]  biu_bmu_dbus_data;               
input           biu_bmu_dbus_data_vld;           
input           biu_bmu_dbus_grnt;               
input           biu_bmu_dbus_trans_cmplt;        
input           cp0_yy_machine_mode_aft_dbg;     
input           cpurst_b;                        
input           deny_clk;                        
input           iahbl_bmu_dbus_acc_err;          
input   [31:0]  iahbl_bmu_dbus_data;             
input           iahbl_bmu_dbus_data_vld;         
input           iahbl_bmu_dbus_grnt;             
input           iahbl_bmu_dbus_trans_cmplt;      
input   [31:0]  lsu_bmu_addr;                    
input           lsu_bmu_addr_check_fail;         
input           lsu_bmu_idle;                    
input   [3 :0]  lsu_bmu_prot;                    
input           lsu_bmu_req;                     
input           lsu_bmu_req_without_cmplt;       
input           lsu_bmu_sg_chk_fail;             
input   [1 :0]  lsu_bmu_size;                    
input           lsu_bmu_store_error;             
input   [31:0]  lsu_bmu_wdata;                   
input           lsu_bmu_wfd1;                    
input           lsu_bmu_write;                   
input   [11:0]  pad_bmu_iahbl_base;              
input   [11:0]  pad_bmu_iahbl_mask;              
input           pmp_bmu_dbus_acc_deny;           
input           tcipif_bmu_dbus_acc_err;         
input   [31:0]  tcipif_bmu_dbus_data;            
input           tcipif_bmu_dbus_data_vld;        
input           tcipif_bmu_dbus_grnt;            
input           tcipif_bmu_dbus_trans_cmplt;     
output          bmu_biu_dbus_acc_deny;           
output  [31:0]  bmu_biu_dbus_addr;               
output          bmu_biu_dbus_chk_fail;           
output  [3 :0]  bmu_biu_dbus_prot;               
output          bmu_biu_dbus_req;                
output          bmu_biu_dbus_req_without_cmplt;  
output  [1 :0]  bmu_biu_dbus_size;               
output  [31:0]  bmu_biu_dbus_wdata;              
output          bmu_biu_dbus_write;              
output          bmu_iahbl_dbus_acc_deny;         
output  [31:0]  bmu_iahbl_dbus_addr;             
output          bmu_iahbl_dbus_chk_fail;         
output  [3 :0]  bmu_iahbl_dbus_prot;             
output          bmu_iahbl_dbus_req;              
output          bmu_iahbl_dbus_req_without_cmplt; 
output  [1 :0]  bmu_iahbl_dbus_size;             
output  [31:0]  bmu_iahbl_dbus_wdata;            
output          bmu_iahbl_dbus_write;            
output          bmu_lsu_acc_err;                 
output          bmu_lsu_bstack_chk_fail;         
output  [31:0]  bmu_lsu_data;                    
output          bmu_lsu_data_vld;                
output          bmu_lsu_grnt;                    
output          bmu_lsu_trans_cmplt;             
output          bmu_tcipif_dbus_acc_deny;        
output  [31:0]  bmu_tcipif_dbus_addr;            
output          bmu_tcipif_dbus_chk_fail;        
output          bmu_tcipif_dbus_req;             
output  [1 :0]  bmu_tcipif_dbus_size;            
output          bmu_tcipif_dbus_supv_mode;       
output  [31:0]  bmu_tcipif_dbus_wdata;           
output          bmu_tcipif_dbus_write;           
output          dbus_deny_clk_en;                

// &Regs; @26
reg     [2 :0]  cross_cur_st;                    
reg     [2 :0]  cross_nxt_st;                    
reg     [1 :0]  cur_state;                       
reg             iahbl_norm_hit_ff;               
reg     [1 :0]  next_state;                      
reg     [2 :0]  req_bus;                         

// &Wires; @27
wire            acc_deny;                        
wire            acc_err_for_deny;                
wire            biu_bmu_dbus_acc_err;            
wire    [31:0]  biu_bmu_dbus_data;               
wire            biu_bmu_dbus_data_vld;           
wire            biu_bmu_dbus_grnt;               
wire            biu_bmu_dbus_trans_cmplt;        
wire            biu_data_vld;                    
wire            bmu_biu_dbus_acc_deny;           
wire    [31:0]  bmu_biu_dbus_addr;               
wire            bmu_biu_dbus_chk_fail;           
wire    [3 :0]  bmu_biu_dbus_prot;               
wire            bmu_biu_dbus_req;                
wire            bmu_biu_dbus_req_without_cmplt;  
wire    [1 :0]  bmu_biu_dbus_size;               
wire    [31:0]  bmu_biu_dbus_wdata;              
wire            bmu_biu_dbus_write;              
wire            bmu_iahbl_dbus_acc_deny;         
wire    [31:0]  bmu_iahbl_dbus_addr;             
wire            bmu_iahbl_dbus_chk_fail;         
wire    [3 :0]  bmu_iahbl_dbus_prot;             
wire            bmu_iahbl_dbus_req;              
wire            bmu_iahbl_dbus_req_without_cmplt; 
wire    [1 :0]  bmu_iahbl_dbus_size;             
wire    [31:0]  bmu_iahbl_dbus_wdata;            
wire            bmu_iahbl_dbus_write;            
wire            bmu_lsu_acc_err;                 
wire            bmu_lsu_bstack_chk_fail;         
wire    [31:0]  bmu_lsu_data;                    
wire            bmu_lsu_data_vld;                
wire            bmu_lsu_grnt;                    
wire            bmu_lsu_trans_cmplt;             
wire            bmu_tcipif_dbus_acc_deny;        
wire    [31:0]  bmu_tcipif_dbus_addr;            
wire            bmu_tcipif_dbus_chk_fail;        
wire            bmu_tcipif_dbus_req;             
wire    [1 :0]  bmu_tcipif_dbus_size;            
wire            bmu_tcipif_dbus_supv_mode;       
wire    [31:0]  bmu_tcipif_dbus_wdata;           
wire            bmu_tcipif_dbus_write;           
wire            bstck_chk_fail;                  
wire            cp0_yy_machine_mode_aft_dbg;     
wire            cpurst_b;                        
wire            cross_fsm_upd;                   
wire            cross_iahbl;                     
wire            cross_idle;                      
wire            cross_sahbl;                     
wire            cross_tcip;                      
wire            dahbl_bmu_dbus_acc_err;          
wire    [31:0]  dahbl_bmu_dbus_data;             
wire            dahbl_bmu_dbus_data_vld;         
wire            dahbl_bmu_dbus_grnt;             
wire            dahbl_bmu_dbus_trans_cmplt;      
wire            dahbl_data_vld;                  
wire            dahbl_hit;                       
wire            dahbl_hit_ff;                    
wire            dahbl_hit_upd;                   
wire            dahbl_req;                       
wire            dbus_deny_clk_en;                
wire            dbus_grnt;                       
wire            deny_clk;                        
wire            iahbl_bmu_dbus_acc_err;          
wire    [31:0]  iahbl_bmu_dbus_data;             
wire            iahbl_bmu_dbus_data_vld;         
wire            iahbl_bmu_dbus_grnt;             
wire            iahbl_bmu_dbus_trans_cmplt;      
wire            iahbl_data_vld;                  
wire            iahbl_hit;                       
wire            iahbl_hit_ff;                    
wire            iahbl_hit_upd;                   
wire            iahbl_lrw_hit;                   
wire            iahbl_lrw_hit_ff;                
wire            iahbl_lrw_hit_upd;               
wire            iahbl_norm_hit_upd;              
wire            iahbl_req;                       
wire            iahbl_vld;                       
wire    [31:0]  lsu_bmu_addr;                    
wire            lsu_bmu_addr_check_fail;         
wire            lsu_bmu_idle;                    
wire    [3 :0]  lsu_bmu_prot;                    
wire            lsu_bmu_req;                     
wire            lsu_bmu_req_without_cmplt;       
wire            lsu_bmu_sg_chk_fail;             
wire    [1 :0]  lsu_bmu_size;                    
wire            lsu_bmu_store_error;             
wire    [31:0]  lsu_bmu_wdata;                   
wire            lsu_bmu_wfd1;                    
wire            lsu_bmu_write;                   
wire            lsu_inst_lrw;                    
wire            lsu_inst_norm;                   
wire    [11:0]  pad_bmu_iahbl_base;              
wire    [11:0]  pad_bmu_iahbl_mask;              
wire            pmp_bmu_dbus_acc_deny;           
wire            sahbl_req;                       
wire            sahbl_vld;                       
wire            tcip_req;                        
wire            tcip_vld;                        
wire    [15:0]  tcipif_addr_low;                 
wire            tcipif_bmu_dbus_acc_err;         
wire    [31:0]  tcipif_bmu_dbus_data;            
wire            tcipif_bmu_dbus_data_vld;        
wire            tcipif_bmu_dbus_grnt;            
wire            tcipif_bmu_dbus_trans_cmplt;     
wire            tcipif_data_vld;                 
wire            tcipif_hit;                      


//parameter DAHBL_BASE  = 3'b001;
parameter TCIPIF_BASE = 4'b1110;

assign acc_deny =  pmp_bmu_dbus_acc_deny 
                || lsu_bmu_sg_chk_fail
                || lsu_bmu_store_error;
//==========================================================
//      compare base address with ahbl base addr
//==========================================================
assign lsu_inst_norm = lsu_bmu_req & lsu_bmu_prot[0] & !tcipif_hit;
assign lsu_inst_lrw  = lsu_bmu_req & !lsu_bmu_prot[0];

assign dahbl_hit     = 1'b0;
assign dahbl_hit_ff  = 1'b0;
assign dahbl_hit_upd = 1'b0;

assign iahbl_hit = ((lsu_bmu_addr[31:20] & pad_bmu_iahbl_mask[11:0]) == pad_bmu_iahbl_base[11:0]);
assign iahbl_lrw_hit = iahbl_hit;

assign iahbl_norm_hit_upd = (iahbl_norm_hit_ff ^ iahbl_hit) & lsu_inst_norm;
always @(posedge deny_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    iahbl_norm_hit_ff <= 1'b0;
  else if(iahbl_norm_hit_upd)
    iahbl_norm_hit_ff <= iahbl_hit;
  else
    iahbl_norm_hit_ff <= iahbl_norm_hit_ff;
end

assign iahbl_lrw_hit_upd = (iahbl_lrw_hit_ff ^ iahbl_lrw_hit) & lsu_inst_lrw;
//always @(posedge deny_clk or negedge cpurst_b)
//begin
//  if(!cpurst_b)
//    iahbl_lrw_hit_ff <= 1'b1;
//  else if(iahbl_lrw_hit_upd)
//    iahbl_lrw_hit_ff <= iahbl_lrw_hit;
//  else
//    iahbl_lrw_hit_ff <= iahbl_lrw_hit_ff;
//end
assign iahbl_lrw_hit_ff = 1'b1;
assign iahbl_hit_ff  = !lsu_bmu_prot[0] ? iahbl_lrw_hit_ff : iahbl_norm_hit_ff;
assign iahbl_hit_upd = iahbl_norm_hit_upd || iahbl_lrw_hit_upd;

//==========================================================
//                    cross bus req judgement & mask
//==========================================================
// cross FSM: Cross IDLE, SysAHBL, TCIP, IAHBL, DAHBL
parameter CIDLE = 3'b000;
parameter SAHBL = 3'b001;
parameter CTCIP = 3'b010;
parameter IAHBL = 3'b011;
parameter DAHBL = 3'b100;

always @(posedge deny_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    cross_cur_st[2:0] <= CIDLE;
  else
    cross_cur_st[2:0] <= cross_nxt_st[2:0];
end

assign sahbl_req = lsu_bmu_req && !iahbl_hit && !dahbl_hit && !tcipif_hit;
assign iahbl_req = lsu_bmu_req &&  iahbl_hit;
assign dahbl_req = lsu_bmu_req &&  dahbl_hit;
assign tcip_req  = lsu_bmu_req && tcipif_hit;
assign cross_fsm_upd = cross_nxt_st[2:0] != cross_cur_st[2:0];

// &CombBeg; @139
always @( sahbl_req
       or iahbl_req
       or dahbl_req
       or tcip_req)
begin
case({sahbl_req, tcip_req, iahbl_req, dahbl_req})
  4'b1000:
    req_bus[2:0] = SAHBL;
  4'b0100:
    req_bus[2:0] = CTCIP;
  4'b0010:
    req_bus[2:0] = IAHBL;
  4'b0001:
    req_bus[2:0] = DAHBL;
  default:
    req_bus[2:0] = CIDLE;
endcase
// &CombEnd; @152
end

// &CombBeg; @154
always @( sahbl_req
       or lsu_bmu_idle
       or req_bus
       or dahbl_req
       or iahbl_req
       or tcip_req
       or cross_cur_st)
begin
case(cross_cur_st)
  CIDLE:
  begin
    case({sahbl_req, tcip_req, iahbl_req, dahbl_req})
      4'b1000:
        cross_nxt_st = SAHBL;
      4'b0100:
        cross_nxt_st = CTCIP;
      4'b0010:
        cross_nxt_st = IAHBL;
      4'b0001:
        cross_nxt_st = DAHBL;
      default:
        cross_nxt_st = CIDLE;
    endcase
  end
  SAHBL:
  begin
    if(lsu_bmu_idle)
      cross_nxt_st = req_bus;
    else
      cross_nxt_st = SAHBL;
  end
  CTCIP:
  begin
    if(lsu_bmu_idle)
      cross_nxt_st = req_bus;
    else
      cross_nxt_st = CTCIP;
  end
  IAHBL:
  begin
    if(lsu_bmu_idle)
      cross_nxt_st = req_bus;
    else
      cross_nxt_st = IAHBL;
  end
  DAHBL:
  begin
    if(lsu_bmu_idle)
      cross_nxt_st = req_bus;
    else
      cross_nxt_st = DAHBL;
  end
  default:
  begin
    cross_nxt_st = CIDLE;
  end
endcase
// &CombEnd; @204
end

assign cross_idle  = cross_cur_st == CIDLE;
assign cross_sahbl = cross_cur_st == SAHBL;

assign sahbl_vld = cross_idle || cross_sahbl;
assign cross_tcip  = cross_cur_st == CTCIP;
assign tcip_vld    = cross_idle || cross_tcip;
assign cross_iahbl = cross_cur_st == IAHBL;
assign iahbl_vld   = cross_idle || cross_iahbl;

//==========================================================
//                    request to AHBLite Interface
//==========================================================
// &Force("input","lsu_bmu_wdata"); @226
// &Force("bus","lsu_bmu_wdata",31,0); @227
// &Force("input","lsu_bmu_wdata_pol"); @229

//interface to DLITE
assign dahbl_bmu_dbus_acc_err     = 1'b0;
assign dahbl_bmu_dbus_data[31:0]  = 32'b0;
assign dahbl_bmu_dbus_data_vld    = 1'b0;
assign dahbl_bmu_dbus_grnt        = 1'b0;
assign dahbl_bmu_dbus_trans_cmplt = 1'b0;

//interface to ILTE
assign bmu_iahbl_dbus_req         = lsu_bmu_req & iahbl_hit & iahbl_hit_ff
                                  & iahbl_vld;
assign bmu_iahbl_dbus_req_without_cmplt = lsu_bmu_req_without_cmplt
                                          & iahbl_hit_ff & iahbl_vld;
assign bmu_iahbl_dbus_acc_deny    = acc_deny;
assign bmu_iahbl_dbus_chk_fail    = lsu_bmu_addr_check_fail;
assign bmu_iahbl_dbus_write       = lsu_bmu_write;
assign bmu_iahbl_dbus_size[1:0]   = lsu_bmu_size[1:0];

assign bmu_iahbl_dbus_wdata[31:0] = lsu_bmu_wdata[31:0];
assign bmu_iahbl_dbus_addr[31:0]  = lsu_bmu_addr[31:0];
assign bmu_iahbl_dbus_prot[3:0]   = lsu_bmu_prot[3:0]; 

//==========================================================
//                    request to system register file
//==========================================================
assign tcipif_hit = (lsu_bmu_addr[31:28] == TCIPIF_BASE);
assign bmu_tcipif_dbus_req         = lsu_bmu_req & tcipif_hit & tcip_vld;
assign bmu_tcipif_dbus_acc_deny    = acc_deny;
assign bmu_tcipif_dbus_chk_fail    = lsu_bmu_addr_check_fail;
assign bmu_tcipif_dbus_write       = lsu_bmu_write;
assign bmu_tcipif_dbus_size[1:0]   = lsu_bmu_size[1:0];
assign bmu_tcipif_dbus_supv_mode   = cp0_yy_machine_mode_aft_dbg;
assign bmu_tcipif_dbus_wdata[31:0] = lsu_bmu_wdata[31:0];
assign tcipif_addr_low[15:0]       = {16{tcipif_hit}}
                                     & lsu_bmu_addr[15:0];
assign bmu_tcipif_dbus_addr[31:0]  = {lsu_bmu_addr[31:16],
                                      tcipif_addr_low[15:0]};

//==========================================================
//                    request to system bus
//==========================================================
assign bmu_biu_dbus_req         = lsu_bmu_req & ~iahbl_hit & ~dahbl_hit
                               & ~iahbl_hit_ff & ~dahbl_hit_ff
                               & ~tcipif_hit & sahbl_vld;
assign bmu_biu_dbus_req_without_cmplt = lsu_bmu_req_without_cmplt 
                                     & ~iahbl_hit_ff & ~dahbl_hit_ff 
                                     & sahbl_vld;
assign bmu_biu_dbus_acc_deny    = acc_deny;
assign bmu_biu_dbus_chk_fail    = lsu_bmu_addr_check_fail;
assign bmu_biu_dbus_write       = lsu_bmu_write;
assign bmu_biu_dbus_size[1:0]   = lsu_bmu_size[1:0];

assign bmu_biu_dbus_wdata[31:0] = lsu_bmu_wdata[31:0];

assign bmu_biu_dbus_addr[31:0]  = lsu_bmu_addr[31:0];
assign bmu_biu_dbus_prot[3:0]   = lsu_bmu_prot[3:0]; 


//==========================================================
//                BMU ACK to LSU
//==========================================================
assign dbus_grnt        = dahbl_bmu_dbus_grnt  |
                          iahbl_bmu_dbus_grnt  |
                          tcipif_bmu_dbus_grnt |
                          biu_bmu_dbus_grnt;
assign bmu_lsu_grnt = dbus_grnt;

//the deny info
//the check fail info
parameter IDLE        = 2'b00;
parameter BSTACK_FAIL = 2'b01;
parameter DENY        = 2'b10;
assign dbus_deny_clk_en = (cur_state != IDLE)
                       || lsu_bmu_addr_check_fail
                       || acc_deny 
                       || iahbl_hit_upd
                       || dahbl_hit_upd
                       || cross_fsm_upd;

//            &Force("nonport","dbus_deny_clk_en"); @410
always @(posedge deny_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    cur_state[1:0] <= IDLE;
  else
    cur_state[1:0] <= next_state[1:0];
end

// &CombBeg; @424
always @( cur_state
       or dbus_grnt
       or acc_deny
       or lsu_bmu_wfd1
       or lsu_bmu_addr_check_fail)
begin
  case(cur_state)
  IDLE        : if(dbus_grnt && lsu_bmu_addr_check_fail)
                  next_state = BSTACK_FAIL;
                else if(dbus_grnt && acc_deny)
                  next_state = DENY;
                else
                  next_state = IDLE;
  BSTACK_FAIL : if(lsu_bmu_wfd1)  
                  next_state = IDLE;
                else
                  next_state = BSTACK_FAIL;
  DENY        : if(lsu_bmu_wfd1)  
                  next_state = IDLE;
                else
                  next_state = DENY;
  default     :   next_state = IDLE;
  endcase
// &CombEnd; @442
end

assign bstck_chk_fail   = (cur_state == BSTACK_FAIL) && lsu_bmu_wfd1;
assign acc_err_for_deny = (cur_state == DENY) && lsu_bmu_wfd1;


// &Force("output","bmu_lsu_trans_cmplt"); @448
assign bmu_lsu_trans_cmplt = dahbl_bmu_dbus_trans_cmplt  |
                             iahbl_bmu_dbus_trans_cmplt  |
                             tcipif_bmu_dbus_trans_cmplt |
                             biu_bmu_dbus_trans_cmplt    |
                             acc_err_for_deny |
                             bstck_chk_fail;

assign bmu_lsu_data_vld    = dahbl_bmu_dbus_data_vld  |
                             iahbl_bmu_dbus_data_vld  |
                             tcipif_bmu_dbus_data_vld |
                             biu_bmu_dbus_data_vld;

assign dahbl_data_vld = dahbl_bmu_dbus_data_vld;
assign iahbl_data_vld = iahbl_bmu_dbus_data_vld;
assign biu_data_vld   = biu_bmu_dbus_data_vld;
assign tcipif_data_vld = tcipif_bmu_dbus_data_vld;

assign bmu_lsu_data[31:0]  = ({32{dahbl_data_vld}}  & dahbl_bmu_dbus_data[31:0])  |
                             ({32{iahbl_data_vld}}  & iahbl_bmu_dbus_data[31:0])  |
                             ({32{tcipif_data_vld}} & tcipif_bmu_dbus_data[31:0]) |
                             ({32{biu_data_vld}}    & biu_bmu_dbus_data[31:0]);


assign bmu_lsu_acc_err     = dahbl_bmu_dbus_acc_err  |
                             iahbl_bmu_dbus_acc_err  |
                             tcipif_bmu_dbus_acc_err |
                             biu_bmu_dbus_acc_err    |
                             acc_err_for_deny;

assign bmu_lsu_bstack_chk_fail = bstck_chk_fail;


// &ModuleEnd; @487
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_bmu_ibus_if(
  biu_bmu_ibus_acc_err,
  biu_bmu_ibus_data,
  biu_bmu_ibus_data_vld,
  biu_bmu_ibus_grnt,
  biu_bmu_ibus_trans_cmplt,
  bmu_biu_ibus_acc_deny,
  bmu_biu_ibus_addr,
  bmu_biu_ibus_hit,
  bmu_biu_ibus_prot,
  bmu_biu_ibus_req,
  bmu_biu_ibus_req_no_hit,
  bmu_biu_ibus_size,
  bmu_biu_ibus_vec_redirect,
  bmu_iahbl_ibus_acc_deny,
  bmu_iahbl_ibus_addr,
  bmu_iahbl_ibus_hit,
  bmu_iahbl_ibus_prot,
  bmu_iahbl_ibus_req,
  bmu_iahbl_ibus_req_no_hit,
  bmu_iahbl_ibus_size,
  bmu_iahbl_ibus_vec_redirect,
  bmu_tcipif_ibus_acc_deny,
  bmu_tcipif_ibus_addr,
  bmu_tcipif_ibus_req,
  bmu_tcipif_ibus_write,
  bmu_xx_ibus_acc_err,
  bmu_xx_ibus_data,
  bmu_xx_ibus_data_vld,
  bmu_xx_ibus_grnt,
  bmu_xx_ibus_trans_cmplt,
  cpurst_b,
  deny_clk,
  iahbl_bmu_ibus_acc_err,
  iahbl_bmu_ibus_data,
  iahbl_bmu_ibus_data_vld,
  iahbl_bmu_ibus_grnt,
  iahbl_bmu_ibus_trans_cmplt,
  ibus_deny_clk_en,
  ifu_bmu_addr,
  ifu_bmu_idle,
  ifu_bmu_prot,
  ifu_bmu_req,
  ifu_bmu_wfd1,
  iu_bmu_vec_redirect,
  pad_bmu_iahbl_base,
  pad_bmu_iahbl_mask,
  pmp_bmu_ibus_acc_deny,
  tcipif_bmu_ibus_acc_err,
  tcipif_bmu_ibus_data,
  tcipif_bmu_ibus_data_vld,
  tcipif_bmu_ibus_grnt,
  tcipif_bmu_ibus_trans_cmplt
);

// &Ports; @25
input           biu_bmu_ibus_acc_err;       
input   [31:0]  biu_bmu_ibus_data;          
input           biu_bmu_ibus_data_vld;      
input           biu_bmu_ibus_grnt;          
input           biu_bmu_ibus_trans_cmplt;   
input           cpurst_b;                   
input           deny_clk;                   
input           iahbl_bmu_ibus_acc_err;     
input   [31:0]  iahbl_bmu_ibus_data;        
input           iahbl_bmu_ibus_data_vld;    
input           iahbl_bmu_ibus_grnt;        
input           iahbl_bmu_ibus_trans_cmplt; 
input   [31:0]  ifu_bmu_addr;               
input           ifu_bmu_idle;               
input   [3 :0]  ifu_bmu_prot;               
input           ifu_bmu_req;                
input           ifu_bmu_wfd1;               
input           iu_bmu_vec_redirect;        
input   [11:0]  pad_bmu_iahbl_base;         
input   [11:0]  pad_bmu_iahbl_mask;         
input           pmp_bmu_ibus_acc_deny;      
input           tcipif_bmu_ibus_acc_err;    
input   [31:0]  tcipif_bmu_ibus_data;       
input           tcipif_bmu_ibus_data_vld;   
input           tcipif_bmu_ibus_grnt;       
input           tcipif_bmu_ibus_trans_cmplt; 
output          bmu_biu_ibus_acc_deny;      
output  [31:0]  bmu_biu_ibus_addr;          
output          bmu_biu_ibus_hit;           
output  [3 :0]  bmu_biu_ibus_prot;          
output          bmu_biu_ibus_req;           
output          bmu_biu_ibus_req_no_hit;    
output  [1 :0]  bmu_biu_ibus_size;          
output          bmu_biu_ibus_vec_redirect;  
output          bmu_iahbl_ibus_acc_deny;    
output  [31:0]  bmu_iahbl_ibus_addr;        
output          bmu_iahbl_ibus_hit;         
output  [3 :0]  bmu_iahbl_ibus_prot;        
output          bmu_iahbl_ibus_req;         
output          bmu_iahbl_ibus_req_no_hit;  
output  [1 :0]  bmu_iahbl_ibus_size;        
output          bmu_iahbl_ibus_vec_redirect; 
output          bmu_tcipif_ibus_acc_deny;   
output  [31:0]  bmu_tcipif_ibus_addr;       
output          bmu_tcipif_ibus_req;        
output          bmu_tcipif_ibus_write;      
output          bmu_xx_ibus_acc_err;        
output  [31:0]  bmu_xx_ibus_data;           
output          bmu_xx_ibus_data_vld;       
output          bmu_xx_ibus_grnt;           
output          bmu_xx_ibus_trans_cmplt;    
output          ibus_deny_clk_en;           

// &Regs; @26
reg             acc_err_for_deny;           
reg             iahbl_hit_ff;               
reg             tcipif_hit_ff;              

// &Wires; @27
wire            biu_bmu_ibus_acc_err;       
wire    [31:0]  biu_bmu_ibus_data;          
wire            biu_bmu_ibus_data_vld;      
wire            biu_bmu_ibus_grnt;          
wire            biu_bmu_ibus_trans_cmplt;   
wire            biu_data_vld;               
wire            bmu_biu_ibus_acc_deny;      
wire    [31:0]  bmu_biu_ibus_addr;          
wire            bmu_biu_ibus_hit;           
wire    [3 :0]  bmu_biu_ibus_prot;          
wire            bmu_biu_ibus_req;           
wire            bmu_biu_ibus_req_no_hit;    
wire    [1 :0]  bmu_biu_ibus_size;          
wire            bmu_biu_ibus_vec_redirect;  
wire            bmu_iahbl_ibus_acc_deny;    
wire    [31:0]  bmu_iahbl_ibus_addr;        
wire            bmu_iahbl_ibus_hit;         
wire    [3 :0]  bmu_iahbl_ibus_prot;        
wire            bmu_iahbl_ibus_req;         
wire            bmu_iahbl_ibus_req_no_hit;  
wire    [1 :0]  bmu_iahbl_ibus_size;        
wire            bmu_iahbl_ibus_vec_redirect; 
wire            bmu_tcipif_ibus_acc_deny;   
wire    [31:0]  bmu_tcipif_ibus_addr;       
wire            bmu_tcipif_ibus_req;        
wire            bmu_tcipif_ibus_write;      
wire            bmu_xx_ibus_acc_err;        
wire    [31:0]  bmu_xx_ibus_data;           
wire            bmu_xx_ibus_data_vld;       
wire            bmu_xx_ibus_grnt;           
wire            bmu_xx_ibus_trans_cmplt;    
wire            cpurst_b;                   
wire            dahbl_bmu_ibus_acc_err;     
wire    [31:0]  dahbl_bmu_ibus_data;        
wire            dahbl_bmu_ibus_data_vld;    
wire            dahbl_bmu_ibus_grnt;        
wire            dahbl_bmu_ibus_trans_cmplt; 
wire            dahbl_data_vld;             
wire            dahbl_hit;                  
wire            dahbl_hit_ff;               
wire            dahbl_hit_upd;              
wire            deny_clk;                   
wire            iahbl_bmu_ibus_acc_err;     
wire    [31:0]  iahbl_bmu_ibus_data;        
wire            iahbl_bmu_ibus_data_vld;    
wire            iahbl_bmu_ibus_grnt;        
wire            iahbl_bmu_ibus_trans_cmplt; 
wire            iahbl_data_vld;             
wire            iahbl_hit;                  
wire            iahbl_hit_upd;              
wire            ibus_deny_clk_en;           
wire            ibus_grnt;                  
wire    [31:0]  ifu_bmu_addr;               
wire            ifu_bmu_idle;               
wire    [3 :0]  ifu_bmu_prot;               
wire            ifu_bmu_req;                
wire            ifu_bmu_wfd1;               
wire            iu_bmu_vec_redirect;        
wire    [11:0]  pad_bmu_iahbl_base;         
wire    [11:0]  pad_bmu_iahbl_mask;         
wire            pmp_bmu_ibus_acc_deny;      
wire            tcipif_bmu_ibus_acc_err;    
wire    [31:0]  tcipif_bmu_ibus_data;       
wire            tcipif_bmu_ibus_data_vld;   
wire            tcipif_bmu_ibus_grnt;       
wire            tcipif_bmu_ibus_trans_cmplt; 
wire            tcipif_data_vld;            
wire            tcipif_hit;                 
wire            tcipif_hit_upd;             


//parameter IAHBL_BASE  = 3'b000;
parameter TCIPIF_BASE = 4'b1110;

//==========================================================
//      compare base address with ahbl base addr
//==========================================================
assign iahbl_hit = ((ifu_bmu_addr[31:20] & pad_bmu_iahbl_mask[11:0]) == pad_bmu_iahbl_base[11:0]);
assign iahbl_hit_upd = (iahbl_hit_ff ^ iahbl_hit) & ifu_bmu_req & ifu_bmu_idle;
always @(posedge deny_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    iahbl_hit_ff <= 1'b1;
  else if(iahbl_hit_upd)
    iahbl_hit_ff <= iahbl_hit;
  else
    iahbl_hit_ff <= iahbl_hit_ff;
end
// &Force("input", "ifu_bmu_idle"); @50

assign dahbl_hit     = 1'b0;
assign dahbl_hit_ff  = 1'b0;
assign dahbl_hit_upd = 1'b0;


//==========================================================
//                    request to AHBLite Interface
//==========================================================
//interface to ILITE
assign bmu_iahbl_ibus_req         = ifu_bmu_req & iahbl_hit & iahbl_hit_ff;
assign bmu_iahbl_ibus_req_no_hit  = ifu_bmu_req & iahbl_hit_ff;
assign bmu_iahbl_ibus_hit         = iahbl_hit_ff;
assign bmu_iahbl_ibus_acc_deny    = pmp_bmu_ibus_acc_deny;
assign bmu_iahbl_ibus_size[1:0]   = 2'b10;
assign bmu_iahbl_ibus_addr[31:0]  = ifu_bmu_addr[31:0];
assign bmu_iahbl_ibus_vec_redirect= iu_bmu_vec_redirect;
assign bmu_iahbl_ibus_prot[3:0]   = ifu_bmu_prot[3:0]; 

//interface to DLITE
assign dahbl_bmu_ibus_acc_err     = 1'b0;
assign dahbl_bmu_ibus_data[31:0]  = 32'b0;
assign dahbl_bmu_ibus_data_vld    = 1'b0;
assign dahbl_bmu_ibus_grnt        = 1'b0;
assign dahbl_bmu_ibus_trans_cmplt = 1'b0;

//==========================================================
//                    request to system register file
//==========================================================
assign tcipif_hit = (ifu_bmu_addr[31:28] == TCIPIF_BASE);
assign tcipif_hit_upd = (tcipif_hit_ff ^ tcipif_hit) & ifu_bmu_req & ifu_bmu_idle;
always @(posedge deny_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    tcipif_hit_ff <= 1'b0;
  else if(tcipif_hit_upd)
    tcipif_hit_ff <= tcipif_hit;
  else
    tcipif_hit_ff <= tcipif_hit_ff;
end
assign bmu_tcipif_ibus_req         = ifu_bmu_req & tcipif_hit & tcipif_hit_ff;
assign bmu_tcipif_ibus_acc_deny    = pmp_bmu_ibus_acc_deny;
assign bmu_tcipif_ibus_write       = 1'b0;
assign bmu_tcipif_ibus_addr[31:0]  = ifu_bmu_addr[31:0];

//==========================================================
//                    request to system bus
//==========================================================
assign bmu_biu_ibus_req          = ifu_bmu_req & ~iahbl_hit & ~dahbl_hit 
                                                            & ~tcipif_hit
                                 & ~iahbl_hit_ff & ~dahbl_hit_ff 
                                                 & ~tcipif_hit_ff;
assign bmu_biu_ibus_req_no_hit   = ifu_bmu_req & ~iahbl_hit_ff 
                                               & ~dahbl_hit_ff 
                                               & ~tcipif_hit_ff;
assign bmu_biu_ibus_hit          = ~iahbl_hit_ff & ~dahbl_hit_ff
                                                 & ~tcipif_hit_ff;
assign bmu_biu_ibus_acc_deny     = pmp_bmu_ibus_acc_deny;
assign bmu_biu_ibus_size[1:0]    = 2'b10;
assign bmu_biu_ibus_addr[31:0]   = ifu_bmu_addr[31:0];
assign bmu_biu_ibus_vec_redirect = iu_bmu_vec_redirect;
assign bmu_biu_ibus_prot[3:0]    = ifu_bmu_prot[3:0]; 

//==========================================================
//                BMU ACK to LSU
//==========================================================
assign ibus_grnt        = iahbl_bmu_ibus_grnt  |
                          dahbl_bmu_ibus_grnt  |
                          tcipif_bmu_ibus_grnt |
                          biu_bmu_ibus_grnt;
assign bmu_xx_ibus_grnt = ibus_grnt;

assign ibus_deny_clk_en = acc_err_for_deny || pmp_bmu_ibus_acc_deny 
                       || iahbl_hit_upd
                       || dahbl_hit_upd
                       || tcipif_hit_upd;


//         &Force("nonport","ibus_deny_clk_en"); @209
always @(posedge deny_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    acc_err_for_deny <= 1'b0;
  else if(ibus_grnt)
    acc_err_for_deny <= pmp_bmu_ibus_acc_deny;
  else if(acc_err_for_deny && ifu_bmu_wfd1)
    acc_err_for_deny <= 1'b0;
end

// &Force("output","bmu_xx_ibus_trans_cmplt"); @224
assign bmu_xx_ibus_trans_cmplt = iahbl_bmu_ibus_trans_cmplt  |
                                 dahbl_bmu_ibus_trans_cmplt  |
                                 tcipif_bmu_ibus_trans_cmplt |
                                 biu_bmu_ibus_trans_cmplt    |
                                 acc_err_for_deny & ifu_bmu_wfd1;

assign bmu_xx_ibus_data_vld    = iahbl_bmu_ibus_data_vld  |
                                 dahbl_bmu_ibus_data_vld  |
                                 tcipif_bmu_ibus_data_vld |
                                 biu_bmu_ibus_data_vld;

assign iahbl_data_vld = iahbl_bmu_ibus_data_vld;
assign dahbl_data_vld = dahbl_bmu_ibus_data_vld;
assign biu_data_vld   = biu_bmu_ibus_data_vld;
assign tcipif_data_vld = tcipif_bmu_ibus_data_vld;

assign bmu_xx_ibus_data[31:0]  = ({32{iahbl_data_vld}}  & iahbl_bmu_ibus_data[31:0])  |
                                 ({32{dahbl_data_vld}}  & dahbl_bmu_ibus_data[31:0])  |
                                 ({32{tcipif_data_vld}} & tcipif_bmu_ibus_data[31:0]) |
                                 ({32{biu_data_vld}}    & biu_bmu_ibus_data[31:0]);



assign bmu_xx_ibus_acc_err     = iahbl_bmu_ibus_acc_err |
                                 dahbl_bmu_ibus_acc_err |
                                 tcipif_bmu_ibus_acc_err |
                                 biu_bmu_ibus_acc_err   |
                                 acc_err_for_deny & ifu_bmu_wfd1;

// &ModuleEnd; @265
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_bmu_top(
  biu_bmu_dbus_acc_err,
  biu_bmu_dbus_data,
  biu_bmu_dbus_data_vld,
  biu_bmu_dbus_grnt,
  biu_bmu_dbus_trans_cmplt,
  biu_bmu_ibus_acc_err,
  biu_bmu_ibus_data,
  biu_bmu_ibus_data_vld,
  biu_bmu_ibus_grnt,
  biu_bmu_ibus_trans_cmplt,
  bmu_biu_dbus_acc_deny,
  bmu_biu_dbus_addr,
  bmu_biu_dbus_chk_fail,
  bmu_biu_dbus_prot,
  bmu_biu_dbus_req,
  bmu_biu_dbus_req_without_cmplt,
  bmu_biu_dbus_size,
  bmu_biu_dbus_wdata,
  bmu_biu_dbus_write,
  bmu_biu_ibus_acc_deny,
  bmu_biu_ibus_addr,
  bmu_biu_ibus_hit,
  bmu_biu_ibus_prot,
  bmu_biu_ibus_req,
  bmu_biu_ibus_req_no_hit,
  bmu_biu_ibus_size,
  bmu_biu_ibus_vec_redirect,
  bmu_iahbl_dbus_acc_deny,
  bmu_iahbl_dbus_addr,
  bmu_iahbl_dbus_chk_fail,
  bmu_iahbl_dbus_prot,
  bmu_iahbl_dbus_req,
  bmu_iahbl_dbus_req_without_cmplt,
  bmu_iahbl_dbus_size,
  bmu_iahbl_dbus_wdata,
  bmu_iahbl_dbus_write,
  bmu_iahbl_ibus_acc_deny,
  bmu_iahbl_ibus_addr,
  bmu_iahbl_ibus_hit,
  bmu_iahbl_ibus_prot,
  bmu_iahbl_ibus_req,
  bmu_iahbl_ibus_req_no_hit,
  bmu_iahbl_ibus_size,
  bmu_iahbl_ibus_vec_redirect,
  bmu_lsu_acc_err,
  bmu_lsu_bstack_chk_fail,
  bmu_lsu_data,
  bmu_lsu_data_vld,
  bmu_lsu_grnt,
  bmu_lsu_trans_cmplt,
  bmu_tcipif_dbus_acc_deny,
  bmu_tcipif_dbus_addr,
  bmu_tcipif_dbus_chk_fail,
  bmu_tcipif_dbus_req,
  bmu_tcipif_dbus_size,
  bmu_tcipif_dbus_supv_mode,
  bmu_tcipif_dbus_wdata,
  bmu_tcipif_dbus_write,
  bmu_tcipif_ibus_acc_deny,
  bmu_tcipif_ibus_addr,
  bmu_tcipif_ibus_req,
  bmu_tcipif_ibus_write,
  bmu_xx_ibus_acc_err,
  bmu_xx_ibus_data,
  bmu_xx_ibus_data_vld,
  bmu_xx_ibus_grnt,
  bmu_xx_ibus_trans_cmplt,
  cp0_yy_clk_en,
  cp0_yy_machine_mode_aft_dbg,
  cpurst_b,
  forever_cpuclk,
  iahbl_bmu_dbus_acc_err,
  iahbl_bmu_dbus_data,
  iahbl_bmu_dbus_data_vld,
  iahbl_bmu_dbus_grnt,
  iahbl_bmu_dbus_trans_cmplt,
  iahbl_bmu_ibus_acc_err,
  iahbl_bmu_ibus_data,
  iahbl_bmu_ibus_data_vld,
  iahbl_bmu_ibus_grnt,
  iahbl_bmu_ibus_trans_cmplt,
  ifu_bmu_addr,
  ifu_bmu_idle,
  ifu_bmu_prot,
  ifu_bmu_req,
  ifu_bmu_wfd1,
  iu_bmu_vec_redirect,
  lsu_bmu_addr,
  lsu_bmu_addr_check_fail,
  lsu_bmu_idle,
  lsu_bmu_prot,
  lsu_bmu_req,
  lsu_bmu_req_without_cmplt,
  lsu_bmu_sg_chk_fail,
  lsu_bmu_size,
  lsu_bmu_store_error,
  lsu_bmu_wdata,
  lsu_bmu_wfd1,
  lsu_bmu_write,
  pad_bmu_iahbl_base,
  pad_bmu_iahbl_mask,
  pad_yy_gate_clk_en_b,
  pmp_bmu_dbus_acc_deny,
  pmp_bmu_ibus_acc_deny,
  tcipif_bmu_dbus_acc_err,
  tcipif_bmu_dbus_data,
  tcipif_bmu_dbus_data_vld,
  tcipif_bmu_dbus_grnt,
  tcipif_bmu_dbus_trans_cmplt,
  tcipif_bmu_ibus_acc_err,
  tcipif_bmu_ibus_data,
  tcipif_bmu_ibus_data_vld,
  tcipif_bmu_ibus_grnt,
  tcipif_bmu_ibus_trans_cmplt
);

// &Ports; @23
input           biu_bmu_dbus_acc_err;            
input   [31:0]  biu_bmu_dbus_data;               
input           biu_bmu_dbus_data_vld;           
input           biu_bmu_dbus_grnt;               
input           biu_bmu_dbus_trans_cmplt;        
input           biu_bmu_ibus_acc_err;            
input   [31:0]  biu_bmu_ibus_data;               
input           biu_bmu_ibus_data_vld;           
input           biu_bmu_ibus_grnt;               
input           biu_bmu_ibus_trans_cmplt;        
input           cp0_yy_clk_en;                   
input           cp0_yy_machine_mode_aft_dbg;     
input           cpurst_b;                        
input           forever_cpuclk;                  
input           iahbl_bmu_dbus_acc_err;          
input   [31:0]  iahbl_bmu_dbus_data;             
input           iahbl_bmu_dbus_data_vld;         
input           iahbl_bmu_dbus_grnt;             
input           iahbl_bmu_dbus_trans_cmplt;      
input           iahbl_bmu_ibus_acc_err;          
input   [31:0]  iahbl_bmu_ibus_data;             
input           iahbl_bmu_ibus_data_vld;         
input           iahbl_bmu_ibus_grnt;             
input           iahbl_bmu_ibus_trans_cmplt;      
input   [31:0]  ifu_bmu_addr;                    
input           ifu_bmu_idle;                    
input   [3 :0]  ifu_bmu_prot;                    
input           ifu_bmu_req;                     
input           ifu_bmu_wfd1;                    
input           iu_bmu_vec_redirect;             
input   [31:0]  lsu_bmu_addr;                    
input           lsu_bmu_addr_check_fail;         
input           lsu_bmu_idle;                    
input   [3 :0]  lsu_bmu_prot;                    
input           lsu_bmu_req;                     
input           lsu_bmu_req_without_cmplt;       
input           lsu_bmu_sg_chk_fail;             
input   [1 :0]  lsu_bmu_size;                    
input           lsu_bmu_store_error;             
input   [31:0]  lsu_bmu_wdata;                   
input           lsu_bmu_wfd1;                    
input           lsu_bmu_write;                   
input   [11:0]  pad_bmu_iahbl_base;              
input   [11:0]  pad_bmu_iahbl_mask;              
input           pad_yy_gate_clk_en_b;            
input           pmp_bmu_dbus_acc_deny;           
input           pmp_bmu_ibus_acc_deny;           
input           tcipif_bmu_dbus_acc_err;         
input   [31:0]  tcipif_bmu_dbus_data;            
input           tcipif_bmu_dbus_data_vld;        
input           tcipif_bmu_dbus_grnt;            
input           tcipif_bmu_dbus_trans_cmplt;     
input           tcipif_bmu_ibus_acc_err;         
input   [31:0]  tcipif_bmu_ibus_data;            
input           tcipif_bmu_ibus_data_vld;        
input           tcipif_bmu_ibus_grnt;            
input           tcipif_bmu_ibus_trans_cmplt;     
output          bmu_biu_dbus_acc_deny;           
output  [31:0]  bmu_biu_dbus_addr;               
output          bmu_biu_dbus_chk_fail;           
output  [3 :0]  bmu_biu_dbus_prot;               
output          bmu_biu_dbus_req;                
output          bmu_biu_dbus_req_without_cmplt;  
output  [1 :0]  bmu_biu_dbus_size;               
output  [31:0]  bmu_biu_dbus_wdata;              
output          bmu_biu_dbus_write;              
output          bmu_biu_ibus_acc_deny;           
output  [31:0]  bmu_biu_ibus_addr;               
output          bmu_biu_ibus_hit;                
output  [3 :0]  bmu_biu_ibus_prot;               
output          bmu_biu_ibus_req;                
output          bmu_biu_ibus_req_no_hit;         
output  [1 :0]  bmu_biu_ibus_size;               
output          bmu_biu_ibus_vec_redirect;       
output          bmu_iahbl_dbus_acc_deny;         
output  [31:0]  bmu_iahbl_dbus_addr;             
output          bmu_iahbl_dbus_chk_fail;         
output  [3 :0]  bmu_iahbl_dbus_prot;             
output          bmu_iahbl_dbus_req;              
output          bmu_iahbl_dbus_req_without_cmplt; 
output  [1 :0]  bmu_iahbl_dbus_size;             
output  [31:0]  bmu_iahbl_dbus_wdata;            
output          bmu_iahbl_dbus_write;            
output          bmu_iahbl_ibus_acc_deny;         
output  [31:0]  bmu_iahbl_ibus_addr;             
output          bmu_iahbl_ibus_hit;              
output  [3 :0]  bmu_iahbl_ibus_prot;             
output          bmu_iahbl_ibus_req;              
output          bmu_iahbl_ibus_req_no_hit;       
output  [1 :0]  bmu_iahbl_ibus_size;             
output          bmu_iahbl_ibus_vec_redirect;     
output          bmu_lsu_acc_err;                 
output          bmu_lsu_bstack_chk_fail;         
output  [31:0]  bmu_lsu_data;                    
output          bmu_lsu_data_vld;                
output          bmu_lsu_grnt;                    
output          bmu_lsu_trans_cmplt;             
output          bmu_tcipif_dbus_acc_deny;        
output  [31:0]  bmu_tcipif_dbus_addr;            
output          bmu_tcipif_dbus_chk_fail;        
output          bmu_tcipif_dbus_req;             
output  [1 :0]  bmu_tcipif_dbus_size;            
output          bmu_tcipif_dbus_supv_mode;       
output  [31:0]  bmu_tcipif_dbus_wdata;           
output          bmu_tcipif_dbus_write;           
output          bmu_tcipif_ibus_acc_deny;        
output  [31:0]  bmu_tcipif_ibus_addr;            
output          bmu_tcipif_ibus_req;             
output          bmu_tcipif_ibus_write;           
output          bmu_xx_ibus_acc_err;             
output  [31:0]  bmu_xx_ibus_data;                
output          bmu_xx_ibus_data_vld;            
output          bmu_xx_ibus_grnt;                
output          bmu_xx_ibus_trans_cmplt;         

// &Regs; @24

// &Wires; @25
wire            biu_bmu_dbus_acc_err;            
wire    [31:0]  biu_bmu_dbus_data;               
wire            biu_bmu_dbus_data_vld;           
wire            biu_bmu_dbus_grnt;               
wire            biu_bmu_dbus_trans_cmplt;        
wire            biu_bmu_ibus_acc_err;            
wire    [31:0]  biu_bmu_ibus_data;               
wire            biu_bmu_ibus_data_vld;           
wire            biu_bmu_ibus_grnt;               
wire            biu_bmu_ibus_trans_cmplt;        
wire            bmu_biu_dbus_acc_deny;           
wire    [31:0]  bmu_biu_dbus_addr;               
wire            bmu_biu_dbus_chk_fail;           
wire    [3 :0]  bmu_biu_dbus_prot;               
wire            bmu_biu_dbus_req;                
wire            bmu_biu_dbus_req_without_cmplt;  
wire    [1 :0]  bmu_biu_dbus_size;               
wire    [31:0]  bmu_biu_dbus_wdata;              
wire            bmu_biu_dbus_write;              
wire            bmu_biu_ibus_acc_deny;           
wire    [31:0]  bmu_biu_ibus_addr;               
wire            bmu_biu_ibus_hit;                
wire    [3 :0]  bmu_biu_ibus_prot;               
wire            bmu_biu_ibus_req;                
wire            bmu_biu_ibus_req_no_hit;         
wire    [1 :0]  bmu_biu_ibus_size;               
wire            bmu_biu_ibus_vec_redirect;       
wire            bmu_iahbl_dbus_acc_deny;         
wire    [31:0]  bmu_iahbl_dbus_addr;             
wire            bmu_iahbl_dbus_chk_fail;         
wire    [3 :0]  bmu_iahbl_dbus_prot;             
wire            bmu_iahbl_dbus_req;              
wire            bmu_iahbl_dbus_req_without_cmplt; 
wire    [1 :0]  bmu_iahbl_dbus_size;             
wire    [31:0]  bmu_iahbl_dbus_wdata;            
wire            bmu_iahbl_dbus_write;            
wire            bmu_iahbl_ibus_acc_deny;         
wire    [31:0]  bmu_iahbl_ibus_addr;             
wire            bmu_iahbl_ibus_hit;              
wire    [3 :0]  bmu_iahbl_ibus_prot;             
wire            bmu_iahbl_ibus_req;              
wire            bmu_iahbl_ibus_req_no_hit;       
wire    [1 :0]  bmu_iahbl_ibus_size;             
wire            bmu_iahbl_ibus_vec_redirect;     
wire            bmu_lsu_acc_err;                 
wire            bmu_lsu_bstack_chk_fail;         
wire    [31:0]  bmu_lsu_data;                    
wire            bmu_lsu_data_vld;                
wire            bmu_lsu_grnt;                    
wire            bmu_lsu_trans_cmplt;             
wire            bmu_tcipif_dbus_acc_deny;        
wire    [31:0]  bmu_tcipif_dbus_addr;            
wire            bmu_tcipif_dbus_chk_fail;        
wire            bmu_tcipif_dbus_req;             
wire    [1 :0]  bmu_tcipif_dbus_size;            
wire            bmu_tcipif_dbus_supv_mode;       
wire    [31:0]  bmu_tcipif_dbus_wdata;           
wire            bmu_tcipif_dbus_write;           
wire            bmu_tcipif_ibus_acc_deny;        
wire    [31:0]  bmu_tcipif_ibus_addr;            
wire            bmu_tcipif_ibus_req;             
wire            bmu_tcipif_ibus_write;           
wire            bmu_xx_ibus_acc_err;             
wire    [31:0]  bmu_xx_ibus_data;                
wire            bmu_xx_ibus_data_vld;            
wire            bmu_xx_ibus_grnt;                
wire            bmu_xx_ibus_trans_cmplt;         
wire            cp0_yy_clk_en;                   
wire            cp0_yy_machine_mode_aft_dbg;     
wire            cpurst_b;                        
wire            dbus_deny_clk_en;                
wire            deny_clk;                        
wire            deny_en;                         
wire            forever_cpuclk;                  
wire            iahbl_bmu_dbus_acc_err;          
wire    [31:0]  iahbl_bmu_dbus_data;             
wire            iahbl_bmu_dbus_data_vld;         
wire            iahbl_bmu_dbus_grnt;             
wire            iahbl_bmu_dbus_trans_cmplt;      
wire            iahbl_bmu_ibus_acc_err;          
wire    [31:0]  iahbl_bmu_ibus_data;             
wire            iahbl_bmu_ibus_data_vld;         
wire            iahbl_bmu_ibus_grnt;             
wire            iahbl_bmu_ibus_trans_cmplt;      
wire            ibus_deny_clk_en;                
wire    [31:0]  ifu_bmu_addr;                    
wire            ifu_bmu_idle;                    
wire    [3 :0]  ifu_bmu_prot;                    
wire            ifu_bmu_req;                     
wire            ifu_bmu_wfd1;                    
wire            iu_bmu_vec_redirect;             
wire    [31:0]  lsu_bmu_addr;                    
wire            lsu_bmu_addr_check_fail;         
wire            lsu_bmu_idle;                    
wire    [3 :0]  lsu_bmu_prot;                    
wire            lsu_bmu_req;                     
wire            lsu_bmu_req_without_cmplt;       
wire            lsu_bmu_sg_chk_fail;             
wire    [1 :0]  lsu_bmu_size;                    
wire            lsu_bmu_store_error;             
wire    [31:0]  lsu_bmu_wdata;                   
wire            lsu_bmu_wfd1;                    
wire            lsu_bmu_write;                   
wire    [11:0]  pad_bmu_iahbl_base;              
wire    [11:0]  pad_bmu_iahbl_mask;              
wire            pad_yy_gate_clk_en_b;            
wire            pmp_bmu_dbus_acc_deny;           
wire            pmp_bmu_ibus_acc_deny;           
wire            tcipif_bmu_dbus_acc_err;         
wire    [31:0]  tcipif_bmu_dbus_data;            
wire            tcipif_bmu_dbus_data_vld;        
wire            tcipif_bmu_dbus_grnt;            
wire            tcipif_bmu_dbus_trans_cmplt;     
wire            tcipif_bmu_ibus_acc_err;         
wire    [31:0]  tcipif_bmu_ibus_data;            
wire            tcipif_bmu_ibus_data_vld;        
wire            tcipif_bmu_ibus_grnt;            
wire            tcipif_bmu_ibus_trans_cmplt;     



//==========================================================
//                 Instance of Gated Cell  
//==========================================================
// &Instance("gated_clk_cell", "x_deny_gated_clk"); @33
// &Connect(.clk_in      (forever_cpuclk), @34
//          .external_en (1'b0), @35
//          .global_en   (cp0_yy_clk_en), @36
//          .module_en   (1'b0), @37
//          .local_en    (deny_en), @38
//          .clk_out     (deny_clk)); @39
// &Instance("gated_clk_cell", "x_deny_gated_clk"); @43
// &Connect(.clk_in      (forever_cpuclk), @44
//          .external_en (1'b0), @45
//          .global_en   (cp0_yy_clk_en), @46
//          .module_en   (1'b0), @47
//          .local_en    (deny_en), @48
//          .clk_out     (deny_clk)); @49
assign deny_en = ibus_deny_clk_en || dbus_deny_clk_en;
// &Instance("gated_clk_cell", "x_deny_gated_clk"); @53
gated_clk_cell  x_deny_gated_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (deny_clk            ),
  .external_en          (1'b0                ),
  .global_en            (cp0_yy_clk_en       ),
  .local_en             (deny_en             ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk), @54
//          .external_en (1'b0), @55
//          .global_en   (cp0_yy_clk_en), @56
//          .module_en   (1'b0), @57
//          .local_en    (deny_en), @58
//          .clk_out     (deny_clk)); @59
// &Instance("gated_clk_cell", "x_deny_gated_clk"); @63
// &Connect(.clk_in      (forever_cpuclk), @64
//          .external_en (1'b0), @65
//          .global_en   (cp0_yy_clk_en), @66
//          .module_en   (1'b0), @67
//          .local_en    (deny_en), @68
//          .clk_out     (deny_clk)); @69
// &Instance("gated_clk_cell", "x_deny_gated_clk"); @73
// &Connect(.clk_in      (forever_cpuclk), @74
//          .external_en (1'b0), @75
//          .global_en   (cp0_yy_clk_en), @76
//          .module_en   (1'b0), @77
//          .local_en    (deny_en), @78
//          .clk_out     (deny_clk)); @79

// &Instance("cr_bmu_dbus_if","x_cr_bmu_dbus_if"); @87
cr_bmu_dbus_if  x_cr_bmu_dbus_if (
  .biu_bmu_dbus_acc_err             (biu_bmu_dbus_acc_err            ),
  .biu_bmu_dbus_data                (biu_bmu_dbus_data               ),
  .biu_bmu_dbus_data_vld            (biu_bmu_dbus_data_vld           ),
  .biu_bmu_dbus_grnt                (biu_bmu_dbus_grnt               ),
  .biu_bmu_dbus_trans_cmplt         (biu_bmu_dbus_trans_cmplt        ),
  .bmu_biu_dbus_acc_deny            (bmu_biu_dbus_acc_deny           ),
  .bmu_biu_dbus_addr                (bmu_biu_dbus_addr               ),
  .bmu_biu_dbus_chk_fail            (bmu_biu_dbus_chk_fail           ),
  .bmu_biu_dbus_prot                (bmu_biu_dbus_prot               ),
  .bmu_biu_dbus_req                 (bmu_biu_dbus_req                ),
  .bmu_biu_dbus_req_without_cmplt   (bmu_biu_dbus_req_without_cmplt  ),
  .bmu_biu_dbus_size                (bmu_biu_dbus_size               ),
  .bmu_biu_dbus_wdata               (bmu_biu_dbus_wdata              ),
  .bmu_biu_dbus_write               (bmu_biu_dbus_write              ),
  .bmu_iahbl_dbus_acc_deny          (bmu_iahbl_dbus_acc_deny         ),
  .bmu_iahbl_dbus_addr              (bmu_iahbl_dbus_addr             ),
  .bmu_iahbl_dbus_chk_fail          (bmu_iahbl_dbus_chk_fail         ),
  .bmu_iahbl_dbus_prot              (bmu_iahbl_dbus_prot             ),
  .bmu_iahbl_dbus_req               (bmu_iahbl_dbus_req              ),
  .bmu_iahbl_dbus_req_without_cmplt (bmu_iahbl_dbus_req_without_cmplt),
  .bmu_iahbl_dbus_size              (bmu_iahbl_dbus_size             ),
  .bmu_iahbl_dbus_wdata             (bmu_iahbl_dbus_wdata            ),
  .bmu_iahbl_dbus_write             (bmu_iahbl_dbus_write            ),
  .bmu_lsu_acc_err                  (bmu_lsu_acc_err                 ),
  .bmu_lsu_bstack_chk_fail          (bmu_lsu_bstack_chk_fail         ),
  .bmu_lsu_data                     (bmu_lsu_data                    ),
  .bmu_lsu_data_vld                 (bmu_lsu_data_vld                ),
  .bmu_lsu_grnt                     (bmu_lsu_grnt                    ),
  .bmu_lsu_trans_cmplt              (bmu_lsu_trans_cmplt             ),
  .bmu_tcipif_dbus_acc_deny         (bmu_tcipif_dbus_acc_deny        ),
  .bmu_tcipif_dbus_addr             (bmu_tcipif_dbus_addr            ),
  .bmu_tcipif_dbus_chk_fail         (bmu_tcipif_dbus_chk_fail        ),
  .bmu_tcipif_dbus_req              (bmu_tcipif_dbus_req             ),
  .bmu_tcipif_dbus_size             (bmu_tcipif_dbus_size            ),
  .bmu_tcipif_dbus_supv_mode        (bmu_tcipif_dbus_supv_mode       ),
  .bmu_tcipif_dbus_wdata            (bmu_tcipif_dbus_wdata           ),
  .bmu_tcipif_dbus_write            (bmu_tcipif_dbus_write           ),
  .cp0_yy_machine_mode_aft_dbg      (cp0_yy_machine_mode_aft_dbg     ),
  .cpurst_b                         (cpurst_b                        ),
  .dbus_deny_clk_en                 (dbus_deny_clk_en                ),
  .deny_clk                         (deny_clk                        ),
  .iahbl_bmu_dbus_acc_err           (iahbl_bmu_dbus_acc_err          ),
  .iahbl_bmu_dbus_data              (iahbl_bmu_dbus_data             ),
  .iahbl_bmu_dbus_data_vld          (iahbl_bmu_dbus_data_vld         ),
  .iahbl_bmu_dbus_grnt              (iahbl_bmu_dbus_grnt             ),
  .iahbl_bmu_dbus_trans_cmplt       (iahbl_bmu_dbus_trans_cmplt      ),
  .lsu_bmu_addr                     (lsu_bmu_addr                    ),
  .lsu_bmu_addr_check_fail          (lsu_bmu_addr_check_fail         ),
  .lsu_bmu_idle                     (lsu_bmu_idle                    ),
  .lsu_bmu_prot                     (lsu_bmu_prot                    ),
  .lsu_bmu_req                      (lsu_bmu_req                     ),
  .lsu_bmu_req_without_cmplt        (lsu_bmu_req_without_cmplt       ),
  .lsu_bmu_sg_chk_fail              (lsu_bmu_sg_chk_fail             ),
  .lsu_bmu_size                     (lsu_bmu_size                    ),
  .lsu_bmu_store_error              (lsu_bmu_store_error             ),
  .lsu_bmu_wdata                    (lsu_bmu_wdata                   ),
  .lsu_bmu_wfd1                     (lsu_bmu_wfd1                    ),
  .lsu_bmu_write                    (lsu_bmu_write                   ),
  .pad_bmu_iahbl_base               (pad_bmu_iahbl_base              ),
  .pad_bmu_iahbl_mask               (pad_bmu_iahbl_mask              ),
  .pmp_bmu_dbus_acc_deny            (pmp_bmu_dbus_acc_deny           ),
  .tcipif_bmu_dbus_acc_err          (tcipif_bmu_dbus_acc_err         ),
  .tcipif_bmu_dbus_data             (tcipif_bmu_dbus_data            ),
  .tcipif_bmu_dbus_data_vld         (tcipif_bmu_dbus_data_vld        ),
  .tcipif_bmu_dbus_grnt             (tcipif_bmu_dbus_grnt            ),
  .tcipif_bmu_dbus_trans_cmplt      (tcipif_bmu_dbus_trans_cmplt     )
);

// &Connect( @90
//          .pmp_bmu_dbus_acc_deny(1'b0) @91
//         ); @92
// &Connect(.deny_clk   (forever_cpuclk)); @99

// &Instance("cr_bmu_ibus_if","x_cr_bmu_ibus_if"); @105
cr_bmu_ibus_if  x_cr_bmu_ibus_if (
  .biu_bmu_ibus_acc_err        (biu_bmu_ibus_acc_err       ),
  .biu_bmu_ibus_data           (biu_bmu_ibus_data          ),
  .biu_bmu_ibus_data_vld       (biu_bmu_ibus_data_vld      ),
  .biu_bmu_ibus_grnt           (biu_bmu_ibus_grnt          ),
  .biu_bmu_ibus_trans_cmplt    (biu_bmu_ibus_trans_cmplt   ),
  .bmu_biu_ibus_acc_deny       (bmu_biu_ibus_acc_deny      ),
  .bmu_biu_ibus_addr           (bmu_biu_ibus_addr          ),
  .bmu_biu_ibus_hit            (bmu_biu_ibus_hit           ),
  .bmu_biu_ibus_prot           (bmu_biu_ibus_prot          ),
  .bmu_biu_ibus_req            (bmu_biu_ibus_req           ),
  .bmu_biu_ibus_req_no_hit     (bmu_biu_ibus_req_no_hit    ),
  .bmu_biu_ibus_size           (bmu_biu_ibus_size          ),
  .bmu_biu_ibus_vec_redirect   (bmu_biu_ibus_vec_redirect  ),
  .bmu_iahbl_ibus_acc_deny     (bmu_iahbl_ibus_acc_deny    ),
  .bmu_iahbl_ibus_addr         (bmu_iahbl_ibus_addr        ),
  .bmu_iahbl_ibus_hit          (bmu_iahbl_ibus_hit         ),
  .bmu_iahbl_ibus_prot         (bmu_iahbl_ibus_prot        ),
  .bmu_iahbl_ibus_req          (bmu_iahbl_ibus_req         ),
  .bmu_iahbl_ibus_req_no_hit   (bmu_iahbl_ibus_req_no_hit  ),
  .bmu_iahbl_ibus_size         (bmu_iahbl_ibus_size        ),
  .bmu_iahbl_ibus_vec_redirect (bmu_iahbl_ibus_vec_redirect),
  .bmu_tcipif_ibus_acc_deny    (bmu_tcipif_ibus_acc_deny   ),
  .bmu_tcipif_ibus_addr        (bmu_tcipif_ibus_addr       ),
  .bmu_tcipif_ibus_req         (bmu_tcipif_ibus_req        ),
  .bmu_tcipif_ibus_write       (bmu_tcipif_ibus_write      ),
  .bmu_xx_ibus_acc_err         (bmu_xx_ibus_acc_err        ),
  .bmu_xx_ibus_data            (bmu_xx_ibus_data           ),
  .bmu_xx_ibus_data_vld        (bmu_xx_ibus_data_vld       ),
  .bmu_xx_ibus_grnt            (bmu_xx_ibus_grnt           ),
  .bmu_xx_ibus_trans_cmplt     (bmu_xx_ibus_trans_cmplt    ),
  .cpurst_b                    (cpurst_b                   ),
  .deny_clk                    (deny_clk                   ),
  .iahbl_bmu_ibus_acc_err      (iahbl_bmu_ibus_acc_err     ),
  .iahbl_bmu_ibus_data         (iahbl_bmu_ibus_data        ),
  .iahbl_bmu_ibus_data_vld     (iahbl_bmu_ibus_data_vld    ),
  .iahbl_bmu_ibus_grnt         (iahbl_bmu_ibus_grnt        ),
  .iahbl_bmu_ibus_trans_cmplt  (iahbl_bmu_ibus_trans_cmplt ),
  .ibus_deny_clk_en            (ibus_deny_clk_en           ),
  .ifu_bmu_addr                (ifu_bmu_addr               ),
  .ifu_bmu_idle                (ifu_bmu_idle               ),
  .ifu_bmu_prot                (ifu_bmu_prot               ),
  .ifu_bmu_req                 (ifu_bmu_req                ),
  .ifu_bmu_wfd1                (ifu_bmu_wfd1               ),
  .iu_bmu_vec_redirect         (iu_bmu_vec_redirect        ),
  .pad_bmu_iahbl_base          (pad_bmu_iahbl_base         ),
  .pad_bmu_iahbl_mask          (pad_bmu_iahbl_mask         ),
  .pmp_bmu_ibus_acc_deny       (pmp_bmu_ibus_acc_deny      ),
  .tcipif_bmu_ibus_acc_err     (tcipif_bmu_ibus_acc_err    ),
  .tcipif_bmu_ibus_data        (tcipif_bmu_ibus_data       ),
  .tcipif_bmu_ibus_data_vld    (tcipif_bmu_ibus_data_vld   ),
  .tcipif_bmu_ibus_grnt        (tcipif_bmu_ibus_grnt       ),
  .tcipif_bmu_ibus_trans_cmplt (tcipif_bmu_ibus_trans_cmplt)
);

// &Connect( @108
//          .pmp_bmu_ibus_acc_deny(1'b0) @109
//         ); @110
// &Connect(.deny_clk   (forever_cpuclk)); @117


// &Instance("cr_bmu_had_if","x_cr_bmu_had_if"); @138
// &Connect(.deny_clk   (forever_cpuclk)); @147


// &ModuleEnd; @158
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @26
module cr_clic_arb(
  arb_ctrl_int_hv,
  arb_ctrl_int_id,
  arb_ctrl_int_il,
  arb_ctrl_int_mode,
  cpurst_b,
  ctrl_xx_int_lv_or_mask,
  kid_arb_int_all_vec,
  kid_arb_int_hv,
  kid_arb_int_req,
  out_clk,
  out_clk_en
);

// &Ports; @27
input            cpurst_b;              
input   [2  :0]  ctrl_xx_int_lv_or_mask; 
input   [319:0]  kid_arb_int_all_vec;   
input   [79 :0]  kid_arb_int_hv;        
input   [79 :0]  kid_arb_int_req;       
input            out_clk;               
output           arb_ctrl_int_hv;       
output  [11 :0]  arb_ctrl_int_id;       
output  [7  :0]  arb_ctrl_int_il;       
output           arb_ctrl_int_mode;     
output           out_clk_en;            

// &Regs; @28
reg              arb_final_int_req_flop; 

// &Wires; @29
wire             arb_ctrl_int_hv;       
wire    [11 :0]  arb_ctrl_int_id;       
wire    [7  :0]  arb_ctrl_int_il;       
wire             arb_ctrl_int_mode;     
wire    [3  :0]  arb_final_int_all;     
wire             arb_final_int_hv;      
wire    [11 :0]  arb_final_int_id;      
wire    [2  :0]  arb_final_int_lv;      
wire             arb_final_int_mode;    
wire             arb_final_int_req;     
wire             arb_final_int_req_updt; 
wire             cpurst_b;              
wire    [2  :0]  ctrl_xx_int_lv_or_mask; 
wire    [79 :0]  kid_arb_int_hv;        
wire    [79 :0]  kid_arb_int_req;       
wire    [79 :0]  kid_final_sel_onehot;  
wire             out_clk;               
wire             out_clk_en;            


parameter CLICINTNUM     = `CLIC_INTNUM;
parameter CLICINTCTLBITS = `CLIC_INTCTLBITS;
parameter ID_WIDTH       = 12;

// &Force("input", "kid_arb_int_all_vec"); @35
// &Force("bus", "kid_arb_int_all_vec", (CLICINTCTLBITS+1)*(CLICINTNUM)-1, 0); @36
// &Force("bus", "kid_arb_int_hv", CLICINTNUM-1, 0); @37
// &Force("bus", "kid_arb_int_req", CLICINTNUM-1, 0); @38

//==========================================================
//                       Arbiter
//==========================================================
// &Force("nonport", "kid_final_sel_onehot"); @43
//csky vperl_off
cr_clic_arb_kernel #((CLICINTCTLBITS+1), CLICINTNUM) x_cr_clic_arb_kernel (
  .prio_in_vec    (kid_arb_int_all_vec),
  .sel_out_onehot (kid_final_sel_onehot)
);
//csky vperl_on

assign arb_final_int_hv  = |(kid_arb_int_hv[CLICINTNUM-1:0]  & kid_final_sel_onehot[CLICINTNUM-1:0]);
assign arb_final_int_req = |(kid_arb_int_req[CLICINTNUM-1:0] & kid_final_sel_onehot[CLICINTNUM-1:0]);

// &Force("nonport", "arb_final_int_all"); @54
//csky vperl_off
cr_clic_sel #((CLICINTCTLBITS+1), CLICINTNUM) x_cr_clic_sel_level_all (
  .data_in        (kid_arb_int_all_vec),
  .sel_in_onehot  (kid_final_sel_onehot),
  .data_out       (arb_final_int_all)
);
//csky vperl_on

// &Force("nonport", "id_vec"); @63
// &Force("nonport", "arb_final_int_id"); @64

//csky vperl_off
wire [ID_WIDTH*CLICINTNUM-1:0] id_vec;

genvar i;
generate
  for (i = 0; i < CLICINTNUM; i = i+1)
  begin: GEN_ID
    assign id_vec[ID_WIDTH*i+:ID_WIDTH] = $unsigned(i) & {ID_WIDTH{1'b1}};
  end
endgenerate

cr_clic_sel #(ID_WIDTH, CLICINTNUM) x_cr_clic_sel_id_vec (
  .data_in        (id_vec),
  .sel_in_onehot  (kid_final_sel_onehot),
  .data_out       (arb_final_int_id)
);
//csky vperl_on

assign arb_final_int_mode = arb_final_int_all[CLICINTCTLBITS];
assign arb_final_int_lv[CLICINTCTLBITS-1:0] = arb_final_int_all[CLICINTCTLBITS-1:0]
                                         | ctrl_xx_int_lv_or_mask[CLICINTCTLBITS-1:0]
                                         & {CLICINTCTLBITS{arb_final_int_req}};


//==========================================================
//                     Output Signal
//==========================================================
assign arb_ctrl_int_hv               = arb_final_int_hv;
assign arb_ctrl_int_id[ID_WIDTH-1:0] = arb_final_int_id[ID_WIDTH-1:0];
assign arb_ctrl_int_mode             = arb_final_int_mode;
assign arb_ctrl_int_il[7:0]          = {arb_final_int_lv[CLICINTCTLBITS-1:0],
                                        {(8-CLICINTCTLBITS){arb_final_int_req}}};

//==========================================================
//                     Gate Clk Cell
//==========================================================
assign arb_final_int_req_updt = arb_final_int_req_flop ^ arb_final_int_req;

always @ (posedge out_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    arb_final_int_req_flop <= 1'b0;
  else if (arb_final_int_req_updt)
    arb_final_int_req_flop <= arb_final_int_req;
end

assign out_clk_en = arb_final_int_req_updt
                 || arb_final_int_req;


// &ModuleEnd; @116
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_clic_arb_kernel(
  // input
  prio_in_vec,
  // output
  sel_out_onehot
);

parameter PRIO_WIDTH   = 6;
parameter INT_NUM     = 32;
parameter PRIO_EXP_NUM = 1 <<< PRIO_WIDTH;

input  [PRIO_WIDTH*INT_NUM-1:0] prio_in_vec;

output [INT_NUM-1:0]            sel_out_onehot;

wire   [INT_NUM-1:0]            sel_out_onehot;

wire   [PRIO_EXP_NUM-1:0]    prio_in_2d[INT_NUM-1:0];
wire   [INT_NUM-1:0]         prio_in_2d_rev[PRIO_EXP_NUM-1:0];

genvar i;
genvar j;
genvar k;

//==========================================================
//                   Generate 2D prio
//==========================================================
generate
  for (k = 0; k < INT_NUM; k = k+1)
  begin: EXPEND_PRIO
    assign prio_in_2d[k][PRIO_EXP_NUM-1:0] = {{(PRIO_EXP_NUM-1){1'b0}}, 1'b1} << prio_in_vec[PRIO_WIDTH*k+:PRIO_WIDTH];
  end
endgenerate

//==========================================================
//                   Reverse 2D signal
//==========================================================
generate
  for (i = 0; i < INT_NUM; i = i+1) begin: REVERSEI
    for (j = 0; j < PRIO_EXP_NUM; j = j+1) begin: REVERSEJ
      assign prio_in_2d_rev[j][i] = prio_in_2d[i][j];
    end
  end
endgenerate

wire   [PRIO_EXP_NUM-1:0]         high_prio_onehot;
wire   [PRIO_EXP_NUM-1:0]         prio_out;
//==========================================================
//                     Do or to sel
//==========================================================
generate
  for (i = 0; i < PRIO_EXP_NUM; i = i+1) begin: OR_SEL
    assign prio_out[i] = |prio_in_2d_rev[i][INT_NUM-1:0];
  end
endgenerate

cr_clic_ff1_onehot #(PRIO_EXP_NUM) x_cr_clic_high_prio(
  .data_in        (prio_out),
  .ff1_out_onehot (high_prio_onehot)
);

wire   [PRIO_EXP_NUM-1:0]    prio_after_mask_2d[INT_NUM-1:0];
wire   [INT_NUM-1:0]         int_hit_prio;
generate
  for (k = 0; k < INT_NUM; k = k+1)
  begin: PRIO_MASK
    assign prio_after_mask_2d[k][PRIO_EXP_NUM-1:0] = prio_in_2d[k][PRIO_EXP_NUM-1:0] & high_prio_onehot[PRIO_EXP_NUM-1:0];
    assign int_hit_prio[k] = |prio_after_mask_2d[k][PRIO_EXP_NUM-1:0];
  end
endgenerate

wire   [INT_NUM-1:0]          int_sel_onehot;

cr_clic_ff1_onehot #(INT_NUM) x_cr_clic_num(
  .data_in        (int_hit_prio),
  .ff1_out_onehot (int_sel_onehot)
);

assign sel_out_onehot[INT_NUM-1:0] = int_sel_onehot[INT_NUM-1:0];

endmodule

/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_clic_busif(
  busif_ctrl_cliccfg_sel,
  busif_ctrl_clicinfo_sel,
  busif_ctrl_mintthresh_sel,
  busif_kid_clicintattr_sel,
  busif_kid_clicintctl_sel,
  busif_kid_clicintie_sel,
  busif_kid_clicintip_sel,
  busif_kid_wdata,
  busif_xx_write_vld,
  clic_tcipif_cmplt,
  clic_tcipif_rdata,
  ctrl_busif_cliccfg_val,
  ctrl_busif_clicinfo_val,
  ctrl_busif_mintthresh_val,
  kid_busif_rdata_vec,
  tcipif_clic_addr,
  tcipif_clic_sel,
  tcipif_clic_size,
  tcipif_clic_wdata,
  tcipif_clic_write
);

// &Ports; @24
input   [31  :0]  ctrl_busif_cliccfg_val;   
input   [31  :0]  ctrl_busif_clicinfo_val;  
input   [31  :0]  ctrl_busif_mintthresh_val; 
input   [2559:0]  kid_busif_rdata_vec;      
input   [15  :0]  tcipif_clic_addr;         
input             tcipif_clic_sel;          
input   [1   :0]  tcipif_clic_size;         
input   [31  :0]  tcipif_clic_wdata;        
input             tcipif_clic_write;        
output            busif_ctrl_cliccfg_sel;   
output            busif_ctrl_clicinfo_sel;  
output            busif_ctrl_mintthresh_sel; 
output  [79  :0]  busif_kid_clicintattr_sel; 
output  [79  :0]  busif_kid_clicintctl_sel; 
output  [79  :0]  busif_kid_clicintie_sel;  
output  [79  :0]  busif_kid_clicintip_sel;  
output  [31  :0]  busif_kid_wdata;          
output            busif_xx_write_vld;       
output            clic_tcipif_cmplt;        
output  [31  :0]  clic_tcipif_rdata;        

// &Regs; @25
reg     [3   :0]  busif_kid_reg_sel;        

// &Wires; @26
wire              busif_ctrl_cliccfg_sel;   
wire              busif_ctrl_clicinfo_sel;  
wire              busif_ctrl_mintthresh_sel; 
wire    [79  :0]  busif_kid_sel;            
wire    [31  :0]  busif_kid_wdata;          
wire              busif_read_vld;           
wire              busif_xx_write_vld;       
wire              clic_tcipif_cmplt;        
wire    [31  :0]  clic_tcipif_rdata;        
wire              cliccfg_sel;              
wire              clicinfo_sel;             
wire    [31  :0]  ctrl_busif_cliccfg_val;   
wire    [31  :0]  ctrl_busif_clicinfo_val;  
wire    [31  :0]  ctrl_busif_mintthresh_val; 
wire    [31  :0]  kid_busif_rdata;          
wire              mintthresh_sel;           
wire    [15  :0]  tcipif_clic_addr;         
wire              tcipif_clic_sel;          
wire    [1   :0]  tcipif_clic_size;         
wire    [31  :0]  tcipif_clic_wdata;        
wire              tcipif_clic_write;        


parameter CLICINTNUM = `CLIC_INTNUM;

parameter CLICCFG_BASE    = 16'h0000;
parameter CLICINFO_BASE   = 16'h0004;
parameter MINTTHRESH_BASE = 16'h0008;

parameter CLICKID_BASE    = 16'h1000;

assign cliccfg_sel    = tcipif_clic_addr[15:0] == CLICCFG_BASE;
assign clicinfo_sel   = tcipif_clic_addr[15:0] == CLICINFO_BASE;
assign mintthresh_sel = tcipif_clic_addr[15:0] == MINTTHRESH_BASE;
assign busif_ctrl_cliccfg_sel    = cliccfg_sel;
assign busif_ctrl_clicinfo_sel   = clicinfo_sel;
assign busif_ctrl_mintthresh_sel = mintthresh_sel;

assign clic_tcipif_cmplt = tcipif_clic_sel;
assign busif_kid_wdata[31:0] = tcipif_clic_wdata[31:0];

// &CombBeg; @46
always @( tcipif_clic_size[1:0]
       or tcipif_clic_addr[1:0])
begin
  case({tcipif_clic_addr[1:0], tcipif_clic_size[1:0]})
    4'b00_00: busif_kid_reg_sel[3:0] = 4'b0001; // Byte
    4'b01_00: busif_kid_reg_sel[3:0] = 4'b0010;
    4'b10_00: busif_kid_reg_sel[3:0] = 4'b0100;
    4'b11_00: busif_kid_reg_sel[3:0] = 4'b1000; // Half word
    4'b00_01: busif_kid_reg_sel[3:0] = 4'b0011;
    4'b10_01: busif_kid_reg_sel[3:0] = 4'b1100;
    4'b00_10: busif_kid_reg_sel[3:0] = 4'b1111;
    default:  busif_kid_reg_sel[3:0] = 4'b0000;
  endcase
// &CombEnd; @57
end
// &Force("nonport", "busif_kid_reg_sel"); @58
// &Force("nonport", "busif_kid_sel"); @59

// &Force("output", "busif_kid_clicintip_sel"); @61
// &Force("output", "busif_kid_clicintie_sel"); @62
// &Force("output", "busif_kid_clicintattr_sel"); @63
// &Force("output", "busif_kid_clicintctl_sel"); @64
// &Force("bus", "busif_kid_clicintip_sel", CLICINTNUM-1, 0); @65
// &Force("bus", "busif_kid_clicintie_sel", CLICINTNUM-1, 0); @66
// &Force("bus", "busif_kid_clicintattr_sel", CLICINTNUM-1, 0); @67
// &Force("bus", "busif_kid_clicintctl_sel", CLICINTNUM-1, 0); @68

//csky vperl_off
wire [CLICINTNUM-1:0] busif_kid_clicintip_sel;
wire [CLICINTNUM-1:0] busif_kid_clicintie_sel;
wire [CLICINTNUM-1:0] busif_kid_clicintattr_sel;
wire [CLICINTNUM-1:0] busif_kid_clicintctl_sel;

genvar i;
generate
for (i = 0; i < CLICINTNUM; i = i+1)
begin: BUSIF_KID
  assign busif_kid_sel[i] = (tcipif_clic_addr[15:2] - CLICKID_BASE[15:2]) == i;
  assign busif_kid_clicintip_sel[i]   = busif_kid_sel[i] && busif_kid_reg_sel[0];
  assign busif_kid_clicintie_sel[i]   = busif_kid_sel[i] && busif_kid_reg_sel[1];
  assign busif_kid_clicintattr_sel[i] = busif_kid_sel[i] && busif_kid_reg_sel[2];
  assign busif_kid_clicintctl_sel[i]  = busif_kid_sel[i] && busif_kid_reg_sel[3];
end
endgenerate
//csky vperl_on

assign busif_xx_write_vld = tcipif_clic_sel && tcipif_clic_write;
assign busif_read_vld     = tcipif_clic_sel && !tcipif_clic_write;
//==========================================================
//                      Read Sel
//==========================================================
// &Force("input", "kid_busif_rdata_vec"); @94
// &Force("bus", "kid_busif_rdata_vec", (CLICINTNUM)*32-1, 0); @95
// &Force("nonport", "kid_busif_rdata"); @96
//csky vperl_off
cr_clic_sel #(32, CLICINTNUM) x_cr_clic_kid_rdata_sel(
  .data_in         (kid_busif_rdata_vec),
  .sel_in_onehot   (busif_kid_sel),
  .data_out        (kid_busif_rdata)
);
//csky vperl_on

assign clic_tcipif_rdata[31:0] = {{32{cliccfg_sel}}    & ctrl_busif_cliccfg_val[31:0]
                                | {32{clicinfo_sel}}   & ctrl_busif_clicinfo_val[31:0]
                                | {32{mintthresh_sel}} & ctrl_busif_mintthresh_val[31:0]
                                | {32{|busif_kid_sel[CLICINTNUM-1:0]}} & kid_busif_rdata[31:0]}
                                & {32{busif_read_vld}};

// &ModuleEnd; @111
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_clic_ctrl(
  arb_ctrl_int_hv,
  arb_ctrl_int_id,
  arb_ctrl_int_il,
  arb_ctrl_int_mode,
  busif_ctrl_cliccfg_sel,
  busif_ctrl_clicinfo_sel,
  busif_ctrl_mintthresh_sel,
  busif_kid_wdata,
  busif_xx_write_vld,
  clic_cpu_int_hv,
  clic_cpu_int_id,
  clic_cpu_int_il,
  clic_cpu_int_priv,
  clicreg_clk,
  cpu_clic_curid,
  cpu_clic_int_exit,
  cpu_clic_mode,
  cpurst_b,
  ctrl_busif_cliccfg_val,
  ctrl_busif_clicinfo_val,
  ctrl_busif_mintthresh_val,
  ctrl_clicintattr_en,
  ctrl_clicintctl_en,
  ctrl_clicintie_en,
  ctrl_clicintip_en,
  ctrl_clicreg_en,
  ctrl_kid_ack_int,
  ctrl_sample_en,
  ctrl_xx_int_lv_or_mask,
  kid_ctrl_clicintattr_en,
  kid_ctrl_clicintctl_en,
  kid_ctrl_clicintie_en,
  kid_ctrl_clicintip_en,
  kid_ctrl_sample_en,
  out_clk
);

// &Ports; @23
input           arb_ctrl_int_hv;          
input   [11:0]  arb_ctrl_int_id;          
input   [7 :0]  arb_ctrl_int_il;          
input           arb_ctrl_int_mode;        
input           busif_ctrl_cliccfg_sel;   
input           busif_ctrl_clicinfo_sel;  
input           busif_ctrl_mintthresh_sel; 
input   [31:0]  busif_kid_wdata;          
input           busif_xx_write_vld;       
input           clicreg_clk;              
input   [11:0]  cpu_clic_curid;           
input           cpu_clic_int_exit;        
input   [1 :0]  cpu_clic_mode;            
input           cpurst_b;                 
input   [79:0]  kid_ctrl_clicintattr_en;  
input   [79:0]  kid_ctrl_clicintctl_en;   
input   [79:0]  kid_ctrl_clicintie_en;    
input   [79:0]  kid_ctrl_clicintip_en;    
input   [79:0]  kid_ctrl_sample_en;       
input           out_clk;                  
output          clic_cpu_int_hv;          
output  [11:0]  clic_cpu_int_id;          
output  [7 :0]  clic_cpu_int_il;          
output  [1 :0]  clic_cpu_int_priv;        
output  [31:0]  ctrl_busif_cliccfg_val;   
output  [31:0]  ctrl_busif_clicinfo_val;  
output  [31:0]  ctrl_busif_mintthresh_val; 
output          ctrl_clicintattr_en;      
output          ctrl_clicintctl_en;       
output          ctrl_clicintie_en;        
output          ctrl_clicintip_en;        
output          ctrl_clicreg_en;          
output  [79:0]  ctrl_kid_ack_int;         
output          ctrl_sample_en;           
output  [2 :0]  ctrl_xx_int_lv_or_mask;   

// &Regs; @24
reg             clic_cpu_int_hv;          
reg     [11:0]  clic_cpu_int_id;          
reg     [7 :0]  clic_cpu_int_il;          
reg     [1 :0]  clic_cpu_int_priv;        
reg     [3 :0]  cliccfg_nlbits;           
reg     [7 :0]  mintthresh_mth;           
reg     [7 :0]  mintthresh_uth;           

// &Wires; @25
wire            arb_ctrl_int_hv;          
wire    [11:0]  arb_ctrl_int_id;          
wire    [7 :0]  arb_ctrl_int_il;          
wire            arb_ctrl_int_mode;        
wire            busif_ctrl_cliccfg_sel;   
wire            busif_ctrl_mintthresh_sel; 
wire    [31:0]  busif_kid_wdata;          
wire            busif_xx_write_vld;       
wire    [1 :0]  cliccfg_nmbits;           
wire            cliccfg_nmbits_0;         
wire            cliccfg_nvbits;           
wire    [31:0]  cliccfg_reg;              
wire    [7 :0]  cliccfg_updt_val;         
wire    [3 :0]  clicinfo_arch_ver;        
wire    [3 :0]  clicinfo_clicintctlbits;  
wire    [3 :0]  clicinfo_impl_ver;        
wire    [12:0]  clicinfo_num_int;         
wire    [31:0]  clicinfo_reg;             
wire            clicreg_clk;              
wire    [1 :0]  cpu_clic_mode;            
wire            cpurst_b;                 
wire    [31:0]  ctrl_busif_cliccfg_val;   
wire    [31:0]  ctrl_busif_clicinfo_val;  
wire    [31:0]  ctrl_busif_mintthresh_val; 
wire            ctrl_cliccfg_updt_vld;    
wire            ctrl_clicintattr_en;      
wire            ctrl_clicintctl_en;       
wire            ctrl_clicintie_en;        
wire            ctrl_clicintip_en;        
wire            ctrl_clicreg_en;          
wire            ctrl_int_gt_thresh;       
wire            ctrl_mintthresh_updt_vld; 
wire            ctrl_mode_vld;            
wire            ctrl_sample_en;           
wire    [7 :0]  ctrl_thresh;              
wire            ctrl_write_vld;           
wire    [79:0]  kid_ctrl_clicintattr_en;  
wire    [79:0]  kid_ctrl_clicintctl_en;   
wire    [79:0]  kid_ctrl_clicintie_en;    
wire    [79:0]  kid_ctrl_clicintip_en;    
wire    [79:0]  kid_ctrl_sample_en;       
wire    [7 :0]  mintthresh_hth;           
wire    [31:0]  mintthresh_reg;           
wire    [7 :0]  mintthresh_sth;           
wire    [31:0]  mintthresh_updt_val;      
wire            out_clk;                  


parameter CLICINTNUM = `CLIC_INTNUM;
parameter CLICINTCTLBITS = `CLIC_INTCTLBITS;
parameter ID_WIDTH = 12;

parameter INT_MODE_U     = 1'b0;
parameter INT_MODE_M     = 1'b1;
parameter CPU_MODE_U     = 2'b00;
parameter CPU_MODE_M     = 2'b11;

//==========================================================
//                    Rename Input
//==========================================================
assign cliccfg_updt_val[7:0]     = busif_kid_wdata[7:0];
// assign clicinfo_updt_val[31:0]   = busif_kid_wdata[31:0];
assign mintthresh_updt_val[31:0] = busif_kid_wdata[31:0];


//==========================================================
//                    Write Vld
//==========================================================
assign ctrl_mode_vld = cpu_clic_mode[1:0] == CPU_MODE_M;
assign ctrl_write_vld = busif_xx_write_vld && ctrl_mode_vld;
assign ctrl_cliccfg_updt_vld    = ctrl_write_vld && busif_ctrl_cliccfg_sel;
// &Force("input", "busif_ctrl_clicinfo_sel"); @50
// assign ctrl_clicinfo_updt_vld   = ctrl_write_vld && busif_ctrl_clicinfo_sel;
assign ctrl_mintthresh_updt_vld = ctrl_write_vld && busif_ctrl_mintthresh_sel;

//==========================================================
//                     CLICCFG
//==========================================================
always @ (posedge clicreg_clk or negedge cpurst_b)
begin
  if (!cpurst_b) begin
    cliccfg_nlbits[3:0] <= 4'b0;
  end
  else if (ctrl_cliccfg_updt_vld) begin
    cliccfg_nlbits[3:0] <= cliccfg_updt_val[4] ? 4'd8 : cliccfg_updt_val[4:1];  // if nlbits > 8, it will be 8.
  end
  else begin
    cliccfg_nlbits[3:0] <= cliccfg_nlbits[3:0];
  end
end

// cliccfg_nmbits only can be 0/1 so [1] is not use.
assign cliccfg_nmbits_0 = 1'b0;
assign cliccfg_nmbits[1:0] = {1'b0, cliccfg_nmbits_0};
assign cliccfg_nvbits      = 1'b1;
assign cliccfg_reg[31:0]    = {25'b0,
                               cliccfg_nmbits[1:0],
                               cliccfg_nlbits[3:0],
                               cliccfg_nvbits};


//==========================================================
//                     CLICINFO
//==========================================================
//csky vperl_off
assign clicinfo_clicintctlbits[3:0] = $unsigned(CLICINTCTLBITS) & 4'hf;
assign clicinfo_arch_ver[3:0] = 4'b0;
assign clicinfo_impl_ver[3:0] = 4'b0;
assign clicinfo_num_int[12:0] = $unsigned(CLICINTNUM) & 13'h1fff;
//csky vperl_on
// &Force("nonport", "clicinfo_clicintctlbits"); @89
// &Force("nonport", "clicinfo_arch_ver"); @90
// &Force("nonport", "clicinfo_impl_ver"); @91
// &Force("nonport", "clicinfo_num_int"); @92

assign clicinfo_reg[31:0] = {7'b0,
                             clicinfo_clicintctlbits[3:0],
                             clicinfo_arch_ver[3:0],
                             clicinfo_impl_ver[3:0],
                             clicinfo_num_int[12:0]};


//==========================================================
//                     MINTTHRESH
//==========================================================
always @ (posedge clicreg_clk or negedge cpurst_b)
begin
  if (!cpurst_b) begin
    mintthresh_mth[7:0] <= 8'b0;
    // mintthresh_hth[7:0] <= 8'b0;
    // mintthresh_sth[7:0] <= 8'b0;
    mintthresh_uth[7:0] <= 8'b0;
  end
  else if (ctrl_mintthresh_updt_vld) begin
    mintthresh_mth[7:0] <= mintthresh_updt_val[31:24];
    // mintthresh_hth[7:0] <= mintthresh_updt_val[23:16];
    // mintthresh_sth[7:0] <= mintthresh_updt_val[15:8];
    mintthresh_uth[7:0] <= mintthresh_updt_val[7:0];
  end
  else begin
    mintthresh_mth[7:0] <= mintthresh_mth[7:0];
    // mintthresh_hth[7:0] <= mintthresh_hth[7:0];
    // mintthresh_sth[7:0] <= mintthresh_sth[7:0];
    mintthresh_uth[7:0] <= mintthresh_uth[7:0];
  end
end

assign mintthresh_hth[7:0] = 8'b0;
assign mintthresh_sth[7:0] = 8'b0;

assign mintthresh_reg[31:0] = {mintthresh_mth[7:0],
                               mintthresh_hth[7:0],
                               mintthresh_sth[7:0],
                               mintthresh_uth[7:0]};


//==========================================================
//                        CPU Ack
//==========================================================
// &Force("output", "ctrl_kid_ack_int"); @138
// &Force("bus", "ctrl_kid_ack_int", CLICINTNUM-1, 0); @139
// &Force("input", "cpu_clic_curid"); @140
// &Force("bus", "cpu_clic_curid", ID_WIDTH-1, 0); @141
// &Force("input", "cpu_clic_int_exit"); @142

//csky vperl_off
wire [CLICINTNUM-1:0]   ctrl_kid_ack_sel;
wire [CLICINTNUM-1:0]   ctrl_kid_ack_int;
wire [ID_WIDTH-1:0]     cpu_clic_curid;
wire                    cpu_clic_int_exit;

genvar i;
generate
for (i = 0; i < CLICINTNUM; i = i+1)
begin: KID_ACK
  assign ctrl_kid_ack_sel[i] = cpu_clic_curid[ID_WIDTH-1:0] == ($unsigned(i) & {ID_WIDTH{1'b1}});
  assign ctrl_kid_ack_int[i] = ctrl_kid_ack_sel[i] && cpu_clic_int_exit;
end
endgenerate
//csky vperl_on

//==========================================================
//                   For Gate Clk Cell
//==========================================================
assign ctrl_sample_en      = |kid_ctrl_sample_en[CLICINTNUM-1:0];
assign ctrl_clicintip_en   = |kid_ctrl_clicintip_en[CLICINTNUM-1:0];
assign ctrl_clicintie_en   = |kid_ctrl_clicintie_en[CLICINTNUM-1:0];
assign ctrl_clicintattr_en = |kid_ctrl_clicintattr_en[CLICINTNUM-1:0];
assign ctrl_clicintctl_en  = |kid_ctrl_clicintctl_en[CLICINTNUM-1:0];

assign ctrl_clicreg_en     = ctrl_mintthresh_updt_vld || ctrl_cliccfg_updt_vld;
//==========================================================
//                      To busif
//==========================================================
// &Force("output", "ctrl_xx_int_lv_or_mask"); &Force("bus", "ctrl_xx_int_lv_or_mask", CLICINTCTLBITS-1, 0); @173
//csky vperl_off
wire [CLICINTCTLBITS-1:0] ctrl_xx_int_lv_or_mask;

generate
for (i = 0; i < CLICINTCTLBITS; i = i+1)
begin: LEVEL_MASK
  assign ctrl_xx_int_lv_or_mask[CLICINTCTLBITS-1-i] = !(($unsigned(i) & {4'hf}) < cliccfg_nlbits[3:0]);
end
endgenerate
//csky vperl_on

//==========================================================
//                      To busif
//==========================================================
assign ctrl_busif_cliccfg_val[31:0]    = cliccfg_reg    & {32{ctrl_mode_vld}};
assign ctrl_busif_clicinfo_val[31:0]   = clicinfo_reg   & {32{ctrl_mode_vld}};
assign ctrl_busif_mintthresh_val[31:0] = mintthresh_reg & {32{ctrl_mode_vld}};

//==========================================================
//                  Final judge mintthresh
//==========================================================
assign ctrl_thresh[7:0] = arb_ctrl_int_mode == INT_MODE_M ? mintthresh_mth[7:0]
                                                          : mintthresh_uth[7:0];
assign ctrl_int_gt_thresh = ctrl_thresh[7:0] < arb_ctrl_int_il[7:0];

always @ (posedge out_clk or negedge cpurst_b)
begin
  if (!cpurst_b) begin
    clic_cpu_int_hv               <= 1'b0;
    clic_cpu_int_id[ID_WIDTH-1:0] <= {ID_WIDTH{1'b0}};
    clic_cpu_int_priv[1:0]        <= 2'b0;
    clic_cpu_int_il[7:0]          <= 8'b0;
  end
  else begin
    clic_cpu_int_hv               <= arb_ctrl_int_hv;
    clic_cpu_int_id[ID_WIDTH-1:0] <= arb_ctrl_int_id[ID_WIDTH-1:0];
    clic_cpu_int_priv[1:0]        <= {2{arb_ctrl_int_mode}};
    clic_cpu_int_il[7:0]          <= {8{ctrl_int_gt_thresh}} & arb_ctrl_int_il[7:0];
  end
end

// &ModuleEnd; @215
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

//==========================================================
//                     Do or to sel
//==========================================================
module cr_clic_ff1_onehot(
  data_in,
  ff1_out_onehot
);

parameter WIDTH = 32;

input  [WIDTH-1:0] data_in;
output [WIDTH-1:0] ff1_out_onehot;

wire [WIDTH:0] ff1_tmp;

assign ff1_tmp[WIDTH] = 1'b0;
genvar i;

generate
  for (i = 0; i < WIDTH; i = i+1)
  begin: FF1_ONEHOT
    assign ff1_tmp[i] = data_in[i] || ff1_tmp[i+1];
  end
endgenerate

assign ff1_out_onehot[WIDTH-1:0] = ff1_tmp[WIDTH:1] ^ ff1_tmp[WIDTH-1:0];

endmodule

/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_clic_kid(
  busif_kid_clicintattr_sel,
  busif_kid_clicintctl_sel,
  busif_kid_clicintie_sel,
  busif_kid_clicintip_sel,
  busif_kid_wdata,
  busif_xx_write_vld,
  clicintattr_clk,
  clicintctl_clk,
  clicintie_clk,
  clicintip_clk,
  cpu_clic_mode,
  cpurst_b,
  ctrl_kid_ack_int,
  kid_arb_int_all,
  kid_arb_int_hv,
  kid_arb_int_req,
  kid_busif_rdata,
  kid_ctrl_clicintattr_en,
  kid_ctrl_clicintctl_en,
  kid_ctrl_clicintie_en,
  kid_ctrl_clicintip_en,
  kid_ctrl_sample_en,
  kid_int_vld,
  sample_clk
);

// &Ports; @23
input           busif_kid_clicintattr_sel; 
input           busif_kid_clicintctl_sel; 
input           busif_kid_clicintie_sel;  
input           busif_kid_clicintip_sel;  
input   [31:0]  busif_kid_wdata;          
input           busif_xx_write_vld;       
input           clicintattr_clk;          
input           clicintctl_clk;           
input           clicintie_clk;            
input           clicintip_clk;            
input   [1 :0]  cpu_clic_mode;            
input           cpurst_b;                 
input           ctrl_kid_ack_int;         
input           kid_int_vld;              
input           sample_clk;               
output  [3 :0]  kid_arb_int_all;          
output          kid_arb_int_hv;           
output          kid_arb_int_req;          
output  [31:0]  kid_busif_rdata;          
output          kid_ctrl_clicintattr_en;  
output          kid_ctrl_clicintctl_en;   
output          kid_ctrl_clicintie_en;    
output          kid_ctrl_clicintip_en;    
output          kid_ctrl_sample_en;       

// &Regs; @24
reg             clicintattr_shv;          
reg     [1 :0]  clicintattr_trig;         
reg             int_enable;               
reg             int_pending;              
reg             int_pending_updt_val;     
reg     [2 :0]  int_prio;                 
reg             int_vld_ff;               

// &Wires; @25
wire            busif_kid_clicintattr_sel; 
wire            busif_kid_clicintctl_sel; 
wire            busif_kid_clicintie_sel;  
wire            busif_kid_clicintip_sel;  
wire    [31:0]  busif_kid_wdata;          
wire            busif_xx_write_vld;       
wire            clicintattr_clk;          
wire    [1 :0]  clicintattr_mode;         
wire    [7 :0]  clicintattr_reg;          
wire    [7 :0]  clicintattr_updt_val;     
wire            clicintattr_updt_vld;     
wire            clicintctl_clk;           
wire    [7 :0]  clicintctl_reg;           
wire    [7 :0]  clicintctl_updt_val;      
wire            clicintctl_updt_vld;      
wire            clicintie_clk;            
wire    [7 :0]  clicintie_reg;            
wire            clicintie_updt_vld;       
wire            clicintip_clk;            
wire    [7 :0]  clicintip_reg;            
wire    [1 :0]  cpu_clic_mode;            
wire            cpurst_b;                 
wire            ctrl_kid_ack_int;         
wire            int_enable_updt_val;      
wire            int_level;                
wire            int_neg_pulse;            
wire            int_pending_clear;        
wire            int_pending_set;          
wire            int_pending_updt_val_raw; 
wire            int_pending_updt_vld;     
wire            int_pos_pulse;            
wire            int_pulse;                
wire            int_vld;                  
wire    [3 :0]  kid_arb_int_all;          
wire            kid_arb_int_hv;           
wire            kid_arb_int_req;          
wire    [31:0]  kid_busif_rdata;          
wire            kid_ctrl_clicintattr_en;  
wire            kid_ctrl_clicintctl_en;   
wire            kid_ctrl_clicintie_en;    
wire            kid_ctrl_clicintip_en;    
wire            kid_ctrl_sample_en;       
wire            kid_int_mode;             
wire            kid_int_vld;              
wire            kid_mode_vld;             
wire            kid_write_vld;            
wire            sample_clk;               
wire            sw_clear_pending;         
wire            sw_set_pending;           


parameter CLICINTCTLBITS = `CLIC_INTCTLBITS;

parameter INT_MODE_U     = 1'b0;
parameter INT_MODE_M     = 1'b1;
parameter CPU_MODE_U     = 2'b00;
parameter CPU_MODE_M     = 2'b11;

//==========================================================
//                    Rename Input
//==========================================================
assign int_pending_updt_val_raw  = busif_kid_wdata[0];
assign int_enable_updt_val       = busif_kid_wdata[8];
assign clicintattr_updt_val[7:0] = busif_kid_wdata[23:16];
assign clicintctl_updt_val[7:0]  = busif_kid_wdata[31:24];

assign int_vld = kid_int_vld;


//==========================================================
//                    kid mode Vld
//==========================================================
// if cpu mode is M, all is vld.
// if cpu mode is U, only U mode int is vld.
assign kid_mode_vld = cpu_clic_mode[1:0] == CPU_MODE_M
                   || cpu_clic_mode[1:0] == CPU_MODE_U && kid_int_mode == INT_MODE_U;

//==========================================================
//                     Write Vld
//==========================================================
assign kid_write_vld  = busif_xx_write_vld && kid_mode_vld;
assign sw_set_pending       = kid_write_vld && busif_kid_clicintip_sel && int_pending_updt_val_raw;
assign sw_clear_pending     = kid_write_vld && busif_kid_clicintip_sel && !int_pending_updt_val_raw;
assign clicintie_updt_vld   = kid_write_vld && busif_kid_clicintie_sel;
assign clicintattr_updt_vld = kid_write_vld && busif_kid_clicintattr_sel;
assign clicintctl_updt_vld  = kid_write_vld && busif_kid_clicintctl_sel;

//------------------------------------------------
//                  Interrupt Sample
//------------------------------------------------
assign kid_ctrl_sample_en = int_vld ^ int_vld_ff;

always@(posedge sample_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    int_vld_ff <= 1'b0;
  else
    int_vld_ff <= int_vld;
end

assign int_level = int_vld;
assign int_pos_pulse = int_vld && !int_vld_ff;
assign int_neg_pulse = !int_vld && int_vld_ff;

//===========================================================
//     interrupt control/status register
//===========================================================

//------------------------------------------------
//  security bit
//------------------------------------------------
// assign op_en = 1'b1;
// // &Force("input","ctl_xx_prot_sec"); @106
// // &Force("input","int_sec_updt_val"); @107

//==========================================================
//                       CLICINTIP
//==========================================================
assign int_pulse = clicintattr_trig[1:0] == 2'b01 && int_pos_pulse
                || clicintattr_trig[1:0] == 2'b11 && int_neg_pulse;

assign int_pending_set   = int_pulse || sw_set_pending;
assign int_pending_clear = ctrl_kid_ack_int || sw_clear_pending;

assign int_pending_updt_vld = int_pending_set || int_pending_clear;

// assign kid_ctrl_clicintip_en = !int_pending & int_pending_set ||
//                                 int_pending & int_pending_clear & !int_pending_set;
assign kid_ctrl_clicintip_en = int_pending_updt_vld
                            || !clicintattr_trig[0] && (int_vld_ff ^ int_vld);


// &CombBeg; @127
always @( int_pending_clear
       or int_pending
       or int_pending_set)
begin
if (int_pending_set)
  int_pending_updt_val = 1'b1;
else if (int_pending_clear)
  int_pending_updt_val = 1'b0;
else
  int_pending_updt_val = int_pending;
// &CombEnd; @134
end

always@(posedge clicintip_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    int_pending <= 1'b0;
  else if (!clicintattr_trig[0])
    int_pending <= int_level;
  else if (int_pending_updt_vld)
    int_pending <= int_pending_updt_val;
  else
    int_pending <= int_pending;
end
assign clicintip_reg[7:0] = {7'b0, int_pending};
//==========================================================
//                       CLICINTIE
//==========================================================
// assign int_enable_updt_vld = op_en && clicintie_updt_vld;
assign kid_ctrl_clicintie_en = clicintie_updt_vld;

always@(posedge clicintie_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    int_enable <= 1'b0;
  else if(clicintie_updt_vld)
    int_enable <= int_enable_updt_val;
  else
    int_enable <= int_enable;
end
assign clicintie_reg[7:0] = {7'b0, int_enable};
//==========================================================
//                      CLICINTATTR
//==========================================================
assign kid_ctrl_clicintattr_en = clicintattr_updt_vld;

always @ (posedge clicintattr_clk or negedge cpurst_b)
begin
  if (!cpurst_b) begin
    clicintattr_trig[1:0] <= 2'b0;
    clicintattr_shv       <= 1'b0;
  end
  else if (clicintattr_updt_vld) begin
    clicintattr_trig[1:0] <= clicintattr_updt_val[2:1];
    clicintattr_shv       <= clicintattr_updt_val[0];
  end
  else begin
    clicintattr_trig[1:0] <= clicintattr_trig[1:0];
    clicintattr_shv       <= clicintattr_shv;
  end
end
assign clicintattr_mode[1:0] = 2'b11;
assign kid_int_mode = 1'b1;

assign clicintattr_reg[7:0] = {clicintattr_mode[1:0],
                               3'b0,
                               clicintattr_trig[1:0],
                               clicintattr_shv};


//==========================================================
//                      CLICINTCTL
//==========================================================
assign kid_ctrl_clicintctl_en = clicintctl_updt_vld;

always@(posedge clicintctl_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    int_prio[CLICINTCTLBITS-1:0] <= {CLICINTCTLBITS{1'b0}};
  else if(clicintctl_updt_vld)
    int_prio[CLICINTCTLBITS-1:0] <= clicintctl_updt_val[7:8-CLICINTCTLBITS];
end

assign clicintctl_reg[7:0] = {int_prio[CLICINTCTLBITS-1:0],
                              {(8-CLICINTCTLBITS){1'b1}}};


//==========================================================
//                       Read Data
//==========================================================
assign kid_busif_rdata[31:0] = {({8{busif_kid_clicintctl_sel}}  & clicintctl_reg[7:0]),
                                ({8{busif_kid_clicintattr_sel}} & clicintattr_reg[7:0]),
                                ({8{busif_kid_clicintie_sel}}   & clicintie_reg[7:0]),
                                ({8{busif_kid_clicintip_sel}}   & clicintip_reg[7:0])}
                             & {32{kid_mode_vld}};


//==========================================================
//     OUTPUT
//==========================================================
// TO arbiter
//------------------------------------------------

assign kid_arb_int_req       = int_enable & int_pending;
// &Force("output", "kid_arb_int_req"); @227
assign kid_arb_int_hv        = clicintattr_shv;
// int_all has three field:
//   [CLICINTCTLBITS]: mode
//   [CLICINTCTLBITS-1: CLICINTCTLBITS-1-nlbits]: int level
//   [CLICINTCTLBITS-2-nlbits]: prio level
assign kid_arb_int_all[CLICINTCTLBITS:0] = {kid_int_mode,
                                           int_prio[CLICINTCTLBITS-1:0]}
                                        & {(CLICINTCTLBITS+1){kid_arb_int_req}};
// assign kid_arb_int_sec    = 1'b0;



// &ModuleEnd; @244
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_clic_kid_dummy(
  kid_arb_int_all,
  kid_arb_int_hv,
  kid_arb_int_req,
  kid_busif_rdata,
  kid_ctrl_clicintattr_en,
  kid_ctrl_clicintctl_en,
  kid_ctrl_clicintie_en,
  kid_ctrl_clicintip_en,
  kid_ctrl_sample_en
);

// &Ports; @23
output  [3 :0]  kid_arb_int_all;        
output          kid_arb_int_hv;         
output          kid_arb_int_req;        
output  [31:0]  kid_busif_rdata;        
output          kid_ctrl_clicintattr_en; 
output          kid_ctrl_clicintctl_en; 
output          kid_ctrl_clicintie_en;  
output          kid_ctrl_clicintip_en;  
output          kid_ctrl_sample_en;     

// &Regs; @24

// &Wires; @25
wire    [3 :0]  kid_arb_int_all;        
wire            kid_arb_int_hv;         
wire            kid_arb_int_req;        
wire    [31:0]  kid_busif_rdata;        
wire            kid_ctrl_clicintattr_en; 
wire            kid_ctrl_clicintctl_en; 
wire            kid_ctrl_clicintie_en;  
wire            kid_ctrl_clicintip_en;  
wire            kid_ctrl_sample_en;     


parameter CLICINTCTLBITS = `CLIC_INTCTLBITS;

assign kid_arb_int_all[CLICINTCTLBITS:0] = {CLICINTCTLBITS+1{1'b0}};
assign kid_arb_int_hv = 1'b0;
assign kid_arb_int_req = 1'b0;
assign kid_busif_rdata[31:0] = 32'b0;
assign kid_ctrl_clicintattr_en = 1'b0;
assign kid_ctrl_clicintctl_en = 1'b0;
assign kid_ctrl_clicintie_en = 1'b0;
assign kid_ctrl_clicintip_en = 1'b0;
assign kid_ctrl_sample_en = 1'b0;

// &ModuleEnd; @39
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_clic_sel(
  // input
  data_in,
  sel_in_onehot,
  // output
  data_out
);

parameter DATA_WIDTH   = 32;
parameter SEL_NUM      = 256;

input  [DATA_WIDTH*SEL_NUM-1:0] data_in;
input  [SEL_NUM-1:0]            sel_in_onehot;

output [DATA_WIDTH-1:0]         data_out;

wire   [DATA_WIDTH-1:0]         data_in_2d[SEL_NUM-1:0];
wire   [SEL_NUM-1:0]            data_in_2d_rev[DATA_WIDTH-1:0];
wire   [DATA_WIDTH-1:0]         data_out;

//==========================================================
//                  Generate 2D signal
//==========================================================
genvar i;
genvar j;

generate
  for (i = 0; i < SEL_NUM; i = i+1) begin: EXPAND
    assign data_in_2d[i][DATA_WIDTH-1:0] = data_in[i*DATA_WIDTH+:DATA_WIDTH] & {DATA_WIDTH{sel_in_onehot[i]}};
  end
endgenerate

//==========================================================
//                   Reverse 2D signal
//==========================================================
generate
  for (i = 0; i < SEL_NUM; i = i+1) begin: REVERSEI
    for (j = 0; j < DATA_WIDTH; j = j+1) begin: REVERSEJ
      assign data_in_2d_rev[j][i] = data_in_2d[i][j];
    end
  end
endgenerate

//==========================================================
//                     Do or to sel
//==========================================================
generate
  for (i = 0; i < DATA_WIDTH; i = i+1) begin: OR_SEL
    assign data_out[i] = |data_in_2d_rev[i][SEL_NUM-1:0];
  end
endgenerate


endmodule
/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @26
module cr_clic_top(
  clic_cpu_int_hv,
  clic_cpu_int_id,
  clic_cpu_int_il,
  clic_cpu_int_priv,
  clic_tcipif_cmplt,
  clic_tcipif_rdata,
  clint_cpu_me_int,
  clint_cpu_ms_int,
  clint_cpu_mt_int,
  cpu_clic_curid,
  cpu_clic_int_exit,
  cpu_clic_mode,
  cpurst_b,
  forever_cpuclk,
  pad_clic_int_vld,
  pad_yy_gate_clk_en_b,
  tcipif_clic_addr,
  tcipif_clic_sel,
  tcipif_clic_size,
  tcipif_clic_wdata,
  tcipif_clic_write
);

// &Ports; @27
input             clint_cpu_me_int;         
input             clint_cpu_ms_int;         
input             clint_cpu_mt_int;         
input   [11  :0]  cpu_clic_curid;           
input             cpu_clic_int_exit;        
input   [1   :0]  cpu_clic_mode;            
input             cpurst_b;                 
input             forever_cpuclk;           
input   [63  :0]  pad_clic_int_vld;         
input             pad_yy_gate_clk_en_b;     
input   [15  :0]  tcipif_clic_addr;         
input             tcipif_clic_sel;          
input   [1   :0]  tcipif_clic_size;         
input   [31  :0]  tcipif_clic_wdata;        
input             tcipif_clic_write;        
output            clic_cpu_int_hv;          
output  [11  :0]  clic_cpu_int_id;          
output  [7   :0]  clic_cpu_int_il;          
output  [1   :0]  clic_cpu_int_priv;        
output            clic_tcipif_cmplt;        
output  [31  :0]  clic_tcipif_rdata;        

// &Regs; @28

// &Wires; @29
wire              arb_ctrl_int_hv;          
wire    [11  :0]  arb_ctrl_int_id;          
wire    [7   :0]  arb_ctrl_int_il;          
wire              arb_ctrl_int_mode;        
wire              busif_ctrl_cliccfg_sel;   
wire              busif_ctrl_clicinfo_sel;  
wire              busif_ctrl_mintthresh_sel; 
wire    [79  :0]  busif_kid_clicintattr_sel; 
wire    [79  :0]  busif_kid_clicintctl_sel; 
wire    [79  :0]  busif_kid_clicintie_sel;  
wire    [79  :0]  busif_kid_clicintip_sel;  
wire    [31  :0]  busif_kid_wdata;          
wire              busif_xx_write_vld;       
wire              clic_cpu_int_hv;          
wire    [11  :0]  clic_cpu_int_id;          
wire    [7   :0]  clic_cpu_int_il;          
wire    [1   :0]  clic_cpu_int_priv;        
wire              clic_tcipif_cmplt;        
wire    [31  :0]  clic_tcipif_rdata;        
wire              clicintattr_clk;          
wire              clicintctl_clk;           
wire              clicintie_clk;            
wire              clicintip_clk;            
wire              clicreg_clk;              
wire              clint_cpu_me_int;         
wire              clint_cpu_ms_int;         
wire              clint_cpu_mt_int;         
wire    [11  :0]  cpu_clic_curid;           
wire              cpu_clic_int_exit;        
wire    [1   :0]  cpu_clic_mode;            
wire              cpurst_b;                 
wire    [31  :0]  ctrl_busif_cliccfg_val;   
wire    [31  :0]  ctrl_busif_clicinfo_val;  
wire    [31  :0]  ctrl_busif_mintthresh_val; 
wire              ctrl_clicintattr_en;      
wire              ctrl_clicintctl_en;       
wire              ctrl_clicintie_en;        
wire              ctrl_clicintip_en;        
wire              ctrl_clicreg_en;          
wire    [79  :0]  ctrl_kid_ack_int;         
wire              ctrl_sample_en;           
wire    [2   :0]  ctrl_xx_int_lv_or_mask;   
wire              forever_cpuclk;           
wire    [319 :0]  kid_arb_int_all_vec;      
wire    [79  :0]  kid_arb_int_hv;           
wire    [79  :0]  kid_arb_int_req;          
wire    [2559:0]  kid_busif_rdata_vec;      
wire    [79  :0]  kid_ctrl_clicintattr_en;  
wire    [79  :0]  kid_ctrl_clicintctl_en;   
wire    [79  :0]  kid_ctrl_clicintie_en;    
wire    [79  :0]  kid_ctrl_clicintip_en;    
wire    [79  :0]  kid_ctrl_sample_en;       
wire    [79  :0]  kid_int_vld;              
wire              out_clk;                  
wire              out_clk_en;               
wire    [63  :0]  pad_clic_int_vld;         
wire              pad_yy_gate_clk_en_b;     
wire              sample_clk;               
wire    [15  :0]  tcipif_clic_addr;         
wire              tcipif_clic_sel;          
wire    [1   :0]  tcipif_clic_size;         
wire    [31  :0]  tcipif_clic_wdata;        
wire              tcipif_clic_write;        


parameter CLICINTNUM     = `CLIC_INTNUM;
parameter CLICINTCTLBITS = `CLIC_INTCTLBITS;

// &Instance("cr_clic_arb"); @34
cr_clic_arb  x_cr_clic_arb (
  .arb_ctrl_int_hv        (arb_ctrl_int_hv       ),
  .arb_ctrl_int_id        (arb_ctrl_int_id       ),
  .arb_ctrl_int_il        (arb_ctrl_int_il       ),
  .arb_ctrl_int_mode      (arb_ctrl_int_mode     ),
  .cpurst_b               (cpurst_b              ),
  .ctrl_xx_int_lv_or_mask (ctrl_xx_int_lv_or_mask),
  .kid_arb_int_all_vec    (kid_arb_int_all_vec   ),
  .kid_arb_int_hv         (kid_arb_int_hv        ),
  .kid_arb_int_req        (kid_arb_int_req       ),
  .out_clk                (out_clk               ),
  .out_clk_en             (out_clk_en            )
);

// &Instance("cr_clic_busif"); @35
cr_clic_busif  x_cr_clic_busif (
  .busif_ctrl_cliccfg_sel    (busif_ctrl_cliccfg_sel   ),
  .busif_ctrl_clicinfo_sel   (busif_ctrl_clicinfo_sel  ),
  .busif_ctrl_mintthresh_sel (busif_ctrl_mintthresh_sel),
  .busif_kid_clicintattr_sel (busif_kid_clicintattr_sel),
  .busif_kid_clicintctl_sel  (busif_kid_clicintctl_sel ),
  .busif_kid_clicintie_sel   (busif_kid_clicintie_sel  ),
  .busif_kid_clicintip_sel   (busif_kid_clicintip_sel  ),
  .busif_kid_wdata           (busif_kid_wdata          ),
  .busif_xx_write_vld        (busif_xx_write_vld       ),
  .clic_tcipif_cmplt         (clic_tcipif_cmplt        ),
  .clic_tcipif_rdata         (clic_tcipif_rdata        ),
  .ctrl_busif_cliccfg_val    (ctrl_busif_cliccfg_val   ),
  .ctrl_busif_clicinfo_val   (ctrl_busif_clicinfo_val  ),
  .ctrl_busif_mintthresh_val (ctrl_busif_mintthresh_val),
  .kid_busif_rdata_vec       (kid_busif_rdata_vec      ),
  .tcipif_clic_addr          (tcipif_clic_addr         ),
  .tcipif_clic_sel           (tcipif_clic_sel          ),
  .tcipif_clic_size          (tcipif_clic_size         ),
  .tcipif_clic_wdata         (tcipif_clic_wdata        ),
  .tcipif_clic_write         (tcipif_clic_write        )
);

// &Instance("cr_clic_ctrl"); @36
cr_clic_ctrl  x_cr_clic_ctrl (
  .arb_ctrl_int_hv           (arb_ctrl_int_hv          ),
  .arb_ctrl_int_id           (arb_ctrl_int_id          ),
  .arb_ctrl_int_il           (arb_ctrl_int_il          ),
  .arb_ctrl_int_mode         (arb_ctrl_int_mode        ),
  .busif_ctrl_cliccfg_sel    (busif_ctrl_cliccfg_sel   ),
  .busif_ctrl_clicinfo_sel   (busif_ctrl_clicinfo_sel  ),
  .busif_ctrl_mintthresh_sel (busif_ctrl_mintthresh_sel),
  .busif_kid_wdata           (busif_kid_wdata          ),
  .busif_xx_write_vld        (busif_xx_write_vld       ),
  .clic_cpu_int_hv           (clic_cpu_int_hv          ),
  .clic_cpu_int_id           (clic_cpu_int_id          ),
  .clic_cpu_int_il           (clic_cpu_int_il          ),
  .clic_cpu_int_priv         (clic_cpu_int_priv        ),
  .clicreg_clk               (clicreg_clk              ),
  .cpu_clic_curid            (cpu_clic_curid           ),
  .cpu_clic_int_exit         (cpu_clic_int_exit        ),
  .cpu_clic_mode             (cpu_clic_mode            ),
  .cpurst_b                  (cpurst_b                 ),
  .ctrl_busif_cliccfg_val    (ctrl_busif_cliccfg_val   ),
  .ctrl_busif_clicinfo_val   (ctrl_busif_clicinfo_val  ),
  .ctrl_busif_mintthresh_val (ctrl_busif_mintthresh_val),
  .ctrl_clicintattr_en       (ctrl_clicintattr_en      ),
  .ctrl_clicintctl_en        (ctrl_clicintctl_en       ),
  .ctrl_clicintie_en         (ctrl_clicintie_en        ),
  .ctrl_clicintip_en         (ctrl_clicintip_en        ),
  .ctrl_clicreg_en           (ctrl_clicreg_en          ),
  .ctrl_kid_ack_int          (ctrl_kid_ack_int         ),
  .ctrl_sample_en            (ctrl_sample_en           ),
  .ctrl_xx_int_lv_or_mask    (ctrl_xx_int_lv_or_mask   ),
  .kid_ctrl_clicintattr_en   (kid_ctrl_clicintattr_en  ),
  .kid_ctrl_clicintctl_en    (kid_ctrl_clicintctl_en   ),
  .kid_ctrl_clicintie_en     (kid_ctrl_clicintie_en    ),
  .kid_ctrl_clicintip_en     (kid_ctrl_clicintip_en    ),
  .kid_ctrl_sample_en        (kid_ctrl_sample_en       ),
  .out_clk                   (out_clk                  )
);


assign kid_int_vld[CLICINTNUM-1:16] = pad_clic_int_vld[CLICINTNUM-17:0];
// &Force("input", "pad_clic_int_vld"); &Force("bus", "pad_clic_int_vld", CLICINTNUM-17, 0); @40
assign kid_int_vld[15:0] = {3'b0, 1'b0,   // clic software int
                            clint_cpu_me_int, 3'b0,
                            clint_cpu_mt_int, 3'b0,
                            clint_cpu_ms_int, 3'b0};
// &Force("nonport", "kid_int_vld"); @46

// &Force("nonport", "kid_busif_rdata_bus"); @48
// &Force("nonport", "busif_kid_clicintattr_sel"); @49
// &Force("nonport", "busif_kid_clicintctl_sel"); @50
// &Force("nonport", "busif_kid_clicintie_sel"); @51
// &Force("nonport", "busif_kid_clicintip_sel"); @52
// &Force("nonport", "clicintattr_clk"); @53
// &Force("nonport", "clicintctl_clk"); @54
// &Force("nonport", "clicintie_clk"); @55
// &Force("nonport", "clicintip_clk"); @56
// &Force("nonport", "sample_clk"); @57
// &Force("nonport", "ctrl_kid_ack_int"); @58
// &Force("nonport", "kid_arb_int_all_vec"); @59
// &Force("nonport", "kid_arb_int_hv"); @60
// &Force("nonport", "kid_arb_int_req"); @61
// &Force("nonport", "kid_busif_rdata_vec"); @62
// &Force("nonport", "kid_ctrl_clicintattr_en"); @63
// &Force("nonport", "kid_ctrl_clicintctl_en"); @64
// &Force("nonport", "kid_ctrl_clicintie_en"); @65
// &Force("nonport", "kid_ctrl_clicintip_en"); @66
// &Force("nonport", "kid_ctrl_sample_en"); @67
//csky vperl_off
genvar i;
generate
for (i = 0; i < CLICINTNUM; i = i+1)
begin:INT_KID
  case(i)
    0, 1, 2,
    4, 5, 6,
    8, 9, 10,
    13, 14, 15:
      cr_clic_kid_dummy x_cr_clic_kid(
        .kid_arb_int_all            (kid_arb_int_all_vec[(CLICINTCTLBITS+1)*i+:(CLICINTCTLBITS+1)]),
        .kid_arb_int_hv             (kid_arb_int_hv[i]),
        .kid_arb_int_req            (kid_arb_int_req[i]),
        .kid_busif_rdata            (kid_busif_rdata_vec[32*i+:32]),
        .kid_ctrl_clicintattr_en    (kid_ctrl_clicintattr_en[i]),
        .kid_ctrl_clicintctl_en     (kid_ctrl_clicintctl_en[i]),
        .kid_ctrl_clicintie_en      (kid_ctrl_clicintie_en[i]),
        .kid_ctrl_clicintip_en      (kid_ctrl_clicintip_en[i]),
        .kid_ctrl_sample_en         (kid_ctrl_sample_en[i])
      );
    default:
      cr_clic_kid x_cr_clic_kid(
        .busif_kid_clicintattr_sel  (busif_kid_clicintattr_sel[i]),
        .busif_kid_clicintctl_sel   (busif_kid_clicintctl_sel[i]),
        .busif_kid_clicintie_sel    (busif_kid_clicintie_sel[i]),
        .busif_kid_clicintip_sel    (busif_kid_clicintip_sel[i]),
        .busif_kid_wdata            (busif_kid_wdata),
        .busif_xx_write_vld         (busif_xx_write_vld),
        .clicintattr_clk            (clicintattr_clk),
        .clicintctl_clk             (clicintctl_clk),
        .clicintie_clk              (clicintie_clk),
        .clicintip_clk              (clicintip_clk),
        .cpu_clic_mode              (cpu_clic_mode),
        .cpurst_b                   (cpurst_b),
        .ctrl_kid_ack_int           (ctrl_kid_ack_int[i]),
        .kid_arb_int_all            (kid_arb_int_all_vec[(CLICINTCTLBITS+1)*i+:(CLICINTCTLBITS+1)]),
        .kid_arb_int_hv             (kid_arb_int_hv[i]),
        .kid_arb_int_req            (kid_arb_int_req[i]),
        .kid_busif_rdata            (kid_busif_rdata_vec[32*i+:32]),
        .kid_ctrl_clicintattr_en    (kid_ctrl_clicintattr_en[i]),
        .kid_ctrl_clicintctl_en     (kid_ctrl_clicintctl_en[i]),
        .kid_ctrl_clicintie_en      (kid_ctrl_clicintie_en[i]),
        .kid_ctrl_clicintip_en      (kid_ctrl_clicintip_en[i]),
        .kid_ctrl_sample_en         (kid_ctrl_sample_en[i]),
        .kid_int_vld                (kid_int_vld[i]),
        .sample_clk                 (sample_clk)
      );
  endcase
end
endgenerate
//csky vperl_on

//==========================================================
//                    Gate Clk Cell
//==========================================================
// &Instance("gated_clk_cell", "x_sample_clk"); @124
gated_clk_cell  x_sample_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (sample_clk          ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (ctrl_sample_en      ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk), @125
//          .external_en (1'b0), @126
//          .global_en   (1'b1), @127
//          .module_en   (1'b0), @128
//          .local_en    (ctrl_sample_en), @129
//          .clk_out     (sample_clk)); @130

// &Instance("gated_clk_cell", "x_clicintip_clk"); @132
gated_clk_cell  x_clicintip_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (clicintip_clk       ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (ctrl_clicintip_en   ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk), @133
//          .external_en (1'b0), @134
//          .global_en   (1'b1), @135
//          .module_en   (1'b0), @136
//          .local_en    (ctrl_clicintip_en), @137
//          .clk_out     (clicintip_clk)); @138

// &Instance("gated_clk_cell", "x_clicintie_clk"); @140
gated_clk_cell  x_clicintie_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (clicintie_clk       ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (ctrl_clicintie_en   ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk), @141
//          .external_en (1'b0), @142
//          .global_en   (1'b1), @143
//          .module_en   (1'b0), @144
//          .local_en    (ctrl_clicintie_en), @145
//          .clk_out     (clicintie_clk)); @146

// &Instance("gated_clk_cell", "x_clicintattr_clk"); @148
gated_clk_cell  x_clicintattr_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (clicintattr_clk     ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (ctrl_clicintattr_en ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk), @149
//          .external_en (1'b0), @150
//          .global_en   (1'b1), @151
//          .module_en   (1'b0), @152
//          .local_en    (ctrl_clicintattr_en), @153
//          .clk_out     (clicintattr_clk)); @154

// &Instance("gated_clk_cell", "x_clicintctl_clk"); @156
gated_clk_cell  x_clicintctl_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (clicintctl_clk      ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (ctrl_clicintctl_en  ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk), @157
//          .external_en (1'b0), @158
//          .global_en   (1'b1), @159
//          .module_en   (1'b0), @160
//          .local_en    (ctrl_clicintctl_en), @161
//          .clk_out     (clicintctl_clk)); @162

// &Instance("gated_clk_cell", "x_clicreg_clk"); @164
gated_clk_cell  x_clicreg_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (clicreg_clk         ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (ctrl_clicreg_en     ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk), @165
//          .external_en (1'b0), @166
//          .global_en   (1'b1), @167
//          .module_en   (1'b0), @168
//          .local_en    (ctrl_clicreg_en), @169
//          .clk_out     (clicreg_clk)); @170

// &Instance("gated_clk_cell", "x_out_clk"); @172
gated_clk_cell  x_out_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (out_clk             ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (out_clk_en          ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk), @173
//          .external_en (1'b0), @174
//          .global_en   (1'b1), @175
//          .module_en   (1'b0), @176
//          .local_en    (out_clk_en), @177
//          .clk_out     (out_clk)); @178


// &ModuleEnd; @181
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_clint_busif(
  busif_regs_msip_sel,
  busif_regs_mtimecmp_hi_sel,
  busif_regs_mtimecmp_lo_sel,
  busif_regs_wdata,
  busif_regs_write_vld,
  clint_tcipif_cmplt,
  clint_tcipif_rdata,
  msip_value,
  mtime_hi_value,
  mtime_lo_value,
  mtimecmp_hi_value,
  mtimecmp_lo_value,
  tcipif_clint_addr,
  tcipif_clint_sel,
  tcipif_clint_wdata,
  tcipif_clint_write
);

// &Ports; @23
input   [31:0]  msip_value;                
input   [31:0]  mtime_hi_value;            
input   [31:0]  mtime_lo_value;            
input   [31:0]  mtimecmp_hi_value;         
input   [31:0]  mtimecmp_lo_value;         
input   [15:0]  tcipif_clint_addr;         
input           tcipif_clint_sel;          
input   [31:0]  tcipif_clint_wdata;        
input           tcipif_clint_write;        
output          busif_regs_msip_sel;       
output          busif_regs_mtimecmp_hi_sel; 
output          busif_regs_mtimecmp_lo_sel; 
output  [31:0]  busif_regs_wdata;          
output          busif_regs_write_vld;      
output          clint_tcipif_cmplt;        
output  [31:0]  clint_tcipif_rdata;        

// &Regs; @24

// &Wires; @25
wire            busif_read_vld;            
wire            busif_regs_msip_sel;       
wire            busif_regs_mtimecmp_hi_sel; 
wire            busif_regs_mtimecmp_lo_sel; 
wire    [31:0]  busif_regs_wdata;          
wire            busif_regs_write_vld;      
wire            clint_tcipif_cmplt;        
wire    [31:0]  clint_tcipif_rdata;        
wire            msip_sel;                  
wire    [31:0]  msip_value;                
wire            mtime_hi_sel;              
wire    [31:0]  mtime_hi_value;            
wire            mtime_lo_sel;              
wire    [31:0]  mtime_lo_value;            
wire            mtimecmp_hi_sel;           
wire    [31:0]  mtimecmp_hi_value;         
wire            mtimecmp_lo_sel;           
wire    [31:0]  mtimecmp_lo_value;         
wire    [15:0]  tcipif_clint_addr;         
wire            tcipif_clint_sel;          
wire    [31:0]  tcipif_clint_wdata;        
wire            tcipif_clint_write;        


parameter MSIP       = 16'h0000;

parameter MTIMECMPLO = 16'h4000;
parameter MTIMECMPHI = 16'h4004;

parameter MTIMELO    = 16'hbff8;
parameter MTIMEHI    = 16'hbffc;

assign msip_sel        = tcipif_clint_addr[15:0] == MSIP;
assign mtimecmp_lo_sel = tcipif_clint_addr[15:0] == MTIMECMPLO;
assign mtimecmp_hi_sel = tcipif_clint_addr[15:0] == MTIMECMPHI;
assign mtime_lo_sel    = tcipif_clint_addr[15:0] == MTIMELO;
assign mtime_hi_sel    = tcipif_clint_addr[15:0] == MTIMEHI;

assign busif_regs_msip_sel        = msip_sel;
assign busif_regs_mtimecmp_lo_sel = mtimecmp_lo_sel;
assign busif_regs_mtimecmp_hi_sel = mtimecmp_hi_sel;

assign clint_tcipif_cmplt = tcipif_clint_sel;

assign busif_regs_write_vld = tcipif_clint_sel && tcipif_clint_write;
assign busif_read_vld     = tcipif_clint_sel && !tcipif_clint_write;

assign clint_tcipif_rdata[31:0] = ({32{msip_sel}}        & msip_value[31:0]
                                 | {32{mtimecmp_lo_sel}} & mtimecmp_lo_value[31:0]
                                 | {32{mtimecmp_hi_sel}} & mtimecmp_hi_value[31:0]
                                 | {32{mtime_lo_sel}}    & mtime_lo_value[31:0]
                                 | {32{mtime_hi_sel}}    & mtime_hi_value[31:0])
                                 & {32{busif_read_vld}};

assign busif_regs_wdata[31:0] = tcipif_clint_wdata[31:0];

// &ModuleEnd; @59
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_clint_regs(
  busif_regs_msip_sel,
  busif_regs_mtimecmp_hi_sel,
  busif_regs_mtimecmp_lo_sel,
  busif_regs_wdata,
  busif_regs_write_vld,
  clint_clk,
  clint_cpu_me_int,
  clint_cpu_ms_int,
  clint_cpu_mt_int,
  cpu_clint_mode,
  cpurst_b,
  msip_value,
  mtime_hi_value,
  mtime_lo_value,
  mtimecmp_hi_value,
  mtimecmp_lo_value,
  sysio_clint_me_int,
  sysio_clint_mtime
);

// &Ports; @23
input           busif_regs_msip_sel;       
input           busif_regs_mtimecmp_hi_sel; 
input           busif_regs_mtimecmp_lo_sel; 
input   [31:0]  busif_regs_wdata;          
input           busif_regs_write_vld;      
input           clint_clk;                 
input   [1 :0]  cpu_clint_mode;            
input           cpurst_b;                  
input           sysio_clint_me_int;        
input   [63:0]  sysio_clint_mtime;         
output          clint_cpu_me_int;          
output          clint_cpu_ms_int;          
output          clint_cpu_mt_int;          
output  [31:0]  msip_value;                
output  [31:0]  mtime_hi_value;            
output  [31:0]  mtime_lo_value;            
output  [31:0]  mtimecmp_hi_value;         
output  [31:0]  mtimecmp_lo_value;         

// &Regs; @24
reg             msip_en;                   
reg     [31:0]  mtimecmp_hi;               
reg     [31:0]  mtimecmp_lo;               

// &Wires; @25
wire            busif_regs_msip_sel;       
wire            busif_regs_mtimecmp_hi_sel; 
wire            busif_regs_mtimecmp_lo_sel; 
wire    [31:0]  busif_regs_wdata;          
wire            busif_regs_write_vld;      
wire            clint_clk;                 
wire            clint_cpu_me_int;          
wire            clint_cpu_ms_int;          
wire            clint_cpu_mt_int;          
wire    [1 :0]  cpu_clint_mode;            
wire            cpu_is_m_mode;             
wire            cpurst_b;                  
wire            mregs_write_vld;           
wire    [31:0]  msip_value;                
wire    [31:0]  mtime_hi_value;            
wire    [31:0]  mtime_lo_value;            
wire    [31:0]  mtimecmp_hi_value;         
wire    [31:0]  mtimecmp_lo_value;         
wire            sysio_clint_me_int;        
wire    [63:0]  sysio_clint_mtime;         


parameter CPU_M_MODE = 2'b11;

//==========================================================
//                       Write Ctrl
//==========================================================
assign cpu_is_m_mode = cpu_clint_mode[1:0] == CPU_M_MODE;

assign mregs_write_vld = busif_regs_write_vld && cpu_is_m_mode;

//==========================================================
//                         Regs
//==========================================================
//----------------- MSIP ---------------
always @ (posedge clint_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    msip_en <= 1'b0;
  else if (mregs_write_vld && busif_regs_msip_sel)
    msip_en <= busif_regs_wdata[0];
  else
    msip_en <= msip_en;
end
assign msip_value[31:0] = {31'b0, msip_en};


//------------- MTIMECMP_LO ------------
always @ (posedge clint_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    mtimecmp_lo[31:0] <= 32'b0;
  else if (mregs_write_vld && busif_regs_mtimecmp_lo_sel)
    mtimecmp_lo[31:0] <= busif_regs_wdata[31:0];
  else
    mtimecmp_lo[31:0] <= mtimecmp_lo[31:0];
end
assign mtimecmp_lo_value[31:0] = mtimecmp_lo[31:0];


//------------- MTIMECMP_HI ------------
always @ (posedge clint_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    mtimecmp_hi[31:0] <= 32'b0;
  else if (mregs_write_vld && busif_regs_mtimecmp_hi_sel)
    mtimecmp_hi[31:0] <= busif_regs_wdata[31:0];
  else
    mtimecmp_hi[31:0] <= mtimecmp_hi[31:0];
end
assign mtimecmp_hi_value[31:0] = mtimecmp_hi[31:0];


//--------------- MTIME_LOW ------------
assign mtime_lo_value[31:0] = sysio_clint_mtime[31:0];

//--------------- MTIME_HI -------------
assign mtime_hi_value[31:0] = sysio_clint_mtime[63:32];


//==========================================================
//                   CLINT Output Signal
//==========================================================
assign clint_cpu_ms_int = msip_en;
assign clint_cpu_mt_int = !({mtimecmp_hi[31:0], mtimecmp_lo[31:0]}
                           > sysio_clint_mtime[63:0]);
assign clint_cpu_me_int = sysio_clint_me_int;

// &ModuleEnd; @93
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_clint_top(
  clint_cpu_me_int,
  clint_cpu_ms_int,
  clint_cpu_mt_int,
  clint_tcipif_cmplt,
  clint_tcipif_rdata,
  cpu_clint_mode,
  cpurst_b,
  forever_cpuclk,
  pad_yy_gate_clk_en_b,
  sysio_clint_me_int,
  sysio_clint_mtime,
  tcipif_clint_addr,
  tcipif_clint_sel,
  tcipif_clint_wdata,
  tcipif_clint_write
);

// &Ports; @23
input   [1 :0]  cpu_clint_mode;            
input           cpurst_b;                  
input           forever_cpuclk;            
input           pad_yy_gate_clk_en_b;      
input           sysio_clint_me_int;        
input   [63:0]  sysio_clint_mtime;         
input   [15:0]  tcipif_clint_addr;         
input           tcipif_clint_sel;          
input   [31:0]  tcipif_clint_wdata;        
input           tcipif_clint_write;        
output          clint_cpu_me_int;          
output          clint_cpu_ms_int;          
output          clint_cpu_mt_int;          
output          clint_tcipif_cmplt;        
output  [31:0]  clint_tcipif_rdata;        

// &Regs; @24

// &Wires; @25
wire            busif_regs_msip_sel;       
wire            busif_regs_mtimecmp_hi_sel; 
wire            busif_regs_mtimecmp_lo_sel; 
wire    [31:0]  busif_regs_wdata;          
wire            busif_regs_write_vld;      
wire            clint_clk;                 
wire            clint_clk_en;              
wire            clint_cpu_me_int;          
wire            clint_cpu_ms_int;          
wire            clint_cpu_mt_int;          
wire            clint_tcipif_cmplt;        
wire    [31:0]  clint_tcipif_rdata;        
wire    [1 :0]  cpu_clint_mode;            
wire            cpurst_b;                  
wire            forever_cpuclk;            
wire    [31:0]  msip_value;                
wire    [31:0]  mtime_hi_value;            
wire    [31:0]  mtime_lo_value;            
wire    [31:0]  mtimecmp_hi_value;         
wire    [31:0]  mtimecmp_lo_value;         
wire            pad_yy_gate_clk_en_b;      
wire            sysio_clint_me_int;        
wire    [63:0]  sysio_clint_mtime;         
wire    [15:0]  tcipif_clint_addr;         
wire            tcipif_clint_sel;          
wire    [31:0]  tcipif_clint_wdata;        
wire            tcipif_clint_write;        


// &Instance("cr_clint_regs"); @27
cr_clint_regs  x_cr_clint_regs (
  .busif_regs_msip_sel        (busif_regs_msip_sel       ),
  .busif_regs_mtimecmp_hi_sel (busif_regs_mtimecmp_hi_sel),
  .busif_regs_mtimecmp_lo_sel (busif_regs_mtimecmp_lo_sel),
  .busif_regs_wdata           (busif_regs_wdata          ),
  .busif_regs_write_vld       (busif_regs_write_vld      ),
  .clint_clk                  (clint_clk                 ),
  .clint_cpu_me_int           (clint_cpu_me_int          ),
  .clint_cpu_ms_int           (clint_cpu_ms_int          ),
  .clint_cpu_mt_int           (clint_cpu_mt_int          ),
  .cpu_clint_mode             (cpu_clint_mode            ),
  .cpurst_b                   (cpurst_b                  ),
  .msip_value                 (msip_value                ),
  .mtime_hi_value             (mtime_hi_value            ),
  .mtime_lo_value             (mtime_lo_value            ),
  .mtimecmp_hi_value          (mtimecmp_hi_value         ),
  .mtimecmp_lo_value          (mtimecmp_lo_value         ),
  .sysio_clint_me_int         (sysio_clint_me_int        ),
  .sysio_clint_mtime          (sysio_clint_mtime         )
);

// &Instance("cr_clint_busif"); @28
cr_clint_busif  x_cr_clint_busif (
  .busif_regs_msip_sel        (busif_regs_msip_sel       ),
  .busif_regs_mtimecmp_hi_sel (busif_regs_mtimecmp_hi_sel),
  .busif_regs_mtimecmp_lo_sel (busif_regs_mtimecmp_lo_sel),
  .busif_regs_wdata           (busif_regs_wdata          ),
  .busif_regs_write_vld       (busif_regs_write_vld      ),
  .clint_tcipif_cmplt         (clint_tcipif_cmplt        ),
  .clint_tcipif_rdata         (clint_tcipif_rdata        ),
  .msip_value                 (msip_value                ),
  .mtime_hi_value             (mtime_hi_value            ),
  .mtime_lo_value             (mtime_lo_value            ),
  .mtimecmp_hi_value          (mtimecmp_hi_value         ),
  .mtimecmp_lo_value          (mtimecmp_lo_value         ),
  .tcipif_clint_addr          (tcipif_clint_addr         ),
  .tcipif_clint_sel           (tcipif_clint_sel          ),
  .tcipif_clint_wdata         (tcipif_clint_wdata        ),
  .tcipif_clint_write         (tcipif_clint_write        )
);


assign clint_clk_en = tcipif_clint_sel;
// &Instance("gated_clk_cell", "x_clint_gateclk"); @31
gated_clk_cell  x_clint_gateclk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (clint_clk           ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (clint_clk_en        ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect( .clk_in     (forever_cpuclk), @32
//           .external_en(1'b0          ), @33
//           .global_en  (1'b1          ), @34
//           .module_en  (1'b0          ), @35
//           .local_en   (clint_clk_en  ), @36
//           .clk_out    (clint_clk     ) @37
//          ); @38


// &ModuleEnd; @41
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_clk_top(
  forever_cpuclk,
  forever_cpuclk_nogated,
  forever_jtgclk,
  pad_had_jtg_tclk,
  pad_yy_test_mode,
  pll_core_cpuclk
);

// &Ports; @24
input        pad_had_jtg_tclk;      
input        pad_yy_test_mode;      
input        pll_core_cpuclk;       
output       forever_cpuclk;        
output       forever_cpuclk_nogated; 
output       forever_jtgclk;        

// &Regs; @25

// &Wires; @26
wire         forever_cpuclk;        
wire         forever_cpuclk_nogated; 
wire         forever_jtgclk;        
wire         pad_had_jtg_tclk;      
wire         pad_yy_test_mode;      
wire         pll_core_cpuclk;       


assign forever_jtgclk = pad_had_jtg_tclk;
assign forever_cpuclk = pad_yy_test_mode ? pad_had_jtg_tclk : pll_core_cpuclk;
assign forever_cpuclk_nogated = pad_yy_test_mode ? pad_had_jtg_tclk : pll_core_cpuclk;

// &ModuleEnd; @34
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @22
module cr_clkrst_top(
  cpurst_b,
  forever_cpuclk,
  forever_cpuclk_nogated,
  forever_jtgclk,
  hadrst_b,
  pad_cpu_rst_b,
  pad_had_jtg_tclk,
  pad_had_jtg_trst_b,
  pad_had_rst_b,
  pad_yy_test_mode,
  pll_core_cpuclk,
  trst_b
);

// &Ports; @23
input        pad_cpu_rst_b;         
input        pad_had_jtg_tclk;      
input        pad_had_jtg_trst_b;    
input        pad_had_rst_b;         
input        pad_yy_test_mode;      
input        pll_core_cpuclk;       
output       cpurst_b;              
output       forever_cpuclk;        
output       forever_cpuclk_nogated; 
output       forever_jtgclk;        
output       hadrst_b;              
output       trst_b;                

// &Regs; @24

// &Wires; @25
wire         cpurst_b;              
wire         forever_cpuclk;        
wire         forever_cpuclk_nogated; 
wire         forever_jtgclk;        
wire         hadrst_b;              
wire         pad_cpu_rst_b;         
wire         pad_had_jtg_tclk;      
wire         pad_had_jtg_trst_b;    
wire         pad_had_rst_b;         
wire         pad_yy_test_mode;      
wire         pll_core_cpuclk;       
wire         trst_b;                


// &Force("output", "forever_cpuclk"); @27
// &Force("output", "forever_cpuclk_nogated"); @29

//----------------------------------------------------------
// clock top
//----------------------------------------------------------
// &Instance("cr_clk_top"); @35
cr_clk_top  x_cr_clk_top (
  .forever_cpuclk         (forever_cpuclk        ),
  .forever_cpuclk_nogated (forever_cpuclk_nogated),
  .forever_jtgclk         (forever_jtgclk        ),
  .pad_had_jtg_tclk       (pad_had_jtg_tclk      ),
  .pad_yy_test_mode       (pad_yy_test_mode      ),
  .pll_core_cpuclk        (pll_core_cpuclk       )
);


//----------------------------------------------------------
// reset top
//----------------------------------------------------------
// &Instance("cr_rst_top"); @40
cr_rst_top  x_cr_rst_top (
  .cpurst_b           (cpurst_b          ),
  .hadrst_b           (hadrst_b          ),
  .pad_cpu_rst_b      (pad_cpu_rst_b     ),
  .pad_had_jtg_trst_b (pad_had_jtg_trst_b),
  .pad_had_rst_b      (pad_had_rst_b     ),
  .pad_yy_test_mode   (pad_yy_test_mode  ),
  .trst_b             (trst_b            )
);

// &ModuleEnd; @41
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &Depend("cpu_cfig.h"); @23

// &ModuleBeg; @25
module cr_core(
  bmu_lsu_acc_err,
  bmu_lsu_bstack_chk_fail,
  bmu_lsu_data,
  bmu_lsu_data_vld,
  bmu_lsu_grnt,
  bmu_lsu_trans_cmplt,
  bmu_xx_ibus_acc_err,
  bmu_xx_ibus_data,
  bmu_xx_ibus_data_vld,
  bmu_xx_ibus_grnt,
  bmu_xx_ibus_trans_cmplt,
  cache_cp0_lpmd_ack,
  cache_cp0_srst_ack,
  cache_iu_lockup_ack,
  clic_cpu_int_hv,
  clic_cpu_int_id,
  clic_cpu_int_il,
  clic_cpu_int_priv,
  clint_cpu_me_int,
  clk_en,
  cp0_cache_lpmd_req,
  cp0_cache_srst_req,
  cp0_had_cpuid_idx0,
  cp0_had_int_exit,
  cp0_had_lpmd_b,
  cp0_had_mcause_data,
  cp0_pad_mcause,
  cp0_pad_mintstatus,
  cp0_pad_mstatus,
  cp0_pmp_csr_sel,
  cp0_pmp_csr_wen,
  cp0_pmp_mstatus_mpp,
  cp0_pmp_mstatus_mprv,
  cp0_pmp_updt_data,
  cp0_sysio_ipend_b,
  cp0_sysio_lpmd_b,
  cp0_sysio_srst,
  cp0_yy_be_v2,
  cp0_yy_clk_en,
  cp0_yy_machine_mode_aft_dbg,
  cp0_yy_priv_mode,
  cpu_clic_curid,
  cpu_clic_int_exit,
  cpurst_b,
  forever_cpuclk,
  had_core_dbg_mode_req,
  had_idu_wbbr_data,
  had_idu_wbbr_vld,
  had_ifu_inst_bkpt_dbq_req,
  had_ifu_inst_bkpt_dbqexp_req,
  had_ifu_ir,
  had_ifu_ir_vld,
  had_iu_bkpt_trace_en,
  had_iu_dr_set_req,
  had_iu_force_dbg_en,
  had_iu_int_vld,
  had_iu_mbkpt_fsm_index_mbee,
  had_iu_mem_bkpt_exp_req,
  had_iu_mem_bkpt_mask,
  had_iu_mem_bkpt_req,
  had_iu_pc,
  had_iu_rte_pc_sel,
  had_iu_trace_req,
  had_iu_trace_req_for_dbg_disable,
  had_iu_xx_fdb,
  had_iu_xx_jdbreq,
  had_yy_xx_dbg,
  had_yy_xx_dp_index_mbee,
  had_yy_xx_exit_dbg,
  ifu_bmu_addr,
  ifu_bmu_idle,
  ifu_bmu_prot,
  ifu_bmu_req,
  ifu_bmu_wfd1,
  ifu_had_chg_flw_inst,
  ifu_had_fetch_expt_vld,
  ifu_had_inst_dbg_disable,
  ifu_had_match_pc,
  ifu_had_split_first,
  iu_bmu_vec_redirect,
  iu_cache_lockup_req,
  iu_had_adr_dbg_ack,
  iu_had_chgflw_dst_pc,
  iu_had_chgflw_vld,
  iu_had_data_bkpt_occur_vld,
  iu_had_dbg_disable_for_tee,
  iu_had_dr_dbg_ack,
  iu_had_expt_vld,
  iu_had_fast_retire_acc_err_pc_update,
  iu_had_fast_retire_acc_err_pc_val,
  iu_had_flush,
  iu_had_inst_bkpt_occur_vld,
  iu_had_int_ack,
  iu_had_retire_with_had_int,
  iu_had_trace_occur_vld,
  iu_had_xx_bkpt_inst,
  iu_had_xx_data,
  iu_had_xx_data_vld,
  iu_had_xx_dbg_ack,
  iu_had_xx_mldst,
  iu_had_xx_retire,
  iu_had_xx_retire_normal,
  iu_had_xx_retire_pc,
  iu_pad_gpr_data,
  iu_pad_gpr_index,
  iu_pad_gpr_we,
  iu_pad_inst_retire,
  iu_pad_inst_split,
  iu_pad_retire_pc,
  iu_sys_lp_wk_int,
  iu_sysio_lockup_on,
  iu_yy_xx_dbgon,
  lsu_bmu_addr,
  lsu_bmu_addr_check_fail,
  lsu_bmu_idle,
  lsu_bmu_prot,
  lsu_bmu_req,
  lsu_bmu_req_without_cmplt,
  lsu_bmu_sg_chk_fail,
  lsu_bmu_size,
  lsu_bmu_store_error,
  lsu_bmu_wdata,
  lsu_bmu_wfd1,
  lsu_bmu_write,
  lsu_had_addr,
  lsu_had_addr_vld,
  lsu_had_ex_cmplt,
  lsu_had_st,
  pad_yy_gate_clk_en_b,
  pmp_cp0_data,
  pmp_ifu_acc_scu,
  pmp_lsu_acc_scu,
  sysio_cp0_bigend,
  sysio_cp0_clkratio,
  sysio_cp0_endian_v2,
  sysio_cp0_rst_addr,
  sysio_cp0_sys_view_lpmd_b,
  sysio_ifu_rst_addr,
  sysio_iu_nmi_int,
  sysio_iu_rst_addr,
  sysio_iu_wk_event,
  sysmap_ifu_acc_ca,
  sysmap_lsu_acc_ca,
  tcip_cp0_clic_base
);

// &Ports; @26
input           bmu_lsu_acc_err;                      
input           bmu_lsu_bstack_chk_fail;              
input   [31:0]  bmu_lsu_data;                         
input           bmu_lsu_data_vld;                     
input           bmu_lsu_grnt;                         
input           bmu_lsu_trans_cmplt;                  
input           bmu_xx_ibus_acc_err;                  
input   [31:0]  bmu_xx_ibus_data;                     
input           bmu_xx_ibus_data_vld;                 
input           bmu_xx_ibus_grnt;                     
input           bmu_xx_ibus_trans_cmplt;              
input           cache_cp0_lpmd_ack;                   
input           cache_cp0_srst_ack;                   
input           cache_iu_lockup_ack;                  
input           clic_cpu_int_hv;                      
input   [11:0]  clic_cpu_int_id;                      
input   [7 :0]  clic_cpu_int_il;                      
input   [1 :0]  clic_cpu_int_priv;                    
input           clint_cpu_me_int;                     
input           clk_en;                               
input           cpurst_b;                             
input           forever_cpuclk;                       
input           had_core_dbg_mode_req;                
input   [31:0]  had_idu_wbbr_data;                    
input           had_idu_wbbr_vld;                     
input           had_ifu_inst_bkpt_dbq_req;            
input           had_ifu_inst_bkpt_dbqexp_req;         
input   [31:0]  had_ifu_ir;                           
input           had_ifu_ir_vld;                       
input           had_iu_bkpt_trace_en;                 
input           had_iu_dr_set_req;                    
input           had_iu_force_dbg_en;                  
input           had_iu_int_vld;                       
input           had_iu_mbkpt_fsm_index_mbee;          
input           had_iu_mem_bkpt_exp_req;              
input           had_iu_mem_bkpt_mask;                 
input           had_iu_mem_bkpt_req;                  
input   [30:0]  had_iu_pc;                            
input           had_iu_rte_pc_sel;                    
input           had_iu_trace_req;                     
input           had_iu_trace_req_for_dbg_disable;     
input           had_iu_xx_fdb;                        
input           had_iu_xx_jdbreq;                     
input           had_yy_xx_dbg;                        
input           had_yy_xx_dp_index_mbee;              
input           had_yy_xx_exit_dbg;                   
input           pad_yy_gate_clk_en_b;                 
input   [31:0]  pmp_cp0_data;                         
input           pmp_ifu_acc_scu;                      
input           pmp_lsu_acc_scu;                      
input           sysio_cp0_bigend;                     
input   [2 :0]  sysio_cp0_clkratio;                   
input           sysio_cp0_endian_v2;                  
input   [31:0]  sysio_cp0_rst_addr;                   
input   [1 :0]  sysio_cp0_sys_view_lpmd_b;            
input   [31:0]  sysio_ifu_rst_addr;                   
input           sysio_iu_nmi_int;                     
input   [31:0]  sysio_iu_rst_addr;                    
input           sysio_iu_wk_event;                    
input           sysmap_ifu_acc_ca;                    
input           sysmap_lsu_acc_ca;                    
input   [31:0]  tcip_cp0_clic_base;                   
output          cp0_cache_lpmd_req;                   
output          cp0_cache_srst_req;                   
output  [31:0]  cp0_had_cpuid_idx0;                   
output          cp0_had_int_exit;                     
output  [1 :0]  cp0_had_lpmd_b;                       
output  [31:0]  cp0_had_mcause_data;                  
output  [31:0]  cp0_pad_mcause;                       
output  [31:0]  cp0_pad_mintstatus;                   
output  [31:0]  cp0_pad_mstatus;                      
output  [11:0]  cp0_pmp_csr_sel;                      
output          cp0_pmp_csr_wen;                      
output  [1 :0]  cp0_pmp_mstatus_mpp;                  
output          cp0_pmp_mstatus_mprv;                 
output  [31:0]  cp0_pmp_updt_data;                    
output          cp0_sysio_ipend_b;                    
output  [1 :0]  cp0_sysio_lpmd_b;                     
output  [1 :0]  cp0_sysio_srst;                       
output          cp0_yy_be_v2;                         
output          cp0_yy_clk_en;                        
output          cp0_yy_machine_mode_aft_dbg;          
output  [1 :0]  cp0_yy_priv_mode;                     
output  [11:0]  cpu_clic_curid;                       
output          cpu_clic_int_exit;                    
output  [31:0]  ifu_bmu_addr;                         
output          ifu_bmu_idle;                         
output  [3 :0]  ifu_bmu_prot;                         
output          ifu_bmu_req;                          
output          ifu_bmu_wfd1;                         
output          ifu_had_chg_flw_inst;                 
output          ifu_had_fetch_expt_vld;               
output          ifu_had_inst_dbg_disable;             
output  [31:0]  ifu_had_match_pc;                     
output          ifu_had_split_first;                  
output          iu_bmu_vec_redirect;                  
output          iu_cache_lockup_req;                  
output          iu_had_adr_dbg_ack;                   
output  [31:0]  iu_had_chgflw_dst_pc;                 
output          iu_had_chgflw_vld;                    
output          iu_had_data_bkpt_occur_vld;           
output          iu_had_dbg_disable_for_tee;           
output          iu_had_dr_dbg_ack;                    
output          iu_had_expt_vld;                      
output          iu_had_fast_retire_acc_err_pc_update; 
output  [30:0]  iu_had_fast_retire_acc_err_pc_val;    
output          iu_had_flush;                         
output          iu_had_inst_bkpt_occur_vld;           
output          iu_had_int_ack;                       
output          iu_had_retire_with_had_int;           
output          iu_had_trace_occur_vld;               
output          iu_had_xx_bkpt_inst;                  
output  [31:0]  iu_had_xx_data;                       
output          iu_had_xx_data_vld;                   
output          iu_had_xx_dbg_ack;                    
output          iu_had_xx_mldst;                      
output          iu_had_xx_retire;                     
output          iu_had_xx_retire_normal;              
output  [31:0]  iu_had_xx_retire_pc;                  
output  [31:0]  iu_pad_gpr_data;                      
output  [4 :0]  iu_pad_gpr_index;                     
output          iu_pad_gpr_we;                        
output          iu_pad_inst_retire;                   
output          iu_pad_inst_split;                    
output  [31:0]  iu_pad_retire_pc;                     
output          iu_sys_lp_wk_int;                     
output          iu_sysio_lockup_on;                   
output          iu_yy_xx_dbgon;                       
output  [31:0]  lsu_bmu_addr;                         
output          lsu_bmu_addr_check_fail;              
output          lsu_bmu_idle;                         
output  [3 :0]  lsu_bmu_prot;                         
output          lsu_bmu_req;                          
output          lsu_bmu_req_without_cmplt;            
output          lsu_bmu_sg_chk_fail;                  
output  [1 :0]  lsu_bmu_size;                         
output          lsu_bmu_store_error;                  
output  [31:0]  lsu_bmu_wdata;                        
output          lsu_bmu_wfd1;                         
output          lsu_bmu_write;                        
output  [31:0]  lsu_had_addr;                         
output          lsu_had_addr_vld;                     
output          lsu_had_ex_cmplt;                     
output          lsu_had_st;                           

// &Regs; @27

// &Wires; @28
wire            bmu_lsu_acc_err;                      
wire            bmu_lsu_bstack_chk_fail;              
wire    [31:0]  bmu_lsu_data;                         
wire            bmu_lsu_data_vld;                     
wire            bmu_lsu_grnt;                         
wire            bmu_lsu_trans_cmplt;                  
wire            bmu_xx_ibus_acc_err;                  
wire    [31:0]  bmu_xx_ibus_data;                     
wire            bmu_xx_ibus_data_vld;                 
wire            bmu_xx_ibus_grnt;                     
wire            bmu_xx_ibus_trans_cmplt;              
wire            cache_cp0_lpmd_ack;                   
wire            cache_cp0_srst_ack;                   
wire            cache_iu_lockup_ack;                  
wire            clic_cpu_int_hv;                      
wire    [11:0]  clic_cpu_int_id;                      
wire    [7 :0]  clic_cpu_int_il;                      
wire    [1 :0]  clic_cpu_int_priv;                    
wire            clint_cpu_me_int;                     
wire            clk_en;                               
wire            cp0_cache_lpmd_req;                   
wire            cp0_cache_srst_req;                   
wire    [31:0]  cp0_had_cpuid_idx0;                   
wire            cp0_had_int_exit;                     
wire    [1 :0]  cp0_had_lpmd_b;                       
wire    [31:0]  cp0_had_mcause_data;                  
wire            cp0_ifu_in_lpmd;                      
wire            cp0_ifu_lpmd_req;                     
wire            cp0_ifu_rst_inv_done;                 
wire            cp0_ifu_srst_mask;                    
wire            cp0_ifu_srst_req;                     
wire            cp0_iu_cache_inv_done;                
wire            cp0_iu_cskyisaee;                     
wire    [31:0]  cp0_iu_data;                          
wire            cp0_iu_data_vld;                      
wire            cp0_iu_dbg_disable_for_tee;           
wire    [30:0]  cp0_iu_epc_for_chgflw;                
wire    [4 :0]  cp0_iu_expt_vec;                      
wire            cp0_iu_expt_vld;                      
wire            cp0_iu_flush;                         
wire            cp0_iu_flush_chgflw_vld;              
wire    [7 :0]  cp0_iu_il;                            
wire            cp0_iu_in_expt;                       
wire            cp0_iu_in_nmi;                        
wire            cp0_iu_inst_mret;                     
wire            cp0_iu_meie;                          
wire            cp0_iu_mie_for_int;                   
wire            cp0_iu_mret;                          
wire            cp0_iu_req;                           
wire            cp0_iu_rte_chgflw_vld;                
wire            cp0_iu_rte_chgflw_vld_for_data;       
wire            cp0_iu_stall;                         
wire            cp0_iu_stall_noinput;                 
wire    [29:0]  cp0_iu_vbr;                           
wire    [1 :0]  cp0_iu_vec_mode;                      
wire            cp0_iu_wfe_en;                        
wire    [31:0]  cp0_pad_mcause;                       
wire    [31:0]  cp0_pad_mintstatus;                   
wire    [31:0]  cp0_pad_mstatus;                      
wire    [11:0]  cp0_pmp_csr_sel;                      
wire            cp0_pmp_csr_wen;                      
wire    [1 :0]  cp0_pmp_mstatus_mpp;                  
wire            cp0_pmp_mstatus_mprv;                 
wire    [31:0]  cp0_pmp_updt_data;                    
wire            cp0_sysio_ipend_b;                    
wire    [1 :0]  cp0_sysio_lpmd_b;                     
wire    [1 :0]  cp0_sysio_srst;                       
wire    [29:0]  cp0_vector_vec_err_vbr;               
wire            cp0_yy_be_v1;                         
wire            cp0_yy_be_v2;                         
wire            cp0_yy_clk_en;                        
wire            cp0_yy_machine_mode_aft_dbg;          
wire    [1 :0]  cp0_yy_priv_mode;                     
wire    [11:0]  cpu_clic_curid;                       
wire            cpu_clic_int_exit;                    
wire            cpurst_b;                             
wire            forever_cpuclk;                       
wire            had_core_dbg_mode_req;                
wire    [31:0]  had_idu_wbbr_data;                    
wire            had_idu_wbbr_vld;                     
wire            had_ifu_inst_bkpt_dbq_req;            
wire            had_ifu_inst_bkpt_dbqexp_req;         
wire    [31:0]  had_ifu_ir;                           
wire            had_ifu_ir_vld;                       
wire            had_iu_bkpt_trace_en;                 
wire            had_iu_dr_set_req;                    
wire            had_iu_force_dbg_en;                  
wire            had_iu_int_vld;                       
wire            had_iu_mbkpt_fsm_index_mbee;          
wire            had_iu_mem_bkpt_exp_req;              
wire            had_iu_mem_bkpt_mask;                 
wire            had_iu_mem_bkpt_req;                  
wire    [30:0]  had_iu_pc;                            
wire            had_iu_rte_pc_sel;                    
wire            had_iu_trace_req;                     
wire            had_iu_trace_req_for_dbg_disable;     
wire            had_iu_xx_fdb;                        
wire            had_iu_xx_jdbreq;                     
wire            had_yy_xx_dbg;                        
wire            had_yy_xx_dp_index_mbee;              
wire            had_yy_xx_exit_dbg;                   
wire    [31:0]  ifu_bmu_addr;                         
wire            ifu_bmu_idle;                         
wire    [3 :0]  ifu_bmu_prot;                         
wire            ifu_bmu_req;                          
wire            ifu_bmu_wfd1;                         
wire            ifu_cp0_lpmd_ack;                     
wire            ifu_cp0_rst_inv_req;                  
wire            ifu_cp0_srst_ack;                     
wire            ifu_had_chg_flw_inst;                 
wire            ifu_had_fetch_expt_vld;               
wire            ifu_had_inst_dbg_disable;             
wire    [31:0]  ifu_had_match_pc;                     
wire            ifu_had_split_first;                  
wire            ifu_iu_ex_expt_cur;                   
wire            ifu_iu_ex_expt_vld;                   
wire    [31:0]  ifu_iu_ex_inst;                       
wire            ifu_iu_ex_inst_bkpt;                  
wire            ifu_iu_ex_inst_dbg_disable;           
wire            ifu_iu_ex_inst_vld;                   
wire            ifu_iu_ex_int_spcu_mask;              
wire            ifu_iu_ex_int_spcu_vld;               
wire            ifu_iu_ex_ni;                         
wire            ifu_iu_ex_prvlg_expt_vld;             
wire            ifu_iu_ex_rand_vld;                   
wire            ifu_iu_ex_sp_oper;                    
wire            ifu_iu_ibus_idle;                     
wire            ifu_iu_inst_bkpt_dbg_occur_vld;       
wire            ifu_iu_inst_bkpt_dbgexp_occur_vld;    
wire            ifu_iu_inst_buf_inst_dbg_disable;     
wire            ifu_iu_inst_buf_inst_vld;             
wire            ifu_iu_lockup_ack;                    
wire            ifu_iu_spcu_retire_mask;              
wire            ifu_iu_vector_ibus_in_idle;           
wire    [31:0]  ifu_iu_xx_ibus_data;                  
wire            iu_bmu_vec_redirect;                  
wire            iu_cache_lockup_req;                  
wire            iu_cp0_ecall;                         
wire    [30:0]  iu_cp0_epc;                           
wire            iu_cp0_epc_update;                    
wire            iu_cp0_ex_csrrc;                      
wire            iu_cp0_ex_csrrci;                     
wire            iu_cp0_ex_csrrs;                      
wire            iu_cp0_ex_csrrsi;                     
wire            iu_cp0_ex_csrrw;                      
wire            iu_cp0_ex_csrrwi;                     
wire            iu_cp0_ex_data_sel;                   
wire    [2 :0]  iu_cp0_ex_func3;                      
wire            iu_cp0_ex_mret;                       
wire    [4 :0]  iu_cp0_ex_rd_reg;                     
wire    [4 :0]  iu_cp0_ex_rs1_reg;                    
wire            iu_cp0_ex_sel;                        
wire            iu_cp0_ex_wfi;                        
wire    [31:0]  iu_cp0_expt_tval;                     
wire            iu_cp0_expt_vld;                      
wire    [11:0]  iu_cp0_imm;                           
wire            iu_cp0_int_vld;                       
wire            iu_cp0_lockup_clr;                    
wire            iu_cp0_lockup_vld;                    
wire            iu_cp0_lp_wk_int;                     
wire            iu_cp0_mtval_updt_vld;                
wire            iu_cp0_nmi_vld;                       
wire            iu_cp0_nt_int_pending_vld;            
wire            iu_cp0_oper_mux_en;                   
wire    [31:0]  iu_cp0_rs1;                           
wire            iu_cp0_syc_rst_b;                     
wire            iu_had_adr_dbg_ack;                   
wire    [31:0]  iu_had_chgflw_dst_pc;                 
wire            iu_had_chgflw_vld;                    
wire            iu_had_data_bkpt_occur_vld;           
wire            iu_had_dbg_disable_for_tee;           
wire            iu_had_dr_dbg_ack;                    
wire            iu_had_expt_vld;                      
wire            iu_had_fast_retire_acc_err_pc_update; 
wire    [30:0]  iu_had_fast_retire_acc_err_pc_val;    
wire            iu_had_flush;                         
wire            iu_had_inst_bkpt_occur_vld;           
wire            iu_had_int_ack;                       
wire            iu_had_retire_with_had_int;           
wire            iu_had_trace_occur_vld;               
wire            iu_had_xx_bkpt_inst;                  
wire    [31:0]  iu_had_xx_data;                       
wire            iu_had_xx_data_vld;                   
wire            iu_had_xx_dbg_ack;                    
wire            iu_had_xx_mldst;                      
wire            iu_had_xx_retire;                     
wire            iu_had_xx_retire_normal;              
wire    [31:0]  iu_had_xx_retire_pc;                  
wire    [30:0]  iu_ifu_addr;                          
wire            iu_ifu_data_fetch;                    
wire            iu_ifu_data_fetch_for_data;           
wire            iu_ifu_ex_stall;                      
wire            iu_ifu_ex_stall_noinput;              
wire            iu_ifu_ex_vld;                        
wire            iu_ifu_inst_fetch;                    
wire            iu_ifu_inst_fetch_for_data;           
wire            iu_ifu_inst_fetch_mask;               
wire            iu_ifu_inst_fetch_without_dbg_disable; 
wire            iu_ifu_kill_inst;                     
wire            iu_ifu_lockup_mask;                   
wire            iu_ifu_lockup_on;                     
wire            iu_ifu_lockup_req;                    
wire            iu_ifu_lsu_inst;                      
wire            iu_ifu_reset_vld;                     
wire            iu_ifu_security_violation;            
wire            iu_ifu_wb_ldst;                       
wire            iu_ifu_wb_stall;                      
wire    [31:0]  iu_lsu_adder_rst;                     
wire    [31:0]  iu_lsu_base;                          
wire    [31:0]  iu_lsu_data;                          
wire            iu_lsu_ex_byte;                       
wire            iu_lsu_ex_data_sel;                   
wire            iu_lsu_ex_half;                       
wire            iu_lsu_ex_sel;                        
wire            iu_lsu_ex_store;                      
wire            iu_lsu_ex_uns;                        
wire    [31:0]  iu_lsu_imm_data;                      
wire            iu_lsu_imm_write_en;                  
wire    [31:0]  iu_lsu_offset;                        
wire            iu_lsu_oper_mux_en;                   
wire    [31:0]  iu_lsu_rs2;                           
wire            iu_lsu_stall_without_hready;          
wire            iu_lsu_wb_ldst;                       
wire            iu_lsu_wb_load;                       
wire            iu_lsu_wb_store;                      
wire    [31:0]  iu_pad_gpr_data;                      
wire    [4 :0]  iu_pad_gpr_index;                     
wire            iu_pad_gpr_we;                        
wire            iu_pad_inst_retire;                   
wire            iu_pad_inst_split;                    
wire    [31:0]  iu_pad_retire_pc;                     
wire            iu_sys_lp_wk_int;                     
wire            iu_sysio_lockup_on;                   
wire            iu_yy_xx_dbgon;                       
wire    [9 :0]  iu_yy_xx_expt_vec;                    
wire            iu_yy_xx_flush;                       
wire            iu_yy_xx_int_hv;                      
wire    [7 :0]  iu_yy_xx_int_il;                      
wire            iu_yy_xx_int_pending_hv;              
wire    [9 :0]  iu_yy_xx_int_pending_id;              
wire    [7 :0]  iu_yy_xx_int_pending_il;              
wire    [1 :0]  iu_yy_xx_int_pending_priv;            
wire    [31:0]  lsu_bmu_addr;                         
wire            lsu_bmu_addr_check_fail;              
wire            lsu_bmu_idle;                         
wire    [3 :0]  lsu_bmu_prot;                         
wire            lsu_bmu_req;                          
wire            lsu_bmu_req_without_cmplt;            
wire            lsu_bmu_sg_chk_fail;                  
wire    [1 :0]  lsu_bmu_size;                         
wire            lsu_bmu_store_error;                  
wire    [31:0]  lsu_bmu_wdata;                        
wire            lsu_bmu_wfd1;                         
wire            lsu_bmu_write;                        
wire    [31:0]  lsu_had_addr;                         
wire            lsu_had_addr_vld;                     
wire            lsu_had_ex_cmplt;                     
wire            lsu_had_st;                           
wire    [31:0]  lsu_iu_addr;                          
wire            lsu_iu_addr_vld;                      
wire            lsu_iu_alu_sel;                       
wire    [31:0]  lsu_iu_data;                          
wire            lsu_iu_data_vld;                      
wire    [4 :0]  lsu_iu_expt_vec;                      
wire            lsu_iu_expt_vld;                      
wire            lsu_iu_fast_retire;                   
wire    [31:0]  lsu_iu_mad_buf;                       
wire            lsu_iu_req;                           
wire            lsu_iu_stall;                         
wire            lsu_iu_stall_noinput;                 
wire            lsu_iu_store;                         
wire            lsu_iu_wb_acc_err;                    
wire            lsu_iu_wb_bstack_chk_fail;            
wire            lsu_iu_wb_cmplt;                      
wire            lsu_iu_wb_data_vld;                   
wire    [31:0]  lsu_iu_wb_load_data;                  
wire            lsu_iu_wfd;                           
wire            pad_yy_gate_clk_en_b;                 
wire    [31:0]  pmp_cp0_data;                         
wire            pmp_ifu_acc_scu;                      
wire            pmp_lsu_acc_scu;                      
wire            split_ifctrl_hs_stall;                
wire            split_ifctrl_hs_stall_part;           
wire            sysio_cp0_bigend;                     
wire    [2 :0]  sysio_cp0_clkratio;                   
wire            sysio_cp0_endian_v2;                  
wire    [31:0]  sysio_cp0_rst_addr;                   
wire    [1 :0]  sysio_cp0_sys_view_lpmd_b;            
wire    [31:0]  sysio_ifu_rst_addr;                   
wire            sysio_iu_nmi_int;                     
wire    [31:0]  sysio_iu_rst_addr;                    
wire            sysio_iu_wk_event;                    
wire            sysmap_ifu_acc_ca;                    
wire            sysmap_lsu_acc_ca;                    
wire    [31:0]  tcip_cp0_clic_base;                   
wire            vector_cp0_vec_err;                   
wire    [29:0]  vector_cp0_vec_err_epc;               
wire            vector_cp0_vec_succeed;               


// &Instance("gated_clk_cell", "x_addr_high_shared_icg"); @32
// &Connect(.clk_in(forever_cpuclk), @33
//          .external_en(1'b0), @34
//          .global_en(cp0_yy_clk_en), @35
//          .module_en(1'b0), @36
//          .local_en(addr_high_shared_en), @37
//          .clk_out(addr_high_shared_clk) @38
//         ); @39
//==========================================================
//  Instance IFU module
//==========================================================
// &Instance("cr_ifu_top"); @44
cr_ifu_top  x_cr_ifu_top (
  .bmu_xx_ibus_acc_err                   (bmu_xx_ibus_acc_err                  ),
  .bmu_xx_ibus_data                      (bmu_xx_ibus_data                     ),
  .bmu_xx_ibus_grnt                      (bmu_xx_ibus_grnt                     ),
  .bmu_xx_ibus_trans_cmplt               (bmu_xx_ibus_trans_cmplt              ),
  .cp0_ifu_in_lpmd                       (cp0_ifu_in_lpmd                      ),
  .cp0_ifu_lpmd_req                      (cp0_ifu_lpmd_req                     ),
  .cp0_ifu_rst_inv_done                  (cp0_ifu_rst_inv_done                 ),
  .cp0_ifu_srst_mask                     (cp0_ifu_srst_mask                    ),
  .cp0_ifu_srst_req                      (cp0_ifu_srst_req                     ),
  .cp0_yy_clk_en                         (cp0_yy_clk_en                        ),
  .cp0_yy_machine_mode_aft_dbg           (cp0_yy_machine_mode_aft_dbg          ),
  .cpurst_b                              (cpurst_b                             ),
  .forever_cpuclk                        (forever_cpuclk                       ),
  .had_core_dbg_mode_req                 (had_core_dbg_mode_req                ),
  .had_ifu_inst_bkpt_dbq_req             (had_ifu_inst_bkpt_dbq_req            ),
  .had_ifu_inst_bkpt_dbqexp_req          (had_ifu_inst_bkpt_dbqexp_req         ),
  .had_ifu_ir                            (had_ifu_ir                           ),
  .had_ifu_ir_vld                        (had_ifu_ir_vld                       ),
  .had_yy_xx_dp_index_mbee               (had_yy_xx_dp_index_mbee              ),
  .ifu_bmu_addr                          (ifu_bmu_addr                         ),
  .ifu_bmu_idle                          (ifu_bmu_idle                         ),
  .ifu_bmu_prot                          (ifu_bmu_prot                         ),
  .ifu_bmu_req                           (ifu_bmu_req                          ),
  .ifu_bmu_wfd1                          (ifu_bmu_wfd1                         ),
  .ifu_cp0_lpmd_ack                      (ifu_cp0_lpmd_ack                     ),
  .ifu_cp0_rst_inv_req                   (ifu_cp0_rst_inv_req                  ),
  .ifu_cp0_srst_ack                      (ifu_cp0_srst_ack                     ),
  .ifu_had_fetch_expt_vld                (ifu_had_fetch_expt_vld               ),
  .ifu_had_inst_dbg_disable              (ifu_had_inst_dbg_disable             ),
  .ifu_had_split_first                   (ifu_had_split_first                  ),
  .ifu_iu_ex_expt_cur                    (ifu_iu_ex_expt_cur                   ),
  .ifu_iu_ex_expt_vld                    (ifu_iu_ex_expt_vld                   ),
  .ifu_iu_ex_inst                        (ifu_iu_ex_inst                       ),
  .ifu_iu_ex_inst_bkpt                   (ifu_iu_ex_inst_bkpt                  ),
  .ifu_iu_ex_inst_dbg_disable            (ifu_iu_ex_inst_dbg_disable           ),
  .ifu_iu_ex_inst_vld                    (ifu_iu_ex_inst_vld                   ),
  .ifu_iu_ex_int_spcu_mask               (ifu_iu_ex_int_spcu_mask              ),
  .ifu_iu_ex_int_spcu_vld                (ifu_iu_ex_int_spcu_vld               ),
  .ifu_iu_ex_ni                          (ifu_iu_ex_ni                         ),
  .ifu_iu_ex_prvlg_expt_vld              (ifu_iu_ex_prvlg_expt_vld             ),
  .ifu_iu_ex_rand_vld                    (ifu_iu_ex_rand_vld                   ),
  .ifu_iu_ex_sp_oper                     (ifu_iu_ex_sp_oper                    ),
  .ifu_iu_ibus_idle                      (ifu_iu_ibus_idle                     ),
  .ifu_iu_inst_bkpt_dbg_occur_vld        (ifu_iu_inst_bkpt_dbg_occur_vld       ),
  .ifu_iu_inst_bkpt_dbgexp_occur_vld     (ifu_iu_inst_bkpt_dbgexp_occur_vld    ),
  .ifu_iu_inst_buf_inst_dbg_disable      (ifu_iu_inst_buf_inst_dbg_disable     ),
  .ifu_iu_inst_buf_inst_vld              (ifu_iu_inst_buf_inst_vld             ),
  .ifu_iu_lockup_ack                     (ifu_iu_lockup_ack                    ),
  .ifu_iu_spcu_retire_mask               (ifu_iu_spcu_retire_mask              ),
  .ifu_iu_vector_ibus_in_idle            (ifu_iu_vector_ibus_in_idle           ),
  .ifu_iu_xx_ibus_data                   (ifu_iu_xx_ibus_data                  ),
  .iu_ifu_addr                           (iu_ifu_addr                          ),
  .iu_ifu_data_fetch                     (iu_ifu_data_fetch                    ),
  .iu_ifu_data_fetch_for_data            (iu_ifu_data_fetch_for_data           ),
  .iu_ifu_ex_stall                       (iu_ifu_ex_stall                      ),
  .iu_ifu_ex_stall_noinput               (iu_ifu_ex_stall_noinput              ),
  .iu_ifu_ex_vld                         (iu_ifu_ex_vld                        ),
  .iu_ifu_inst_fetch                     (iu_ifu_inst_fetch                    ),
  .iu_ifu_inst_fetch_for_data            (iu_ifu_inst_fetch_for_data           ),
  .iu_ifu_inst_fetch_mask                (iu_ifu_inst_fetch_mask               ),
  .iu_ifu_inst_fetch_without_dbg_disable (iu_ifu_inst_fetch_without_dbg_disable),
  .iu_ifu_kill_inst                      (iu_ifu_kill_inst                     ),
  .iu_ifu_lockup_mask                    (iu_ifu_lockup_mask                   ),
  .iu_ifu_lockup_on                      (iu_ifu_lockup_on                     ),
  .iu_ifu_lockup_req                     (iu_ifu_lockup_req                    ),
  .iu_ifu_lsu_inst                       (iu_ifu_lsu_inst                      ),
  .iu_ifu_reset_vld                      (iu_ifu_reset_vld                     ),
  .iu_ifu_security_violation             (iu_ifu_security_violation            ),
  .iu_ifu_wb_ldst                        (iu_ifu_wb_ldst                       ),
  .iu_ifu_wb_stall                       (iu_ifu_wb_stall                      ),
  .iu_yy_xx_dbgon                        (iu_yy_xx_dbgon                       ),
  .iu_yy_xx_flush                        (iu_yy_xx_flush                       ),
  .pad_yy_gate_clk_en_b                  (pad_yy_gate_clk_en_b                 ),
  .pmp_ifu_acc_scu                       (pmp_ifu_acc_scu                      ),
  .split_ifctrl_hs_stall                 (split_ifctrl_hs_stall                ),
  .split_ifctrl_hs_stall_part            (split_ifctrl_hs_stall_part           ),
  .sysio_ifu_rst_addr                    (sysio_ifu_rst_addr                   ),
  .sysmap_ifu_acc_ca                     (sysmap_ifu_acc_ca                    )
);

// &Force("output","iu_yy_ssp_sel"); @47

//==========================================================
//  Instance IU module 
//==========================================================
// &Instance("cr_iu_top"); @54
cr_iu_top  x_cr_iu_top (
  .bmu_xx_ibus_acc_err                   (bmu_xx_ibus_acc_err                  ),
  .bmu_xx_ibus_data_vld                  (bmu_xx_ibus_data_vld                 ),
  .bmu_xx_ibus_grnt                      (bmu_xx_ibus_grnt                     ),
  .cache_iu_lockup_ack                   (cache_iu_lockup_ack                  ),
  .clic_cpu_int_hv                       (clic_cpu_int_hv                      ),
  .clic_cpu_int_id                       (clic_cpu_int_id                      ),
  .clic_cpu_int_il                       (clic_cpu_int_il                      ),
  .clic_cpu_int_priv                     (clic_cpu_int_priv                    ),
  .clint_cpu_me_int                      (clint_cpu_me_int                     ),
  .clk_en                                (clk_en                               ),
  .cp0_iu_cache_inv_done                 (cp0_iu_cache_inv_done                ),
  .cp0_iu_cskyisaee                      (cp0_iu_cskyisaee                     ),
  .cp0_iu_data                           (cp0_iu_data                          ),
  .cp0_iu_data_vld                       (cp0_iu_data_vld                      ),
  .cp0_iu_dbg_disable_for_tee            (cp0_iu_dbg_disable_for_tee           ),
  .cp0_iu_epc_for_chgflw                 (cp0_iu_epc_for_chgflw                ),
  .cp0_iu_expt_vec                       (cp0_iu_expt_vec                      ),
  .cp0_iu_expt_vld                       (cp0_iu_expt_vld                      ),
  .cp0_iu_flush                          (cp0_iu_flush                         ),
  .cp0_iu_flush_chgflw_vld               (cp0_iu_flush_chgflw_vld              ),
  .cp0_iu_il                             (cp0_iu_il                            ),
  .cp0_iu_in_expt                        (cp0_iu_in_expt                       ),
  .cp0_iu_in_nmi                         (cp0_iu_in_nmi                        ),
  .cp0_iu_inst_mret                      (cp0_iu_inst_mret                     ),
  .cp0_iu_meie                           (cp0_iu_meie                          ),
  .cp0_iu_mie_for_int                    (cp0_iu_mie_for_int                   ),
  .cp0_iu_mret                           (cp0_iu_mret                          ),
  .cp0_iu_req                            (cp0_iu_req                           ),
  .cp0_iu_rte_chgflw_vld                 (cp0_iu_rte_chgflw_vld                ),
  .cp0_iu_rte_chgflw_vld_for_data        (cp0_iu_rte_chgflw_vld_for_data       ),
  .cp0_iu_stall                          (cp0_iu_stall                         ),
  .cp0_iu_stall_noinput                  (cp0_iu_stall_noinput                 ),
  .cp0_iu_vbr                            (cp0_iu_vbr                           ),
  .cp0_iu_vec_mode                       (cp0_iu_vec_mode                      ),
  .cp0_iu_wfe_en                         (cp0_iu_wfe_en                        ),
  .cp0_vector_vec_err_vbr                (cp0_vector_vec_err_vbr               ),
  .cp0_yy_clk_en                         (cp0_yy_clk_en                        ),
  .cp0_yy_priv_mode                      (cp0_yy_priv_mode                     ),
  .cpurst_b                              (cpurst_b                             ),
  .forever_cpuclk                        (forever_cpuclk                       ),
  .had_core_dbg_mode_req                 (had_core_dbg_mode_req                ),
  .had_idu_wbbr_data                     (had_idu_wbbr_data                    ),
  .had_idu_wbbr_vld                      (had_idu_wbbr_vld                     ),
  .had_iu_bkpt_trace_en                  (had_iu_bkpt_trace_en                 ),
  .had_iu_dr_set_req                     (had_iu_dr_set_req                    ),
  .had_iu_force_dbg_en                   (had_iu_force_dbg_en                  ),
  .had_iu_int_vld                        (had_iu_int_vld                       ),
  .had_iu_mbkpt_fsm_index_mbee           (had_iu_mbkpt_fsm_index_mbee          ),
  .had_iu_mem_bkpt_exp_req               (had_iu_mem_bkpt_exp_req              ),
  .had_iu_mem_bkpt_mask                  (had_iu_mem_bkpt_mask                 ),
  .had_iu_mem_bkpt_req                   (had_iu_mem_bkpt_req                  ),
  .had_iu_pc                             (had_iu_pc                            ),
  .had_iu_rte_pc_sel                     (had_iu_rte_pc_sel                    ),
  .had_iu_trace_req                      (had_iu_trace_req                     ),
  .had_iu_trace_req_for_dbg_disable      (had_iu_trace_req_for_dbg_disable     ),
  .had_iu_xx_fdb                         (had_iu_xx_fdb                        ),
  .had_iu_xx_jdbreq                      (had_iu_xx_jdbreq                     ),
  .had_yy_xx_exit_dbg                    (had_yy_xx_exit_dbg                   ),
  .ifu_had_chg_flw_inst                  (ifu_had_chg_flw_inst                 ),
  .ifu_had_match_pc                      (ifu_had_match_pc                     ),
  .ifu_iu_ex_expt_cur                    (ifu_iu_ex_expt_cur                   ),
  .ifu_iu_ex_expt_vld                    (ifu_iu_ex_expt_vld                   ),
  .ifu_iu_ex_inst                        (ifu_iu_ex_inst                       ),
  .ifu_iu_ex_inst_bkpt                   (ifu_iu_ex_inst_bkpt                  ),
  .ifu_iu_ex_inst_dbg_disable            (ifu_iu_ex_inst_dbg_disable           ),
  .ifu_iu_ex_inst_vld                    (ifu_iu_ex_inst_vld                   ),
  .ifu_iu_ex_int_spcu_mask               (ifu_iu_ex_int_spcu_mask              ),
  .ifu_iu_ex_int_spcu_vld                (ifu_iu_ex_int_spcu_vld               ),
  .ifu_iu_ex_ni                          (ifu_iu_ex_ni                         ),
  .ifu_iu_ex_prvlg_expt_vld              (ifu_iu_ex_prvlg_expt_vld             ),
  .ifu_iu_ex_rand_vld                    (ifu_iu_ex_rand_vld                   ),
  .ifu_iu_ex_sp_oper                     (ifu_iu_ex_sp_oper                    ),
  .ifu_iu_ibus_idle                      (ifu_iu_ibus_idle                     ),
  .ifu_iu_inst_bkpt_dbg_occur_vld        (ifu_iu_inst_bkpt_dbg_occur_vld       ),
  .ifu_iu_inst_bkpt_dbgexp_occur_vld     (ifu_iu_inst_bkpt_dbgexp_occur_vld    ),
  .ifu_iu_inst_buf_inst_dbg_disable      (ifu_iu_inst_buf_inst_dbg_disable     ),
  .ifu_iu_inst_buf_inst_vld              (ifu_iu_inst_buf_inst_vld             ),
  .ifu_iu_lockup_ack                     (ifu_iu_lockup_ack                    ),
  .ifu_iu_spcu_retire_mask               (ifu_iu_spcu_retire_mask              ),
  .ifu_iu_vector_ibus_in_idle            (ifu_iu_vector_ibus_in_idle           ),
  .ifu_iu_xx_ibus_data                   (ifu_iu_xx_ibus_data                  ),
  .iu_bmu_vec_redirect                   (iu_bmu_vec_redirect                  ),
  .iu_cache_lockup_req                   (iu_cache_lockup_req                  ),
  .iu_cp0_ecall                          (iu_cp0_ecall                         ),
  .iu_cp0_epc                            (iu_cp0_epc                           ),
  .iu_cp0_epc_update                     (iu_cp0_epc_update                    ),
  .iu_cp0_ex_csrrc                       (iu_cp0_ex_csrrc                      ),
  .iu_cp0_ex_csrrci                      (iu_cp0_ex_csrrci                     ),
  .iu_cp0_ex_csrrs                       (iu_cp0_ex_csrrs                      ),
  .iu_cp0_ex_csrrsi                      (iu_cp0_ex_csrrsi                     ),
  .iu_cp0_ex_csrrw                       (iu_cp0_ex_csrrw                      ),
  .iu_cp0_ex_csrrwi                      (iu_cp0_ex_csrrwi                     ),
  .iu_cp0_ex_data_sel                    (iu_cp0_ex_data_sel                   ),
  .iu_cp0_ex_func3                       (iu_cp0_ex_func3                      ),
  .iu_cp0_ex_mret                        (iu_cp0_ex_mret                       ),
  .iu_cp0_ex_rd_reg                      (iu_cp0_ex_rd_reg                     ),
  .iu_cp0_ex_rs1_reg                     (iu_cp0_ex_rs1_reg                    ),
  .iu_cp0_ex_sel                         (iu_cp0_ex_sel                        ),
  .iu_cp0_ex_wfi                         (iu_cp0_ex_wfi                        ),
  .iu_cp0_expt_tval                      (iu_cp0_expt_tval                     ),
  .iu_cp0_expt_vld                       (iu_cp0_expt_vld                      ),
  .iu_cp0_imm                            (iu_cp0_imm                           ),
  .iu_cp0_int_vld                        (iu_cp0_int_vld                       ),
  .iu_cp0_lockup_clr                     (iu_cp0_lockup_clr                    ),
  .iu_cp0_lockup_vld                     (iu_cp0_lockup_vld                    ),
  .iu_cp0_lp_wk_int                      (iu_cp0_lp_wk_int                     ),
  .iu_cp0_mtval_updt_vld                 (iu_cp0_mtval_updt_vld                ),
  .iu_cp0_nmi_vld                        (iu_cp0_nmi_vld                       ),
  .iu_cp0_nt_int_pending_vld             (iu_cp0_nt_int_pending_vld            ),
  .iu_cp0_oper_mux_en                    (iu_cp0_oper_mux_en                   ),
  .iu_cp0_rs1                            (iu_cp0_rs1                           ),
  .iu_cp0_syc_rst_b                      (iu_cp0_syc_rst_b                     ),
  .iu_had_adr_dbg_ack                    (iu_had_adr_dbg_ack                   ),
  .iu_had_chgflw_dst_pc                  (iu_had_chgflw_dst_pc                 ),
  .iu_had_chgflw_vld                     (iu_had_chgflw_vld                    ),
  .iu_had_data_bkpt_occur_vld            (iu_had_data_bkpt_occur_vld           ),
  .iu_had_dbg_disable_for_tee            (iu_had_dbg_disable_for_tee           ),
  .iu_had_dr_dbg_ack                     (iu_had_dr_dbg_ack                    ),
  .iu_had_expt_vld                       (iu_had_expt_vld                      ),
  .iu_had_fast_retire_acc_err_pc_update  (iu_had_fast_retire_acc_err_pc_update ),
  .iu_had_fast_retire_acc_err_pc_val     (iu_had_fast_retire_acc_err_pc_val    ),
  .iu_had_flush                          (iu_had_flush                         ),
  .iu_had_inst_bkpt_occur_vld            (iu_had_inst_bkpt_occur_vld           ),
  .iu_had_int_ack                        (iu_had_int_ack                       ),
  .iu_had_retire_with_had_int            (iu_had_retire_with_had_int           ),
  .iu_had_trace_occur_vld                (iu_had_trace_occur_vld               ),
  .iu_had_xx_bkpt_inst                   (iu_had_xx_bkpt_inst                  ),
  .iu_had_xx_data                        (iu_had_xx_data                       ),
  .iu_had_xx_data_vld                    (iu_had_xx_data_vld                   ),
  .iu_had_xx_dbg_ack                     (iu_had_xx_dbg_ack                    ),
  .iu_had_xx_mldst                       (iu_had_xx_mldst                      ),
  .iu_had_xx_retire                      (iu_had_xx_retire                     ),
  .iu_had_xx_retire_normal               (iu_had_xx_retire_normal              ),
  .iu_had_xx_retire_pc                   (iu_had_xx_retire_pc                  ),
  .iu_ifu_addr                           (iu_ifu_addr                          ),
  .iu_ifu_data_fetch                     (iu_ifu_data_fetch                    ),
  .iu_ifu_data_fetch_for_data            (iu_ifu_data_fetch_for_data           ),
  .iu_ifu_ex_stall                       (iu_ifu_ex_stall                      ),
  .iu_ifu_ex_stall_noinput               (iu_ifu_ex_stall_noinput              ),
  .iu_ifu_ex_vld                         (iu_ifu_ex_vld                        ),
  .iu_ifu_inst_fetch                     (iu_ifu_inst_fetch                    ),
  .iu_ifu_inst_fetch_for_data            (iu_ifu_inst_fetch_for_data           ),
  .iu_ifu_inst_fetch_mask                (iu_ifu_inst_fetch_mask               ),
  .iu_ifu_inst_fetch_without_dbg_disable (iu_ifu_inst_fetch_without_dbg_disable),
  .iu_ifu_kill_inst                      (iu_ifu_kill_inst                     ),
  .iu_ifu_lockup_mask                    (iu_ifu_lockup_mask                   ),
  .iu_ifu_lockup_on                      (iu_ifu_lockup_on                     ),
  .iu_ifu_lockup_req                     (iu_ifu_lockup_req                    ),
  .iu_ifu_lsu_inst                       (iu_ifu_lsu_inst                      ),
  .iu_ifu_reset_vld                      (iu_ifu_reset_vld                     ),
  .iu_ifu_security_violation             (iu_ifu_security_violation            ),
  .iu_ifu_wb_ldst                        (iu_ifu_wb_ldst                       ),
  .iu_ifu_wb_stall                       (iu_ifu_wb_stall                      ),
  .iu_lsu_adder_rst                      (iu_lsu_adder_rst                     ),
  .iu_lsu_base                           (iu_lsu_base                          ),
  .iu_lsu_data                           (iu_lsu_data                          ),
  .iu_lsu_ex_byte                        (iu_lsu_ex_byte                       ),
  .iu_lsu_ex_data_sel                    (iu_lsu_ex_data_sel                   ),
  .iu_lsu_ex_half                        (iu_lsu_ex_half                       ),
  .iu_lsu_ex_sel                         (iu_lsu_ex_sel                        ),
  .iu_lsu_ex_store                       (iu_lsu_ex_store                      ),
  .iu_lsu_ex_uns                         (iu_lsu_ex_uns                        ),
  .iu_lsu_imm_data                       (iu_lsu_imm_data                      ),
  .iu_lsu_imm_write_en                   (iu_lsu_imm_write_en                  ),
  .iu_lsu_offset                         (iu_lsu_offset                        ),
  .iu_lsu_oper_mux_en                    (iu_lsu_oper_mux_en                   ),
  .iu_lsu_rs2                            (iu_lsu_rs2                           ),
  .iu_lsu_stall_without_hready           (iu_lsu_stall_without_hready          ),
  .iu_lsu_wb_ldst                        (iu_lsu_wb_ldst                       ),
  .iu_lsu_wb_load                        (iu_lsu_wb_load                       ),
  .iu_lsu_wb_store                       (iu_lsu_wb_store                      ),
  .iu_pad_gpr_data                       (iu_pad_gpr_data                      ),
  .iu_pad_gpr_index                      (iu_pad_gpr_index                     ),
  .iu_pad_gpr_we                         (iu_pad_gpr_we                        ),
  .iu_pad_inst_retire                    (iu_pad_inst_retire                   ),
  .iu_pad_inst_split                     (iu_pad_inst_split                    ),
  .iu_pad_retire_pc                      (iu_pad_retire_pc                     ),
  .iu_sys_lp_wk_int                      (iu_sys_lp_wk_int                     ),
  .iu_sysio_lockup_on                    (iu_sysio_lockup_on                   ),
  .iu_yy_xx_dbgon                        (iu_yy_xx_dbgon                       ),
  .iu_yy_xx_expt_vec                     (iu_yy_xx_expt_vec                    ),
  .iu_yy_xx_flush                        (iu_yy_xx_flush                       ),
  .iu_yy_xx_int_hv                       (iu_yy_xx_int_hv                      ),
  .iu_yy_xx_int_il                       (iu_yy_xx_int_il                      ),
  .iu_yy_xx_int_pending_hv               (iu_yy_xx_int_pending_hv              ),
  .iu_yy_xx_int_pending_id               (iu_yy_xx_int_pending_id              ),
  .iu_yy_xx_int_pending_il               (iu_yy_xx_int_pending_il              ),
  .iu_yy_xx_int_pending_priv             (iu_yy_xx_int_pending_priv            ),
  .lsu_iu_addr                           (lsu_iu_addr                          ),
  .lsu_iu_addr_vld                       (lsu_iu_addr_vld                      ),
  .lsu_iu_alu_sel                        (lsu_iu_alu_sel                       ),
  .lsu_iu_data                           (lsu_iu_data                          ),
  .lsu_iu_data_vld                       (lsu_iu_data_vld                      ),
  .lsu_iu_expt_vec                       (lsu_iu_expt_vec                      ),
  .lsu_iu_expt_vld                       (lsu_iu_expt_vld                      ),
  .lsu_iu_fast_retire                    (lsu_iu_fast_retire                   ),
  .lsu_iu_mad_buf                        (lsu_iu_mad_buf                       ),
  .lsu_iu_req                            (lsu_iu_req                           ),
  .lsu_iu_stall                          (lsu_iu_stall                         ),
  .lsu_iu_stall_noinput                  (lsu_iu_stall_noinput                 ),
  .lsu_iu_store                          (lsu_iu_store                         ),
  .lsu_iu_wb_acc_err                     (lsu_iu_wb_acc_err                    ),
  .lsu_iu_wb_bstack_chk_fail             (lsu_iu_wb_bstack_chk_fail            ),
  .lsu_iu_wb_cmplt                       (lsu_iu_wb_cmplt                      ),
  .lsu_iu_wb_data_vld                    (lsu_iu_wb_data_vld                   ),
  .lsu_iu_wb_load_data                   (lsu_iu_wb_load_data                  ),
  .lsu_iu_wfd                            (lsu_iu_wfd                           ),
  .pad_yy_gate_clk_en_b                  (pad_yy_gate_clk_en_b                 ),
  .split_ifctrl_hs_stall                 (split_ifctrl_hs_stall                ),
  .split_ifctrl_hs_stall_part            (split_ifctrl_hs_stall_part           ),
  .sysio_iu_nmi_int                      (sysio_iu_nmi_int                     ),
  .sysio_iu_rst_addr                     (sysio_iu_rst_addr                    ),
  .sysio_iu_wk_event                     (sysio_iu_wk_event                    ),
  .vector_cp0_vec_err                    (vector_cp0_vec_err                   ),
  .vector_cp0_vec_err_epc                (vector_cp0_vec_err_epc               ),
  .vector_cp0_vec_succeed                (vector_cp0_vec_succeed               )
);

// &Force("output","iu_yy_xx_dbgon"); @55

//==========================================================
//  Instance LSU module 
//==========================================================
// &Instance("cr_lsu_top"); @60
cr_lsu_top  x_cr_lsu_top (
  .bmu_lsu_acc_err             (bmu_lsu_acc_err            ),
  .bmu_lsu_bstack_chk_fail     (bmu_lsu_bstack_chk_fail    ),
  .bmu_lsu_data                (bmu_lsu_data               ),
  .bmu_lsu_data_vld            (bmu_lsu_data_vld           ),
  .bmu_lsu_grnt                (bmu_lsu_grnt               ),
  .bmu_lsu_trans_cmplt         (bmu_lsu_trans_cmplt        ),
  .cp0_yy_be_v1                (cp0_yy_be_v1               ),
  .cp0_yy_be_v2                (cp0_yy_be_v2               ),
  .cp0_yy_clk_en               (cp0_yy_clk_en              ),
  .cp0_yy_machine_mode_aft_dbg (cp0_yy_machine_mode_aft_dbg),
  .cpurst_b                    (cpurst_b                   ),
  .forever_cpuclk              (forever_cpuclk             ),
  .iu_lsu_adder_rst            (iu_lsu_adder_rst           ),
  .iu_lsu_base                 (iu_lsu_base                ),
  .iu_lsu_data                 (iu_lsu_data                ),
  .iu_lsu_ex_byte              (iu_lsu_ex_byte             ),
  .iu_lsu_ex_data_sel          (iu_lsu_ex_data_sel         ),
  .iu_lsu_ex_half              (iu_lsu_ex_half             ),
  .iu_lsu_ex_sel               (iu_lsu_ex_sel              ),
  .iu_lsu_ex_store             (iu_lsu_ex_store            ),
  .iu_lsu_ex_uns               (iu_lsu_ex_uns              ),
  .iu_lsu_imm_data             (iu_lsu_imm_data            ),
  .iu_lsu_imm_write_en         (iu_lsu_imm_write_en        ),
  .iu_lsu_offset               (iu_lsu_offset              ),
  .iu_lsu_oper_mux_en          (iu_lsu_oper_mux_en         ),
  .iu_lsu_rs2                  (iu_lsu_rs2                 ),
  .iu_lsu_stall_without_hready (iu_lsu_stall_without_hready),
  .iu_lsu_wb_ldst              (iu_lsu_wb_ldst             ),
  .iu_lsu_wb_load              (iu_lsu_wb_load             ),
  .iu_lsu_wb_store             (iu_lsu_wb_store            ),
  .iu_yy_xx_flush              (iu_yy_xx_flush             ),
  .lsu_bmu_addr                (lsu_bmu_addr               ),
  .lsu_bmu_addr_check_fail     (lsu_bmu_addr_check_fail    ),
  .lsu_bmu_idle                (lsu_bmu_idle               ),
  .lsu_bmu_prot                (lsu_bmu_prot               ),
  .lsu_bmu_req                 (lsu_bmu_req                ),
  .lsu_bmu_req_without_cmplt   (lsu_bmu_req_without_cmplt  ),
  .lsu_bmu_sg_chk_fail         (lsu_bmu_sg_chk_fail        ),
  .lsu_bmu_size                (lsu_bmu_size               ),
  .lsu_bmu_store_error         (lsu_bmu_store_error        ),
  .lsu_bmu_wdata               (lsu_bmu_wdata              ),
  .lsu_bmu_wfd1                (lsu_bmu_wfd1               ),
  .lsu_bmu_write               (lsu_bmu_write              ),
  .lsu_had_addr                (lsu_had_addr               ),
  .lsu_had_addr_vld            (lsu_had_addr_vld           ),
  .lsu_had_ex_cmplt            (lsu_had_ex_cmplt           ),
  .lsu_had_st                  (lsu_had_st                 ),
  .lsu_iu_addr                 (lsu_iu_addr                ),
  .lsu_iu_addr_vld             (lsu_iu_addr_vld            ),
  .lsu_iu_alu_sel              (lsu_iu_alu_sel             ),
  .lsu_iu_data                 (lsu_iu_data                ),
  .lsu_iu_data_vld             (lsu_iu_data_vld            ),
  .lsu_iu_expt_vec             (lsu_iu_expt_vec            ),
  .lsu_iu_expt_vld             (lsu_iu_expt_vld            ),
  .lsu_iu_fast_retire          (lsu_iu_fast_retire         ),
  .lsu_iu_mad_buf              (lsu_iu_mad_buf             ),
  .lsu_iu_req                  (lsu_iu_req                 ),
  .lsu_iu_stall                (lsu_iu_stall               ),
  .lsu_iu_stall_noinput        (lsu_iu_stall_noinput       ),
  .lsu_iu_store                (lsu_iu_store               ),
  .lsu_iu_wb_acc_err           (lsu_iu_wb_acc_err          ),
  .lsu_iu_wb_bstack_chk_fail   (lsu_iu_wb_bstack_chk_fail  ),
  .lsu_iu_wb_cmplt             (lsu_iu_wb_cmplt            ),
  .lsu_iu_wb_data_vld          (lsu_iu_wb_data_vld         ),
  .lsu_iu_wb_load_data         (lsu_iu_wb_load_data        ),
  .lsu_iu_wfd                  (lsu_iu_wfd                 ),
  .pad_yy_gate_clk_en_b        (pad_yy_gate_clk_en_b       ),
  .pmp_lsu_acc_scu             (pmp_lsu_acc_scu            ),
  .sysmap_lsu_acc_ca           (sysmap_lsu_acc_ca          )
);


//==========================================================
//  Instance CP0 sub module 
//==========================================================
// &Instance("cr_cp0_top"); @65
cr_cp0_top  x_cr_cp0_top (
  .cache_cp0_lpmd_ack             (cache_cp0_lpmd_ack            ),
  .cache_cp0_srst_ack             (cache_cp0_srst_ack            ),
  .clic_cpu_int_id                (clic_cpu_int_id               ),
  .cp0_cache_lpmd_req             (cp0_cache_lpmd_req            ),
  .cp0_cache_srst_req             (cp0_cache_srst_req            ),
  .cp0_had_cpuid_idx0             (cp0_had_cpuid_idx0            ),
  .cp0_had_int_exit               (cp0_had_int_exit              ),
  .cp0_had_lpmd_b                 (cp0_had_lpmd_b                ),
  .cp0_had_mcause_data            (cp0_had_mcause_data           ),
  .cp0_ifu_in_lpmd                (cp0_ifu_in_lpmd               ),
  .cp0_ifu_lpmd_req               (cp0_ifu_lpmd_req              ),
  .cp0_ifu_rst_inv_done           (cp0_ifu_rst_inv_done          ),
  .cp0_ifu_srst_mask              (cp0_ifu_srst_mask             ),
  .cp0_ifu_srst_req               (cp0_ifu_srst_req              ),
  .cp0_iu_cache_inv_done          (cp0_iu_cache_inv_done         ),
  .cp0_iu_cskyisaee               (cp0_iu_cskyisaee              ),
  .cp0_iu_data                    (cp0_iu_data                   ),
  .cp0_iu_data_vld                (cp0_iu_data_vld               ),
  .cp0_iu_dbg_disable_for_tee     (cp0_iu_dbg_disable_for_tee    ),
  .cp0_iu_epc_for_chgflw          (cp0_iu_epc_for_chgflw         ),
  .cp0_iu_expt_vec                (cp0_iu_expt_vec               ),
  .cp0_iu_expt_vld                (cp0_iu_expt_vld               ),
  .cp0_iu_flush                   (cp0_iu_flush                  ),
  .cp0_iu_flush_chgflw_vld        (cp0_iu_flush_chgflw_vld       ),
  .cp0_iu_il                      (cp0_iu_il                     ),
  .cp0_iu_in_expt                 (cp0_iu_in_expt                ),
  .cp0_iu_in_nmi                  (cp0_iu_in_nmi                 ),
  .cp0_iu_inst_mret               (cp0_iu_inst_mret              ),
  .cp0_iu_meie                    (cp0_iu_meie                   ),
  .cp0_iu_mie_for_int             (cp0_iu_mie_for_int            ),
  .cp0_iu_mret                    (cp0_iu_mret                   ),
  .cp0_iu_req                     (cp0_iu_req                    ),
  .cp0_iu_rte_chgflw_vld          (cp0_iu_rte_chgflw_vld         ),
  .cp0_iu_rte_chgflw_vld_for_data (cp0_iu_rte_chgflw_vld_for_data),
  .cp0_iu_stall                   (cp0_iu_stall                  ),
  .cp0_iu_stall_noinput           (cp0_iu_stall_noinput          ),
  .cp0_iu_vbr                     (cp0_iu_vbr                    ),
  .cp0_iu_vec_mode                (cp0_iu_vec_mode               ),
  .cp0_iu_wfe_en                  (cp0_iu_wfe_en                 ),
  .cp0_pad_mcause                 (cp0_pad_mcause                ),
  .cp0_pad_mintstatus             (cp0_pad_mintstatus            ),
  .cp0_pad_mstatus                (cp0_pad_mstatus               ),
  .cp0_pmp_csr_sel                (cp0_pmp_csr_sel               ),
  .cp0_pmp_csr_wen                (cp0_pmp_csr_wen               ),
  .cp0_pmp_mstatus_mpp            (cp0_pmp_mstatus_mpp           ),
  .cp0_pmp_mstatus_mprv           (cp0_pmp_mstatus_mprv          ),
  .cp0_pmp_updt_data              (cp0_pmp_updt_data             ),
  .cp0_sysio_ipend_b              (cp0_sysio_ipend_b             ),
  .cp0_sysio_lpmd_b               (cp0_sysio_lpmd_b              ),
  .cp0_sysio_srst                 (cp0_sysio_srst                ),
  .cp0_vector_vec_err_vbr         (cp0_vector_vec_err_vbr        ),
  .cp0_yy_be_v1                   (cp0_yy_be_v1                  ),
  .cp0_yy_be_v2                   (cp0_yy_be_v2                  ),
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .cp0_yy_machine_mode_aft_dbg    (cp0_yy_machine_mode_aft_dbg   ),
  .cp0_yy_priv_mode               (cp0_yy_priv_mode              ),
  .cpu_clic_curid                 (cpu_clic_curid                ),
  .cpu_clic_int_exit              (cpu_clic_int_exit             ),
  .cpurst_b                       (cpurst_b                      ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .had_iu_force_dbg_en            (had_iu_force_dbg_en           ),
  .had_yy_xx_dbg                  (had_yy_xx_dbg                 ),
  .ifu_cp0_lpmd_ack               (ifu_cp0_lpmd_ack              ),
  .ifu_cp0_rst_inv_req            (ifu_cp0_rst_inv_req           ),
  .ifu_cp0_srst_ack               (ifu_cp0_srst_ack              ),
  .iu_cp0_ecall                   (iu_cp0_ecall                  ),
  .iu_cp0_epc                     (iu_cp0_epc                    ),
  .iu_cp0_epc_update              (iu_cp0_epc_update             ),
  .iu_cp0_ex_csrrc                (iu_cp0_ex_csrrc               ),
  .iu_cp0_ex_csrrci               (iu_cp0_ex_csrrci              ),
  .iu_cp0_ex_csrrs                (iu_cp0_ex_csrrs               ),
  .iu_cp0_ex_csrrsi               (iu_cp0_ex_csrrsi              ),
  .iu_cp0_ex_csrrw                (iu_cp0_ex_csrrw               ),
  .iu_cp0_ex_csrrwi               (iu_cp0_ex_csrrwi              ),
  .iu_cp0_ex_data_sel             (iu_cp0_ex_data_sel            ),
  .iu_cp0_ex_func3                (iu_cp0_ex_func3               ),
  .iu_cp0_ex_mret                 (iu_cp0_ex_mret                ),
  .iu_cp0_ex_rd_reg               (iu_cp0_ex_rd_reg              ),
  .iu_cp0_ex_rs1_reg              (iu_cp0_ex_rs1_reg             ),
  .iu_cp0_ex_sel                  (iu_cp0_ex_sel                 ),
  .iu_cp0_ex_wfi                  (iu_cp0_ex_wfi                 ),
  .iu_cp0_expt_tval               (iu_cp0_expt_tval              ),
  .iu_cp0_expt_vld                (iu_cp0_expt_vld               ),
  .iu_cp0_imm                     (iu_cp0_imm                    ),
  .iu_cp0_int_vld                 (iu_cp0_int_vld                ),
  .iu_cp0_lockup_clr              (iu_cp0_lockup_clr             ),
  .iu_cp0_lockup_vld              (iu_cp0_lockup_vld             ),
  .iu_cp0_lp_wk_int               (iu_cp0_lp_wk_int              ),
  .iu_cp0_mtval_updt_vld          (iu_cp0_mtval_updt_vld         ),
  .iu_cp0_nmi_vld                 (iu_cp0_nmi_vld                ),
  .iu_cp0_nt_int_pending_vld      (iu_cp0_nt_int_pending_vld     ),
  .iu_cp0_oper_mux_en             (iu_cp0_oper_mux_en            ),
  .iu_cp0_rs1                     (iu_cp0_rs1                    ),
  .iu_cp0_syc_rst_b               (iu_cp0_syc_rst_b              ),
  .iu_yy_xx_dbgon                 (iu_yy_xx_dbgon                ),
  .iu_yy_xx_expt_vec              (iu_yy_xx_expt_vec             ),
  .iu_yy_xx_flush                 (iu_yy_xx_flush                ),
  .iu_yy_xx_int_hv                (iu_yy_xx_int_hv               ),
  .iu_yy_xx_int_il                (iu_yy_xx_int_il               ),
  .iu_yy_xx_int_pending_hv        (iu_yy_xx_int_pending_hv       ),
  .iu_yy_xx_int_pending_id        (iu_yy_xx_int_pending_id       ),
  .iu_yy_xx_int_pending_il        (iu_yy_xx_int_pending_il       ),
  .iu_yy_xx_int_pending_priv      (iu_yy_xx_int_pending_priv     ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          ),
  .pmp_cp0_data                   (pmp_cp0_data                  ),
  .sysio_cp0_bigend               (sysio_cp0_bigend              ),
  .sysio_cp0_clkratio             (sysio_cp0_clkratio            ),
  .sysio_cp0_endian_v2            (sysio_cp0_endian_v2           ),
  .sysio_cp0_rst_addr             (sysio_cp0_rst_addr            ),
  .sysio_cp0_sys_view_lpmd_b      (sysio_cp0_sys_view_lpmd_b     ),
  .tcip_cp0_clic_base             (tcip_cp0_clic_base            ),
  .vector_cp0_vec_err             (vector_cp0_vec_err            ),
  .vector_cp0_vec_err_epc         (vector_cp0_vec_err_epc        ),
  .vector_cp0_vec_succeed         (vector_cp0_vec_succeed        )
);

// //&Force("output","cp0_yy_supv_mode_aft_dbg"); @66
// //&Force("output","cp0_yy_supv_mode"); @67
// &Force("output","cp0_yy_machine_mode_aft_dbg"); @68
// &Force("output","cp0_yy_secu_mode_aft_dbg"); @71
// &Force("output","cp0_yy_be_v1"); @75
// &Force("output","cp0_yy_be_v1"); @78
// &Force("output","cp0_yy_be_v1"); @81

// &Force("output","cp0_yy_clk_en"); @85
// &Force("output","cp0_yy_clk_en"); @88
// &Force("output","cp0_yy_clk_en"); @91
// &Force("output","cp0_yy_clk_en"); @94
// &Force("output","cp0_yy_clk_en"); @97
// &Force("output","cp0_yy_clk_en"); @100
// &Force("output","cp0_yy_clk_en"); @103



// &Force("output","cp0_yy_be_v2"); @116
// &Force("output","cp0_yy_priv_mode");  &Force("output","cp0_yy_priv_mode",1,0); @117
// &Force("output","cp0_yy_be_v1"); @120
// &Force("output","cp0_yy_be_v2"); @121
// &ModuleEnd; @123
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_core_top(
  biu_pad_haddr,
  biu_pad_hburst,
  biu_pad_hprot,
  biu_pad_hsize,
  biu_pad_htrans,
  biu_pad_hwdata,
  biu_pad_hwrite,
  bmu_tcipif_dbus_acc_deny,
  bmu_tcipif_dbus_addr,
  bmu_tcipif_dbus_chk_fail,
  bmu_tcipif_dbus_req,
  bmu_tcipif_dbus_size,
  bmu_tcipif_dbus_supv_mode,
  bmu_tcipif_dbus_wdata,
  bmu_tcipif_dbus_write,
  bmu_tcipif_ibus_acc_deny,
  bmu_tcipif_ibus_addr,
  bmu_tcipif_ibus_req,
  bmu_tcipif_ibus_write,
  clic_cpu_int_hv,
  clic_cpu_int_id,
  clic_cpu_int_il,
  clic_cpu_int_priv,
  clint_cpu_me_int,
  clk_en,
  cp0_had_cpuid_idx0,
  cp0_had_int_exit,
  cp0_had_lpmd_b,
  cp0_had_mcause_data,
  cp0_pad_mcause,
  cp0_pad_mintstatus,
  cp0_pad_mstatus,
  cp0_yy_be_v2,
  cp0_yy_priv_mode,
  cpu_clic_curid,
  cpu_clic_int_exit,
  cpu_pad_dfs_ack,
  cpu_pad_lockup,
  cpu_pad_soft_rst,
  cpurst_b,
  forever_cpuclk,
  had_core_dbg_mode_req,
  had_core_exit_dbg,
  had_idu_wbbr_data,
  had_idu_wbbr_vld,
  had_ifu_inst_bkpt_dbq_req,
  had_ifu_inst_bkpt_dbqexp_req,
  had_ifu_ir,
  had_ifu_ir_vld,
  had_iu_bkpt_trace_en,
  had_iu_dr_set_req,
  had_iu_force_dbg_en,
  had_iu_int_vld,
  had_iu_mbkpt_fsm_index_mbee,
  had_iu_mem_bkpt_exp_req,
  had_iu_mem_bkpt_mask,
  had_iu_mem_bkpt_req,
  had_iu_pc,
  had_iu_rte_pc_sel,
  had_iu_trace_req,
  had_iu_trace_req_for_dbg_disable,
  had_iu_xx_fdb,
  had_iu_xx_jdbreq,
  had_yy_xx_dbg,
  had_yy_xx_dp_index_mbee,
  iahbl_pad_haddr,
  iahbl_pad_hburst,
  iahbl_pad_hprot,
  iahbl_pad_hsize,
  iahbl_pad_htrans,
  iahbl_pad_hwdata,
  iahbl_pad_hwrite,
  ifu_had_chg_flw_inst,
  ifu_had_fetch_expt_vld,
  ifu_had_inst_dbg_disable,
  ifu_had_match_pc,
  ifu_had_split_first,
  iu_had_adr_dbg_ack,
  iu_had_chgflw_dst_pc,
  iu_had_chgflw_vld,
  iu_had_data_bkpt_occur_vld,
  iu_had_dbg_disable_for_tee,
  iu_had_dr_dbg_ack,
  iu_had_expt_vld,
  iu_had_fast_retire_acc_err_pc_update,
  iu_had_fast_retire_acc_err_pc_val,
  iu_had_flush,
  iu_had_inst_bkpt_occur_vld,
  iu_had_int_ack,
  iu_had_retire_with_had_int,
  iu_had_trace_occur_vld,
  iu_had_xx_bkpt_inst,
  iu_had_xx_data,
  iu_had_xx_data_vld,
  iu_had_xx_dbg_ack,
  iu_had_xx_mldst,
  iu_had_xx_retire,
  iu_had_xx_retire_normal,
  iu_had_xx_retire_pc,
  iu_pad_gpr_data,
  iu_pad_gpr_index,
  iu_pad_gpr_we,
  iu_pad_inst_retire,
  iu_pad_inst_split,
  iu_pad_retire_pc,
  iu_yy_xx_dbgon,
  lsu_had_addr,
  lsu_had_addr_vld,
  lsu_had_ex_cmplt,
  lsu_had_st,
  pad_biu_hrdata,
  pad_biu_hready,
  pad_biu_hresp,
  pad_bmu_iahbl_base,
  pad_bmu_iahbl_mask,
  pad_cpu_dfs_req,
  pad_cpu_ext_int_b,
  pad_cpu_nmi,
  pad_cpu_rst_addr,
  pad_cpu_sys_cnt,
  pad_cpu_wakeup_event,
  pad_iahbl_hrdata,
  pad_iahbl_hready,
  pad_iahbl_hresp,
  pad_sysio_dbgrq_b,
  pad_yy_gate_clk_en_b,
  pwrm_cpu_bus_peak_power_limit_en,
  sysio_clint_me_int,
  sysio_clint_mtime,
  sysio_had_sdb_req_b,
  sysio_pad_lpmd_b,
  tcip_cp0_clic_base,
  tcipif_bmu_dbus_acc_err,
  tcipif_bmu_dbus_data,
  tcipif_bmu_dbus_data_vld,
  tcipif_bmu_dbus_grnt,
  tcipif_bmu_dbus_trans_cmplt,
  tcipif_bmu_ibus_acc_err,
  tcipif_bmu_ibus_data,
  tcipif_bmu_ibus_data_vld,
  tcipif_bmu_ibus_grnt,
  tcipif_bmu_ibus_trans_cmplt
);

// &Ports; @26
input           clic_cpu_int_hv;                     
input   [11:0]  clic_cpu_int_id;                     
input   [7 :0]  clic_cpu_int_il;                     
input   [1 :0]  clic_cpu_int_priv;                   
input           clint_cpu_me_int;                    
input           clk_en;                              
input           cpurst_b;                            
input           forever_cpuclk;                      
input           had_core_dbg_mode_req;               
input           had_core_exit_dbg;                   
input   [31:0]  had_idu_wbbr_data;                   
input           had_idu_wbbr_vld;                    
input           had_ifu_inst_bkpt_dbq_req;           
input           had_ifu_inst_bkpt_dbqexp_req;        
input   [31:0]  had_ifu_ir;                          
input           had_ifu_ir_vld;                      
input           had_iu_bkpt_trace_en;                
input           had_iu_dr_set_req;                   
input           had_iu_force_dbg_en;                 
input           had_iu_int_vld;                      
input           had_iu_mbkpt_fsm_index_mbee;         
input           had_iu_mem_bkpt_exp_req;             
input           had_iu_mem_bkpt_mask;                
input           had_iu_mem_bkpt_req;                 
input   [30:0]  had_iu_pc;                           
input           had_iu_rte_pc_sel;                   
input           had_iu_trace_req;                    
input           had_iu_trace_req_for_dbg_disable;    
input           had_iu_xx_fdb;                       
input           had_iu_xx_jdbreq;                    
input           had_yy_xx_dbg;                       
input           had_yy_xx_dp_index_mbee;             
input   [31:0]  pad_biu_hrdata;                      
input           pad_biu_hready;                      
input           pad_biu_hresp;                       
input   [11:0]  pad_bmu_iahbl_base;                  
input   [11:0]  pad_bmu_iahbl_mask;                  
input           pad_cpu_dfs_req;                     
input           pad_cpu_ext_int_b;                   
input           pad_cpu_nmi;                         
input   [31:0]  pad_cpu_rst_addr;                    
input   [63:0]  pad_cpu_sys_cnt;                     
input           pad_cpu_wakeup_event;                
input   [31:0]  pad_iahbl_hrdata;                    
input           pad_iahbl_hready;                    
input           pad_iahbl_hresp;                     
input           pad_sysio_dbgrq_b;                   
input           pad_yy_gate_clk_en_b;                
input           pwrm_cpu_bus_peak_power_limit_en;    
input   [31:0]  tcip_cp0_clic_base;                  
input           tcipif_bmu_dbus_acc_err;             
input   [31:0]  tcipif_bmu_dbus_data;                
input           tcipif_bmu_dbus_data_vld;            
input           tcipif_bmu_dbus_grnt;                
input           tcipif_bmu_dbus_trans_cmplt;         
input           tcipif_bmu_ibus_acc_err;             
input   [31:0]  tcipif_bmu_ibus_data;                
input           tcipif_bmu_ibus_data_vld;            
input           tcipif_bmu_ibus_grnt;                
input           tcipif_bmu_ibus_trans_cmplt;         
output  [31:0]  biu_pad_haddr;                       
output  [2 :0]  biu_pad_hburst;                      
output  [3 :0]  biu_pad_hprot;                       
output  [2 :0]  biu_pad_hsize;                       
output  [1 :0]  biu_pad_htrans;                      
output  [31:0]  biu_pad_hwdata;                      
output          biu_pad_hwrite;                      
output          bmu_tcipif_dbus_acc_deny;            
output  [31:0]  bmu_tcipif_dbus_addr;                
output          bmu_tcipif_dbus_chk_fail;            
output          bmu_tcipif_dbus_req;                 
output  [1 :0]  bmu_tcipif_dbus_size;                
output          bmu_tcipif_dbus_supv_mode;           
output  [31:0]  bmu_tcipif_dbus_wdata;               
output          bmu_tcipif_dbus_write;               
output          bmu_tcipif_ibus_acc_deny;            
output  [31:0]  bmu_tcipif_ibus_addr;                
output          bmu_tcipif_ibus_req;                 
output          bmu_tcipif_ibus_write;               
output  [31:0]  cp0_had_cpuid_idx0;                  
output          cp0_had_int_exit;                    
output  [1 :0]  cp0_had_lpmd_b;                      
output  [31:0]  cp0_had_mcause_data;                 
output  [31:0]  cp0_pad_mcause;                      
output  [31:0]  cp0_pad_mintstatus;                  
output  [31:0]  cp0_pad_mstatus;                     
output          cp0_yy_be_v2;                        
output  [1 :0]  cp0_yy_priv_mode;                    
output  [11:0]  cpu_clic_curid;                      
output          cpu_clic_int_exit;                   
output          cpu_pad_dfs_ack;                     
output          cpu_pad_lockup;                      
output  [1 :0]  cpu_pad_soft_rst;                    
output  [31:0]  iahbl_pad_haddr;                     
output  [2 :0]  iahbl_pad_hburst;                    
output  [3 :0]  iahbl_pad_hprot;                     
output  [2 :0]  iahbl_pad_hsize;                     
output  [1 :0]  iahbl_pad_htrans;                    
output  [31:0]  iahbl_pad_hwdata;                    
output          iahbl_pad_hwrite;                    
output          ifu_had_chg_flw_inst;                
output          ifu_had_fetch_expt_vld;              
output          ifu_had_inst_dbg_disable;            
output  [31:0]  ifu_had_match_pc;                    
output          ifu_had_split_first;                 
output          iu_had_adr_dbg_ack;                  
output  [31:0]  iu_had_chgflw_dst_pc;                
output          iu_had_chgflw_vld;                   
output          iu_had_data_bkpt_occur_vld;          
output          iu_had_dbg_disable_for_tee;          
output          iu_had_dr_dbg_ack;                   
output          iu_had_expt_vld;                     
output          iu_had_fast_retire_acc_err_pc_update; 
output  [30:0]  iu_had_fast_retire_acc_err_pc_val;   
output          iu_had_flush;                        
output          iu_had_inst_bkpt_occur_vld;          
output          iu_had_int_ack;                      
output          iu_had_retire_with_had_int;          
output          iu_had_trace_occur_vld;              
output          iu_had_xx_bkpt_inst;                 
output  [31:0]  iu_had_xx_data;                      
output          iu_had_xx_data_vld;                  
output          iu_had_xx_dbg_ack;                   
output          iu_had_xx_mldst;                     
output          iu_had_xx_retire;                    
output          iu_had_xx_retire_normal;             
output  [31:0]  iu_had_xx_retire_pc;                 
output  [31:0]  iu_pad_gpr_data;                     
output  [4 :0]  iu_pad_gpr_index;                    
output          iu_pad_gpr_we;                       
output          iu_pad_inst_retire;                  
output          iu_pad_inst_split;                   
output  [31:0]  iu_pad_retire_pc;                    
output          iu_yy_xx_dbgon;                      
output  [31:0]  lsu_had_addr;                        
output          lsu_had_addr_vld;                    
output          lsu_had_ex_cmplt;                    
output          lsu_had_st;                          
output          sysio_clint_me_int;                  
output  [63:0]  sysio_clint_mtime;                   
output          sysio_had_sdb_req_b;                 
output  [1 :0]  sysio_pad_lpmd_b;                    

// &Regs; @27
reg             pad_cpu_halt_ff1;                    
reg             pad_cpu_halt_ff2;                    

// &Wires; @28
wire            biu_bmu_dbus_acc_err;                
wire    [31:0]  biu_bmu_dbus_data;                   
wire            biu_bmu_dbus_data_vld;               
wire            biu_bmu_dbus_grnt;                   
wire            biu_bmu_dbus_trans_cmplt;            
wire            biu_bmu_ibus_acc_err;                
wire    [31:0]  biu_bmu_ibus_data;                   
wire            biu_bmu_ibus_data_vld;               
wire            biu_bmu_ibus_grnt;                   
wire            biu_bmu_ibus_trans_cmplt;            
wire    [31:0]  biu_pad_haddr;                       
wire    [2 :0]  biu_pad_hburst;                      
wire    [3 :0]  biu_pad_hprot;                       
wire    [2 :0]  biu_pad_hsize;                       
wire    [1 :0]  biu_pad_htrans;                      
wire    [31:0]  biu_pad_hwdata;                      
wire            biu_pad_hwrite;                      
wire            bmu_biu_dbus_acc_deny;               
wire    [31:0]  bmu_biu_dbus_addr;                   
wire            bmu_biu_dbus_chk_fail;               
wire    [3 :0]  bmu_biu_dbus_prot;                   
wire            bmu_biu_dbus_req;                    
wire            bmu_biu_dbus_req_without_cmplt;      
wire    [1 :0]  bmu_biu_dbus_size;                   
wire    [31:0]  bmu_biu_dbus_wdata;                  
wire            bmu_biu_dbus_write;                  
wire            bmu_biu_ibus_acc_deny;               
wire    [31:0]  bmu_biu_ibus_addr;                   
wire            bmu_biu_ibus_hit;                    
wire    [3 :0]  bmu_biu_ibus_prot;                   
wire            bmu_biu_ibus_req;                    
wire            bmu_biu_ibus_req_no_hit;             
wire    [1 :0]  bmu_biu_ibus_size;                   
wire            bmu_biu_ibus_vec_redirect;           
wire            bmu_iahbl_dbus_acc_deny;             
wire    [31:0]  bmu_iahbl_dbus_addr;                 
wire            bmu_iahbl_dbus_chk_fail;             
wire    [3 :0]  bmu_iahbl_dbus_prot;                 
wire            bmu_iahbl_dbus_req;                  
wire            bmu_iahbl_dbus_req_without_cmplt;    
wire    [1 :0]  bmu_iahbl_dbus_size;                 
wire    [31:0]  bmu_iahbl_dbus_wdata;                
wire            bmu_iahbl_dbus_write;                
wire            bmu_iahbl_ibus_acc_deny;             
wire    [31:0]  bmu_iahbl_ibus_addr;                 
wire            bmu_iahbl_ibus_hit;                  
wire    [3 :0]  bmu_iahbl_ibus_prot;                 
wire            bmu_iahbl_ibus_req;                  
wire            bmu_iahbl_ibus_req_no_hit;           
wire    [1 :0]  bmu_iahbl_ibus_size;                 
wire            bmu_iahbl_ibus_vec_redirect;         
wire            bmu_lsu_acc_err;                     
wire            bmu_lsu_bstack_chk_fail;             
wire    [31:0]  bmu_lsu_data;                        
wire            bmu_lsu_data_vld;                    
wire            bmu_lsu_grnt;                        
wire            bmu_lsu_trans_cmplt;                 
wire            bmu_tcipif_dbus_acc_deny;            
wire    [31:0]  bmu_tcipif_dbus_addr;                
wire            bmu_tcipif_dbus_chk_fail;            
wire            bmu_tcipif_dbus_req;                 
wire    [1 :0]  bmu_tcipif_dbus_size;                
wire            bmu_tcipif_dbus_supv_mode;           
wire    [31:0]  bmu_tcipif_dbus_wdata;               
wire            bmu_tcipif_dbus_write;               
wire            bmu_tcipif_ibus_acc_deny;            
wire    [31:0]  bmu_tcipif_ibus_addr;                
wire            bmu_tcipif_ibus_req;                 
wire            bmu_tcipif_ibus_write;               
wire            bmu_xx_ibus_acc_err;                 
wire    [31:0]  bmu_xx_ibus_data;                    
wire            bmu_xx_ibus_data_vld;                
wire            bmu_xx_ibus_grnt;                    
wire            bmu_xx_ibus_trans_cmplt;             
wire            cache_cp0_lpmd_ack;                  
wire            cache_cp0_srst_ack;                  
wire            cache_iu_lockup_ack;                 
wire            clic_cpu_int_hv;                     
wire    [11:0]  clic_cpu_int_id;                     
wire    [7 :0]  clic_cpu_int_il;                     
wire    [1 :0]  clic_cpu_int_priv;                   
wire            clint_cpu_me_int;                    
wire            clk_en;                              
wire            cp0_cache_lpmd_req;                  
wire            cp0_cache_srst_req;                  
wire    [31:0]  cp0_had_cpuid_idx0;                  
wire            cp0_had_int_exit;                    
wire    [1 :0]  cp0_had_lpmd_b;                      
wire    [31:0]  cp0_had_mcause_data;                 
wire    [31:0]  cp0_pad_mcause;                      
wire    [31:0]  cp0_pad_mintstatus;                  
wire    [31:0]  cp0_pad_mstatus;                     
wire    [11:0]  cp0_pmp_csr_sel;                     
wire            cp0_pmp_csr_wen;                     
wire    [1 :0]  cp0_pmp_mstatus_mpp;                 
wire            cp0_pmp_mstatus_mprv;                
wire    [31:0]  cp0_pmp_updt_data;                   
wire            cp0_sysio_ipend_b;                   
wire    [1 :0]  cp0_sysio_lpmd_b;                    
wire    [1 :0]  cp0_sysio_srst;                      
wire            cp0_yy_be_v2;                        
wire            cp0_yy_clk_en;                       
wire            cp0_yy_machine_mode_aft_dbg;         
wire    [1 :0]  cp0_yy_priv_mode;                    
wire    [11:0]  cpu_clic_curid;                      
wire            cpu_clic_int_exit;                   
wire            cpu_pad_dfs_ack;                     
wire            cpu_pad_lockup;                      
wire    [1 :0]  cpu_pad_soft_rst;                    
wire            cpurst_b;                            
wire            dahblif_other_mask;                  
wire            dbus_idle;                           
wire            forever_cpuclk;                      
wire            had_core_dbg_mode_req;               
wire            had_core_exit_dbg;                   
wire    [31:0]  had_idu_wbbr_data;                   
wire            had_idu_wbbr_vld;                    
wire            had_ifu_inst_bkpt_dbq_req;           
wire            had_ifu_inst_bkpt_dbqexp_req;        
wire    [31:0]  had_ifu_ir;                          
wire            had_ifu_ir_vld;                      
wire            had_iu_bkpt_trace_en;                
wire            had_iu_dr_set_req;                   
wire            had_iu_force_dbg_en;                 
wire            had_iu_int_vld;                      
wire            had_iu_mbkpt_fsm_index_mbee;         
wire            had_iu_mem_bkpt_exp_req;             
wire            had_iu_mem_bkpt_mask;                
wire            had_iu_mem_bkpt_req;                 
wire    [30:0]  had_iu_pc;                           
wire            had_iu_rte_pc_sel;                   
wire            had_iu_trace_req;                    
wire            had_iu_trace_req_for_dbg_disable;    
wire            had_iu_xx_fdb;                       
wire            had_iu_xx_jdbreq;                    
wire            had_yy_xx_dbg;                       
wire            had_yy_xx_dp_index_mbee;             
wire            iahbl_bmu_dbus_acc_err;              
wire    [31:0]  iahbl_bmu_dbus_data;                 
wire            iahbl_bmu_dbus_data_vld;             
wire            iahbl_bmu_dbus_grnt;                 
wire            iahbl_bmu_dbus_trans_cmplt;          
wire            iahbl_bmu_ibus_acc_err;              
wire    [31:0]  iahbl_bmu_ibus_data;                 
wire            iahbl_bmu_ibus_data_vld;             
wire            iahbl_bmu_ibus_grnt;                 
wire            iahbl_bmu_ibus_trans_cmplt;          
wire    [31:0]  iahbl_pad_haddr;                     
wire    [2 :0]  iahbl_pad_hburst;                    
wire    [3 :0]  iahbl_pad_hprot;                     
wire    [2 :0]  iahbl_pad_hsize;                     
wire    [1 :0]  iahbl_pad_htrans;                    
wire    [31:0]  iahbl_pad_hwdata;                    
wire            iahbl_pad_hwrite;                    
wire            iahblif_other_mask;                  
wire            ibus_idle;                           
wire    [31:0]  ifu_bmu_addr;                        
wire            ifu_bmu_idle;                        
wire    [3 :0]  ifu_bmu_prot;                        
wire            ifu_bmu_req;                         
wire            ifu_bmu_wfd1;                        
wire            ifu_had_chg_flw_inst;                
wire            ifu_had_fetch_expt_vld;              
wire            ifu_had_inst_dbg_disable;            
wire    [31:0]  ifu_had_match_pc;                    
wire            ifu_had_split_first;                 
wire            iu_bmu_vec_redirect;                 
wire            iu_cache_lockup_req;                 
wire            iu_had_adr_dbg_ack;                  
wire    [31:0]  iu_had_chgflw_dst_pc;                
wire            iu_had_chgflw_vld;                   
wire            iu_had_data_bkpt_occur_vld;          
wire            iu_had_dbg_disable_for_tee;          
wire            iu_had_dr_dbg_ack;                   
wire            iu_had_expt_vld;                     
wire            iu_had_fast_retire_acc_err_pc_update; 
wire    [30:0]  iu_had_fast_retire_acc_err_pc_val;   
wire            iu_had_flush;                        
wire            iu_had_inst_bkpt_occur_vld;          
wire            iu_had_int_ack;                      
wire            iu_had_retire_with_had_int;          
wire            iu_had_trace_occur_vld;              
wire            iu_had_xx_bkpt_inst;                 
wire    [31:0]  iu_had_xx_data;                      
wire            iu_had_xx_data_vld;                  
wire            iu_had_xx_dbg_ack;                   
wire            iu_had_xx_mldst;                     
wire            iu_had_xx_retire;                    
wire            iu_had_xx_retire_normal;             
wire    [31:0]  iu_had_xx_retire_pc;                 
wire    [31:0]  iu_pad_gpr_data;                     
wire    [4 :0]  iu_pad_gpr_index;                    
wire            iu_pad_gpr_we;                       
wire            iu_pad_inst_retire;                  
wire            iu_pad_inst_split;                   
wire    [31:0]  iu_pad_retire_pc;                    
wire            iu_sys_lp_wk_int;                    
wire            iu_sysio_lockup_on;                  
wire            iu_yy_xx_dbgon;                      
wire    [31:0]  lsu_bmu_addr;                        
wire            lsu_bmu_addr_check_fail;             
wire            lsu_bmu_idle;                        
wire    [3 :0]  lsu_bmu_prot;                        
wire            lsu_bmu_req;                         
wire            lsu_bmu_req_without_cmplt;           
wire            lsu_bmu_sg_chk_fail;                 
wire    [1 :0]  lsu_bmu_size;                        
wire            lsu_bmu_store_error;                 
wire    [31:0]  lsu_bmu_wdata;                       
wire            lsu_bmu_wfd1;                        
wire            lsu_bmu_write;                       
wire    [31:0]  lsu_had_addr;                        
wire            lsu_had_addr_vld;                    
wire            lsu_had_ex_cmplt;                    
wire            lsu_had_st;                          
wire    [31:0]  pad_biu_hrdata;                      
wire            pad_biu_hready;                      
wire            pad_biu_hresp;                       
wire    [11:0]  pad_bmu_iahbl_base;                  
wire    [11:0]  pad_bmu_iahbl_mask;                  
wire            pad_cpu_dfs_req;                     
wire            pad_cpu_ext_int_b;                   
wire            pad_cpu_nmi;                         
wire    [31:0]  pad_cpu_rst_addr;                    
wire    [63:0]  pad_cpu_sys_cnt;                     
wire            pad_cpu_wakeup_event;                
wire    [31:0]  pad_iahbl_hrdata;                    
wire            pad_iahbl_hready;                    
wire            pad_iahbl_hresp;                     
wire            pad_sysio_dbgrq_b;                   
wire            pad_yy_gate_clk_en_b;                
wire            pmp_bmu_dbus_acc_deny;               
wire            pmp_bmu_ibus_acc_deny;               
wire    [31:0]  pmp_cp0_data;                        
wire            pmp_ifu_acc_scu;                     
wire            pmp_lsu_acc_scu;                     
wire            pwrm_cpu_bus_peak_power_limit_en;    
wire            sahblif_iahblif_mask;                
wire            sbus_idle;                           
wire            sysio_clint_me_int;                  
wire    [63:0]  sysio_clint_mtime;                   
wire            sysio_cp0_bigend;                    
wire    [2 :0]  sysio_cp0_clkratio;                  
wire            sysio_cp0_endian_v2;                 
wire    [31:0]  sysio_cp0_rst_addr;                  
wire    [1 :0]  sysio_cp0_sys_view_lpmd_b;           
wire            sysio_had_sdb_req_b;                 
wire    [31:0]  sysio_ifu_rst_addr;                  
wire            sysio_iu_nmi_int;                    
wire    [31:0]  sysio_iu_rst_addr;                   
wire            sysio_iu_wk_event;                   
wire    [1 :0]  sysio_pad_lpmd_b;                    
wire            sysmap_ifu_acc_ca;                   
wire            sysmap_lsu_acc_ca;                   
wire    [31:0]  tcip_cp0_clic_base;                  
wire            tcipif_bmu_dbus_acc_err;             
wire    [31:0]  tcipif_bmu_dbus_data;                
wire            tcipif_bmu_dbus_data_vld;            
wire            tcipif_bmu_dbus_grnt;                
wire            tcipif_bmu_dbus_trans_cmplt;         
wire            tcipif_bmu_ibus_acc_err;             
wire    [31:0]  tcipif_bmu_ibus_data;                
wire            tcipif_bmu_ibus_data_vld;            
wire            tcipif_bmu_ibus_grnt;                
wire            tcipif_bmu_ibus_trans_cmplt;         


//==========================================================
//  Define SCAN CHAIN
//==========================================================
// //&Force("input", "nm_top_si_1"); @33
// //&Force("input", "nm_top_si_2"); @34
// //&Force("input", "nm_top_si_3"); @35
// //&Force("input", "nm_top_si_4"); @36
// //&Force("output", "nm_top_so_1"); @37
// //&Force("output", "nm_top_so_2"); @38
// //&Force("output", "nm_top_so_3"); @39
// //&Force("output", "nm_top_so_4"); @40
// //&Force("input", "pad_yy_scan_enable"); @41


//==========================================================
//  Instance CK802 core module
//==========================================================
// &Instance("cr_core"); @47
cr_core  x_cr_core (
  .bmu_lsu_acc_err                      (bmu_lsu_acc_err                     ),
  .bmu_lsu_bstack_chk_fail              (bmu_lsu_bstack_chk_fail             ),
  .bmu_lsu_data                         (bmu_lsu_data                        ),
  .bmu_lsu_data_vld                     (bmu_lsu_data_vld                    ),
  .bmu_lsu_grnt                         (bmu_lsu_grnt                        ),
  .bmu_lsu_trans_cmplt                  (bmu_lsu_trans_cmplt                 ),
  .bmu_xx_ibus_acc_err                  (bmu_xx_ibus_acc_err                 ),
  .bmu_xx_ibus_data                     (bmu_xx_ibus_data                    ),
  .bmu_xx_ibus_data_vld                 (bmu_xx_ibus_data_vld                ),
  .bmu_xx_ibus_grnt                     (bmu_xx_ibus_grnt                    ),
  .bmu_xx_ibus_trans_cmplt              (bmu_xx_ibus_trans_cmplt             ),
  .cache_cp0_lpmd_ack                   (cache_cp0_lpmd_ack                  ),
  .cache_cp0_srst_ack                   (cache_cp0_srst_ack                  ),
  .cache_iu_lockup_ack                  (cache_iu_lockup_ack                 ),
  .clic_cpu_int_hv                      (clic_cpu_int_hv                     ),
  .clic_cpu_int_id                      (clic_cpu_int_id                     ),
  .clic_cpu_int_il                      (clic_cpu_int_il                     ),
  .clic_cpu_int_priv                    (clic_cpu_int_priv                   ),
  .clint_cpu_me_int                     (clint_cpu_me_int                    ),
  .clk_en                               (clk_en                              ),
  .cp0_cache_lpmd_req                   (cp0_cache_lpmd_req                  ),
  .cp0_cache_srst_req                   (cp0_cache_srst_req                  ),
  .cp0_had_cpuid_idx0                   (cp0_had_cpuid_idx0                  ),
  .cp0_had_int_exit                     (cp0_had_int_exit                    ),
  .cp0_had_lpmd_b                       (cp0_had_lpmd_b                      ),
  .cp0_had_mcause_data                  (cp0_had_mcause_data                 ),
  .cp0_pad_mcause                       (cp0_pad_mcause                      ),
  .cp0_pad_mintstatus                   (cp0_pad_mintstatus                  ),
  .cp0_pad_mstatus                      (cp0_pad_mstatus                     ),
  .cp0_pmp_csr_sel                      (cp0_pmp_csr_sel                     ),
  .cp0_pmp_csr_wen                      (cp0_pmp_csr_wen                     ),
  .cp0_pmp_mstatus_mpp                  (cp0_pmp_mstatus_mpp                 ),
  .cp0_pmp_mstatus_mprv                 (cp0_pmp_mstatus_mprv                ),
  .cp0_pmp_updt_data                    (cp0_pmp_updt_data                   ),
  .cp0_sysio_ipend_b                    (cp0_sysio_ipend_b                   ),
  .cp0_sysio_lpmd_b                     (cp0_sysio_lpmd_b                    ),
  .cp0_sysio_srst                       (cp0_sysio_srst                      ),
  .cp0_yy_be_v2                         (cp0_yy_be_v2                        ),
  .cp0_yy_clk_en                        (cp0_yy_clk_en                       ),
  .cp0_yy_machine_mode_aft_dbg          (cp0_yy_machine_mode_aft_dbg         ),
  .cp0_yy_priv_mode                     (cp0_yy_priv_mode                    ),
  .cpu_clic_curid                       (cpu_clic_curid                      ),
  .cpu_clic_int_exit                    (cpu_clic_int_exit                   ),
  .cpurst_b                             (cpurst_b                            ),
  .forever_cpuclk                       (forever_cpuclk                      ),
  .had_core_dbg_mode_req                (had_core_dbg_mode_req               ),
  .had_idu_wbbr_data                    (had_idu_wbbr_data                   ),
  .had_idu_wbbr_vld                     (had_idu_wbbr_vld                    ),
  .had_ifu_inst_bkpt_dbq_req            (had_ifu_inst_bkpt_dbq_req           ),
  .had_ifu_inst_bkpt_dbqexp_req         (had_ifu_inst_bkpt_dbqexp_req        ),
  .had_ifu_ir                           (had_ifu_ir                          ),
  .had_ifu_ir_vld                       (had_ifu_ir_vld                      ),
  .had_iu_bkpt_trace_en                 (had_iu_bkpt_trace_en                ),
  .had_iu_dr_set_req                    (had_iu_dr_set_req                   ),
  .had_iu_force_dbg_en                  (had_iu_force_dbg_en                 ),
  .had_iu_int_vld                       (had_iu_int_vld                      ),
  .had_iu_mbkpt_fsm_index_mbee          (had_iu_mbkpt_fsm_index_mbee         ),
  .had_iu_mem_bkpt_exp_req              (had_iu_mem_bkpt_exp_req             ),
  .had_iu_mem_bkpt_mask                 (had_iu_mem_bkpt_mask                ),
  .had_iu_mem_bkpt_req                  (had_iu_mem_bkpt_req                 ),
  .had_iu_pc                            (had_iu_pc                           ),
  .had_iu_rte_pc_sel                    (had_iu_rte_pc_sel                   ),
  .had_iu_trace_req                     (had_iu_trace_req                    ),
  .had_iu_trace_req_for_dbg_disable     (had_iu_trace_req_for_dbg_disable    ),
  .had_iu_xx_fdb                        (had_iu_xx_fdb                       ),
  .had_iu_xx_jdbreq                     (had_iu_xx_jdbreq                    ),
  .had_yy_xx_dbg                        (had_yy_xx_dbg                       ),
  .had_yy_xx_dp_index_mbee              (had_yy_xx_dp_index_mbee             ),
  .had_yy_xx_exit_dbg                   (had_core_exit_dbg                   ),
  .ifu_bmu_addr                         (ifu_bmu_addr                        ),
  .ifu_bmu_idle                         (ifu_bmu_idle                        ),
  .ifu_bmu_prot                         (ifu_bmu_prot                        ),
  .ifu_bmu_req                          (ifu_bmu_req                         ),
  .ifu_bmu_wfd1                         (ifu_bmu_wfd1                        ),
  .ifu_had_chg_flw_inst                 (ifu_had_chg_flw_inst                ),
  .ifu_had_fetch_expt_vld               (ifu_had_fetch_expt_vld              ),
  .ifu_had_inst_dbg_disable             (ifu_had_inst_dbg_disable            ),
  .ifu_had_match_pc                     (ifu_had_match_pc                    ),
  .ifu_had_split_first                  (ifu_had_split_first                 ),
  .iu_bmu_vec_redirect                  (iu_bmu_vec_redirect                 ),
  .iu_cache_lockup_req                  (iu_cache_lockup_req                 ),
  .iu_had_adr_dbg_ack                   (iu_had_adr_dbg_ack                  ),
  .iu_had_chgflw_dst_pc                 (iu_had_chgflw_dst_pc                ),
  .iu_had_chgflw_vld                    (iu_had_chgflw_vld                   ),
  .iu_had_data_bkpt_occur_vld           (iu_had_data_bkpt_occur_vld          ),
  .iu_had_dbg_disable_for_tee           (iu_had_dbg_disable_for_tee          ),
  .iu_had_dr_dbg_ack                    (iu_had_dr_dbg_ack                   ),
  .iu_had_expt_vld                      (iu_had_expt_vld                     ),
  .iu_had_fast_retire_acc_err_pc_update (iu_had_fast_retire_acc_err_pc_update),
  .iu_had_fast_retire_acc_err_pc_val    (iu_had_fast_retire_acc_err_pc_val   ),
  .iu_had_flush                         (iu_had_flush                        ),
  .iu_had_inst_bkpt_occur_vld           (iu_had_inst_bkpt_occur_vld          ),
  .iu_had_int_ack                       (iu_had_int_ack                      ),
  .iu_had_retire_with_had_int           (iu_had_retire_with_had_int          ),
  .iu_had_trace_occur_vld               (iu_had_trace_occur_vld              ),
  .iu_had_xx_bkpt_inst                  (iu_had_xx_bkpt_inst                 ),
  .iu_had_xx_data                       (iu_had_xx_data                      ),
  .iu_had_xx_data_vld                   (iu_had_xx_data_vld                  ),
  .iu_had_xx_dbg_ack                    (iu_had_xx_dbg_ack                   ),
  .iu_had_xx_mldst                      (iu_had_xx_mldst                     ),
  .iu_had_xx_retire                     (iu_had_xx_retire                    ),
  .iu_had_xx_retire_normal              (iu_had_xx_retire_normal             ),
  .iu_had_xx_retire_pc                  (iu_had_xx_retire_pc                 ),
  .iu_pad_gpr_data                      (iu_pad_gpr_data                     ),
  .iu_pad_gpr_index                     (iu_pad_gpr_index                    ),
  .iu_pad_gpr_we                        (iu_pad_gpr_we                       ),
  .iu_pad_inst_retire                   (iu_pad_inst_retire                  ),
  .iu_pad_inst_split                    (iu_pad_inst_split                   ),
  .iu_pad_retire_pc                     (iu_pad_retire_pc                    ),
  .iu_sys_lp_wk_int                     (iu_sys_lp_wk_int                    ),
  .iu_sysio_lockup_on                   (iu_sysio_lockup_on                  ),
  .iu_yy_xx_dbgon                       (iu_yy_xx_dbgon                      ),
  .lsu_bmu_addr                         (lsu_bmu_addr                        ),
  .lsu_bmu_addr_check_fail              (lsu_bmu_addr_check_fail             ),
  .lsu_bmu_idle                         (lsu_bmu_idle                        ),
  .lsu_bmu_prot                         (lsu_bmu_prot                        ),
  .lsu_bmu_req                          (lsu_bmu_req                         ),
  .lsu_bmu_req_without_cmplt            (lsu_bmu_req_without_cmplt           ),
  .lsu_bmu_sg_chk_fail                  (lsu_bmu_sg_chk_fail                 ),
  .lsu_bmu_size                         (lsu_bmu_size                        ),
  .lsu_bmu_store_error                  (lsu_bmu_store_error                 ),
  .lsu_bmu_wdata                        (lsu_bmu_wdata                       ),
  .lsu_bmu_wfd1                         (lsu_bmu_wfd1                        ),
  .lsu_bmu_write                        (lsu_bmu_write                       ),
  .lsu_had_addr                         (lsu_had_addr                        ),
  .lsu_had_addr_vld                     (lsu_had_addr_vld                    ),
  .lsu_had_ex_cmplt                     (lsu_had_ex_cmplt                    ),
  .lsu_had_st                           (lsu_had_st                          ),
  .pad_yy_gate_clk_en_b                 (pad_yy_gate_clk_en_b                ),
  .pmp_cp0_data                         (pmp_cp0_data                        ),
  .pmp_ifu_acc_scu                      (pmp_ifu_acc_scu                     ),
  .pmp_lsu_acc_scu                      (pmp_lsu_acc_scu                     ),
  .sysio_cp0_bigend                     (sysio_cp0_bigend                    ),
  .sysio_cp0_clkratio                   (sysio_cp0_clkratio                  ),
  .sysio_cp0_endian_v2                  (sysio_cp0_endian_v2                 ),
  .sysio_cp0_rst_addr                   (sysio_cp0_rst_addr                  ),
  .sysio_cp0_sys_view_lpmd_b            (sysio_cp0_sys_view_lpmd_b           ),
  .sysio_ifu_rst_addr                   (sysio_ifu_rst_addr                  ),
  .sysio_iu_nmi_int                     (sysio_iu_nmi_int                    ),
  .sysio_iu_rst_addr                    (sysio_iu_rst_addr                   ),
  .sysio_iu_wk_event                    (sysio_iu_wk_event                   ),
  .sysmap_ifu_acc_ca                    (sysmap_ifu_acc_ca                   ),
  .sysmap_lsu_acc_ca                    (sysmap_lsu_acc_ca                   ),
  .tcip_cp0_clic_base                   (tcip_cp0_clic_base                  )
);

// &Connect( @48
//          .had_yy_xx_exit_dbg    (had_core_exit_dbg       ), @49
//         ); @50
//assign cp0_had_supv_mode = cp0_yy_supv_mode;
// &Force("output", "iu_yy_xx_dbgon"); @52
// //&Force("output","cp0_yy_secu_mode"); @54

//==========================================================
//  Instance MPU module 
//==========================================================
// &Instance("cr_pmp_top"); @61
cr_pmp_top  x_cr_pmp_top (
  .cp0_pmp_csr_sel             (cp0_pmp_csr_sel            ),
  .cp0_pmp_csr_wen             (cp0_pmp_csr_wen            ),
  .cp0_pmp_mstatus_mpp         (cp0_pmp_mstatus_mpp        ),
  .cp0_pmp_mstatus_mprv        (cp0_pmp_mstatus_mprv       ),
  .cp0_pmp_updt_data           (cp0_pmp_updt_data          ),
  .cp0_yy_clk_en               (cp0_yy_clk_en              ),
  .cp0_yy_machine_mode_aft_dbg (cp0_yy_machine_mode_aft_dbg),
  .cpurst_b                    (cpurst_b                   ),
  .forever_cpuclk              (forever_cpuclk             ),
  .ifu_bmu_addr                (ifu_bmu_addr               ),
  .ifu_bmu_prot                (ifu_bmu_prot               ),
  .lsu_bmu_addr                (lsu_bmu_addr               ),
  .lsu_bmu_write               (lsu_bmu_write              ),
  .pad_yy_gate_clk_en_b        (pad_yy_gate_clk_en_b       ),
  .pmp_bmu_dbus_acc_deny       (pmp_bmu_dbus_acc_deny      ),
  .pmp_bmu_ibus_acc_deny       (pmp_bmu_ibus_acc_deny      ),
  .pmp_cp0_data                (pmp_cp0_data               ),
  .pmp_ifu_acc_scu             (pmp_ifu_acc_scu            ),
  .pmp_lsu_acc_scu             (pmp_lsu_acc_scu            )
);


//==========================================================
//  Instance BMU module 
//==========================================================
// &Instance("cr_bmu_top"); @67
cr_bmu_top  x_cr_bmu_top (
  .biu_bmu_dbus_acc_err             (biu_bmu_dbus_acc_err            ),
  .biu_bmu_dbus_data                (biu_bmu_dbus_data               ),
  .biu_bmu_dbus_data_vld            (biu_bmu_dbus_data_vld           ),
  .biu_bmu_dbus_grnt                (biu_bmu_dbus_grnt               ),
  .biu_bmu_dbus_trans_cmplt         (biu_bmu_dbus_trans_cmplt        ),
  .biu_bmu_ibus_acc_err             (biu_bmu_ibus_acc_err            ),
  .biu_bmu_ibus_data                (biu_bmu_ibus_data               ),
  .biu_bmu_ibus_data_vld            (biu_bmu_ibus_data_vld           ),
  .biu_bmu_ibus_grnt                (biu_bmu_ibus_grnt               ),
  .biu_bmu_ibus_trans_cmplt         (biu_bmu_ibus_trans_cmplt        ),
  .bmu_biu_dbus_acc_deny            (bmu_biu_dbus_acc_deny           ),
  .bmu_biu_dbus_addr                (bmu_biu_dbus_addr               ),
  .bmu_biu_dbus_chk_fail            (bmu_biu_dbus_chk_fail           ),
  .bmu_biu_dbus_prot                (bmu_biu_dbus_prot               ),
  .bmu_biu_dbus_req                 (bmu_biu_dbus_req                ),
  .bmu_biu_dbus_req_without_cmplt   (bmu_biu_dbus_req_without_cmplt  ),
  .bmu_biu_dbus_size                (bmu_biu_dbus_size               ),
  .bmu_biu_dbus_wdata               (bmu_biu_dbus_wdata              ),
  .bmu_biu_dbus_write               (bmu_biu_dbus_write              ),
  .bmu_biu_ibus_acc_deny            (bmu_biu_ibus_acc_deny           ),
  .bmu_biu_ibus_addr                (bmu_biu_ibus_addr               ),
  .bmu_biu_ibus_hit                 (bmu_biu_ibus_hit                ),
  .bmu_biu_ibus_prot                (bmu_biu_ibus_prot               ),
  .bmu_biu_ibus_req                 (bmu_biu_ibus_req                ),
  .bmu_biu_ibus_req_no_hit          (bmu_biu_ibus_req_no_hit         ),
  .bmu_biu_ibus_size                (bmu_biu_ibus_size               ),
  .bmu_biu_ibus_vec_redirect        (bmu_biu_ibus_vec_redirect       ),
  .bmu_iahbl_dbus_acc_deny          (bmu_iahbl_dbus_acc_deny         ),
  .bmu_iahbl_dbus_addr              (bmu_iahbl_dbus_addr             ),
  .bmu_iahbl_dbus_chk_fail          (bmu_iahbl_dbus_chk_fail         ),
  .bmu_iahbl_dbus_prot              (bmu_iahbl_dbus_prot             ),
  .bmu_iahbl_dbus_req               (bmu_iahbl_dbus_req              ),
  .bmu_iahbl_dbus_req_without_cmplt (bmu_iahbl_dbus_req_without_cmplt),
  .bmu_iahbl_dbus_size              (bmu_iahbl_dbus_size             ),
  .bmu_iahbl_dbus_wdata             (bmu_iahbl_dbus_wdata            ),
  .bmu_iahbl_dbus_write             (bmu_iahbl_dbus_write            ),
  .bmu_iahbl_ibus_acc_deny          (bmu_iahbl_ibus_acc_deny         ),
  .bmu_iahbl_ibus_addr              (bmu_iahbl_ibus_addr             ),
  .bmu_iahbl_ibus_hit               (bmu_iahbl_ibus_hit              ),
  .bmu_iahbl_ibus_prot              (bmu_iahbl_ibus_prot             ),
  .bmu_iahbl_ibus_req               (bmu_iahbl_ibus_req              ),
  .bmu_iahbl_ibus_req_no_hit        (bmu_iahbl_ibus_req_no_hit       ),
  .bmu_iahbl_ibus_size              (bmu_iahbl_ibus_size             ),
  .bmu_iahbl_ibus_vec_redirect      (bmu_iahbl_ibus_vec_redirect     ),
  .bmu_lsu_acc_err                  (bmu_lsu_acc_err                 ),
  .bmu_lsu_bstack_chk_fail          (bmu_lsu_bstack_chk_fail         ),
  .bmu_lsu_data                     (bmu_lsu_data                    ),
  .bmu_lsu_data_vld                 (bmu_lsu_data_vld                ),
  .bmu_lsu_grnt                     (bmu_lsu_grnt                    ),
  .bmu_lsu_trans_cmplt              (bmu_lsu_trans_cmplt             ),
  .bmu_tcipif_dbus_acc_deny         (bmu_tcipif_dbus_acc_deny        ),
  .bmu_tcipif_dbus_addr             (bmu_tcipif_dbus_addr            ),
  .bmu_tcipif_dbus_chk_fail         (bmu_tcipif_dbus_chk_fail        ),
  .bmu_tcipif_dbus_req              (bmu_tcipif_dbus_req             ),
  .bmu_tcipif_dbus_size             (bmu_tcipif_dbus_size            ),
  .bmu_tcipif_dbus_supv_mode        (bmu_tcipif_dbus_supv_mode       ),
  .bmu_tcipif_dbus_wdata            (bmu_tcipif_dbus_wdata           ),
  .bmu_tcipif_dbus_write            (bmu_tcipif_dbus_write           ),
  .bmu_tcipif_ibus_acc_deny         (bmu_tcipif_ibus_acc_deny        ),
  .bmu_tcipif_ibus_addr             (bmu_tcipif_ibus_addr            ),
  .bmu_tcipif_ibus_req              (bmu_tcipif_ibus_req             ),
  .bmu_tcipif_ibus_write            (bmu_tcipif_ibus_write           ),
  .bmu_xx_ibus_acc_err              (bmu_xx_ibus_acc_err             ),
  .bmu_xx_ibus_data                 (bmu_xx_ibus_data                ),
  .bmu_xx_ibus_data_vld             (bmu_xx_ibus_data_vld            ),
  .bmu_xx_ibus_grnt                 (bmu_xx_ibus_grnt                ),
  .bmu_xx_ibus_trans_cmplt          (bmu_xx_ibus_trans_cmplt         ),
  .cp0_yy_clk_en                    (cp0_yy_clk_en                   ),
  .cp0_yy_machine_mode_aft_dbg      (cp0_yy_machine_mode_aft_dbg     ),
  .cpurst_b                         (cpurst_b                        ),
  .forever_cpuclk                   (forever_cpuclk                  ),
  .iahbl_bmu_dbus_acc_err           (iahbl_bmu_dbus_acc_err          ),
  .iahbl_bmu_dbus_data              (iahbl_bmu_dbus_data             ),
  .iahbl_bmu_dbus_data_vld          (iahbl_bmu_dbus_data_vld         ),
  .iahbl_bmu_dbus_grnt              (iahbl_bmu_dbus_grnt             ),
  .iahbl_bmu_dbus_trans_cmplt       (iahbl_bmu_dbus_trans_cmplt      ),
  .iahbl_bmu_ibus_acc_err           (iahbl_bmu_ibus_acc_err          ),
  .iahbl_bmu_ibus_data              (iahbl_bmu_ibus_data             ),
  .iahbl_bmu_ibus_data_vld          (iahbl_bmu_ibus_data_vld         ),
  .iahbl_bmu_ibus_grnt              (iahbl_bmu_ibus_grnt             ),
  .iahbl_bmu_ibus_trans_cmplt       (iahbl_bmu_ibus_trans_cmplt      ),
  .ifu_bmu_addr                     (ifu_bmu_addr                    ),
  .ifu_bmu_idle                     (ifu_bmu_idle                    ),
  .ifu_bmu_prot                     (ifu_bmu_prot                    ),
  .ifu_bmu_req                      (ifu_bmu_req                     ),
  .ifu_bmu_wfd1                     (ifu_bmu_wfd1                    ),
  .iu_bmu_vec_redirect              (iu_bmu_vec_redirect             ),
  .lsu_bmu_addr                     (lsu_bmu_addr                    ),
  .lsu_bmu_addr_check_fail          (lsu_bmu_addr_check_fail         ),
  .lsu_bmu_idle                     (lsu_bmu_idle                    ),
  .lsu_bmu_prot                     (lsu_bmu_prot                    ),
  .lsu_bmu_req                      (lsu_bmu_req                     ),
  .lsu_bmu_req_without_cmplt        (lsu_bmu_req_without_cmplt       ),
  .lsu_bmu_sg_chk_fail              (lsu_bmu_sg_chk_fail             ),
  .lsu_bmu_size                     (lsu_bmu_size                    ),
  .lsu_bmu_store_error              (lsu_bmu_store_error             ),
  .lsu_bmu_wdata                    (lsu_bmu_wdata                   ),
  .lsu_bmu_wfd1                     (lsu_bmu_wfd1                    ),
  .lsu_bmu_write                    (lsu_bmu_write                   ),
  .pad_bmu_iahbl_base               (pad_bmu_iahbl_base              ),
  .pad_bmu_iahbl_mask               (pad_bmu_iahbl_mask              ),
  .pad_yy_gate_clk_en_b             (pad_yy_gate_clk_en_b            ),
  .pmp_bmu_dbus_acc_deny            (pmp_bmu_dbus_acc_deny           ),
  .pmp_bmu_ibus_acc_deny            (pmp_bmu_ibus_acc_deny           ),
  .tcipif_bmu_dbus_acc_err          (tcipif_bmu_dbus_acc_err         ),
  .tcipif_bmu_dbus_data             (tcipif_bmu_dbus_data            ),
  .tcipif_bmu_dbus_data_vld         (tcipif_bmu_dbus_data_vld        ),
  .tcipif_bmu_dbus_grnt             (tcipif_bmu_dbus_grnt            ),
  .tcipif_bmu_dbus_trans_cmplt      (tcipif_bmu_dbus_trans_cmplt     ),
  .tcipif_bmu_ibus_acc_err          (tcipif_bmu_ibus_acc_err         ),
  .tcipif_bmu_ibus_data             (tcipif_bmu_ibus_data            ),
  .tcipif_bmu_ibus_data_vld         (tcipif_bmu_ibus_data_vld        ),
  .tcipif_bmu_ibus_grnt             (tcipif_bmu_ibus_grnt            ),
  .tcipif_bmu_ibus_trans_cmplt      (tcipif_bmu_ibus_trans_cmplt     )
);


// &Instance("cr_cache_top"); @73
// &Connect(.cpuclk          (forever_cpuclk)); @74
// &Connect(.cache_global_en (cp0_yy_clk_en)); @75
// //&Force("output", "ifu_bmu_addr"); @76
// //&Force("output", "lsu_bmu_addr"); @77
// //&Force("output", "lsu_bmu_prot"); @78
// //&Force("output", "ifu_bmu_prot"); @79
// //&Force("output", "lsu_bmu_write"); @80
// &Instance("cr_sysmap_top"); @81
// &Force("nonport", "cp0_cache_lpmd_req"); @83
// &Force("nonport", "cp0_cache_srst_req"); @84
// &Force("nonport", "iu_cache_lockup_req"); @85
assign cache_cp0_lpmd_ack = 1'b1;
assign cache_cp0_srst_ack = 1'b1;
assign cache_iu_lockup_ack = 1'b1;
assign sysmap_ifu_acc_ca  = 1'b0;
assign sysmap_lsu_acc_ca  = 1'b0;

always @ (posedge forever_cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
  begin
    pad_cpu_halt_ff1 <= 1'b0;
    pad_cpu_halt_ff2 <= 1'b0;
  end
  else
  begin
    pad_cpu_halt_ff1 <= pad_cpu_dfs_req;
    pad_cpu_halt_ff2 <= pad_cpu_halt_ff1;
  end
end
assign cpu_pad_dfs_ack = ibus_idle && dbus_idle && sbus_idle
                       && pad_cpu_halt_ff2;
//==========================================================
//  Instance BIU module 
//==========================================================
// &Instance("cr_sahbl_top"); @111
cr_sahbl_top  x_cr_sahbl_top (
  .ahblif_idle                      (sbus_idle                       ),
  .biu_bmu_dbus_acc_err             (biu_bmu_dbus_acc_err            ),
  .biu_bmu_dbus_data                (biu_bmu_dbus_data               ),
  .biu_bmu_dbus_data_vld            (biu_bmu_dbus_data_vld           ),
  .biu_bmu_dbus_grnt                (biu_bmu_dbus_grnt               ),
  .biu_bmu_dbus_trans_cmplt         (biu_bmu_dbus_trans_cmplt        ),
  .biu_bmu_ibus_acc_err             (biu_bmu_ibus_acc_err            ),
  .biu_bmu_ibus_data                (biu_bmu_ibus_data               ),
  .biu_bmu_ibus_data_vld            (biu_bmu_ibus_data_vld           ),
  .biu_bmu_ibus_grnt                (biu_bmu_ibus_grnt               ),
  .biu_bmu_ibus_trans_cmplt         (biu_bmu_ibus_trans_cmplt        ),
  .biu_pad_haddr                    (biu_pad_haddr                   ),
  .biu_pad_hburst                   (biu_pad_hburst                  ),
  .biu_pad_hprot                    (biu_pad_hprot                   ),
  .biu_pad_hsize                    (biu_pad_hsize                   ),
  .biu_pad_htrans                   (biu_pad_htrans                  ),
  .biu_pad_hwdata                   (biu_pad_hwdata                  ),
  .biu_pad_hwrite                   (biu_pad_hwrite                  ),
  .bmu_biu_dbus_acc_deny            (bmu_biu_dbus_acc_deny           ),
  .bmu_biu_dbus_addr                (bmu_biu_dbus_addr               ),
  .bmu_biu_dbus_chk_fail            (bmu_biu_dbus_chk_fail           ),
  .bmu_biu_dbus_prot                (bmu_biu_dbus_prot               ),
  .bmu_biu_dbus_req                 (bmu_biu_dbus_req                ),
  .bmu_biu_dbus_req_without_cmplt   (bmu_biu_dbus_req_without_cmplt  ),
  .bmu_biu_dbus_size                (bmu_biu_dbus_size               ),
  .bmu_biu_dbus_wdata               (bmu_biu_dbus_wdata              ),
  .bmu_biu_dbus_write               (bmu_biu_dbus_write              ),
  .bmu_biu_ibus_acc_deny            (bmu_biu_ibus_acc_deny           ),
  .bmu_biu_ibus_addr                (bmu_biu_ibus_addr               ),
  .bmu_biu_ibus_hit                 (bmu_biu_ibus_hit                ),
  .bmu_biu_ibus_prot                (bmu_biu_ibus_prot               ),
  .bmu_biu_ibus_req                 (bmu_biu_ibus_req                ),
  .bmu_biu_ibus_req_no_hit          (bmu_biu_ibus_req_no_hit         ),
  .bmu_biu_ibus_size                (bmu_biu_ibus_size               ),
  .bmu_biu_ibus_vec_redirect        (bmu_biu_ibus_vec_redirect       ),
  .cpurst_b                         (cpurst_b                        ),
  .dahblif_other_mask               (dahblif_other_mask              ),
  .forever_cpuclk                   (forever_cpuclk                  ),
  .iahblif_other_mask               (iahblif_other_mask              ),
  .pad_biu_hrdata                   (pad_biu_hrdata                  ),
  .pad_biu_hready                   (pad_biu_hready                  ),
  .pad_biu_hresp                    (pad_biu_hresp                   ),
  .pad_cpu_halt_ff2                 (pad_cpu_halt_ff2                ),
  .pad_yy_gate_clk_en_b             (pad_yy_gate_clk_en_b            ),
  .pwrm_cpu_bus_peak_power_limit_en (pwrm_cpu_bus_peak_power_limit_en),
  .sahblif_iahblif_mask             (sahblif_iahblif_mask            )
);

// &Connect(.ahblif_idle (sbus_idle)); @112

//==========================================================
//  Instance IAHBLite module
//==========================================================
// &Instance("cr_iahbl_top"); @118
cr_iahbl_top  x_cr_iahbl_top (
  .ahblif_idle                      (ibus_idle                       ),
  .bmu_iahbl_dbus_acc_deny          (bmu_iahbl_dbus_acc_deny         ),
  .bmu_iahbl_dbus_addr              (bmu_iahbl_dbus_addr             ),
  .bmu_iahbl_dbus_chk_fail          (bmu_iahbl_dbus_chk_fail         ),
  .bmu_iahbl_dbus_prot              (bmu_iahbl_dbus_prot             ),
  .bmu_iahbl_dbus_req               (bmu_iahbl_dbus_req              ),
  .bmu_iahbl_dbus_req_without_cmplt (bmu_iahbl_dbus_req_without_cmplt),
  .bmu_iahbl_dbus_size              (bmu_iahbl_dbus_size             ),
  .bmu_iahbl_dbus_wdata             (bmu_iahbl_dbus_wdata            ),
  .bmu_iahbl_dbus_write             (bmu_iahbl_dbus_write            ),
  .bmu_iahbl_ibus_acc_deny          (bmu_iahbl_ibus_acc_deny         ),
  .bmu_iahbl_ibus_addr              (bmu_iahbl_ibus_addr             ),
  .bmu_iahbl_ibus_hit               (bmu_iahbl_ibus_hit              ),
  .bmu_iahbl_ibus_prot              (bmu_iahbl_ibus_prot             ),
  .bmu_iahbl_ibus_req               (bmu_iahbl_ibus_req              ),
  .bmu_iahbl_ibus_req_no_hit        (bmu_iahbl_ibus_req_no_hit       ),
  .bmu_iahbl_ibus_size              (bmu_iahbl_ibus_size             ),
  .bmu_iahbl_ibus_vec_redirect      (bmu_iahbl_ibus_vec_redirect     ),
  .cpurst_b                         (cpurst_b                        ),
  .dahblif_other_mask               (dahblif_other_mask              ),
  .forever_cpuclk                   (forever_cpuclk                  ),
  .iahbl_bmu_dbus_acc_err           (iahbl_bmu_dbus_acc_err          ),
  .iahbl_bmu_dbus_data              (iahbl_bmu_dbus_data             ),
  .iahbl_bmu_dbus_data_vld          (iahbl_bmu_dbus_data_vld         ),
  .iahbl_bmu_dbus_grnt              (iahbl_bmu_dbus_grnt             ),
  .iahbl_bmu_dbus_trans_cmplt       (iahbl_bmu_dbus_trans_cmplt      ),
  .iahbl_bmu_ibus_acc_err           (iahbl_bmu_ibus_acc_err          ),
  .iahbl_bmu_ibus_data              (iahbl_bmu_ibus_data             ),
  .iahbl_bmu_ibus_data_vld          (iahbl_bmu_ibus_data_vld         ),
  .iahbl_bmu_ibus_grnt              (iahbl_bmu_ibus_grnt             ),
  .iahbl_bmu_ibus_trans_cmplt       (iahbl_bmu_ibus_trans_cmplt      ),
  .iahbl_pad_haddr                  (iahbl_pad_haddr                 ),
  .iahbl_pad_hburst                 (iahbl_pad_hburst                ),
  .iahbl_pad_hprot                  (iahbl_pad_hprot                 ),
  .iahbl_pad_hsize                  (iahbl_pad_hsize                 ),
  .iahbl_pad_htrans                 (iahbl_pad_htrans                ),
  .iahbl_pad_hwdata                 (iahbl_pad_hwdata                ),
  .iahbl_pad_hwrite                 (iahbl_pad_hwrite                ),
  .iahblif_other_mask               (iahblif_other_mask              ),
  .pad_cpu_halt_ff2                 (pad_cpu_halt_ff2                ),
  .pad_iahbl_hrdata                 (pad_iahbl_hrdata                ),
  .pad_iahbl_hready                 (pad_iahbl_hready                ),
  .pad_iahbl_hresp                  (pad_iahbl_hresp                 ),
  .pad_yy_gate_clk_en_b             (pad_yy_gate_clk_en_b            ),
  .pwrm_cpu_bus_peak_power_limit_en (pwrm_cpu_bus_peak_power_limit_en),
  .sahblif_iahblif_mask             (sahblif_iahblif_mask            )
);

// &Connect(.ahblif_idle (ibus_idle)); @119

// &Instance("cr_dahbl_top"); @129
// &Connect(.ahblif_idle (dbus_idle)); @130
assign dahblif_other_mask = 1'b0;  
assign dbus_idle = 1'b1;

//==========================================================
//  Instance SYSTEM IO module
//==========================================================
// &Instance("cr_sys_io","x_cr_sys_io"); @139
cr_sys_io  x_cr_sys_io (
  .clk_en                    (clk_en                   ),
  .cp0_sysio_ipend_b         (cp0_sysio_ipend_b        ),
  .cp0_sysio_lpmd_b          (cp0_sysio_lpmd_b         ),
  .cp0_sysio_srst            (cp0_sysio_srst           ),
  .cpu_pad_lockup            (cpu_pad_lockup           ),
  .cpu_pad_soft_rst          (cpu_pad_soft_rst         ),
  .cpurst_b                  (cpurst_b                 ),
  .forever_cpuclk            (forever_cpuclk           ),
  .had_yy_xx_dbg             (had_yy_xx_dbg            ),
  .iu_sys_lp_wk_int          (iu_sys_lp_wk_int         ),
  .iu_sysio_lockup_on        (iu_sysio_lockup_on       ),
  .iu_yy_xx_dbgon            (iu_yy_xx_dbgon           ),
  .pad_cpu_ext_int_b         (pad_cpu_ext_int_b        ),
  .pad_cpu_nmi               (pad_cpu_nmi              ),
  .pad_cpu_rst_addr          (pad_cpu_rst_addr         ),
  .pad_cpu_sys_cnt           (pad_cpu_sys_cnt          ),
  .pad_cpu_wakeup_event      (pad_cpu_wakeup_event     ),
  .pad_sysio_dbgrq_b         (pad_sysio_dbgrq_b        ),
  .pad_yy_gate_clk_en_b      (pad_yy_gate_clk_en_b     ),
  .sysio_clint_me_int        (sysio_clint_me_int       ),
  .sysio_clint_mtime         (sysio_clint_mtime        ),
  .sysio_cp0_bigend          (sysio_cp0_bigend         ),
  .sysio_cp0_clkratio        (sysio_cp0_clkratio       ),
  .sysio_cp0_endian_v2       (sysio_cp0_endian_v2      ),
  .sysio_cp0_rst_addr        (sysio_cp0_rst_addr       ),
  .sysio_cp0_sys_view_lpmd_b (sysio_cp0_sys_view_lpmd_b),
  .sysio_had_sdb_req_b       (sysio_had_sdb_req_b      ),
  .sysio_ifu_rst_addr        (sysio_ifu_rst_addr       ),
  .sysio_iu_nmi_int          (sysio_iu_nmi_int         ),
  .sysio_iu_rst_addr         (sysio_iu_rst_addr        ),
  .sysio_iu_wk_event         (sysio_iu_wk_event        ),
  .sysio_pad_lpmd_b          (sysio_pad_lpmd_b         )
);


// &ModuleEnd; @141
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_coretim_top_dummy(
  iu_yy_xx_dbgon
);

// &Ports; @24
input        iu_yy_xx_dbgon; 

// &Regs; @25

// &Wires; @26



// //&Force("input", "pad_ctim_refclk"); @29
// &Force("input", "iu_yy_xx_dbgon"); @30
// //&Force("output", "ctim_pad_int_vld"); @31

// &ModuleEnd; @33
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module cr_cp0_iui(
  cp0_iu_data,
  cp0_iu_data_vld,
  cp0_iu_dbg_disable_for_tee,
  cp0_iu_expt_vec,
  cp0_iu_expt_vld,
  cp0_iu_flush,
  cp0_iu_flush_chgflw_vld,
  cp0_iu_inst_mret,
  cp0_iu_req,
  cp0_iu_rte_chgflw_vld,
  cp0_iu_rte_chgflw_vld_for_data,
  cp0_iu_stall,
  cp0_iu_stall_noinput,
  inst_lpmd,
  iu_cp0_ex_csrrc,
  iu_cp0_ex_csrrci,
  iu_cp0_ex_csrrs,
  iu_cp0_ex_csrrsi,
  iu_cp0_ex_csrrw,
  iu_cp0_ex_csrrwi,
  iu_cp0_ex_data_sel,
  iu_cp0_ex_func3,
  iu_cp0_ex_mret,
  iu_cp0_ex_rd_reg,
  iu_cp0_ex_rs1_reg,
  iu_cp0_ex_sel,
  iu_cp0_ex_wfi,
  iu_cp0_imm,
  iu_cp0_oper_mux_en,
  iu_cp0_rs1,
  iu_cp0_syc_rst_b,
  iu_yy_xx_dbgon,
  iui_lpmd_inst_lpmd_for_data,
  iui_oreg_csr_acc,
  iui_oreg_expt,
  iui_oreg_imm,
  iui_oreg_inst_csr,
  iui_oreg_inst_mret,
  iui_oreg_nmi_mret,
  iui_oreg_rd_x0,
  iui_oreg_rs1,
  iui_oreg_rs1_raw,
  iui_oreg_rs1_x0,
  iui_oreg_tval,
  lpmd_iui_stall,
  marchid_value,
  mcause_value,
  mclicbase_value,
  mcpuid_value,
  mcycle_value,
  mcycleh_value,
  mepc_value,
  mexstatus_value,
  mhartid_value,
  mhcr_value,
  mie_value,
  mimpid_value,
  minstret_value,
  minstreth_value,
  mintstatus_value,
  mip_value,
  misa_value,
  mnmicause_value,
  mnmipc_value,
  mnxti_value,
  mraddr_value,
  mscratch_value,
  mscratchcsw_value,
  mscratchcswl_value,
  mstatus_value,
  mtval_value,
  mtvec_value,
  mtvt_value,
  mvendorid_value,
  mxstatus_value,
  oreg_iui_priv_mode,
  oreg_iui_wr_rdonly,
  pmp_cp0_data,
  srst_iui_stall,
  srst_iui_stall_noinput,
  status_xx_nmi
);

// &Ports; @25
input           iu_cp0_ex_csrrc;               
input           iu_cp0_ex_csrrci;              
input           iu_cp0_ex_csrrs;               
input           iu_cp0_ex_csrrsi;              
input           iu_cp0_ex_csrrw;               
input           iu_cp0_ex_csrrwi;              
input           iu_cp0_ex_data_sel;            
input   [2 :0]  iu_cp0_ex_func3;               
input           iu_cp0_ex_mret;                
input   [4 :0]  iu_cp0_ex_rd_reg;              
input   [4 :0]  iu_cp0_ex_rs1_reg;             
input           iu_cp0_ex_sel;                 
input           iu_cp0_ex_wfi;                 
input   [11:0]  iu_cp0_imm;                    
input           iu_cp0_oper_mux_en;            
input   [31:0]  iu_cp0_rs1;                    
input           iu_cp0_syc_rst_b;              
input           iu_yy_xx_dbgon;                
input           lpmd_iui_stall;                
input   [31:0]  marchid_value;                 
input   [31:0]  mcause_value;                  
input   [31:0]  mclicbase_value;               
input   [31:0]  mcpuid_value;                  
input   [31:0]  mcycle_value;                  
input   [31:0]  mcycleh_value;                 
input   [31:0]  mepc_value;                    
input   [31:0]  mexstatus_value;               
input   [31:0]  mhartid_value;                 
input   [31:0]  mhcr_value;                    
input   [31:0]  mie_value;                     
input   [31:0]  mimpid_value;                  
input   [31:0]  minstret_value;                
input   [31:0]  minstreth_value;               
input   [31:0]  mintstatus_value;              
input   [31:0]  mip_value;                     
input   [31:0]  misa_value;                    
input   [31:0]  mnmicause_value;               
input   [31:0]  mnmipc_value;                  
input   [31:0]  mnxti_value;                   
input   [31:0]  mraddr_value;                  
input   [31:0]  mscratch_value;                
input   [31:0]  mscratchcsw_value;             
input   [31:0]  mscratchcswl_value;            
input   [31:0]  mstatus_value;                 
input   [31:0]  mtval_value;                   
input   [31:0]  mtvec_value;                   
input   [31:0]  mtvt_value;                    
input   [31:0]  mvendorid_value;               
input   [31:0]  mxstatus_value;                
input   [1 :0]  oreg_iui_priv_mode;            
input           oreg_iui_wr_rdonly;            
input   [31:0]  pmp_cp0_data;                  
input           srst_iui_stall;                
input           srst_iui_stall_noinput;        
input           status_xx_nmi;                 
output  [31:0]  cp0_iu_data;                   
output          cp0_iu_data_vld;               
output          cp0_iu_dbg_disable_for_tee;    
output  [4 :0]  cp0_iu_expt_vec;               
output          cp0_iu_expt_vld;               
output          cp0_iu_flush;                  
output          cp0_iu_flush_chgflw_vld;       
output          cp0_iu_inst_mret;              
output          cp0_iu_req;                    
output          cp0_iu_rte_chgflw_vld;         
output          cp0_iu_rte_chgflw_vld_for_data; 
output          cp0_iu_stall;                  
output          cp0_iu_stall_noinput;          
output          inst_lpmd;                     
output          iui_lpmd_inst_lpmd_for_data;   
output          iui_oreg_csr_acc;              
output          iui_oreg_expt;                 
output  [11:0]  iui_oreg_imm;                  
output          iui_oreg_inst_csr;             
output          iui_oreg_inst_mret;            
output          iui_oreg_nmi_mret;             
output          iui_oreg_rd_x0;                
output  [31:0]  iui_oreg_rs1;                  
output  [31:0]  iui_oreg_rs1_raw;              
output          iui_oreg_rs1_x0;               
output  [31:0]  iui_oreg_tval;                 

// &Regs; @26
reg     [31:0]  data_out;                      
reg             imm_inv;                       

// &Wires; @27
wire            cp0_csr_flush;                 
wire            cp0_expt_vld;                  
wire            cp0_inst_cmplt;                
wire    [31:0]  cp0_iu_data;                   
wire            cp0_iu_data_vld;               
wire            cp0_iu_dbg_disable_for_tee;    
wire    [4 :0]  cp0_iu_expt_vec;               
wire            cp0_iu_expt_vld;               
wire            cp0_iu_flush;                  
wire            cp0_iu_flush_chgflw_vld;       
wire            cp0_iu_inst_mret;              
wire            cp0_iu_req;                    
wire            cp0_iu_rte_chgflw_vld;         
wire            cp0_iu_rte_chgflw_vld_for_data; 
wire            cp0_iu_stall;                  
wire            cp0_iu_stall_noinput;          
wire            cp0_mret_flush;                
wire            cp0_select;                    
wire            csr_imm_inv;                   
wire    [31:0]  csrrc_rs1;                     
wire    [31:0]  csrrci_rs1;                    
wire    [31:0]  csrrs_rs1;                     
wire    [31:0]  csrrsi_rs1;                    
wire    [31:0]  csrrw_rs1;                     
wire    [31:0]  csrrwi_rs1;                    
wire            imm_vld;                       
wire            inst_csr;                      
wire            inst_csrrc;                    
wire            inst_csrrci;                   
wire            inst_csrrs;                    
wire            inst_csrrsi;                   
wire            inst_csrrw;                    
wire            inst_csrrwi;                   
wire            inst_csrsc;                    
wire            inst_lpmd;                     
wire            inst_mret;                     
wire            inst_no_violation;             
wire            inst_vld;                      
wire            inst_wfi;                      
wire            iu_cp0_ex_csrrc;               
wire            iu_cp0_ex_csrrci;              
wire            iu_cp0_ex_csrrs;               
wire            iu_cp0_ex_csrrsi;              
wire            iu_cp0_ex_csrrw;               
wire            iu_cp0_ex_csrrwi;              
wire            iu_cp0_ex_data_sel;            
wire    [2 :0]  iu_cp0_ex_func3;               
wire            iu_cp0_ex_mret;                
wire    [4 :0]  iu_cp0_ex_rd_reg;              
wire    [4 :0]  iu_cp0_ex_rs1_reg;             
wire            iu_cp0_ex_sel;                 
wire            iu_cp0_ex_wfi;                 
wire    [11:0]  iu_cp0_imm;                    
wire            iu_cp0_oper_mux_en;            
wire    [31:0]  iu_cp0_rs1;                    
wire            iu_cp0_syc_rst_b;              
wire            iu_yy_xx_dbgon;                
wire            iui_csr_cmplt;                 
wire    [11:0]  iui_imm;                       
wire            iui_lpmd_inst_lpmd_for_data;   
wire            iui_oreg_csr_acc;              
wire            iui_oreg_expt;                 
wire    [11:0]  iui_oreg_imm;                  
wire            iui_oreg_inst_csr;             
wire            iui_oreg_inst_mret;            
wire            iui_oreg_nmi_mret;             
wire            iui_oreg_rd_x0;                
wire    [31:0]  iui_oreg_rs1;                  
wire    [31:0]  iui_oreg_rs1_raw;              
wire            iui_oreg_rs1_x0;               
wire    [31:0]  iui_oreg_tval;                 
wire    [31:0]  iui_rs1;                       
wire    [31:0]  iui_uimm;                      
wire            lpmd_iui_stall;                
wire    [31:0]  marchid_value;                 
wire    [31:0]  mcause_value;                  
wire    [31:0]  mclicbase_value;               
wire    [31:0]  mcpuid_value;                  
wire    [31:0]  mcycle_value;                  
wire    [31:0]  mcycleh_value;                 
wire    [31:0]  mepc_value;                    
wire    [31:0]  mexstatus_value;               
wire    [31:0]  mhartid_value;                 
wire    [31:0]  mhcr_value;                    
wire    [31:0]  mie_value;                     
wire    [31:0]  mimpid_value;                  
wire    [31:0]  minstret_value;                
wire    [31:0]  minstreth_value;               
wire    [31:0]  mintstatus_value;              
wire    [31:0]  mip_value;                     
wire    [31:0]  misa_value;                    
wire    [31:0]  mnmicause_value;               
wire    [31:0]  mnmipc_value;                  
wire    [31:0]  mnxti_value;                   
wire    [31:0]  mraddr_value;                  
wire    [31:0]  mscratch_value;                
wire    [31:0]  mscratchcsw_value;             
wire    [31:0]  mscratchcswl_value;            
wire    [31:0]  mstatus_value;                 
wire    [31:0]  mtval_value;                   
wire    [31:0]  mtvec_value;                   
wire    [31:0]  mtvt_value;                    
wire    [31:0]  mvendorid_value;               
wire    [31:0]  mxstatus_value;                
wire            no_expt_vld;                   
wire    [1 :0]  oreg_iui_priv_mode;            
wire            oreg_iui_wr_rdonly;            
wire    [31:0]  pmp_cp0_data;                  
wire            rs1_vld;                       
wire            srst_iui_stall;                
wire            srst_iui_stall_noinput;        
wire            status_xx_nmi;                 
wire            wsc_inv;                       


//==========================================================
//                Define the CSR ADDR
//==========================================================
parameter MSTATUS   = 12'h300;
parameter MISA      = 12'h301;
parameter MIE       = 12'h304;
parameter MTVEC     = 12'h305;
parameter MSCRATCH  = 12'h340;
parameter MEPC      = 12'h341;
parameter MCAUSE    = 12'h342;
parameter MTVAL     = 12'h343;
parameter MIP       = 12'h344;
parameter MCYCLE    = 12'hB00;
parameter MINSTRET  = 12'hB02;
parameter MCYCLEH   = 12'hB80; // RV32I only?
parameter MINSTRETH = 12'hB82; // RV32I only?
parameter MVENDORID = 12'hF11;
parameter MARCHID   = 12'hF12;
parameter MIMPID    = 12'hF13;
parameter MHARTID   = 12'hF14;
parameter MCPUID    = 12'hFC0;
parameter MXSTATUS  = 12'h7c0;
parameter MHCR      = 12'h7C1;
parameter PMPCFG0   = 12'h3A0;
parameter PMPCFG1   = 12'h3A1;
parameter PMPCFG2   = 12'h3A2;
parameter PMPCFG3   = 12'h3A3;
parameter PMPADDR0  = 12'h3B0;
parameter PMPADDR1  = 12'h3B1;
parameter PMPADDR2  = 12'h3B2;
parameter PMPADDR3  = 12'h3B3;
parameter PMPADDR4  = 12'h3B4;
parameter PMPADDR5  = 12'h3B5;
parameter PMPADDR6  = 12'h3B6;
parameter PMPADDR7  = 12'h3B7;
parameter PMPADDR8  = 12'h3B8;
parameter PMPADDR9  = 12'h3B9;
parameter PMPADDR10 = 12'h3BA;
parameter PMPADDR11 = 12'h3BB;
parameter PMPADDR12 = 12'h3BC;
parameter PMPADDR13 = 12'h3BD;
parameter PMPADDR14 = 12'h3BE;
parameter PMPADDR15 = 12'h3BF;
parameter PMPTEECFG = 12'hBEF;
parameter MTVT      = 12'h307;
parameter MNXTI     = 12'h345;
parameter MINTSTATUS = 12'h346;
parameter MSCRATCHCSW  = 12'h348;
parameter MSCRATCHCSWL = 12'h349;
parameter MCLICBASE    = 12'h350;
parameter MRADDR    = 12'h7E0;
parameter MEXSTATUS = 12'h7E1;
parameter MNMICAUSE = 12'h7E2;
parameter MNMIPC    = 12'h7E3;

//==========================================================
//            Handling the CP0 select signal
//==========================================================
assign cp0_select   = iu_cp0_ex_sel;

//==========================================================
//              CP0 operand mux
//==========================================================
assign rs1_vld       = iu_cp0_oper_mux_en && iu_cp0_syc_rst_b;
assign imm_vld       = iu_cp0_oper_mux_en;
assign iui_rs1[31:0] = {32{rs1_vld}} & iu_cp0_rs1[31:0];
assign iui_imm[11:0] = {12{imm_vld}} & iu_cp0_imm[11:0];
assign iui_uimm[4:0] = { 5{imm_vld}} & iu_cp0_ex_rs1_reg[4:0];
assign iui_uimm[31:5] = 27'b0;
assign iui_oreg_rs1_x0 = (inst_csrrs || inst_csrrc || inst_csrrsi || inst_csrrci) && (iu_cp0_ex_rs1_reg[4:0] == 5'b0);
assign iui_oreg_rd_x0  = iu_cp0_ex_rd_reg[4:0] == 5'b0;
//==========================================================
//                Qualify CP0 instructions
//==========================================================
assign inst_no_violation = 1'b1;
assign inst_vld    = cp0_select && inst_no_violation;
//instruction valid are selected when psr_s is high or debug mode
assign inst_mret   = inst_vld && iu_cp0_ex_mret && !iu_yy_xx_dbgon;   
assign inst_wfi    = inst_vld && iu_cp0_ex_wfi;  
assign inst_csrrw  = inst_vld && iu_cp0_ex_csrrw;
assign inst_csrrs  = inst_vld && iu_cp0_ex_csrrs;
assign inst_csrrc  = inst_vld && iu_cp0_ex_csrrc;
assign inst_csrrwi = inst_vld && iu_cp0_ex_csrrwi;
assign inst_csrrsi = inst_vld && iu_cp0_ex_csrrsi;
assign inst_csrrci = inst_vld && iu_cp0_ex_csrrci;

assign inst_csr    = inst_csrrw  || inst_csrrs  || inst_csrrc
                  || inst_csrrwi || inst_csrrsi || inst_csrrci;
assign inst_csrsc  = inst_csrrs  || inst_csrrc  || inst_csrrsi || inst_csrrci;

assign no_expt_vld = inst_csrsc && iui_uimm[4:0] == 5'b0;
assign cp0_expt_vld = oreg_iui_wr_rdonly && !no_expt_vld || csr_imm_inv;
//assign iui_oreg_mret_for_data = iu_cp0_ex_data_sel && iu_cp0_ex_mret;

// oreg signals
assign csrrw_rs1[31:0]  = iui_rs1[31:0];
assign csrrs_rs1[31:0]  = data_out[31:0] |   iui_rs1[31:0];
assign csrrc_rs1[31:0]  = data_out[31:0] & (~iui_rs1[31:0]);
assign csrrwi_rs1[31:0] = iui_uimm[31:0];
assign csrrsi_rs1[31:0] = data_out[31:0] |   iui_uimm[31:0];
assign csrrci_rs1[31:0] = data_out[31:0] & (~iui_uimm[31:0]);

assign iui_oreg_rs1[31:0] = {32{iu_cp0_ex_csrrw}}  & csrrw_rs1[31:0]
                          | {32{iu_cp0_ex_csrrs}}  & csrrs_rs1[31:0]
                          | {32{iu_cp0_ex_csrrc}}  & csrrc_rs1[31:0]
                          | {32{iu_cp0_ex_csrrwi}} & csrrwi_rs1[31:0]
                          | {32{iu_cp0_ex_csrrsi}} & csrrsi_rs1[31:0]
                          | {32{iu_cp0_ex_csrrci}} & csrrci_rs1[31:0];
assign iui_oreg_rs1_raw[31:0] = csrrw_rs1[31:0];

assign iui_oreg_imm[11:0] = iui_imm[11:0];
assign iui_oreg_inst_csr  = cp0_select && inst_csr && !no_expt_vld;
assign iui_oreg_inst_mret = cp0_select && inst_mret;
assign iui_oreg_nmi_mret  = cp0_select && inst_mret && status_xx_nmi;
assign iui_oreg_csr_acc   = cp0_select && inst_csr;

assign iui_oreg_expt = cp0_expt_vld;
assign iui_oreg_tval[31:0] = {iui_imm[11:0], iu_cp0_ex_rs1_reg[4:0], iu_cp0_ex_func3[2:0], iu_cp0_ex_rd_reg[4:0], 7'b1110011};

//low power instruction
// &Force("output","inst_lpmd"); @189
assign inst_lpmd   = inst_wfi;
assign iui_lpmd_inst_lpmd_for_data = inst_no_violation && iu_cp0_ex_wfi;

assign cp0_iu_stall = (lpmd_iui_stall || srst_iui_stall) && iu_cp0_ex_data_sel;
assign cp0_iu_stall_noinput = (lpmd_iui_stall || srst_iui_stall_noinput) && iu_cp0_ex_data_sel;

//==========================================================
//              Handling the CP0 Complete Signal
//==========================================================
//all cp0 instruction can be completed when there is no operation
//in BIU and can enter into low power mode
assign cp0_inst_cmplt  = cp0_select && !(lpmd_iui_stall || srst_iui_stall);
assign cp0_iu_req      = cp0_inst_cmplt;
assign cp0_iu_expt_vld = cp0_select && cp0_expt_vld;

assign cp0_iu_expt_vec[4:0] = 5'b10;

assign cp0_iu_inst_mret = cp0_select && inst_mret;

//==========================================================
//               Generate Data from CP0 to IU
//==========================================================
// &CombBeg; @212
always @( mnmicause_value[31:0]
       or mcycleh_value[31:0]
       or mtval_value[31:0]
       or mie_value[31:0]
       or mcpuid_value[31:0]
       or mstatus_value[31:0]
       or mhcr_value[31:0]
       or mcycle_value[31:0]
       or mraddr_value[31:0]
       or iui_imm[11:0]
       or mscratch_value[31:0]
       or mimpid_value[31:0]
       or mip_value[31:0]
       or mcause_value[31:0]
       or mintstatus_value[31:0]
       or mtvt_value[31:0]
       or mscratchcswl_value[31:0]
       or mvendorid_value[31:0]
       or pmp_cp0_data[31:0]
       or mepc_value[31:0]
       or minstreth_value[31:0]
       or marchid_value[31:0]
       or mxstatus_value[31:0]
       or mexstatus_value[31:0]
       or mscratchcsw_value[31:0]
       or mtvec_value[31:0]
       or mnmipc_value[31:0]
       or mclicbase_value[31:0]
       or misa_value[31:0]
       or mhartid_value[31:0]
       or minstret_value[31:0])
begin
  case(iui_imm[11:0])
    MSTATUS   : data_out[31:0] = mstatus_value[31:0];
    MISA      : data_out[31:0] = misa_value[31:0];   
    MIE       : data_out[31:0] = mie_value[31:0];   
    MTVEC     : data_out[31:0] = mtvec_value[31:0];   
    MSCRATCH  : data_out[31:0] = mscratch_value[31:0];
    MEPC      : data_out[31:0] = mepc_value[31:0];
    MCAUSE    : data_out[31:0] = mcause_value[31:0];
    MTVAL     : data_out[31:0] = mtval_value[31:0];
    MIP       : data_out[31:0] = mip_value[31:0];
    MCYCLE    : data_out[31:0] = mcycle_value[31:0];
    MINSTRET  : data_out[31:0] = minstret_value[31:0];
    MCYCLEH   : data_out[31:0] = mcycleh_value[31:0];
    MINSTRETH : data_out[31:0] = minstreth_value[31:0];
    MVENDORID : data_out[31:0] = mvendorid_value[31:0];
    MARCHID   : data_out[31:0] = marchid_value[31:0];
    MIMPID    : data_out[31:0] = mimpid_value[31:0];
    MHARTID   : data_out[31:0] = mhartid_value[31:0];
    MCPUID    : data_out[31:0] = mcpuid_value[31:0];
    MHCR      : data_out[31:0] = mhcr_value[31:0];
    MRADDR    : data_out[31:0] = mraddr_value[31:0];
    MEXSTATUS : data_out[31:0] = mexstatus_value[31:0];
    PMPCFG0   : data_out[31:0] = pmp_cp0_data[31:0];
    PMPCFG1   : data_out[31:0] = pmp_cp0_data[31:0];
    PMPCFG2   : data_out[31:0] = pmp_cp0_data[31:0];
    PMPCFG3   : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR0  : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR1  : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR2  : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR3  : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR4  : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR5  : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR6  : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR7  : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR8  : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR9  : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR10 : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR11 : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR12 : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR13 : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR14 : data_out[31:0] = pmp_cp0_data[31:0];
    PMPADDR15 : data_out[31:0] = pmp_cp0_data[31:0];
    MTVT      : data_out[31:0] = mtvt_value[31:0];
    MNXTI     : data_out[31:0] = mstatus_value[31:0];
    MINTSTATUS: data_out[31:0] = mintstatus_value[31:0];
    MSCRATCHCSW:  data_out[31:0] = mscratchcsw_value[31:0];
    MSCRATCHCSWL: data_out[31:0] = mscratchcswl_value[31:0];
    MCLICBASE:    data_out[31:0] = mclicbase_value[31:0];
    MXSTATUS    : data_out[31:0] = mxstatus_value[31:0];
    MNMICAUSE  : data_out[31:0] = mnmicause_value[31:0];
    MNMIPC     : data_out[31:0] = mnmipc_value[31:0];
    default   : data_out[31:0] = 32'b0;  
  endcase
// &CombEnd; @302
end

// &CombBeg; @304
always @( iui_imm[11:0])
begin
  case(iui_imm[11:0])
    MSTATUS   : imm_inv = 1'b0; 
    MISA      : imm_inv = 1'b0; 
    MIE       : imm_inv = 1'b0; 
    MTVEC     : imm_inv = 1'b0; 
    MSCRATCH  : imm_inv = 1'b0; 
    MEPC      : imm_inv = 1'b0; 
    MCAUSE    : imm_inv = 1'b0; 
    MTVAL     : imm_inv = 1'b0; 
    MIP       : imm_inv = 1'b0; 
    MCYCLE    : imm_inv = 1'b0; 
    MINSTRET  : imm_inv = 1'b0; 
    MCYCLEH   : imm_inv = 1'b0; 
    MINSTRETH : imm_inv = 1'b0; 
    MVENDORID : imm_inv = 1'b0; 
    MARCHID   : imm_inv = 1'b0; 
    MIMPID    : imm_inv = 1'b0; 
    MHARTID   : imm_inv = 1'b0;
    MCPUID    : imm_inv = 1'b0;
    MHCR      : imm_inv = 1'b0;
    MRADDR    : imm_inv = 1'b0;
    MEXSTATUS : imm_inv = 1'b0;
    PMPCFG0   : imm_inv = 1'b0;
    PMPCFG1   : imm_inv = 1'b0;
    PMPCFG2   : imm_inv = 1'b0;
    PMPCFG3   : imm_inv = 1'b0;
    PMPADDR0  : imm_inv = 1'b0;
    PMPADDR1  : imm_inv = 1'b0;
    PMPADDR2  : imm_inv = 1'b0;
    PMPADDR3  : imm_inv = 1'b0;
    PMPADDR4  : imm_inv = 1'b0;
    PMPADDR5  : imm_inv = 1'b0;
    PMPADDR6  : imm_inv = 1'b0;
    PMPADDR7  : imm_inv = 1'b0;
    PMPADDR8  : imm_inv = 1'b0;
    PMPADDR9  : imm_inv = 1'b0;
    PMPADDR10 : imm_inv = 1'b0;
    PMPADDR11 : imm_inv = 1'b0;
    PMPADDR12 : imm_inv = 1'b0;
    PMPADDR13 : imm_inv = 1'b0;
    PMPADDR14 : imm_inv = 1'b0;
    PMPADDR15 : imm_inv = 1'b0;
    PMPTEECFG : imm_inv = 1'b0;
    MTVT        : imm_inv = 1'b0;
    MNXTI       : imm_inv = 1'b0;
    MINTSTATUS  : imm_inv = 1'b0;
    MSCRATCHCSW : imm_inv = 1'b0;
    MSCRATCHCSWL: imm_inv = 1'b0;
    MCLICBASE   : imm_inv = 1'b0;
    MNMICAUSE  : imm_inv = 1'b0;
    MNMIPC     : imm_inv = 1'b0;
    default   : imm_inv = 1'b1; 
  endcase
// &CombEnd; @399
end
assign csr_imm_inv = wsc_inv || (inst_csr && (imm_inv || ((oreg_iui_priv_mode[1:0] < 2'b11) && !iu_yy_xx_dbgon)));
assign wsc_inv = 1'b0;
//==========================================================
//           Debug Level Control to IU 
//==========================================================
assign cp0_iu_dbg_disable_for_tee = 1'b0;

//==========================================================
//           Generate data valid signal to IU 
//==========================================================
//if there is a mfcr instruction, data valid 
assign cp0_iu_data_vld = (inst_csrsc || iu_cp0_ex_rd_reg[4:0] != 5'b0) &&
                         !cp0_expt_vld;

assign cp0_iu_data[31:0] = iui_imm[11:0] == MNXTI ? mnxti_value[31:0]
                                                  : data_out[31:0];

//==========================================================
//                 generate cp0 flush                   
//==========================================================
//cp0 will generate flush if
//1.mret
//2.CSR write: 
assign cp0_mret_flush  = inst_mret;
assign cp0_csr_flush   = inst_csr;

assign cp0_iu_flush = cp0_mret_flush || cp0_csr_flush;
//==========================================================
//                 CP0 change flow
//==========================================================
//cpu need to fetch instruction after flush, so cp0 flush 
//needs to change flow
assign cp0_iu_rte_chgflw_vld            = inst_mret;
assign cp0_iu_rte_chgflw_vld_for_data   = iu_cp0_ex_data_sel && iu_cp0_ex_mret;

assign iui_csr_cmplt          = inst_csr;
assign cp0_iu_flush_chgflw_vld = iui_csr_cmplt;



// &ModuleEnd; @500
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module cr_cp0_lpmd(
  cache_cp0_lpmd_ack,
  cp0_cache_lpmd_req,
  cp0_had_lpmd_b,
  cp0_ifu_in_lpmd,
  cp0_ifu_lpmd_req,
  cp0_sysio_ipend_b,
  cp0_sysio_lpmd_b,
  cp0_yy_clk_en,
  cpurst_b,
  forever_cpuclk,
  had_yy_xx_dbg,
  ifu_cp0_lpmd_ack,
  inst_lpmd,
  iu_cp0_ex_sel,
  iu_cp0_lp_wk_int,
  iu_yy_xx_dbgon,
  iu_yy_xx_flush,
  iui_lpmd_inst_lpmd_for_data,
  lpmd_iui_stall,
  lpmd_sm_clk,
  lpmd_sm_clk_en,
  pad_yy_gate_clk_en_b,
  status_lpmd_lpmd,
  sysio_cp0_sys_view_lpmd_b
);

// &Ports; @25
input          cache_cp0_lpmd_ack;         
input          cpurst_b;                   
input          forever_cpuclk;             
input          had_yy_xx_dbg;              
input          ifu_cp0_lpmd_ack;           
input          inst_lpmd;                  
input          iu_cp0_ex_sel;              
input          iu_cp0_lp_wk_int;           
input          iu_yy_xx_dbgon;             
input          iu_yy_xx_flush;             
input          iui_lpmd_inst_lpmd_for_data; 
input          lpmd_sm_clk;                
input          pad_yy_gate_clk_en_b;       
input   [1:0]  status_lpmd_lpmd;           
input   [1:0]  sysio_cp0_sys_view_lpmd_b;  
output         cp0_cache_lpmd_req;         
output  [1:0]  cp0_had_lpmd_b;             
output         cp0_ifu_in_lpmd;            
output         cp0_ifu_lpmd_req;           
output         cp0_sysio_ipend_b;          
output  [1:0]  cp0_sysio_lpmd_b;           
output         cp0_yy_clk_en;              
output         lpmd_iui_stall;             
output         lpmd_sm_clk_en;             

// &Regs; @26
reg     [1:0]  cur_state;                  
reg     [1:0]  lpmd_b;                     
reg     [1:0]  next_state;                 

// &Wires; @27
wire           cache_cp0_lpmd_ack;         
wire           cp0_cache_lpmd_req;         
wire    [1:0]  cp0_had_lpmd_b;             
wire           cp0_ifu_in_lpmd;            
wire           cp0_ifu_lpmd_req;           
wire           cp0_sysio_ipend_b;          
wire    [1:0]  cp0_sysio_lpmd_b;           
wire           cp0_yy_clk_en;              
wire           cpu_in_lpmd;                
wire           cpu_in_lpmd_core_view;      
wire           cpu_in_lpmd_sys_view;       
wire           cpurst_b;                   
wire           forever_cpuclk;             
wire           had_yy_xx_dbg;              
wire           ifu_cp0_lpmd_ack;           
wire           inst_lpmd;                  
wire           iu_cp0_ex_sel;              
wire           iu_cp0_lp_wk_int;           
wire           iu_yy_xx_dbgon;             
wire           iu_yy_xx_flush;             
wire           iui_lpmd_inst_lpmd_for_data; 
wire           lpmd_ack;                   
wire           lpmd_clk;                   
wire           lpmd_clk_en;                
wire           lpmd_in_wait_state;         
wire           lpmd_iui_stall;             
wire           lpmd_sm_clk;                
wire           lpmd_sm_clk_en;             
wire           lpmd_start;                 
wire           pad_yy_gate_clk_en_b;       
wire    [1:0]  status_lpmd_lpmd;           
wire    [1:0]  sys_lpmd_b;                 
wire    [1:0]  sysio_cp0_sys_view_lpmd_b;  


parameter IDLE   = 2'b00;
parameter WFACK  = 2'b01;
parameter WFCPLT = 2'b11;
parameter CPLT   = 2'b10;

//==========================================================
//                 Instance of Gated Cell  
//==========================================================
assign lpmd_sm_clk_en = iu_cp0_ex_sel || (cur_state != IDLE); 

assign lpmd_clk_en = had_yy_xx_dbg || iu_cp0_lp_wk_int || iu_yy_xx_dbgon
                     || lpmd_start;
// &Instance("gated_clk_cell", "x_lpmd_gated_clk"); @41
gated_clk_cell  x_lpmd_gated_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (lpmd_clk            ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (1'b0                ),
  .module_en            (lpmd_clk_en         ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk), @42
//          .external_en (1'b0), @43
//          .global_en   (1'b1), @44
//          .module_en   (lpmd_clk_en), @45
//          .local_en    (1'b0), @46
//          .clk_out     (lpmd_clk)); @47

//-----------------------------------------------
//   Handling the low power operating modes
//-----------------------------------------------

//-----------------------------------------------------
// Request the BIU to enter low power mode and do
// not accept any more transaction from IFU or LSU
//-----------------------------------------------------

//-------------------FSM of lpmd req logic-----------------
// State Description:
// IDLE     : no lpmd instruction (wait,stop,doze)
// WFACK    : request sysio and wait for sysio ack
//           the lpmd request        
//-----------------------------------------------------

always @(posedge lpmd_sm_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    cur_state[1:0] <= IDLE;
  else if(iu_yy_xx_flush)
    cur_state[1:0] <= IDLE;
  else
    cur_state[1:0] <= next_state[1:0];
end

// &CombBeg; @75
always @( cur_state
       or lpmd_start
       or inst_lpmd
       or cpu_in_lpmd)
begin
  case(cur_state)
  IDLE       : if(inst_lpmd)
                next_state = WFACK;
              else
                next_state = IDLE;
  WFACK      : if(lpmd_start)
                next_state = WFCPLT;
              else
                next_state = WFACK;
  WFCPLT    : if(!cpu_in_lpmd)
                next_state = CPLT;
              else
                next_state = WFCPLT;
  CPLT      :   next_state = IDLE;
  default   :   next_state = IDLE;
  endcase
// &CombEnd; @92
end

assign lpmd_in_wait_state = (cur_state == WFACK);

//-------------------control signal by lpmd FSM-------------
assign lpmd_iui_stall = (cur_state == IDLE) && iui_lpmd_inst_lpmd_for_data 
                        || (cur_state == WFACK)
                        || (cur_state == WFCPLT);
//req if entering into WFACK state
//in CK802, lsu transfer will take up EX stage, when low power
//instruction executing, no load/store is in process, so do not
//need handshake with LSU
assign cp0_ifu_lpmd_req = lpmd_in_wait_state;
assign cp0_cache_lpmd_req = lpmd_in_wait_state;

//-----------------------------------------------------
//               lpmd request ack 
//-----------------------------------------------------
assign lpmd_ack = ifu_cp0_lpmd_ack && cache_cp0_lpmd_ack;
assign lpmd_start = lpmd_ack;

//-----------------------------------------------------
// Send lpmd bits to BIU and HAD, when
// cp0 can enter low power mode (get sysio_cp0_no_op)
//-----------------------------------------------------
// &Force("output","cp0_sysio_lpmd_b"); @117

always @(posedge lpmd_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    lpmd_b[1:0] <= 2'b11;
  else if(had_yy_xx_dbg || iu_cp0_lp_wk_int || iu_yy_xx_dbgon)
    lpmd_b[1:0] <= 2'b11;
  else if(lpmd_start && !cpu_in_lpmd)
  begin
    lpmd_b[1:0] <= status_lpmd_lpmd[1:0];
  end
  else
    lpmd_b[1:0] <= lpmd_b[1:0];
end

assign cp0_had_lpmd_b[1:0] = lpmd_b[1:0];
assign cp0_sysio_lpmd_b[1:0] = lpmd_b[1:0];
//the cpu condsider both pm bit in cp0(cpu view) and sysio(soc view)
assign sys_lpmd_b[1:0] = sysio_cp0_sys_view_lpmd_b[1:0];
assign cpu_in_lpmd_sys_view = !(sys_lpmd_b[1] & sys_lpmd_b[0]);
//cpu ack in debug mode
assign cpu_in_lpmd_core_view = !(lpmd_b[1] & lpmd_b[0]);

assign cpu_in_lpmd = cpu_in_lpmd_sys_view || cpu_in_lpmd_core_view;

//Indicate in lpmd mode for IFU request mask
assign cp0_ifu_in_lpmd  = cpu_in_lpmd;

//======================================================
//Generate clock enable signal to clock module
//Disable the clock when low power mode is entered
//======================================================
// &Force("output","cp0_yy_clk_en"); @150
assign cp0_yy_clk_en = !cpu_in_lpmd;

//--------------------------------------------------------
//Indicate that an asynchronous raw interrupt request 
//has been recognized internally by the processor.
//--------------------------------------------------------
assign cp0_sysio_ipend_b = !iu_cp0_lp_wk_int;

// &ModuleEnd; @159
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// &ModuleBeg; @25
module cr_cp0_oreg(
  cp0_had_cpuid_idx0,
  cp0_ifu_rst_inv_done,
  cp0_iu_cache_inv_done,
  cp0_iu_epc_for_chgflw,
  cp0_iu_meie,
  cp0_iu_vbr,
  cp0_iu_vec_mode,
  cp0_pmp_csr_sel,
  cp0_pmp_csr_wen,
  cp0_pmp_updt_data,
  cp0_vector_vec_err_vbr,
  cp0_yy_be_v1,
  cp0_yy_be_v2,
  cpurst_b,
  forever_cpuclk,
  had_iu_force_dbg_en,
  ifu_cp0_rst_inv_req,
  iu_cp0_ecall,
  iu_cp0_epc,
  iu_cp0_epc_update,
  iu_cp0_ex_data_sel,
  iu_cp0_ex_sel,
  iu_cp0_expt_tval,
  iu_cp0_expt_vld,
  iu_cp0_int_vld,
  iu_cp0_lockup_clr,
  iu_cp0_lockup_vld,
  iu_cp0_mtval_updt_vld,
  iu_cp0_nmi_vld,
  iu_cp0_nt_int_pending_vld,
  iu_cp0_syc_rst_b,
  iu_yy_xx_dbgon,
  iu_yy_xx_int_hv,
  iu_yy_xx_int_pending_hv,
  iu_yy_xx_int_pending_id,
  iu_yy_xx_int_pending_il,
  iu_yy_xx_int_pending_priv,
  iui_oreg_csr_acc,
  iui_oreg_expt,
  iui_oreg_imm,
  iui_oreg_inst_csr,
  iui_oreg_inst_mret,
  iui_oreg_nmi_mret,
  iui_oreg_rs1,
  iui_oreg_rs1_raw,
  iui_oreg_tval,
  marchid_value,
  mclicbase_value,
  mcpuid_value,
  mcycle_value,
  mcycleh_value,
  mepc_value,
  mexstatus_local_en,
  mexstatus_sel,
  mhartid_value,
  mhcr_value,
  mie_value,
  mimpid_value,
  minstret_value,
  minstreth_value,
  mip_value,
  misa_value,
  mnmicause_local_en,
  mnmipc_value,
  mnxti_value,
  mnxti_vld_int_pending,
  mraddr_value,
  mscratch_value,
  mscratchcsw_value,
  mscratchcswl_value,
  mtval_value,
  mtvec_value,
  mtvt_value,
  mvendorid_value,
  oreg_clk,
  oreg_clk_en,
  oreg_iui_priv_mode,
  oreg_iui_wr_rdonly,
  oreg_status_mode,
  status_oreg_intr,
  status_oreg_mil,
  status_oreg_mpil,
  status_oreg_mpp,
  status_oreg_mxstatus_t,
  status_oreg_pm,
  status_oreg_vector,
  sysio_cp0_bigend,
  sysio_cp0_clkratio,
  sysio_cp0_endian_v2,
  sysio_cp0_rst_addr,
  tcip_cp0_clic_base,
  vector_cp0_vec_err,
  vector_cp0_vec_err_epc,
  vector_cp0_vec_succeed
);

// &Ports; @26
input           cpurst_b;                 
input           forever_cpuclk;           
input           had_iu_force_dbg_en;      
input           ifu_cp0_rst_inv_req;      
input           iu_cp0_ecall;             
input   [30:0]  iu_cp0_epc;               
input           iu_cp0_epc_update;        
input           iu_cp0_ex_data_sel;       
input           iu_cp0_ex_sel;            
input   [31:0]  iu_cp0_expt_tval;         
input           iu_cp0_expt_vld;          
input           iu_cp0_int_vld;           
input           iu_cp0_lockup_clr;        
input           iu_cp0_lockup_vld;        
input           iu_cp0_mtval_updt_vld;    
input           iu_cp0_nmi_vld;           
input           iu_cp0_nt_int_pending_vld; 
input           iu_cp0_syc_rst_b;         
input           iu_yy_xx_dbgon;           
input           iu_yy_xx_int_hv;          
input           iu_yy_xx_int_pending_hv;  
input   [9 :0]  iu_yy_xx_int_pending_id;  
input   [7 :0]  iu_yy_xx_int_pending_il;  
input   [1 :0]  iu_yy_xx_int_pending_priv; 
input           iui_oreg_csr_acc;         
input           iui_oreg_expt;            
input   [11:0]  iui_oreg_imm;             
input           iui_oreg_inst_csr;        
input           iui_oreg_inst_mret;       
input           iui_oreg_nmi_mret;        
input   [31:0]  iui_oreg_rs1;             
input   [31:0]  iui_oreg_rs1_raw;         
input   [31:0]  iui_oreg_tval;            
input           oreg_clk;                 
input   [1 :0]  oreg_iui_priv_mode;       
input           status_oreg_intr;         
input   [7 :0]  status_oreg_mil;          
input   [7 :0]  status_oreg_mpil;         
input   [1 :0]  status_oreg_mpp;          
input           status_oreg_mxstatus_t;   
input   [1 :0]  status_oreg_pm;           
input   [9 :0]  status_oreg_vector;       
input           sysio_cp0_bigend;         
input   [2 :0]  sysio_cp0_clkratio;       
input           sysio_cp0_endian_v2;      
input   [31:0]  sysio_cp0_rst_addr;       
input   [31:0]  tcip_cp0_clic_base;       
input           vector_cp0_vec_err;       
input   [29:0]  vector_cp0_vec_err_epc;   
input           vector_cp0_vec_succeed;   
output  [31:0]  cp0_had_cpuid_idx0;       
output          cp0_ifu_rst_inv_done;     
output          cp0_iu_cache_inv_done;    
output  [30:0]  cp0_iu_epc_for_chgflw;    
output          cp0_iu_meie;              
output  [29:0]  cp0_iu_vbr;               
output  [1 :0]  cp0_iu_vec_mode;          
output  [11:0]  cp0_pmp_csr_sel;          
output          cp0_pmp_csr_wen;          
output  [31:0]  cp0_pmp_updt_data;        
output  [29:0]  cp0_vector_vec_err_vbr;   
output          cp0_yy_be_v1;             
output          cp0_yy_be_v2;             
output  [31:0]  marchid_value;            
output  [31:0]  mclicbase_value;          
output  [31:0]  mcpuid_value;             
output  [31:0]  mcycle_value;             
output  [31:0]  mcycleh_value;            
output  [31:0]  mepc_value;               
output          mexstatus_local_en;       
output          mexstatus_sel;            
output  [31:0]  mhartid_value;            
output  [31:0]  mhcr_value;               
output  [31:0]  mie_value;                
output  [31:0]  mimpid_value;             
output  [31:0]  minstret_value;           
output  [31:0]  minstreth_value;          
output  [31:0]  mip_value;                
output  [31:0]  misa_value;               
output          mnmicause_local_en;       
output  [31:0]  mnmipc_value;             
output  [31:0]  mnxti_value;              
output          mnxti_vld_int_pending;    
output  [31:0]  mraddr_value;             
output  [31:0]  mscratch_value;           
output  [31:0]  mscratchcsw_value;        
output  [31:0]  mscratchcswl_value;       
output  [31:0]  mtval_value;              
output  [31:0]  mtvec_value;              
output  [31:0]  mtvt_value;               
output  [31:0]  mvendorid_value;          
output          oreg_clk_en;              
output          oreg_iui_wr_rdonly;       
output  [1 :0]  oreg_status_mode;         

// &Regs; @27
reg     [29:0]  cp0_iu_vbr;               
reg     [31:0]  cpuid_value;              
reg     [1 :0]  index;                    
reg             int_hv;                   
reg     [63:0]  mcycle_reg;               
reg     [31:0]  mscratch_reg;             
reg     [31:0]  mtval_value;              
reg     [29:0]  nt_base;                  
reg             nt_meie;                  
reg     [30:0]  nt_mepc;                  
reg     [30:0]  nt_mnmipc;                
reg     [25:0]  nt_mtvt;                  

// &Wires; @28
wire    [29:0]  base;                     
wire    [2 :0]  clk_ratio;                
wire    [31:0]  cp0_had_cpuid_idx0;       
wire            cp0_ifu_rst_inv_done;     
wire            cp0_iu_cache_inv_done;    
wire    [30:0]  cp0_iu_epc_for_chgflw;    
wire            cp0_iu_meie;              
wire    [1 :0]  cp0_iu_vec_mode;          
wire    [11:0]  cp0_pmp_csr_sel;          
wire            cp0_pmp_csr_wen;          
wire    [31:0]  cp0_pmp_updt_data;        
wire    [29:0]  cp0_vector_vec_err_vbr;   
wire            cp0_yy_be_v1;             
wire            cp0_yy_be_v2;             
wire    [31:0]  cpuid_index0_value;       
wire    [31:0]  cpuid_index1_value;       
wire    [31:0]  cpuid_index2_value;       
wire            cpurst_b;                 
wire            csr_wen;                  
wire            expt_int_epc_update_vld;  
wire            forever_cpuclk;           
wire            had_iu_force_dbg_en;      
wire    [29:0]  hv_base;                  
wire            ie;                       
wire            index_max;                
wire    [1 :0]  index_next_val;           
wire            intr;                     
wire            inv_sm_clk_en;            
wire            iu_cp0_ecall;             
wire    [30:0]  iu_cp0_epc;               
wire            iu_cp0_epc_update;        
wire            iu_cp0_ex_data_sel;       
wire            iu_cp0_ex_sel;            
wire    [31:0]  iu_cp0_expt_tval;         
wire            iu_cp0_expt_vld;          
wire            iu_cp0_int_vld;           
wire            iu_cp0_lockup_clr;        
wire            iu_cp0_lockup_vld;        
wire            iu_cp0_mtval_updt_vld;    
wire            iu_cp0_nmi_vld;           
wire            iu_cp0_nt_int_pending_vld; 
wire            iu_cp0_syc_rst_b;         
wire            iu_yy_xx_dbgon;           
wire            iu_yy_xx_int_hv;          
wire            iu_yy_xx_int_pending_hv;  
wire    [9 :0]  iu_yy_xx_int_pending_id;  
wire    [7 :0]  iu_yy_xx_int_pending_il;  
wire    [1 :0]  iu_yy_xx_int_pending_priv; 
wire            iui_oreg_csr_acc;         
wire            iui_oreg_expt;            
wire    [11:0]  iui_oreg_imm;             
wire            iui_oreg_inst_csr;        
wire            iui_oreg_inst_mret;       
wire            iui_oreg_nmi_mret;        
wire    [31:0]  iui_oreg_rs1;             
wire    [31:0]  iui_oreg_rs1_raw;         
wire    [31:0]  iui_oreg_tval;            
wire            marchid_local_en;         
wire    [31:0]  marchid_value;            
wire    [31:0]  mclicbase_value;          
wire            mcpuid_local_en;          
wire    [31:0]  mcpuid_value;             
wire            mcpuid_wen;               
wire            mcycle_local_en;          
wire    [31:0]  mcycle_value;             
wire            mcycleh_local_en;         
wire    [31:0]  mcycleh_value;            
wire            meie;                     
wire            mepc_local_en;            
wire    [31:0]  mepc_value;               
wire    [30:0]  mepc_value_31;            
wire            mexstatus_local_en;       
wire            mexstatus_sel;            
wire            mhartid_local_en;         
wire    [31:0]  mhartid_value;            
wire    [31:0]  mhcr_value;               
wire            mie_local_en;             
wire    [31:0]  mie_value;                
wire    [7 :0]  mil;                      
wire            mimpid_local_en;          
wire    [31:0]  mimpid_value;             
wire    [31:0]  minstret_value;           
wire    [31:0]  minstreth_value;          
wire    [31:0]  mip_value;                
wire            misa_m;                   
wire            misa_user_mode;           
wire    [31:0]  misa_value;               
wire            mnmicause_local_en;       
wire    [31:0]  mnmipc_value;             
wire    [31:0]  mnxti_value;              
wire            mnxti_vld_int_pending;    
wire    [1 :0]  mode;                     
wire    [7 :0]  mpil;                     
wire    [1 :0]  mpp;                      
wire    [31:0]  mraddr_value;             
wire            mscratch_local_en;        
wire    [31:0]  mscratch_value;           
wire            mscratchcsw_local_en;     
wire            mscratchcsw_swap_en;      
wire    [31:0]  mscratchcsw_value;        
wire            mscratchcswl_local_en;    
wire            mscratchcswl_swap_en;     
wire    [31:0]  mscratchcswl_value;       
wire    [31:0]  mtval_expt_update;        
wire            mtval_local_en;           
wire            mtvec_local_en;           
wire    [31:0]  mtvec_value;              
wire            mtvt_local_en;            
wire    [31:0]  mtvt_value;               
wire    [25:0]  mtvt_value_26;            
wire            mvendorid_local_en;       
wire    [31:0]  mvendorid_value;          
wire            mxstatus_t;               
wire            nmi_epc_update_vld;       
wire    [29:0]  nt_base_pre;              
wire            nt_meip;                  
wire            nt_mepc_local_en;         
wire            nt_mie_local_en;          
wire            nt_mnmipc_local_en;       
wire    [1 :0]  nt_mode;                  
wire            nt_mtvec_local_en;        
wire            nt_mtvt_local_en;         
wire            oreg_clk;                 
wire            oreg_clk_en;              
wire    [1 :0]  oreg_iui_priv_mode;       
wire            oreg_iui_wr_rdonly;       
wire    [1 :0]  oreg_status_mode;         
wire            pad_cpu_secu_dbg_en;      
wire    [1 :0]  pm;                       
wire            status_oreg_intr;         
wire    [7 :0]  status_oreg_mil;          
wire    [7 :0]  status_oreg_mpil;         
wire    [1 :0]  status_oreg_mpp;          
wire            status_oreg_mxstatus_t;   
wire    [1 :0]  status_oreg_pm;           
wire    [9 :0]  status_oreg_vector;       
wire    [2 :0]  sysio_cp0_clkratio;       
wire    [31:0]  sysio_cp0_rst_addr;       
wire            t_nt_mie_local_en;        
wire            t_nt_mip_local_en;        
wire            t_ntmepc_local_en;        
wire            t_ntmtvec_local_en;       
wire            t_ntmtvt_local_en;        
wire    [31:0]  tcip_cp0_clic_base;       
wire    [29:0]  vec_adder_base;           
wire    [29:0]  vec_adder_vbr;            
wire    [9 :0]  vec_adder_vec;            
wire    [9 :0]  vector;                   
wire            vector_cp0_vec_err;       
wire    [29:0]  vector_cp0_vec_err_epc;   
wire            vector_cp0_vec_succeed;   
wire            vld_int_pending;          


parameter MSTATUS   = 12'h300;
parameter MISA      = 12'h301;
parameter MIE       = 12'h304;
parameter MTVEC     = 12'h305;
parameter MSCRATCH  = 12'h340;
parameter MEPC      = 12'h341;
parameter MCAUSE    = 12'h342;
parameter MTVAL     = 12'h343;
parameter MIP       = 12'h344;
parameter MCYCLE    = 12'hB00;
parameter MINSTRET  = 12'hB02;
parameter MCYCLEH   = 12'hB80; // RV32I only?
parameter MINSTRETH = 12'hB82; // RV32I only?
parameter MVENDORID = 12'hF11;
parameter MARCHID   = 12'hF12;
parameter MIMPID    = 12'hF13;
parameter MHARTID   = 12'hF14;

parameter MHCR      = 12'h7C1;

parameter MCPUID    = 12'hFC0;
parameter MTVT      = 12'h307;
parameter MNXTI     = 12'h345;
parameter MINTSTATUS   = 12'h346;
parameter MSCRATCHCSW  = 12'h348;
parameter MSCRATCHCSWL = 12'h349;
parameter MCLICBASE    = 12'h350;

parameter MRADDR    = 12'h7E0;
parameter MEXSTATUS = 12'h7E1;
parameter MNMICAUSE = 12'h7E2;
parameter MNMIPC    = 12'h7E3;

//==========================================================
//                 Instance of Gated Cell  
//==========================================================
//oreg share the same clock with psr
assign oreg_clk_en = csr_wen 
                     || iu_cp0_expt_vld
                     || iui_oreg_inst_mret 
                     || iu_cp0_epc_update 
                     || vector_cp0_vec_succeed 
                     || vector_cp0_vec_err 
                     || iu_cp0_mtval_updt_vld
                     || pad_cpu_secu_dbg_en
                     || had_iu_force_dbg_en
                     || inv_sm_clk_en
                     || iu_cp0_lockup_clr
                     || iu_cp0_lockup_vld;
//==========================================================
//   Generate endian mode and dcache enable to LSU
//==========================================================


// &Force("bus","iui_oreg_rs1",31,0); @109
// &Force("bus","had_cp0_psr_data",31,0); @110
// &Force("bus","iu_yy_xx_expt_vec",7,0); @111
assign csr_wen = iui_oreg_inst_csr && iu_cp0_syc_rst_b && ((oreg_iui_priv_mode[1:0] == 2'b11) || iu_yy_xx_dbgon);
assign nt_mtvec_local_en  = !mxstatus_t  && mtvec_local_en   || t_ntmtvec_local_en;
assign nt_mepc_local_en   = !mxstatus_t  && mepc_local_en    || t_ntmepc_local_en;
assign nt_mie_local_en    = !mxstatus_t  && mie_local_en     || t_nt_mie_local_en;
assign mie_local_en       = csr_wen && iui_oreg_imm[11:0] == MIE;       
assign mtvec_local_en     = csr_wen && iui_oreg_imm[11:0] == MTVEC;     
assign mepc_local_en      = csr_wen && iui_oreg_imm[11:0] == MEPC;      
// &Force("nonport", "t_nt_mip_local_en"); @119
assign mvendorid_local_en = csr_wen && iui_oreg_imm[11:0] == MVENDORID; 
assign marchid_local_en   = csr_wen && iui_oreg_imm[11:0] == MARCHID;   
assign mimpid_local_en    = csr_wen && iui_oreg_imm[11:0] == MIMPID;    
assign mhartid_local_en   = csr_wen && iui_oreg_imm[11:0] == MHARTID;   
assign mcpuid_local_en    = iui_oreg_imm[11:0] == MCPUID;
assign mexstatus_local_en = csr_wen && iui_oreg_imm[11:0] == MEXSTATUS;   
assign mexstatus_sel      = iu_cp0_ex_data_sel && iui_oreg_imm[11:0] == MEXSTATUS;
assign mtval_local_en     = csr_wen && iui_oreg_imm[11:0] == MTVAL;     
assign mscratch_local_en  = csr_wen && iui_oreg_imm[11:0] == MSCRATCH;  
assign mcycle_local_en    = csr_wen && iui_oreg_imm[11:0] == MCYCLE;  
assign mcycleh_local_en   = csr_wen && iui_oreg_imm[11:0] == MCYCLEH;  
assign mtvt_local_en      = csr_wen && iui_oreg_imm[11:0] == MTVT;
assign nt_mtvt_local_en   = mtvt_local_en && !mxstatus_t || t_ntmtvt_local_en;
assign mscratchcsw_local_en  = csr_wen && iui_oreg_imm[11:0] == MSCRATCHCSW;
assign mscratchcswl_local_en = csr_wen && iui_oreg_imm[11:0] == MSCRATCHCSWL;
assign t_ntmtvec_local_en     = 1'b0;
assign t_ntmepc_local_en      = 1'b0;
assign t_nt_mie_local_en      = 1'b0;
assign t_nt_mip_local_en      = 1'b0;

assign nt_mnmipc_local_en    = csr_wen && iui_oreg_imm[11:0] == MNMIPC;
assign mnmicause_local_en = csr_wen && iui_oreg_imm[11:0] == MNMICAUSE;

//assign t_ntmcause_local_en    = 1'b0;
assign t_ntmtvt_local_en      = 1'b0;
assign oreg_iui_wr_rdonly = //misa_local_en || mip_local_en || mcycle_local_en
                         //|| minstret_local_en || mcycleh_local_en 
                         //|| minstreth_local_en || 
                            mvendorid_local_en 
                         || marchid_local_en || mimpid_local_en || mhartid_local_en;


//==========================================================
//               Define the MISA register
//==========================================================
assign misa_value[31:0] = 
// [31:30]          [20]             [12]          [4]         [2]
//  RV32              U               M             E           C
  {2'b1, 9'b0, misa_user_mode, 7'b0, misa_m, 7'b0, 1'b1, 1'b0, 1'b1, 2'b0};
assign misa_user_mode = 1'b1;   
assign misa_m         = 1'b1;   



//==========================================================
//               Define the MTVEC register
//==========================================================
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    nt_base[29:0] <= 30'b0;
  else if(nt_mtvec_local_en)
    nt_base[29:0] <= nt_base_pre[29:0];
  else
    nt_base[29:0] <= nt_base[29:0];
end
assign nt_base_pre[29:0] = mode[1] ? {iui_oreg_rs1[31:6],nt_base[3:0]} : iui_oreg_rs1[31:2];
// &Force("output","nt_mtvec_value"); @236
assign nt_mode = 2'b11;
assign base[29:0]        = {nt_base[29:4], 4'b0};

assign mtvec_value[31:0] = {nt_base[29:0], mode[1:0]};
assign mode[1:0]         = nt_mode[1:0];
//==========================================================
//               Define the MEPC register
//==========================================================
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    nt_mepc[30:0] <= 31'b0;
  else if(expt_int_epc_update_vld)
    nt_mepc[30:0] <= iu_cp0_epc[30:0];
  else if(vector_cp0_vec_err&& !mxstatus_t)
    nt_mepc[30:0] <= {vector_cp0_vec_err_epc[29:0],1'b0};
  else if (iu_cp0_expt_vld && iui_oreg_nmi_mret)
    nt_mepc[30:0] <= nt_mepc[30:0];
  else if (iui_oreg_nmi_mret)
    nt_mepc[30:0] <= nt_mnmipc[30:0];
  else if(nt_mepc_local_en&& !mxstatus_t)
    nt_mepc[30:0] <= iui_oreg_rs1[31:1];
  else
    nt_mepc[30:0] <= nt_mepc[30:0];
end
assign mepc_value[31:0] = {nt_mepc[30:0], 1'b0};
assign mepc_value_31[30:0] = nt_mepc[30:0];
assign expt_int_epc_update_vld  = ((iu_cp0_expt_vld && !iui_oreg_inst_mret) 
                                  || iu_cp0_epc_update) && !mxstatus_t;


always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    nt_mnmipc[30:0] <= 31'b0;
  else if(nt_mepc_local_en&& !mxstatus_t && nmi_epc_update_vld)
    nt_mnmipc[30:0] <= iui_oreg_rs1[31:1];
  else if(nmi_epc_update_vld)
    nt_mnmipc[30:0] <= nt_mepc[30:0];
  else if (nt_mnmipc_local_en && !mxstatus_t)
    nt_mnmipc[30:0] <= iui_oreg_rs1[31:1];
  else
    nt_mnmipc[30:0] <= nt_mnmipc[30:0];
end
assign mnmipc_value[31:0] = {nt_mnmipc[30:0], 1'b0};
assign nmi_epc_update_vld = iu_cp0_nmi_vld && !iui_oreg_inst_mret;
//==========================================================
//               Define the MSCRATCH register
//==========================================================
// &Force("output", "mscratch_value"); @346
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    mscratch_reg[31:0] <= 32'b0;
  else if(mscratch_local_en)
    mscratch_reg[31:0] <= iui_oreg_rs1[31:0];
  else if(mscratchcsw_swap_en || mscratchcswl_swap_en)
    mscratch_reg[31:0] <= iui_oreg_rs1[31:0];
  else
    mscratch_reg[31:0] <= mscratch_reg[31:0];
end
assign mscratch_value[31:0] = mscratch_reg[31:0];

//==========================================================
//               Define the MTVT register in CLIC mode
//==========================================================
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    nt_mtvt[25:0] <= 26'b0;
  else if(nt_mtvt_local_en)
    nt_mtvt[25:0] <= iui_oreg_rs1[31:6];
  else
    nt_mtvt[25:0] <= nt_mtvt[25:0];
end
// &Force("nonport","hv_base"); @395
assign mtvt_value[31:0]  = {nt_mtvt[25:0],6'b0};
assign mtvt_value_26[25:0]        = nt_mtvt[25:0];
assign mnxti_value[31:0] = (mode[1:0] == 2'b11) ? vld_int_pending ?  {hv_base[29:0],2'b0} : 32'b0 : 32'b0;
assign vld_int_pending   = (iu_yy_xx_int_pending_il[7:0] > mpil[7:0]) 
                            && (iu_yy_xx_int_pending_priv[1:0] == 2'b11) 
                            && !iu_yy_xx_int_pending_hv;
assign mnxti_vld_int_pending = vld_int_pending && !iu_cp0_nmi_vld; //write csr inst will definitly write the mie
assign mpil[7:0]             = status_oreg_mpil[7:0];
assign mil[7:0]              = status_oreg_mil[7:0];
assign pm[1:0]               = status_oreg_pm[1:0];
assign mpp[1:0]              = status_oreg_mpp[1:0];
assign mscratchcsw_swap_en = mscratchcsw_local_en && mpp[1:0] != pm[1:0];
assign mscratchcsw_value[31:0] = mscratchcsw_swap_en ? mscratch_reg[31:0]
                                                     : iui_oreg_rs1_raw[31:0];

assign mscratchcswl_swap_en = mscratchcswl_local_en && ((mil[7:0] == 8'b0) ^ (mpil[7:0] == 8'b0));
assign mscratchcswl_value[31:0] = mscratchcswl_swap_en ? mscratch_reg[31:0]
                                                       : iui_oreg_rs1_raw[31:0];
assign mclicbase_value[31:0] = tcip_cp0_clic_base[31:0];
//==========================================================
//               Define the MTVAL register
//==========================================================
// &Force("input", "iu_cp0_expt_tval"); @422
// &Force("input", "iu_cp0_ecall"); @423
// &Force("input", "iu_cp0_mtval_updt_vld"); @424
// &Force("input", "iui_oreg_expt"); @425
// &Force("input", "iui_oreg_tval"); @426
// &Force("bus", "iu_cp0_expt_tval",31,0); @427
// &Force("bus", "iui_oreg_tval",31,0); @428
// &Force("output", "mtval_value"); @431
assign mtval_expt_update[31:0] = (iu_cp0_int_vld || iu_cp0_ecall && iu_cp0_ex_sel) ? 
                                  32'b0 : iui_oreg_expt ? iui_oreg_tval[31:0]
                                                       : iu_cp0_expt_tval[31:0];
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    mtval_value[31:0] <= 32'b0;
  else if(iu_cp0_mtval_updt_vld)
    mtval_value[31:0] <= mtval_expt_update[31:0];
  else if(mtval_local_en)
    mtval_value[31:0] <= iui_oreg_rs1[31:0];
  else
    mtval_value[31:0] <= mtval_value[31:0];
end
//==========================================================
//               Define the MIE register
//==========================================================
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    nt_meie <= 1'b0;
  else if(nt_mie_local_en)
    nt_meie <= (mode[1] == 1'b0) ? iui_oreg_rs1[11] : nt_meie;
  else
    nt_meie <= nt_meie;
end
assign mie_value[31:0]    = mode[1] ? 32'b0 : {20'b0, nt_meie, 3'b0, 1'b0 , 3'b0, 1'b0, 3'b0};
assign meie               = nt_meie;
//always @(posedge oreg_clk or negedge cpurst_b)
//begin
//  if(!cpurst_b)
//    nt_meip <= 1'b0;
//  else if(mode[1] == 1'b0)
//    nt_meip <= iu_cp0_nt_int_pending_vld;
//end
assign nt_meip = iu_cp0_nt_int_pending_vld && (mode[1] == 1'b0);

assign mip_value[31:0]    = mode[1] ? 32'b0 : {20'b0, nt_meip, 3'b0, 1'b0 , 3'b0, 1'b0, 3'b0};

//always @(posedge oreg_clk or negedge cpurst_b)
//begin
//  if(!cpurst_b)
//    mtie <= 1'b0;
//  else if(mie_local_en)
//    mtie <= iui_oreg_rs1[7];
//  else
//    mtie <= mtie;
//end
//
//always @(posedge oreg_clk or negedge cpurst_b)
//begin
//  if(!cpurst_b)
//    msie <= 1'b0;
//  else if(mie_local_en)
//    msie <= iui_oreg_rs1[3];
//  else
//    msie <= msie;
//end
//assign mie_value[31:0]  = {20'b0, meie, 3'b0, 1'b0 , 3'b0, 1'b0, 3'b0};

//==========================================================
//               Define the MIP register
//==========================================================
//always @(posedge oreg_clk or negedge cpurst_b)
//begin
//  if(!cpurst_b)
//    meip <= 1'b0;
//  else if(iu_cp0_int_pending)
//    meip <= 1'b1;
//  else if(iu_cp0_int_vld)
//    meip <= 1'b0;
//  else
//    meip <= meip;
//end
//always @(posedge oreg_clk or negedge cpurst_b)
//begin
//  if(!cpurst_b)
//    mtip <= 1'b0;
//  else if(iu_cp0_int_pending) // todo
//    mtip <= 1'b1;
//  else
//    mtip <= mtip;
//end
//always @(posedge oreg_clk or negedge cpurst_b)
//begin
//  if(!cpurst_b)
//    msip <= 1'b0;
//  else if(iu_cp0_int_pending)
//    msip <= 1'b1;
//  else
//    msip <= msip;
//end
////assign mip_value[31:0] = {20'b0, meip, 3'b0, mtip, 3'b0, msip, 3'b0};
//// currently only meip is useful
//assign mip_value[31:0] = {20'b0, meip, 3'b0, 1'b0, 3'b0, 1'b0, 3'b0};
//==========================================================
//               Machine SP define
//               
//=========================================================
//assign cp0_iu_nt_user_sp_we = 1'b0;
//assign cp0_iu_reg_write_data[31:0] = 32'b0;
//==========================================================
//               Define CSKY TEE registers
//               Define the MEBR register
//=========================================================
// &Force("output","mebr_value"); @612
assign pad_cpu_secu_dbg_en = 1'b0;

//==========================================================
//               Define the MCYLE register
//==========================================================
always @(posedge forever_cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    mcycle_reg[63:0] <= 64'b0;
  else if(mcycle_local_en)
    mcycle_reg[63:0] <= {mcycle_reg[63:32], iui_oreg_rs1[31:0]};
  else if(mcycleh_local_en)
    mcycle_reg[63:0] <= {iui_oreg_rs1[31:0], mcycle_reg[31:0]};
  else
    mcycle_reg[63:0] <= mcycle_reg[63:0] + 1'b1;
end
assign mcycle_value[31:0]  = mcycle_reg[31:0];
assign mcycleh_value[31:0] = mcycle_reg[63:32];

//==========================================================
//               Define the MINSTRET register
//==========================================================
assign minstret_value[31:0]  = 32'b0;
assign minstreth_value[31:0] = 32'b0;

//==========================================================
//               Define the ID Registers
//==========================================================

assign mvendorid_value[31:0] = 32'h5B7; 
assign mimpid_value[31:0]    = 32'b0; 
assign mhartid_value[31:0]   = 32'b0; 

//==========================================================
//               Define the MARCHID register
//==========================================================
assign marchid_value[31:0] = 32'b0;

//==========================================================
//               Define the MRADDR register
//==========================================================
assign mraddr_value[31:0] = sysio_cp0_rst_addr[31:0];

//==========================================================
//               Define the cpuid register
//==========================================================

//----------------------------------------------------------
//                    Index Register
//----------------------------------------------------------
assign index_max = (index[1:0] == 2'd2);
assign index_next_val[1:0] = (index_max) ? 2'd0
                                         : index[1:0] + 2'd1;
assign mcpuid_wen = iui_oreg_csr_acc && iu_cp0_syc_rst_b && ((oreg_iui_priv_mode[1:0] == 2'b11) || iu_yy_xx_dbgon);

always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    begin
      index[1:0] <= 2'b0;
    end
  else if (mcpuid_wen && mcpuid_local_en)
    begin
      index[1:0] <= index_next_val[1:0];
    end
  else
    begin
      index[1:0] <= index[1:0];
    end
end

//----------------------------------------------------------
//                Implement of cpuid register
//----------------------------------------------------------
// &CombBeg; @720
always @( cpuid_index1_value[31:0]
       or cpuid_index0_value[31:0]
       or index[1:0]
       or cpuid_index2_value[31:0])
begin
  case(index[1:0])
  2'b00   : cpuid_value[31:0] = cpuid_index0_value[31:0];
  2'b01   : cpuid_value[31:0] = cpuid_index1_value[31:0];
  2'b10   : cpuid_value[31:0] = cpuid_index2_value[31:0];
  default : cpuid_value[31:0] = 32'bx;
  endcase
// &CombEnd; @727
end

//---------------------------------------------------------
//                    Index 0
//---------------------------------------------------------
    assign cpuid_index0_value[31:28] = 4'b0000;

//------------------------------------------------
//                     Arch  
//------------------------------------------------
    assign cpuid_index0_value[27:26] = 2'b10; // CSKY V3 instruction set

//------------------------------------------------
//                     Family
//------------------------------------------------
    assign cpuid_index0_value[25:22] = 4'b0000; // E Series

//------------------------------------------------
//                     Class 
//------------------------------------------------
    assign cpuid_index0_value[21:18] = 4'b0001; // E902

//------------------------------------------------
//                     Model 
//------------------------------------------------
    assign cpuid_index0_value[17:10] = 8'b0; 
  
    assign cpuid_index0_value[9] = 1'b0;

    assign cpuid_index0_value[8] = 1'b0; 

//------------------------------------------------
//                   ISA Revision
//------------------------------------------------
    assign cpuid_index0_value[7:3] = 5'b00001; 

//------------------------------------------------
//                     Version
//------------------------------------------------
    assign cpuid_index0_value[2:0] = 3'b101; //CPID Rev.5

//---------------------------------------------------------
//                    Index 1
//---------------------------------------------------------
    assign cpuid_index1_value[31:28] = 4'b0001;

//------------------------------------------------
//                    Revision
//------------------------------------------------
    assign cpuid_index1_value[27:24] = `REVISION;

//------------------------------------------------
//                  Sub Revision
//------------------------------------------------
    assign cpuid_index1_value[23:18] = `SUB_VERSION;

//------------------------------------------------
//                     Patch
//------------------------------------------------
    assign cpuid_index1_value[17:12] = `PATCH;


//------------------------------------------------
//                     PRODUCT ID 
//------------------------------------------------
    assign cpuid_index1_value[11:0] = `PRODUCT_ID; 

//------------------------------------------------
//                    Index 2
//------------------------------------------------
    assign cpuid_index2_value[31:28] = 4'b0010;

//------------------------------------------------
//                    IBUS
//------------------------------------------------
    assign cpuid_index2_value[27:26] = 2'b01;

//------------------------------------------------
//                    DBUS
//------------------------------------------------
    assign cpuid_index2_value[25:24] = 2'b00;

//------------------------------------------------
//                    SBUS
//------------------------------------------------
    assign cpuid_index2_value[23:21] = 3'b001;

//------------------------------------------------
//                    Reserved
//------------------------------------------------
    assign cpuid_index2_value[20:16] = 5'b0;

//------------------------------------------------
//                    INTC
//------------------------------------------------
    assign cpuid_index2_value[15:12] = 4'b1111;

//------------------------------------------------
//                  DCACHE 
//------------------------------------------------
    assign cpuid_index2_value[11:9] = 3'b0;

//------------------------------------------------
//                  ICACHE
//------------------------------------------------
    assign cpuid_index2_value[8:6] = 3'b0;

//------------------------------------------------
//                   PMP zone size
//------------------------------------------------
    assign cpuid_index2_value[5:3] = 3'b111; // 4B

//------------------------------------------------
//                   MGU zone num
//------------------------------------------------
    assign cpuid_index2_value[2:0] = 3'b011;
assign mcpuid_value[31:0] = cpuid_value[31:0];
// &Force("bus", "iui_regs_wdata", 31, 0); @892

//==========================================================
//               Define the MHCR register
//  Machine Hardwire Control Register
//  32-bit Machine Mode Read/Write
//  the definiton for MHSR register is listed as follows
//==========================================================
assign clk_ratio[2:0] = sysio_cp0_clkratio[2:0];

assign ie = 1'b0;

assign mhcr_value[31:0] = {13'b0, clk_ratio[2:0], 15'b0, ie};

// &CombBeg; @937
// &CombEnd; @958
// &Force("bus", "iu_cp0_rs1", 31, 0); @965
// &Force("input","ifu_cp0_rst_inv_req"); @971
assign cp0_ifu_rst_inv_done     = 1'b1;
assign cp0_iu_cache_inv_done    = 1'b1;
assign inv_sm_clk_en            = 1'b0;

//==========================================================
//               Output to lpmd
//==========================================================
// &Force("nonport","meie"); @983
assign cp0_iu_meie = meie;
//==========================================================
//               Output to IU
//==========================================================
assign vector[9:0]                 = status_oreg_vector[9:0];
assign intr                        = status_oreg_intr;
// &Force("output","cp0_iu_vbr"); @993
//=======================
//// clic int hv flop
////
//=======================
//the other signals: id, il will be floped by mcause and int status
//th hv should also be floped,
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    int_hv <= 1'b0;
  else if(iu_cp0_expt_vld)
    int_hv <= iu_yy_xx_int_hv;
  else 
    int_hv <= int_hv;
end

// &CombBeg; @1010
always @( intr
       or vec_adder_vbr[29:0]
       or base[29:0]
       or mode[1:0]
       or int_hv)
begin
case({intr,mode[1:0]})
3'b100:cp0_iu_vbr[29:0] = base[29:0];
3'b101:cp0_iu_vbr[29:0] = vec_adder_vbr[29:0];
3'b111:cp0_iu_vbr[29:0] = int_hv ? vec_adder_vbr[29:0] : {base[29:4],4'b0};
// 3'b111:cp0_iu_vbr[29:0] = vec_adder_vbr[29:0];
3'b000:cp0_iu_vbr[29:0] = base[29:0];
3'b001:cp0_iu_vbr[29:0] = base[29:0];
// 3'b010:cp0_iu_vbr[29:0] = {base[29:4],4'b0};
3'b011:cp0_iu_vbr[29:0] = {base[29:4],4'b0};
default: cp0_iu_vbr[29:0] = {30{1'bx}};
endcase
// &CombEnd; @1022
end
assign vec_adder_base[29:0]        = mode[1] ? {mtvt_value_26[25:0],4'b0} : base[29:0];
assign vec_adder_vec[9:0]          = mode[1] ? vld_int_pending ? iu_yy_xx_int_pending_id[9:0] : vector[9:0] 
                                             : {6'b0,vector[3:0]};
assign vec_adder_vbr[29:0]         = vec_adder_base[29:0] + {20'b0, vec_adder_vec[9:0]};
assign hv_base[29:0]               = vec_adder_vbr[29:0];
assign cp0_vector_vec_err_vbr[29:0] = {base[29:4],4'b0};
assign cp0_iu_epc_for_chgflw[30:0] = mepc_value_31[30:0]; 
// all interrups are external now
//assign cp0_iu_ie_for_int           = iui_oreg_inst_mret ? mpie && meie 
//                                                        : mie && meie;
assign oreg_status_mode[1:0]       = mode[1:0];

assign cp0_iu_vec_mode[1:0]        = mode[1:0];
assign mxstatus_t                  = status_oreg_mxstatus_t;
//==========================================================
//               Output to PMP
//==========================================================
assign cp0_pmp_csr_wen         = csr_wen;
assign cp0_pmp_csr_sel[11:0]   = iui_oreg_imm[11:0];
assign cp0_pmp_updt_data[31:0] = iui_oreg_rs1[31:0];


//==========================================================
//               Output to HAD
//==========================================================
assign cp0_had_cpuid_idx0[31:0] = cpuid_index0_value[31:0];
//assign cp0_had_psr_data[31:0]      = 32'b0;
//assign cp0_had_spsr_data[31:0]     = 32'b0;

//==========================================================
//               Output to Pad
//================secu_mode_aft_dbg================================
// assign cp0_pad_psr[31:0]           = mstatus_value[31:0];

//assign cp0_yy_supv_mode_aft_dbg    = 1'b0;
//assign iu_cp0_int_pending = 1'b0;
// &Force("input", "sysio_cp0_bigend"); @1069
// &Force("input", "sysio_cp0_clkratio"); @1070
// &Force("bus", "sysio_cp0_clkratio", 2, 0); @1071
// &Force("input", "sysio_cp0_endian_v2"); @1072
assign cp0_yy_be_v1 = 1'b0; 
assign cp0_yy_be_v2 = 1'b0; 

// &ModuleEnd; @1076
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module cr_cp0_randclk(
  randclk_psr_mod_en_w13
);

// &Ports; @25
output       randclk_psr_mod_en_w13; 

// &Regs; @26

// &Wires; @27
wire         randclk_psr_mod_en_w13; 


// &Force("bus","seu_cp0_randclk_mod_en",31,0); @31

//assign randclk_oreg_vec_mod_en_w22 = 1'b0;
//assign randclk_psr_c_mod_en_w2     = 1'b0;
assign randclk_psr_mod_en_w13      = 1'b0;
//assign randclk_psr_epsr_mod_en_w46 = 1'b0;


// &ModuleEnd; @47
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module cr_cp0_srst(
  cache_cp0_srst_ack,
  cp0_cache_srst_req,
  cp0_ifu_srst_mask,
  cp0_ifu_srst_req,
  cp0_sysio_srst,
  cpurst_b,
  ifu_cp0_srst_ack,
  iu_cp0_ex_sel,
  iu_yy_xx_flush,
  srst_iui_stall,
  srst_iui_stall_noinput,
  srst_sm_clk,
  srst_sm_clk_en,
  status_srst_req_valid,
  status_srst_req_valid_noinput,
  status_srst_value
);

// &Ports; @25
input          cache_cp0_srst_ack;           
input          cpurst_b;                     
input          ifu_cp0_srst_ack;             
input          iu_cp0_ex_sel;                
input          iu_yy_xx_flush;               
input          srst_sm_clk;                  
input          status_srst_req_valid;        
input          status_srst_req_valid_noinput; 
input   [1:0]  status_srst_value;            
output         cp0_cache_srst_req;           
output         cp0_ifu_srst_mask;            
output         cp0_ifu_srst_req;             
output  [1:0]  cp0_sysio_srst;               
output         srst_iui_stall;               
output         srst_iui_stall_noinput;       
output         srst_sm_clk_en;               

// &Regs; @26
reg     [1:0]  cur_state;                    
reg     [1:0]  next_state;                   

// &Wires; @27
wire           cache_cp0_srst_ack;           
wire           cp0_cache_srst_req;           
wire           cp0_ifu_srst_mask;            
wire           cp0_ifu_srst_req;             
wire    [1:0]  cp0_sysio_srst;               
wire           cpurst_b;                     
wire           ifu_cp0_srst_ack;             
wire           iu_cp0_ex_sel;                
wire           iu_yy_xx_flush;               
wire           srst_ack;                     
wire           srst_cmplt;                   
wire           srst_in_wait_state;           
wire           srst_iui_stall;               
wire           srst_iui_stall_noinput;       
wire           srst_sm_clk;                  
wire           srst_sm_clk_en;               
wire           status_srst_req_valid;        
wire           status_srst_req_valid_noinput; 
wire    [1:0]  status_srst_value;            


parameter IDLE   = 2'b00;
parameter WFACK  = 2'b01;
parameter WFCPLT = 2'b10;
parameter WFRST  = 2'b11;

//==========================================================
//                 Instance of Gated Cell  
//==========================================================
assign srst_sm_clk_en = iu_cp0_ex_sel || (cur_state != IDLE); 

//-----------------------------------------------------
// Request the BIU to enter low power mode and do
// not accept any more transaction from IFU or LSU
//-----------------------------------------------------

//-------------------FSM of srst req logic-----------------
// State Description:
// IDLE     : no srst instruction (wait,stop,doze)
// WFACK    : request sysio and wait for sysio ack
//           the srst request        
//-----------------------------------------------------

always @(posedge srst_sm_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    cur_state[1:0] <= IDLE;
  else if(iu_yy_xx_flush)
    cur_state[1:0] <= IDLE;
  else
    cur_state[1:0] <= next_state[1:0];
end

// &CombBeg; @61
always @( cur_state
       or status_srst_req_valid
       or srst_ack)
begin
  case(cur_state)
  IDLE   : if(status_srst_req_valid)
             next_state = WFACK;
           else
             next_state = IDLE;
  WFACK  : if(srst_ack)
             next_state = WFCPLT;
           else
             next_state = WFACK;
  WFCPLT :   next_state = WFRST;
  WFRST  :   next_state = WFRST;
  default:   next_state = IDLE;
  endcase
// &CombEnd; @75
end

assign srst_in_wait_state = (cur_state == WFACK);
assign srst_cmplt         = (cur_state == WFCPLT);

//-------------------control signal by srst FSM-------------
assign srst_iui_stall = (cur_state == IDLE) && status_srst_req_valid
                     || (cur_state != IDLE);
assign srst_iui_stall_noinput = (cur_state == IDLE) && status_srst_req_valid_noinput
                     || (cur_state != IDLE);

assign cp0_ifu_srst_req = srst_in_wait_state;
assign cp0_cache_srst_req = srst_in_wait_state;

//-----------------------------------------------------
//               srst request ack 
//-----------------------------------------------------
assign srst_ack = ifu_cp0_srst_ack && cache_cp0_srst_ack;

assign cp0_sysio_srst[1:0] = {2{srst_cmplt}} & status_srst_value[1:0];

assign cp0_ifu_srst_mask = (cur_state == WFCPLT) || (cur_state == WFRST);

// &ModuleEnd; @98
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// &ModuleBeg; @25
module cr_cp0_status(
  clic_cpu_int_id,
  cp0_had_int_exit,
  cp0_had_mcause_data,
  cp0_iu_cskyisaee,
  cp0_iu_il,
  cp0_iu_in_expt,
  cp0_iu_in_nmi,
  cp0_iu_mie_for_int,
  cp0_iu_mret,
  cp0_iu_wfe_en,
  cp0_pad_mcause,
  cp0_pad_mintstatus,
  cp0_pad_mstatus,
  cp0_pmp_mstatus_mpp,
  cp0_pmp_mstatus_mprv,
  cp0_yy_machine_mode_aft_dbg,
  cp0_yy_priv_mode,
  cpu_clic_curid,
  cpu_clic_int_exit,
  cpurst_b,
  iu_cp0_expt_vld,
  iu_cp0_int_vld,
  iu_cp0_lockup_clr,
  iu_cp0_lockup_vld,
  iu_cp0_nmi_vld,
  iu_cp0_syc_rst_b,
  iu_yy_xx_dbgon,
  iu_yy_xx_expt_vec,
  iu_yy_xx_int_hv,
  iu_yy_xx_int_il,
  iu_yy_xx_int_pending_id,
  iu_yy_xx_int_pending_il,
  iui_oreg_imm,
  iui_oreg_inst_csr,
  iui_oreg_inst_mret,
  iui_oreg_nmi_mret,
  iui_oreg_rd_x0,
  iui_oreg_rs1,
  iui_oreg_rs1_raw,
  iui_oreg_rs1_x0,
  mcause_value,
  mexstatus_local_en,
  mexstatus_sel,
  mexstatus_value,
  mintstatus_value,
  mnmicause_local_en,
  mnmicause_value,
  mnxti_vld_int_pending,
  mstatus_value,
  mxstatus_value,
  oreg_clk,
  oreg_iui_priv_mode,
  oreg_status_mode,
  status_lpmd_lpmd,
  status_oreg_intr,
  status_oreg_mil,
  status_oreg_mpil,
  status_oreg_mpp,
  status_oreg_mxstatus_t,
  status_oreg_pm,
  status_oreg_vector,
  status_srst_req_valid,
  status_srst_req_valid_noinput,
  status_srst_value,
  status_xx_nmi,
  vector_cp0_vec_succeed
);

// &Ports; @26
input   [11:0]  clic_cpu_int_id;              
input           cpurst_b;                     
input           iu_cp0_expt_vld;              
input           iu_cp0_int_vld;               
input           iu_cp0_lockup_clr;            
input           iu_cp0_lockup_vld;            
input           iu_cp0_nmi_vld;               
input           iu_cp0_syc_rst_b;             
input           iu_yy_xx_dbgon;               
input   [9 :0]  iu_yy_xx_expt_vec;            
input           iu_yy_xx_int_hv;              
input   [7 :0]  iu_yy_xx_int_il;              
input   [9 :0]  iu_yy_xx_int_pending_id;      
input   [7 :0]  iu_yy_xx_int_pending_il;      
input   [11:0]  iui_oreg_imm;                 
input           iui_oreg_inst_csr;            
input           iui_oreg_inst_mret;           
input           iui_oreg_nmi_mret;            
input           iui_oreg_rd_x0;               
input   [31:0]  iui_oreg_rs1;                 
input   [31:0]  iui_oreg_rs1_raw;             
input           iui_oreg_rs1_x0;              
input           mexstatus_local_en;           
input           mexstatus_sel;                
input           mnmicause_local_en;           
input           mnxti_vld_int_pending;        
input           oreg_clk;                     
input   [1 :0]  oreg_status_mode;             
input           vector_cp0_vec_succeed;       
output          cp0_had_int_exit;             
output  [31:0]  cp0_had_mcause_data;          
output          cp0_iu_cskyisaee;             
output  [7 :0]  cp0_iu_il;                    
output          cp0_iu_in_expt;               
output          cp0_iu_in_nmi;                
output          cp0_iu_mie_for_int;           
output          cp0_iu_mret;                  
output          cp0_iu_wfe_en;                
output  [31:0]  cp0_pad_mcause;               
output  [31:0]  cp0_pad_mintstatus;           
output  [31:0]  cp0_pad_mstatus;              
output  [1 :0]  cp0_pmp_mstatus_mpp;          
output          cp0_pmp_mstatus_mprv;         
output          cp0_yy_machine_mode_aft_dbg;  
output  [1 :0]  cp0_yy_priv_mode;             
output  [11:0]  cpu_clic_curid;               
output          cpu_clic_int_exit;            
output  [31:0]  mcause_value;                 
output  [31:0]  mexstatus_value;              
output  [31:0]  mintstatus_value;             
output  [31:0]  mnmicause_value;              
output  [31:0]  mstatus_value;                
output  [31:0]  mxstatus_value;               
output  [1 :0]  oreg_iui_priv_mode;           
output  [1 :0]  status_lpmd_lpmd;             
output          status_oreg_intr;             
output  [7 :0]  status_oreg_mil;              
output  [7 :0]  status_oreg_mpil;             
output  [1 :0]  status_oreg_mpp;              
output          status_oreg_mxstatus_t;       
output  [1 :0]  status_oreg_pm;               
output  [9 :0]  status_oreg_vector;           
output          status_srst_req_valid;        
output          status_srst_req_valid_noinput; 
output  [1 :0]  status_srst_value;            
output          status_xx_nmi;                

// &Regs; @27
reg             intr;                         
reg             mexstatus_expt_vld;           
reg             mexstatus_lockup_vld;         
reg     [1 :0]  mexstatus_lpmd;               
reg             mexstatus_nmi_vld;            
reg     [1 :0]  mexstatus_reset_mode;         
reg             mexstatus_wfe_en;             
reg             mie;                          
reg     [7 :0]  mil;                          
reg             minhv;                        
reg             mpie;                         
reg     [7 :0]  mpil;                         
reg     [1 :0]  mpp;                          
reg             mprv;                         
reg             nmi_intr;                     
reg             nmi_mpie;                     
reg     [1 :0]  nmi_mpp;                      
reg     [9 :0]  nmi_vector;                   
reg     [1 :0]  pm;                           
reg     [9 :0]  vector;                       

// &Wires; @28
wire    [11:0]  clic_cpu_int_id;              
wire            cp0_had_int_exit;             
wire    [31:0]  cp0_had_mcause_data;          
wire            cp0_iu_cskyisaee;             
wire    [7 :0]  cp0_iu_il;                    
wire            cp0_iu_in_expt;               
wire            cp0_iu_in_nmi;                
wire            cp0_iu_mie_for_int;           
wire            cp0_iu_mret;                  
wire            cp0_iu_wfe_en;                
wire    [31:0]  cp0_pad_mcause;               
wire    [31:0]  cp0_pad_mintstatus;           
wire    [31:0]  cp0_pad_mstatus;              
wire    [1 :0]  cp0_pmp_mstatus_mpp;          
wire            cp0_pmp_mstatus_mprv;         
wire            cp0_yy_machine_mode_aft_dbg;  
wire    [1 :0]  cp0_yy_priv_mode;             
wire    [11:0]  cpu_clic_curid;               
wire            cpu_clic_int_exit;            
wire            cpurst_b;                     
wire            csr_wen;                      
wire            hw_vector_clic_on;            
wire            iu_cp0_expt_vld;              
wire            iu_cp0_int_vld;               
wire            iu_cp0_lockup_clr;            
wire            iu_cp0_lockup_vld;            
wire            iu_cp0_nmi_vld;               
wire            iu_cp0_syc_rst_b;             
wire            iu_yy_xx_dbgon;               
wire    [9 :0]  iu_yy_xx_expt_vec;            
wire            iu_yy_xx_int_hv;              
wire    [7 :0]  iu_yy_xx_int_il;              
wire    [9 :0]  iu_yy_xx_int_pending_id;      
wire    [7 :0]  iu_yy_xx_int_pending_il;      
wire    [11:0]  iui_oreg_imm;                 
wire            iui_oreg_inst_csr;            
wire            iui_oreg_inst_mret;           
wire            iui_oreg_nmi_mret;            
wire            iui_oreg_rd_x0;               
wire    [31:0]  iui_oreg_rs1;                 
wire    [31:0]  iui_oreg_rs1_raw;             
wire            iui_oreg_rs1_x0;              
wire    [1 :0]  lpmd_in;                      
wire            mcause_local_en;              
wire    [31:0]  mcause_value;                 
wire            mexstatus_local_en;           
wire            mexstatus_sel;                
wire    [31:0]  mexstatus_value;              
wire            mie_bypass;                   
wire    [7 :0]  mil_bypass;                   
wire    [31:0]  mintstatus_value;             
wire            mnmicause_local_en;           
wire    [31:0]  mnmicause_value;              
wire            mnxti_local_en;               
wire            mnxti_mstatus_local_en;       
wire            mnxti_vld_int_pending;        
wire    [1 :0]  mode;                         
wire            mstatus_local_en;             
wire    [31:0]  mstatus_value;                
wire            mxstatus_cskyisaee;           
wire            mxstatus_mspe;                
wire            mxstatus_t;                   
wire    [31:0]  mxstatus_value;               
wire            oreg_clk;                     
wire    [1 :0]  oreg_iui_priv_mode;           
wire    [1 :0]  oreg_status_mode;             
wire    [1 :0]  pm_bypass;                    
wire    [1 :0]  reset_mode_in;                
wire            status_in_nmi;                
wire    [1 :0]  status_lpmd_lpmd;             
wire            status_oreg_intr;             
wire    [7 :0]  status_oreg_mil;              
wire    [7 :0]  status_oreg_mpil;             
wire    [1 :0]  status_oreg_mpp;              
wire            status_oreg_mxstatus_t;       
wire    [1 :0]  status_oreg_pm;               
wire    [9 :0]  status_oreg_vector;           
wire            status_srst_req_valid;        
wire            status_srst_req_valid_noinput; 
wire    [1 :0]  status_srst_value;            
wire            status_xx_nmi;                
wire            vector_cp0_vec_succeed;       

parameter MSTATUS   = 12'h300;
parameter MCAUSE    = 12'h342;
parameter MNXTI     = 12'h345;
parameter MXSTATUS  = 12'h7c0;

assign csr_wen                = iui_oreg_inst_csr 
                                && iu_cp0_syc_rst_b 
                                && ((pm[1:0] == 2'b11) || iu_yy_xx_dbgon);

//===============
// csr write en 
//===============
assign mstatus_local_en       = (csr_wen && iui_oreg_imm[11:0] == MSTATUS) 
                                || (mnxti_mstatus_local_en);
assign mnxti_local_en         = mnxti_mstatus_local_en
                                && !iui_oreg_rd_x0;
assign mnxti_mstatus_local_en = csr_wen 
                                && (iui_oreg_imm[11:0] == MNXTI) 
                                && !iui_oreg_rs1_x0;
assign mode[1:0]              = oreg_status_mode[1:0];
assign mcause_local_en        = csr_wen && iui_oreg_imm[11:0] == MCAUSE;
// no further had update the status register when exit debug mode
//==========================================================
//               Define the MSTATUS register
//==========================================================
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    mpie <= 1'b0;
  else if(mstatus_local_en && iu_cp0_int_vld)
    mpie <= iui_oreg_rs1[3];
  else if((mode[1]==1'b1) && mcause_local_en && iu_cp0_int_vld)
    mpie <=iui_oreg_rs1[27];
  else if(iui_oreg_inst_mret && iu_cp0_int_vld)
    mpie <= mpie;
  else if(iu_cp0_expt_vld)
    mpie <= mie;
  else if(iui_oreg_nmi_mret)
    mpie <= nmi_mpie;
  else if(iui_oreg_inst_mret)
    mpie <= 1'b1;
  else if(mstatus_local_en)
    mpie <= iui_oreg_rs1[7];
  else if((mode[1]==1'b1) && mcause_local_en)
    mpie <=iui_oreg_rs1[27];
  else
    mpie <= mpie;
end

always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    nmi_mpie <= 1'b0;
  else if((mode[1]==1'b1) && mnmicause_local_en && iu_cp0_nmi_vld)
    nmi_mpie <=iui_oreg_rs1[27];
  else if(iui_oreg_nmi_mret && iu_cp0_nmi_vld)
    nmi_mpie <= nmi_mpie;
  else if(iu_cp0_nmi_vld)
    nmi_mpie <= mpie;
  else if(iui_oreg_nmi_mret)
    nmi_mpie <= 1'b1;
  else if((mode[1]==1'b1) && mnmicause_local_en)
    nmi_mpie <=iui_oreg_rs1[27];
  else
    nmi_mpie <= nmi_mpie;
end
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    mpp[1:0] <= 2'b11;
  else if(mstatus_local_en && iu_cp0_int_vld)
    mpp[1:0] <= pm[1:0];
  else if((mode[1]==1'b1) && mcause_local_en && iu_cp0_int_vld)
    mpp[1:0] <= {2{iui_oreg_rs1[28]}};
  else if(iui_oreg_inst_mret && iu_cp0_int_vld)
    mpp[1:0] <= mpp[1:0];
  else if(iu_cp0_expt_vld)
    mpp[1:0] <= pm[1:0];
  else if(iui_oreg_nmi_mret)
    mpp[1:0] <= nmi_mpp[1:0];
  else if(iui_oreg_inst_mret)
    mpp[1:0] <= 2'b00;
  else if(mstatus_local_en)
    mpp[1:0] <= {2{iui_oreg_rs1[11]}};
  else if((mode[1]==1'b1) && mcause_local_en)
    mpp[1:0] <= {2{iui_oreg_rs1[28]}};
  else
    mpp[1:0] <= mpp[1:0];
end

always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    nmi_mpp[1:0] <= 2'b11;
  else if((mode[1]==1'b1) && mnmicause_local_en && iu_cp0_nmi_vld)
    nmi_mpp[1:0] <= {2{iui_oreg_rs1[28]}};
  else if(iui_oreg_nmi_mret && iu_cp0_nmi_vld)
    nmi_mpp[1:0] <= nmi_mpp[1:0];
  else if(iu_cp0_nmi_vld)
    nmi_mpp[1:0] <= mpp[1:0];
  else if(iui_oreg_nmi_mret)
    nmi_mpp[1:0] <= 2'b00;
  else if((mode[1]==1'b1) && mnmicause_local_en)
    nmi_mpp[1:0] <= {2{iui_oreg_rs1[28]}};
  else
    nmi_mpp[1:0] <= nmi_mpp[1:0];
end
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    mprv <= 1'b0;
  else if(mstatus_local_en)
    mprv <= iui_oreg_rs1[17];
  else
    mprv <= mprv;
end

always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    pm[1:0] <= 2'b11;
  else if(iu_cp0_expt_vld)
    pm[1:0] <= 2'b11;
  else if(iui_oreg_inst_mret)
    pm[1:0] <= mpp[1:0];
  else
    pm[1:0] <= pm[1:0];
end
assign pm_bypass[1:0] = iui_oreg_inst_mret ? mpp[1:0]
                                           : pm[1:0];

always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    mie <= 1'b0;
  else if(iu_cp0_expt_vld)
    mie <= 1'b0;
  else if(iui_oreg_inst_mret)
    mie <= mpie;
  else if(mstatus_local_en)
    mie <= iui_oreg_rs1[3];
  else
    mie <= mie;
end
assign mie_bypass = iui_oreg_inst_mret ? mpie
                                       : mie;
// &Force("output", "mstatus_value"); @193
assign mstatus_value[31:0]  = {13'b0,1'b0,mprv,4'b0,mpp[1:0],3'b0, mpie, 3'b0, mie, 3'b0};
//==========================================================
//               Define the MCAUSE register
//==========================================================
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    intr <= 1'b0;
   else if(iu_cp0_int_vld)
    intr <= 1'b1;
  else if(iu_cp0_expt_vld)
    intr <= 1'b0;
  else if(iui_oreg_nmi_mret)
    intr <= nmi_intr;
  else if(mcause_local_en)
    intr <= iui_oreg_rs1[31];
  else
    intr <= intr;
end

assign status_oreg_intr = intr;

// When NMI hit, intr backuped in nmi_intr.
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    nmi_intr <= 1'b0;
  else if(iu_cp0_nmi_vld)
    nmi_intr <= intr;
  else if(mnmicause_local_en)
    nmi_intr <= iui_oreg_rs1[31];
  else
    nmi_intr <= nmi_intr;
end

always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    vector[9:0] <= 10'b0;
  else if (iu_cp0_nmi_vld)
    vector[9:0] <= 10'd24;
  else if(iu_cp0_expt_vld)
    vector[9:0] <= {iu_yy_xx_expt_vec[9:0]};
  else if(iui_oreg_nmi_mret)
    vector[9:0] <= nmi_vector[9:0];
  else if(mcause_local_en)
    vector[9:0] <= (mode[1]==1'b1) ? iui_oreg_rs1[9:0] : {6'b0,iui_oreg_rs1[3:0]};
  else if(mnxti_local_en && mnxti_vld_int_pending)
    vector[9:0] <= iu_yy_xx_int_pending_id[9:0];
  else
    vector[9:0] <= vector[9:0];
end
assign status_oreg_vector[9:0] = (mode[1]==1'b1) ? vector[9:0] :{6'b0,vector[3:0]};

// When NMI hit, vector backuped in nmi_vector.
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    nmi_vector[9:0] <= 10'b0;
  else if(iu_cp0_nmi_vld)
    nmi_vector[9:0] <= vector[9:0];
  else if(mnmicause_local_en)
    nmi_vector[9:0] <= (mode[1]==1'b1) ? iui_oreg_rs1[9:0] : {6'b0,iui_oreg_rs1[3:0]};
  else
    nmi_vector[9:0] <= nmi_vector[9:0];
end
// &Force("bus", "iu_yy_xx_expt_vec", 9, 0); @262

always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    minhv <= 1'b0;
  else if(mode[1]==1'b0)//Orignal vec mode
    minhv <=1'b0;
  else if(mcause_local_en)
    minhv <= iui_oreg_rs1[30];
  else if(hw_vector_clic_on)//CLICmode
    minhv <= 1'b1;
  else if(vector_cp0_vec_succeed)
    minhv <= 1'b0;
end
assign hw_vector_clic_on = iu_yy_xx_int_hv && iu_cp0_int_vld;
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    mpil[7:0] <= 8'b0;
  else if(mode[1]==1'b0)
    mpil[7:0] <= 8'b0;
  else if(iu_cp0_int_vld)
    mpil[7:0] <= mil_bypass[7:0];
  else if(mcause_local_en)
    mpil[7:0] <= iui_oreg_rs1[23:16];
  else
    mpil[7:0] <= mpil[7:0];
end
assign status_oreg_mpil[7:0] = mpil[7:0];
assign mcause_value[31:0]    = mode[1] ? {intr, minhv, mpp[1:0], mpie, 3'b0, 
                                          mpil[7:0], 6'b0, vector[9:0]}
                                       : {intr,27'b0,vector[3:0]};
assign mnmicause_value[31:0] = {nmi_intr, 1'b0, nmi_mpp[1:0], nmi_mpie, 3'b0,
                                8'b0, 6'b0, nmi_vector[9:0]};
// &Force("output", "mcause_value"); @315

always @(posedge oreg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    mil[7:0] <= 8'b0;
  else if(mode[1]==1'b0)
    mil[7:0] <= 8'b0;
   else if(iu_cp0_int_vld)
    mil[7:0] <= iu_yy_xx_int_il[7:0];
  else if(iui_oreg_inst_mret && intr)
    mil[7:0] <= mpil[7:0];
  else if(mnxti_local_en && mnxti_vld_int_pending)
    mil[7:0] <= iu_yy_xx_int_pending_il[7:0];
  else
    mil[7:0] <= mil[7:0];
end
assign mil_bypass[7:0] = iui_oreg_inst_mret && intr ? mpil[7:0]
                                                    : mil[7:0];
assign status_oreg_mil[7:0] = mil[7:0];
assign mintstatus_value[31:0] = {mil[7:0],24'b0};
// &Force("output","mintstatus_value"); @337
//===========================================
// interface to iu
//===========================================
assign cp0_iu_mie_for_int            = mie_bypass || (pm_bypass[1:0] != 2'b11);
assign cp0_iu_il[7:0]                = mil_bypass[7:0];
//===========================================
// interface to other module
//===========================================
assign status_oreg_pm[1:0]           = pm[1:0];
assign status_oreg_mpp[1:0]          = mpp[1:0];
assign cp0_yy_priv_mode[1:0]         = pm[1:0];
assign cp0_yy_machine_mode_aft_dbg   = pm[0];
assign cp0_pmp_mstatus_mpp[1:0]      = mpp[1:0];
assign cp0_pmp_mstatus_mprv          = mprv;
assign cp0_had_mcause_data[31:0]     = 32'b0;
//when TEE not implemented, this signal is not needed
assign cp0_had_int_exit              = 1'b0;
//===========================================
//  to pad
//===========================================
assign cp0_pad_mstatus[31:0]         = mstatus_value[31:0];
assign cp0_pad_mcause[31:0]          = mcause_value[31:0];
assign cp0_pad_mintstatus[31:0]      = mintstatus_value[31:0];
// to oreg 
assign status_oreg_mxstatus_t       = mxstatus_t;
assign oreg_iui_priv_mode[1:0]       = pm[1:0];
assign mxstatus_t                   = 1'b0;
assign cpu_clic_int_exit             = iu_cp0_int_vld ? iu_yy_xx_int_hv
                                                      : mnxti_local_en && mnxti_vld_int_pending;
assign cpu_clic_curid[11:0]         = clic_cpu_int_id[11:0];

//==========================================================
//               Define the MXSTATUS register
//==========================================================
// &Force("output","mxstatus_mspe"); @398
assign mxstatus_mspe = 1'b0;
assign mxstatus_cskyisaee = 1'b0;
assign mxstatus_value[31:0]  = {pm[1:0],5'b0,mxstatus_mspe,1'b0,mxstatus_cskyisaee,22'b0};
assign cp0_iu_cskyisaee = mxstatus_cskyisaee;

//==========================================================
//               Define the MEXSTATUS register
//==========================================================
assign reset_mode_in[1:0] = (&iui_oreg_rs1[1:0]) ? mexstatus_reset_mode[1:0] : iui_oreg_rs1[1:0];
assign lpmd_in[1:0]       = iui_oreg_rs1[3] ? mexstatus_lpmd[1:0] : iui_oreg_rs1[3:2];
always @(posedge oreg_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
  begin
    mexstatus_reset_mode[1:0] <= 2'b0;
    mexstatus_lpmd[1:0]       <= 2'b0;
    mexstatus_wfe_en          <= 1'b1;
  end
  else if(mexstatus_local_en)
  begin
    mexstatus_reset_mode[1:0] <= reset_mode_in[1:0];
    mexstatus_lpmd[1:0]       <= lpmd_in[1:0];
    mexstatus_wfe_en          <= iui_oreg_rs1[4];
  end
  else
  begin
    mexstatus_reset_mode[1:0] <= mexstatus_reset_mode[1:0];
    mexstatus_lpmd[1:0]       <= mexstatus_lpmd[1:0];
    mexstatus_wfe_en          <= mexstatus_wfe_en;
  end
end

always @(posedge oreg_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    mexstatus_expt_vld <= 1'b0;
  else if(iu_yy_xx_dbgon && mexstatus_local_en)
    mexstatus_expt_vld <= iui_oreg_rs1[5];
  else if(iu_cp0_lockup_clr)
    mexstatus_expt_vld <= 1'b0;
  else if(iu_cp0_expt_vld && !iu_cp0_int_vld && !iu_cp0_nmi_vld)
    mexstatus_expt_vld <= 1'b1;
  else if(iui_oreg_inst_mret && !mexstatus_nmi_vld)
    mexstatus_expt_vld <= 1'b0;
  else
    mexstatus_expt_vld <= mexstatus_expt_vld;
end

always @(posedge oreg_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    mexstatus_nmi_vld <= 1'b0;
  else if(iu_yy_xx_dbgon && mexstatus_local_en)
    mexstatus_nmi_vld <= iui_oreg_rs1[7];
  else if(iu_cp0_lockup_clr)
    mexstatus_nmi_vld <= 1'b0;
  else if(iu_cp0_nmi_vld)
    mexstatus_nmi_vld <= 1'b1;
  else if(iui_oreg_inst_mret)
    mexstatus_nmi_vld <= 1'b0;
  else
    mexstatus_nmi_vld <= mexstatus_nmi_vld;
end
assign status_in_nmi = mexstatus_nmi_vld;

always @(posedge oreg_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    mexstatus_lockup_vld <= 1'b0;
  else if(iu_cp0_lockup_clr)
    mexstatus_lockup_vld <= 1'b0;
  else if(iu_cp0_lockup_vld)
    mexstatus_lockup_vld <= 1'b1;
  else
    mexstatus_lockup_vld <= mexstatus_lockup_vld;
end

assign mexstatus_value[31:0]  = {24'b0, mexstatus_nmi_vld, mexstatus_lockup_vld, mexstatus_expt_vld, mexstatus_wfe_en,
                                 mexstatus_lpmd[1:0], mexstatus_reset_mode[1:0]};

assign status_lpmd_lpmd[1:0]  = mexstatus_lpmd[1:0];

assign status_srst_req_valid  = mexstatus_local_en && (|reset_mode_in[1:0]);
assign status_srst_req_valid_noinput = mexstatus_sel && (|iui_oreg_rs1_raw[1:0]);
// &Force("bus", "iui_oreg_rs1_raw", 31, 0); @497

assign status_srst_value[1:0] = mexstatus_reset_mode[1:0];
assign cp0_iu_wfe_en = mexstatus_wfe_en;

assign cp0_iu_in_expt = mexstatus_expt_vld && vector[3:0] != 4'd11 && vector[3:0] != 4'd3;
assign cp0_iu_in_nmi   = status_in_nmi;
assign status_xx_nmi   = status_in_nmi;
assign cp0_iu_mret     = iui_oreg_inst_mret;

// &ModuleEnd; @507
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module cr_cp0_top(
  cache_cp0_lpmd_ack,
  cache_cp0_srst_ack,
  clic_cpu_int_id,
  cp0_cache_lpmd_req,
  cp0_cache_srst_req,
  cp0_had_cpuid_idx0,
  cp0_had_int_exit,
  cp0_had_lpmd_b,
  cp0_had_mcause_data,
  cp0_ifu_in_lpmd,
  cp0_ifu_lpmd_req,
  cp0_ifu_rst_inv_done,
  cp0_ifu_srst_mask,
  cp0_ifu_srst_req,
  cp0_iu_cache_inv_done,
  cp0_iu_cskyisaee,
  cp0_iu_data,
  cp0_iu_data_vld,
  cp0_iu_dbg_disable_for_tee,
  cp0_iu_epc_for_chgflw,
  cp0_iu_expt_vec,
  cp0_iu_expt_vld,
  cp0_iu_flush,
  cp0_iu_flush_chgflw_vld,
  cp0_iu_il,
  cp0_iu_in_expt,
  cp0_iu_in_nmi,
  cp0_iu_inst_mret,
  cp0_iu_meie,
  cp0_iu_mie_for_int,
  cp0_iu_mret,
  cp0_iu_req,
  cp0_iu_rte_chgflw_vld,
  cp0_iu_rte_chgflw_vld_for_data,
  cp0_iu_stall,
  cp0_iu_stall_noinput,
  cp0_iu_vbr,
  cp0_iu_vec_mode,
  cp0_iu_wfe_en,
  cp0_pad_mcause,
  cp0_pad_mintstatus,
  cp0_pad_mstatus,
  cp0_pmp_csr_sel,
  cp0_pmp_csr_wen,
  cp0_pmp_mstatus_mpp,
  cp0_pmp_mstatus_mprv,
  cp0_pmp_updt_data,
  cp0_sysio_ipend_b,
  cp0_sysio_lpmd_b,
  cp0_sysio_srst,
  cp0_vector_vec_err_vbr,
  cp0_yy_be_v1,
  cp0_yy_be_v2,
  cp0_yy_clk_en,
  cp0_yy_machine_mode_aft_dbg,
  cp0_yy_priv_mode,
  cpu_clic_curid,
  cpu_clic_int_exit,
  cpurst_b,
  forever_cpuclk,
  had_iu_force_dbg_en,
  had_yy_xx_dbg,
  ifu_cp0_lpmd_ack,
  ifu_cp0_rst_inv_req,
  ifu_cp0_srst_ack,
  iu_cp0_ecall,
  iu_cp0_epc,
  iu_cp0_epc_update,
  iu_cp0_ex_csrrc,
  iu_cp0_ex_csrrci,
  iu_cp0_ex_csrrs,
  iu_cp0_ex_csrrsi,
  iu_cp0_ex_csrrw,
  iu_cp0_ex_csrrwi,
  iu_cp0_ex_data_sel,
  iu_cp0_ex_func3,
  iu_cp0_ex_mret,
  iu_cp0_ex_rd_reg,
  iu_cp0_ex_rs1_reg,
  iu_cp0_ex_sel,
  iu_cp0_ex_wfi,
  iu_cp0_expt_tval,
  iu_cp0_expt_vld,
  iu_cp0_imm,
  iu_cp0_int_vld,
  iu_cp0_lockup_clr,
  iu_cp0_lockup_vld,
  iu_cp0_lp_wk_int,
  iu_cp0_mtval_updt_vld,
  iu_cp0_nmi_vld,
  iu_cp0_nt_int_pending_vld,
  iu_cp0_oper_mux_en,
  iu_cp0_rs1,
  iu_cp0_syc_rst_b,
  iu_yy_xx_dbgon,
  iu_yy_xx_expt_vec,
  iu_yy_xx_flush,
  iu_yy_xx_int_hv,
  iu_yy_xx_int_il,
  iu_yy_xx_int_pending_hv,
  iu_yy_xx_int_pending_id,
  iu_yy_xx_int_pending_il,
  iu_yy_xx_int_pending_priv,
  pad_yy_gate_clk_en_b,
  pmp_cp0_data,
  sysio_cp0_bigend,
  sysio_cp0_clkratio,
  sysio_cp0_endian_v2,
  sysio_cp0_rst_addr,
  sysio_cp0_sys_view_lpmd_b,
  tcip_cp0_clic_base,
  vector_cp0_vec_err,
  vector_cp0_vec_err_epc,
  vector_cp0_vec_succeed
);

// &Ports; @25
input           cache_cp0_lpmd_ack;            
input           cache_cp0_srst_ack;            
input   [11:0]  clic_cpu_int_id;               
input           cpurst_b;                      
input           forever_cpuclk;                
input           had_iu_force_dbg_en;           
input           had_yy_xx_dbg;                 
input           ifu_cp0_lpmd_ack;              
input           ifu_cp0_rst_inv_req;           
input           ifu_cp0_srst_ack;              
input           iu_cp0_ecall;                  
input   [30:0]  iu_cp0_epc;                    
input           iu_cp0_epc_update;             
input           iu_cp0_ex_csrrc;               
input           iu_cp0_ex_csrrci;              
input           iu_cp0_ex_csrrs;               
input           iu_cp0_ex_csrrsi;              
input           iu_cp0_ex_csrrw;               
input           iu_cp0_ex_csrrwi;              
input           iu_cp0_ex_data_sel;            
input   [2 :0]  iu_cp0_ex_func3;               
input           iu_cp0_ex_mret;                
input   [4 :0]  iu_cp0_ex_rd_reg;              
input   [4 :0]  iu_cp0_ex_rs1_reg;             
input           iu_cp0_ex_sel;                 
input           iu_cp0_ex_wfi;                 
input   [31:0]  iu_cp0_expt_tval;              
input           iu_cp0_expt_vld;               
input   [11:0]  iu_cp0_imm;                    
input           iu_cp0_int_vld;                
input           iu_cp0_lockup_clr;             
input           iu_cp0_lockup_vld;             
input           iu_cp0_lp_wk_int;              
input           iu_cp0_mtval_updt_vld;         
input           iu_cp0_nmi_vld;                
input           iu_cp0_nt_int_pending_vld;     
input           iu_cp0_oper_mux_en;            
input   [31:0]  iu_cp0_rs1;                    
input           iu_cp0_syc_rst_b;              
input           iu_yy_xx_dbgon;                
input   [9 :0]  iu_yy_xx_expt_vec;             
input           iu_yy_xx_flush;                
input           iu_yy_xx_int_hv;               
input   [7 :0]  iu_yy_xx_int_il;               
input           iu_yy_xx_int_pending_hv;       
input   [9 :0]  iu_yy_xx_int_pending_id;       
input   [7 :0]  iu_yy_xx_int_pending_il;       
input   [1 :0]  iu_yy_xx_int_pending_priv;     
input           pad_yy_gate_clk_en_b;          
input   [31:0]  pmp_cp0_data;                  
input           sysio_cp0_bigend;              
input   [2 :0]  sysio_cp0_clkratio;            
input           sysio_cp0_endian_v2;           
input   [31:0]  sysio_cp0_rst_addr;            
input   [1 :0]  sysio_cp0_sys_view_lpmd_b;     
input   [31:0]  tcip_cp0_clic_base;            
input           vector_cp0_vec_err;            
input   [29:0]  vector_cp0_vec_err_epc;        
input           vector_cp0_vec_succeed;        
output          cp0_cache_lpmd_req;            
output          cp0_cache_srst_req;            
output  [31:0]  cp0_had_cpuid_idx0;            
output          cp0_had_int_exit;              
output  [1 :0]  cp0_had_lpmd_b;                
output  [31:0]  cp0_had_mcause_data;           
output          cp0_ifu_in_lpmd;               
output          cp0_ifu_lpmd_req;              
output          cp0_ifu_rst_inv_done;          
output          cp0_ifu_srst_mask;             
output          cp0_ifu_srst_req;              
output          cp0_iu_cache_inv_done;         
output          cp0_iu_cskyisaee;              
output  [31:0]  cp0_iu_data;                   
output          cp0_iu_data_vld;               
output          cp0_iu_dbg_disable_for_tee;    
output  [30:0]  cp0_iu_epc_for_chgflw;         
output  [4 :0]  cp0_iu_expt_vec;               
output          cp0_iu_expt_vld;               
output          cp0_iu_flush;                  
output          cp0_iu_flush_chgflw_vld;       
output  [7 :0]  cp0_iu_il;                     
output          cp0_iu_in_expt;                
output          cp0_iu_in_nmi;                 
output          cp0_iu_inst_mret;              
output          cp0_iu_meie;                   
output          cp0_iu_mie_for_int;            
output          cp0_iu_mret;                   
output          cp0_iu_req;                    
output          cp0_iu_rte_chgflw_vld;         
output          cp0_iu_rte_chgflw_vld_for_data; 
output          cp0_iu_stall;                  
output          cp0_iu_stall_noinput;          
output  [29:0]  cp0_iu_vbr;                    
output  [1 :0]  cp0_iu_vec_mode;               
output          cp0_iu_wfe_en;                 
output  [31:0]  cp0_pad_mcause;                
output  [31:0]  cp0_pad_mintstatus;            
output  [31:0]  cp0_pad_mstatus;               
output  [11:0]  cp0_pmp_csr_sel;               
output          cp0_pmp_csr_wen;               
output  [1 :0]  cp0_pmp_mstatus_mpp;           
output          cp0_pmp_mstatus_mprv;          
output  [31:0]  cp0_pmp_updt_data;             
output          cp0_sysio_ipend_b;             
output  [1 :0]  cp0_sysio_lpmd_b;              
output  [1 :0]  cp0_sysio_srst;                
output  [29:0]  cp0_vector_vec_err_vbr;        
output          cp0_yy_be_v1;                  
output          cp0_yy_be_v2;                  
output          cp0_yy_clk_en;                 
output          cp0_yy_machine_mode_aft_dbg;   
output  [1 :0]  cp0_yy_priv_mode;              
output  [11:0]  cpu_clic_curid;                
output          cpu_clic_int_exit;             

// &Regs; @26

// &Wires; @27
wire            cache_cp0_lpmd_ack;            
wire            cache_cp0_srst_ack;            
wire    [11:0]  clic_cpu_int_id;               
wire            cp0_cache_lpmd_req;            
wire            cp0_cache_srst_req;            
wire    [31:0]  cp0_had_cpuid_idx0;            
wire            cp0_had_int_exit;              
wire    [1 :0]  cp0_had_lpmd_b;                
wire    [31:0]  cp0_had_mcause_data;           
wire            cp0_ifu_in_lpmd;               
wire            cp0_ifu_lpmd_req;              
wire            cp0_ifu_rst_inv_done;          
wire            cp0_ifu_srst_mask;             
wire            cp0_ifu_srst_req;              
wire            cp0_iu_cache_inv_done;         
wire            cp0_iu_cskyisaee;              
wire    [31:0]  cp0_iu_data;                   
wire            cp0_iu_data_vld;               
wire            cp0_iu_dbg_disable_for_tee;    
wire    [30:0]  cp0_iu_epc_for_chgflw;         
wire    [4 :0]  cp0_iu_expt_vec;               
wire            cp0_iu_expt_vld;               
wire            cp0_iu_flush;                  
wire            cp0_iu_flush_chgflw_vld;       
wire    [7 :0]  cp0_iu_il;                     
wire            cp0_iu_in_expt;                
wire            cp0_iu_in_nmi;                 
wire            cp0_iu_inst_mret;              
wire            cp0_iu_meie;                   
wire            cp0_iu_mie_for_int;            
wire            cp0_iu_mret;                   
wire            cp0_iu_req;                    
wire            cp0_iu_rte_chgflw_vld;         
wire            cp0_iu_rte_chgflw_vld_for_data; 
wire            cp0_iu_stall;                  
wire            cp0_iu_stall_noinput;          
wire    [29:0]  cp0_iu_vbr;                    
wire    [1 :0]  cp0_iu_vec_mode;               
wire            cp0_iu_wfe_en;                 
wire    [31:0]  cp0_pad_mcause;                
wire    [31:0]  cp0_pad_mintstatus;            
wire    [31:0]  cp0_pad_mstatus;               
wire    [11:0]  cp0_pmp_csr_sel;               
wire            cp0_pmp_csr_wen;               
wire    [1 :0]  cp0_pmp_mstatus_mpp;           
wire            cp0_pmp_mstatus_mprv;          
wire    [31:0]  cp0_pmp_updt_data;             
wire            cp0_sysio_ipend_b;             
wire    [1 :0]  cp0_sysio_lpmd_b;              
wire    [1 :0]  cp0_sysio_srst;                
wire    [29:0]  cp0_vector_vec_err_vbr;        
wire            cp0_yy_be_v1;                  
wire            cp0_yy_be_v2;                  
wire            cp0_yy_clk_en;                 
wire            cp0_yy_machine_mode_aft_dbg;   
wire    [1 :0]  cp0_yy_priv_mode;              
wire    [11:0]  cpu_clic_curid;                
wire            cpu_clic_int_exit;             
wire            cpurst_b;                      
wire            forever_cpuclk;                
wire            had_iu_force_dbg_en;           
wire            had_yy_xx_dbg;                 
wire            ifu_cp0_lpmd_ack;              
wire            ifu_cp0_rst_inv_req;           
wire            ifu_cp0_srst_ack;              
wire            inst_lpmd;                     
wire            iu_cp0_ecall;                  
wire    [30:0]  iu_cp0_epc;                    
wire            iu_cp0_epc_update;             
wire            iu_cp0_ex_csrrc;               
wire            iu_cp0_ex_csrrci;              
wire            iu_cp0_ex_csrrs;               
wire            iu_cp0_ex_csrrsi;              
wire            iu_cp0_ex_csrrw;               
wire            iu_cp0_ex_csrrwi;              
wire            iu_cp0_ex_data_sel;            
wire    [2 :0]  iu_cp0_ex_func3;               
wire            iu_cp0_ex_mret;                
wire    [4 :0]  iu_cp0_ex_rd_reg;              
wire    [4 :0]  iu_cp0_ex_rs1_reg;             
wire            iu_cp0_ex_sel;                 
wire            iu_cp0_ex_wfi;                 
wire    [31:0]  iu_cp0_expt_tval;              
wire            iu_cp0_expt_vld;               
wire    [11:0]  iu_cp0_imm;                    
wire            iu_cp0_int_vld;                
wire            iu_cp0_lockup_clr;             
wire            iu_cp0_lockup_vld;             
wire            iu_cp0_lp_wk_int;              
wire            iu_cp0_mtval_updt_vld;         
wire            iu_cp0_nmi_vld;                
wire            iu_cp0_nt_int_pending_vld;     
wire            iu_cp0_oper_mux_en;            
wire    [31:0]  iu_cp0_rs1;                    
wire            iu_cp0_syc_rst_b;              
wire            iu_yy_xx_dbgon;                
wire    [9 :0]  iu_yy_xx_expt_vec;             
wire            iu_yy_xx_flush;                
wire            iu_yy_xx_int_hv;               
wire    [7 :0]  iu_yy_xx_int_il;               
wire            iu_yy_xx_int_pending_hv;       
wire    [9 :0]  iu_yy_xx_int_pending_id;       
wire    [7 :0]  iu_yy_xx_int_pending_il;       
wire    [1 :0]  iu_yy_xx_int_pending_priv;     
wire            iui_lpmd_inst_lpmd_for_data;   
wire            iui_oreg_csr_acc;              
wire            iui_oreg_expt;                 
wire    [11:0]  iui_oreg_imm;                  
wire            iui_oreg_inst_csr;             
wire            iui_oreg_inst_mret;            
wire            iui_oreg_nmi_mret;             
wire            iui_oreg_rd_x0;                
wire    [31:0]  iui_oreg_rs1;                  
wire    [31:0]  iui_oreg_rs1_raw;              
wire            iui_oreg_rs1_x0;               
wire    [31:0]  iui_oreg_tval;                 
wire            lpmd_iui_stall;                
wire            lpmd_sm_clk;                   
wire            lpmd_sm_clk_en;                
wire    [31:0]  marchid_value;                 
wire    [31:0]  mcause_value;                  
wire    [31:0]  mclicbase_value;               
wire    [31:0]  mcpuid_value;                  
wire    [31:0]  mcycle_value;                  
wire    [31:0]  mcycleh_value;                 
wire    [31:0]  mepc_value;                    
wire            mexstatus_local_en;            
wire            mexstatus_sel;                 
wire    [31:0]  mexstatus_value;               
wire    [31:0]  mhartid_value;                 
wire    [31:0]  mhcr_value;                    
wire    [31:0]  mie_value;                     
wire    [31:0]  mimpid_value;                  
wire    [31:0]  minstret_value;                
wire    [31:0]  minstreth_value;               
wire    [31:0]  mintstatus_value;              
wire    [31:0]  mip_value;                     
wire    [31:0]  misa_value;                    
wire            mnmicause_local_en;            
wire    [31:0]  mnmicause_value;               
wire    [31:0]  mnmipc_value;                  
wire    [31:0]  mnxti_value;                   
wire            mnxti_vld_int_pending;         
wire    [31:0]  mraddr_value;                  
wire    [31:0]  mscratch_value;                
wire    [31:0]  mscratchcsw_value;             
wire    [31:0]  mscratchcswl_value;            
wire    [31:0]  mstatus_value;                 
wire    [31:0]  mtval_value;                   
wire    [31:0]  mtvec_value;                   
wire    [31:0]  mtvt_value;                    
wire    [31:0]  mvendorid_value;               
wire    [31:0]  mxstatus_value;                
wire            oreg_clk;                      
wire            oreg_clk_en;                   
wire    [1 :0]  oreg_iui_priv_mode;            
wire            oreg_iui_wr_rdonly;            
wire    [1 :0]  oreg_status_mode;              
wire            pad_yy_gate_clk_en_b;          
wire    [31:0]  pmp_cp0_data;                  
wire            psr_oreg_lpmd_sm_clk;          
wire            psr_oreg_lpmd_sm_clk_en;       
wire            randclk_psr_mod_en_w13;        
wire            srst_iui_stall;                
wire            srst_iui_stall_noinput;        
wire            srst_sm_clk;                   
wire            srst_sm_clk_en;                
wire    [1 :0]  status_lpmd_lpmd;              
wire            status_oreg_intr;              
wire    [7 :0]  status_oreg_mil;               
wire    [7 :0]  status_oreg_mpil;              
wire    [1 :0]  status_oreg_mpp;               
wire            status_oreg_mxstatus_t;        
wire    [1 :0]  status_oreg_pm;                
wire    [9 :0]  status_oreg_vector;            
wire            status_srst_req_valid;         
wire            status_srst_req_valid_noinput; 
wire    [1 :0]  status_srst_value;             
wire            status_xx_nmi;                 
wire            sysio_cp0_bigend;              
wire    [2 :0]  sysio_cp0_clkratio;            
wire            sysio_cp0_endian_v2;           
wire    [31:0]  sysio_cp0_rst_addr;            
wire    [1 :0]  sysio_cp0_sys_view_lpmd_b;     
wire    [31:0]  tcip_cp0_clic_base;            
wire            vector_cp0_vec_err;            
wire    [29:0]  vector_cp0_vec_err_epc;        
wire            vector_cp0_vec_succeed;        


//This gatecell is shared by psr, oreg and lpmd state machine
assign psr_oreg_lpmd_sm_clk_en = oreg_clk_en || lpmd_sm_clk_en || srst_sm_clk_en
                              || iu_cp0_nmi_vld || iu_cp0_lockup_vld;
// &Instance("gated_clk_cell", "x_psr_lpmd_gated_clk"); @32
gated_clk_cell  x_psr_lpmd_gated_clk (
  .clk_in                  (forever_cpuclk         ),
  .clk_out                 (psr_oreg_lpmd_sm_clk   ),
  .external_en             (1'b0                   ),
  .global_en               (cp0_yy_clk_en          ),
  .local_en                (psr_oreg_lpmd_sm_clk_en),
  .module_en               (randclk_psr_mod_en_w13 ),
  .pad_yy_gate_clk_en_b    (pad_yy_gate_clk_en_b   )
);

// &Connect(.clk_in      (forever_cpuclk), @33
//          .external_en (1'b0), @34
//          .global_en   (cp0_yy_clk_en), @35
//          .module_en   (randclk_psr_mod_en_w13), @36
//          .local_en    (psr_oreg_lpmd_sm_clk_en), @37
//          .clk_out     (psr_oreg_lpmd_sm_clk)); @38

assign oreg_clk    = psr_oreg_lpmd_sm_clk;
assign lpmd_sm_clk = psr_oreg_lpmd_sm_clk;
assign srst_sm_clk = psr_oreg_lpmd_sm_clk;
//assign psr_clk     = psr_oreg_lpmd_sm_clk;
// &Instance("gated_clk_cell", "x_status_reg_clk"); @45
// &Connect(.clk_in      (forever_cpuclk), @46
//          .external_en (1'b0), @47
//          .global_en   (cp0_yy_clk_en), @48
//          .module_en   (randclk_psr_mod_en_w13), @49
//          .local_en    (status_clk_en), @50
//          .clk_out     (status_clk)); @51


// &Instance("cr_cp0_iui", "x_cr_cp0_iui"); @55
cr_cp0_iui  x_cr_cp0_iui (
  .cp0_iu_data                    (cp0_iu_data                   ),
  .cp0_iu_data_vld                (cp0_iu_data_vld               ),
  .cp0_iu_dbg_disable_for_tee     (cp0_iu_dbg_disable_for_tee    ),
  .cp0_iu_expt_vec                (cp0_iu_expt_vec               ),
  .cp0_iu_expt_vld                (cp0_iu_expt_vld               ),
  .cp0_iu_flush                   (cp0_iu_flush                  ),
  .cp0_iu_flush_chgflw_vld        (cp0_iu_flush_chgflw_vld       ),
  .cp0_iu_inst_mret               (cp0_iu_inst_mret              ),
  .cp0_iu_req                     (cp0_iu_req                    ),
  .cp0_iu_rte_chgflw_vld          (cp0_iu_rte_chgflw_vld         ),
  .cp0_iu_rte_chgflw_vld_for_data (cp0_iu_rte_chgflw_vld_for_data),
  .cp0_iu_stall                   (cp0_iu_stall                  ),
  .cp0_iu_stall_noinput           (cp0_iu_stall_noinput          ),
  .inst_lpmd                      (inst_lpmd                     ),
  .iu_cp0_ex_csrrc                (iu_cp0_ex_csrrc               ),
  .iu_cp0_ex_csrrci               (iu_cp0_ex_csrrci              ),
  .iu_cp0_ex_csrrs                (iu_cp0_ex_csrrs               ),
  .iu_cp0_ex_csrrsi               (iu_cp0_ex_csrrsi              ),
  .iu_cp0_ex_csrrw                (iu_cp0_ex_csrrw               ),
  .iu_cp0_ex_csrrwi               (iu_cp0_ex_csrrwi              ),
  .iu_cp0_ex_data_sel             (iu_cp0_ex_data_sel            ),
  .iu_cp0_ex_func3                (iu_cp0_ex_func3               ),
  .iu_cp0_ex_mret                 (iu_cp0_ex_mret                ),
  .iu_cp0_ex_rd_reg               (iu_cp0_ex_rd_reg              ),
  .iu_cp0_ex_rs1_reg              (iu_cp0_ex_rs1_reg             ),
  .iu_cp0_ex_sel                  (iu_cp0_ex_sel                 ),
  .iu_cp0_ex_wfi                  (iu_cp0_ex_wfi                 ),
  .iu_cp0_imm                     (iu_cp0_imm                    ),
  .iu_cp0_oper_mux_en             (iu_cp0_oper_mux_en            ),
  .iu_cp0_rs1                     (iu_cp0_rs1                    ),
  .iu_cp0_syc_rst_b               (iu_cp0_syc_rst_b              ),
  .iu_yy_xx_dbgon                 (iu_yy_xx_dbgon                ),
  .iui_lpmd_inst_lpmd_for_data    (iui_lpmd_inst_lpmd_for_data   ),
  .iui_oreg_csr_acc               (iui_oreg_csr_acc              ),
  .iui_oreg_expt                  (iui_oreg_expt                 ),
  .iui_oreg_imm                   (iui_oreg_imm                  ),
  .iui_oreg_inst_csr              (iui_oreg_inst_csr             ),
  .iui_oreg_inst_mret             (iui_oreg_inst_mret            ),
  .iui_oreg_nmi_mret              (iui_oreg_nmi_mret             ),
  .iui_oreg_rd_x0                 (iui_oreg_rd_x0                ),
  .iui_oreg_rs1                   (iui_oreg_rs1                  ),
  .iui_oreg_rs1_raw               (iui_oreg_rs1_raw              ),
  .iui_oreg_rs1_x0                (iui_oreg_rs1_x0               ),
  .iui_oreg_tval                  (iui_oreg_tval                 ),
  .lpmd_iui_stall                 (lpmd_iui_stall                ),
  .marchid_value                  (marchid_value                 ),
  .mcause_value                   (mcause_value                  ),
  .mclicbase_value                (mclicbase_value               ),
  .mcpuid_value                   (mcpuid_value                  ),
  .mcycle_value                   (mcycle_value                  ),
  .mcycleh_value                  (mcycleh_value                 ),
  .mepc_value                     (mepc_value                    ),
  .mexstatus_value                (mexstatus_value               ),
  .mhartid_value                  (mhartid_value                 ),
  .mhcr_value                     (mhcr_value                    ),
  .mie_value                      (mie_value                     ),
  .mimpid_value                   (mimpid_value                  ),
  .minstret_value                 (minstret_value                ),
  .minstreth_value                (minstreth_value               ),
  .mintstatus_value               (mintstatus_value              ),
  .mip_value                      (mip_value                     ),
  .misa_value                     (misa_value                    ),
  .mnmicause_value                (mnmicause_value               ),
  .mnmipc_value                   (mnmipc_value                  ),
  .mnxti_value                    (mnxti_value                   ),
  .mraddr_value                   (mraddr_value                  ),
  .mscratch_value                 (mscratch_value                ),
  .mscratchcsw_value              (mscratchcsw_value             ),
  .mscratchcswl_value             (mscratchcswl_value            ),
  .mstatus_value                  (mstatus_value                 ),
  .mtval_value                    (mtval_value                   ),
  .mtvec_value                    (mtvec_value                   ),
  .mtvt_value                     (mtvt_value                    ),
  .mvendorid_value                (mvendorid_value               ),
  .mxstatus_value                 (mxstatus_value                ),
  .oreg_iui_priv_mode             (oreg_iui_priv_mode            ),
  .oreg_iui_wr_rdonly             (oreg_iui_wr_rdonly            ),
  .pmp_cp0_data                   (pmp_cp0_data                  ),
  .srst_iui_stall                 (srst_iui_stall                ),
  .srst_iui_stall_noinput         (srst_iui_stall_noinput        ),
  .status_xx_nmi                  (status_xx_nmi                 )
);


// &Instance("cr_cp0_oreg", "x_cr_cp0_oreg"); @57
cr_cp0_oreg  x_cr_cp0_oreg (
  .cp0_had_cpuid_idx0        (cp0_had_cpuid_idx0       ),
  .cp0_ifu_rst_inv_done      (cp0_ifu_rst_inv_done     ),
  .cp0_iu_cache_inv_done     (cp0_iu_cache_inv_done    ),
  .cp0_iu_epc_for_chgflw     (cp0_iu_epc_for_chgflw    ),
  .cp0_iu_meie               (cp0_iu_meie              ),
  .cp0_iu_vbr                (cp0_iu_vbr               ),
  .cp0_iu_vec_mode           (cp0_iu_vec_mode          ),
  .cp0_pmp_csr_sel           (cp0_pmp_csr_sel          ),
  .cp0_pmp_csr_wen           (cp0_pmp_csr_wen          ),
  .cp0_pmp_updt_data         (cp0_pmp_updt_data        ),
  .cp0_vector_vec_err_vbr    (cp0_vector_vec_err_vbr   ),
  .cp0_yy_be_v1              (cp0_yy_be_v1             ),
  .cp0_yy_be_v2              (cp0_yy_be_v2             ),
  .cpurst_b                  (cpurst_b                 ),
  .forever_cpuclk            (forever_cpuclk           ),
  .had_iu_force_dbg_en       (had_iu_force_dbg_en      ),
  .ifu_cp0_rst_inv_req       (ifu_cp0_rst_inv_req      ),
  .iu_cp0_ecall              (iu_cp0_ecall             ),
  .iu_cp0_epc                (iu_cp0_epc               ),
  .iu_cp0_epc_update         (iu_cp0_epc_update        ),
  .iu_cp0_ex_data_sel        (iu_cp0_ex_data_sel       ),
  .iu_cp0_ex_sel             (iu_cp0_ex_sel            ),
  .iu_cp0_expt_tval          (iu_cp0_expt_tval         ),
  .iu_cp0_expt_vld           (iu_cp0_expt_vld          ),
  .iu_cp0_int_vld            (iu_cp0_int_vld           ),
  .iu_cp0_lockup_clr         (iu_cp0_lockup_clr        ),
  .iu_cp0_lockup_vld         (iu_cp0_lockup_vld        ),
  .iu_cp0_mtval_updt_vld     (iu_cp0_mtval_updt_vld    ),
  .iu_cp0_nmi_vld            (iu_cp0_nmi_vld           ),
  .iu_cp0_nt_int_pending_vld (iu_cp0_nt_int_pending_vld),
  .iu_cp0_syc_rst_b          (iu_cp0_syc_rst_b         ),
  .iu_yy_xx_dbgon            (iu_yy_xx_dbgon           ),
  .iu_yy_xx_int_hv           (iu_yy_xx_int_hv          ),
  .iu_yy_xx_int_pending_hv   (iu_yy_xx_int_pending_hv  ),
  .iu_yy_xx_int_pending_id   (iu_yy_xx_int_pending_id  ),
  .iu_yy_xx_int_pending_il   (iu_yy_xx_int_pending_il  ),
  .iu_yy_xx_int_pending_priv (iu_yy_xx_int_pending_priv),
  .iui_oreg_csr_acc          (iui_oreg_csr_acc         ),
  .iui_oreg_expt             (iui_oreg_expt            ),
  .iui_oreg_imm              (iui_oreg_imm             ),
  .iui_oreg_inst_csr         (iui_oreg_inst_csr        ),
  .iui_oreg_inst_mret        (iui_oreg_inst_mret       ),
  .iui_oreg_nmi_mret         (iui_oreg_nmi_mret        ),
  .iui_oreg_rs1              (iui_oreg_rs1             ),
  .iui_oreg_rs1_raw          (iui_oreg_rs1_raw         ),
  .iui_oreg_tval             (iui_oreg_tval            ),
  .marchid_value             (marchid_value            ),
  .mclicbase_value           (mclicbase_value          ),
  .mcpuid_value              (mcpuid_value             ),
  .mcycle_value              (mcycle_value             ),
  .mcycleh_value             (mcycleh_value            ),
  .mepc_value                (mepc_value               ),
  .mexstatus_local_en        (mexstatus_local_en       ),
  .mexstatus_sel             (mexstatus_sel            ),
  .mhartid_value             (mhartid_value            ),
  .mhcr_value                (mhcr_value               ),
  .mie_value                 (mie_value                ),
  .mimpid_value              (mimpid_value             ),
  .minstret_value            (minstret_value           ),
  .minstreth_value           (minstreth_value          ),
  .mip_value                 (mip_value                ),
  .misa_value                (misa_value               ),
  .mnmicause_local_en        (mnmicause_local_en       ),
  .mnmipc_value              (mnmipc_value             ),
  .mnxti_value               (mnxti_value              ),
  .mnxti_vld_int_pending     (mnxti_vld_int_pending    ),
  .mraddr_value              (mraddr_value             ),
  .mscratch_value            (mscratch_value           ),
  .mscratchcsw_value         (mscratchcsw_value        ),
  .mscratchcswl_value        (mscratchcswl_value       ),
  .mtval_value               (mtval_value              ),
  .mtvec_value               (mtvec_value              ),
  .mtvt_value                (mtvt_value               ),
  .mvendorid_value           (mvendorid_value          ),
  .oreg_clk                  (oreg_clk                 ),
  .oreg_clk_en               (oreg_clk_en              ),
  .oreg_iui_priv_mode        (oreg_iui_priv_mode       ),
  .oreg_iui_wr_rdonly        (oreg_iui_wr_rdonly       ),
  .oreg_status_mode          (oreg_status_mode         ),
  .status_oreg_intr          (status_oreg_intr         ),
  .status_oreg_mil           (status_oreg_mil          ),
  .status_oreg_mpil          (status_oreg_mpil         ),
  .status_oreg_mpp           (status_oreg_mpp          ),
  .status_oreg_mxstatus_t    (status_oreg_mxstatus_t   ),
  .status_oreg_pm            (status_oreg_pm           ),
  .status_oreg_vector        (status_oreg_vector       ),
  .sysio_cp0_bigend          (sysio_cp0_bigend         ),
  .sysio_cp0_clkratio        (sysio_cp0_clkratio       ),
  .sysio_cp0_endian_v2       (sysio_cp0_endian_v2      ),
  .sysio_cp0_rst_addr        (sysio_cp0_rst_addr       ),
  .tcip_cp0_clic_base        (tcip_cp0_clic_base       ),
  .vector_cp0_vec_err        (vector_cp0_vec_err       ),
  .vector_cp0_vec_err_epc    (vector_cp0_vec_err_epc   ),
  .vector_cp0_vec_succeed    (vector_cp0_vec_succeed   )
);

// &Instance("cr_cp0_status_tee","x_cr_cp0_status"); @59
// &Instance("cr_cp0_status","x_cr_cp0_status"); @61
cr_cp0_status  x_cr_cp0_status (
  .clic_cpu_int_id               (clic_cpu_int_id              ),
  .cp0_had_int_exit              (cp0_had_int_exit             ),
  .cp0_had_mcause_data           (cp0_had_mcause_data          ),
  .cp0_iu_cskyisaee              (cp0_iu_cskyisaee             ),
  .cp0_iu_il                     (cp0_iu_il                    ),
  .cp0_iu_in_expt                (cp0_iu_in_expt               ),
  .cp0_iu_in_nmi                 (cp0_iu_in_nmi                ),
  .cp0_iu_mie_for_int            (cp0_iu_mie_for_int           ),
  .cp0_iu_mret                   (cp0_iu_mret                  ),
  .cp0_iu_wfe_en                 (cp0_iu_wfe_en                ),
  .cp0_pad_mcause                (cp0_pad_mcause               ),
  .cp0_pad_mintstatus            (cp0_pad_mintstatus           ),
  .cp0_pad_mstatus               (cp0_pad_mstatus              ),
  .cp0_pmp_mstatus_mpp           (cp0_pmp_mstatus_mpp          ),
  .cp0_pmp_mstatus_mprv          (cp0_pmp_mstatus_mprv         ),
  .cp0_yy_machine_mode_aft_dbg   (cp0_yy_machine_mode_aft_dbg  ),
  .cp0_yy_priv_mode              (cp0_yy_priv_mode             ),
  .cpu_clic_curid                (cpu_clic_curid               ),
  .cpu_clic_int_exit             (cpu_clic_int_exit            ),
  .cpurst_b                      (cpurst_b                     ),
  .iu_cp0_expt_vld               (iu_cp0_expt_vld              ),
  .iu_cp0_int_vld                (iu_cp0_int_vld               ),
  .iu_cp0_lockup_clr             (iu_cp0_lockup_clr            ),
  .iu_cp0_lockup_vld             (iu_cp0_lockup_vld            ),
  .iu_cp0_nmi_vld                (iu_cp0_nmi_vld               ),
  .iu_cp0_syc_rst_b              (iu_cp0_syc_rst_b             ),
  .iu_yy_xx_dbgon                (iu_yy_xx_dbgon               ),
  .iu_yy_xx_expt_vec             (iu_yy_xx_expt_vec            ),
  .iu_yy_xx_int_hv               (iu_yy_xx_int_hv              ),
  .iu_yy_xx_int_il               (iu_yy_xx_int_il              ),
  .iu_yy_xx_int_pending_id       (iu_yy_xx_int_pending_id      ),
  .iu_yy_xx_int_pending_il       (iu_yy_xx_int_pending_il      ),
  .iui_oreg_imm                  (iui_oreg_imm                 ),
  .iui_oreg_inst_csr             (iui_oreg_inst_csr            ),
  .iui_oreg_inst_mret            (iui_oreg_inst_mret           ),
  .iui_oreg_nmi_mret             (iui_oreg_nmi_mret            ),
  .iui_oreg_rd_x0                (iui_oreg_rd_x0               ),
  .iui_oreg_rs1                  (iui_oreg_rs1                 ),
  .iui_oreg_rs1_raw              (iui_oreg_rs1_raw             ),
  .iui_oreg_rs1_x0               (iui_oreg_rs1_x0              ),
  .mcause_value                  (mcause_value                 ),
  .mexstatus_local_en            (mexstatus_local_en           ),
  .mexstatus_sel                 (mexstatus_sel                ),
  .mexstatus_value               (mexstatus_value              ),
  .mintstatus_value              (mintstatus_value             ),
  .mnmicause_local_en            (mnmicause_local_en           ),
  .mnmicause_value               (mnmicause_value              ),
  .mnxti_vld_int_pending         (mnxti_vld_int_pending        ),
  .mstatus_value                 (mstatus_value                ),
  .mxstatus_value                (mxstatus_value               ),
  .oreg_clk                      (oreg_clk                     ),
  .oreg_iui_priv_mode            (oreg_iui_priv_mode           ),
  .oreg_status_mode              (oreg_status_mode             ),
  .status_lpmd_lpmd              (status_lpmd_lpmd             ),
  .status_oreg_intr              (status_oreg_intr             ),
  .status_oreg_mil               (status_oreg_mil              ),
  .status_oreg_mpil              (status_oreg_mpil             ),
  .status_oreg_mpp               (status_oreg_mpp              ),
  .status_oreg_mxstatus_t        (status_oreg_mxstatus_t       ),
  .status_oreg_pm                (status_oreg_pm               ),
  .status_oreg_vector            (status_oreg_vector           ),
  .status_srst_req_valid         (status_srst_req_valid        ),
  .status_srst_req_valid_noinput (status_srst_req_valid_noinput),
  .status_srst_value             (status_srst_value            ),
  .status_xx_nmi                 (status_xx_nmi                ),
  .vector_cp0_vec_succeed        (vector_cp0_vec_succeed       )
);

// &Instance("cr_cp0_lpmd", "x_cr_cp0_lpmd"); @63
cr_cp0_lpmd  x_cr_cp0_lpmd (
  .cache_cp0_lpmd_ack          (cache_cp0_lpmd_ack         ),
  .cp0_cache_lpmd_req          (cp0_cache_lpmd_req         ),
  .cp0_had_lpmd_b              (cp0_had_lpmd_b             ),
  .cp0_ifu_in_lpmd             (cp0_ifu_in_lpmd            ),
  .cp0_ifu_lpmd_req            (cp0_ifu_lpmd_req           ),
  .cp0_sysio_ipend_b           (cp0_sysio_ipend_b          ),
  .cp0_sysio_lpmd_b            (cp0_sysio_lpmd_b           ),
  .cp0_yy_clk_en               (cp0_yy_clk_en              ),
  .cpurst_b                    (cpurst_b                   ),
  .forever_cpuclk              (forever_cpuclk             ),
  .had_yy_xx_dbg               (had_yy_xx_dbg              ),
  .ifu_cp0_lpmd_ack            (ifu_cp0_lpmd_ack           ),
  .inst_lpmd                   (inst_lpmd                  ),
  .iu_cp0_ex_sel               (iu_cp0_ex_sel              ),
  .iu_cp0_lp_wk_int            (iu_cp0_lp_wk_int           ),
  .iu_yy_xx_dbgon              (iu_yy_xx_dbgon             ),
  .iu_yy_xx_flush              (iu_yy_xx_flush             ),
  .iui_lpmd_inst_lpmd_for_data (iui_lpmd_inst_lpmd_for_data),
  .lpmd_iui_stall              (lpmd_iui_stall             ),
  .lpmd_sm_clk                 (lpmd_sm_clk                ),
  .lpmd_sm_clk_en              (lpmd_sm_clk_en             ),
  .pad_yy_gate_clk_en_b        (pad_yy_gate_clk_en_b       ),
  .status_lpmd_lpmd            (status_lpmd_lpmd           ),
  .sysio_cp0_sys_view_lpmd_b   (sysio_cp0_sys_view_lpmd_b  )
);

// &Instance("cr_cp0_srst", "x_cr_cp0_srst"); @64
cr_cp0_srst  x_cr_cp0_srst (
  .cache_cp0_srst_ack            (cache_cp0_srst_ack           ),
  .cp0_cache_srst_req            (cp0_cache_srst_req           ),
  .cp0_ifu_srst_mask             (cp0_ifu_srst_mask            ),
  .cp0_ifu_srst_req              (cp0_ifu_srst_req             ),
  .cp0_sysio_srst                (cp0_sysio_srst               ),
  .cpurst_b                      (cpurst_b                     ),
  .ifu_cp0_srst_ack              (ifu_cp0_srst_ack             ),
  .iu_cp0_ex_sel                 (iu_cp0_ex_sel                ),
  .iu_yy_xx_flush                (iu_yy_xx_flush               ),
  .srst_iui_stall                (srst_iui_stall               ),
  .srst_iui_stall_noinput        (srst_iui_stall_noinput       ),
  .srst_sm_clk                   (srst_sm_clk                  ),
  .srst_sm_clk_en                (srst_sm_clk_en               ),
  .status_srst_req_valid         (status_srst_req_valid        ),
  .status_srst_req_valid_noinput (status_srst_req_valid_noinput),
  .status_srst_value             (status_srst_value            )
);

// &Force ("output","cp0_yy_clk_en"); @65
// //&Force ("output","cp0_yy_intsp_sel_post"); @66
//assign cp0_yy_intsp_sel_post = 1'b0;
// &Instance("cr_cp0_randclk", "x_cr_cp0_randclk"); @68
cr_cp0_randclk  x_cr_cp0_randclk (
  .randclk_psr_mod_en_w13 (randclk_psr_mod_en_w13)
);


// &ModuleEnd; @70
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module openE902(
  biu_pad_haddr,
  biu_pad_hburst,
  biu_pad_hprot,
  biu_pad_hsize,
  biu_pad_htrans,
  biu_pad_hwdata,
  biu_pad_hwrite,
  cp0_pad_mcause,
  cp0_pad_mintstatus,
  cp0_pad_mstatus,
  cpu_pad_dfs_ack,
  cpu_pad_lockup,
  cpu_pad_soft_rst,
  had_pad_jdb_pm,
  had_pad_jtg_tms_o,
  had_pad_jtg_tms_oe,
  iahbl_pad_haddr,
  iahbl_pad_hburst,
  iahbl_pad_hprot,
  iahbl_pad_hsize,
  iahbl_pad_htrans,
  iahbl_pad_hwdata,
  iahbl_pad_hwrite,
  iu_pad_gpr_data,
  iu_pad_gpr_index,
  iu_pad_gpr_we,
  iu_pad_inst_retire,
  iu_pad_inst_split,
  iu_pad_retire_pc,
  pad_biu_hrdata,
  pad_biu_hready,
  pad_biu_hresp,
  pad_bmu_iahbl_base,
  pad_bmu_iahbl_mask,
  pad_clic_int_vld,
  pad_cpu_dfs_req,
  pad_cpu_ext_int_b,
  pad_cpu_nmi,
  pad_cpu_rst_addr,
  pad_cpu_rst_b,
  pad_cpu_sys_cnt,
  pad_cpu_wakeup_event,
  pad_had_jtg_tclk,
  pad_had_jtg_tms_i,
  pad_had_jtg_trst_b,
  pad_had_rst_b,
  pad_iahbl_hrdata,
  pad_iahbl_hready,
  pad_iahbl_hresp,
  pad_sysio_dbgrq_b,
  pad_yy_gate_clk_en_b,
  pad_yy_test_mode,
  pll_core_cpuclk,
  sysio_pad_lpmd_b
);

//==========================================================
// GOLDEN PORTS GENERATION AND CHECK
//==========================================================
//------------------------------------------------
// generating golden ports
//------------------------------------------------
//   &Shell("cat ../../../src_rtl/cpu/rtl/ck802_golden_ports > penta_golden_ports"); @33
//    &Shell("cat ../../../src_rtl/cpu/rtl/ck802_16_golden_ports > penta_golden_ports"); @36
//   &Shell("cat ../../../src_rtl/cpu/rtl/clic_golden_ports >> penta_golden_ports"); @39
//     &Shell("cat ../../../src_rtl/cpu/rtl/iahbl_golden_ports >> penta_golden_ports"); @43
//     &Shell("cat ../../../src_rtl/cpu/rtl/iahbl_16_golden_ports >> penta_golden_ports"); @46
//     &Shell("cat ../../../src_rtl/cpu/rtl/iahbl_fo_golden_ports >> penta_golden_ports"); @49
//     &Shell("cat ../../../src_rtl/cpu/rtl/dahbl_golden_ports >> penta_golden_ports"); @54
//     &Shell("cat ../../../src_rtl/cpu/rtl/dahbl_16_golden_ports >> penta_golden_ports"); @57
//     &Shell("cat ../../../src_rtl/cpu/rtl/dahbl_fo_golden_ports >> penta_golden_ports"); @60
//&Shell("cat ../../../src_rtl/cpu/rtl/scan_golden_ports >> penta_golden_ports");
//   &Shell("cat ../../../src_rtl/cpu/rtl/seu_golden_ports >> penta_golden_ports"); @68
  // &Shell("cat clic_kid_golden_ports.v | grep -v // | grep pad_clic_int_vld >> penta_golden_ports");
//   &Shell("cat clic_kid_golden_ports.v >> penta_golden_ports"); @72
//       &Shell("cat ../../../src_rtl/cpu/rtl/noclic_golden_ports >> penta_golden_ports"); @75
//      &Shell("cat ../../../src_rtl/cpu/rtl/noclic_tee_golden_ports >> penta_golden_ports"); @77
//   &Shell("cat ../../../src_rtl/cpu/rtl/had_jtag2_golden_ports >> penta_golden_ports"); @82
//   &Shell("cat ../../../src_rtl/cpu/rtl/had_jtag5_golden_ports >> penta_golden_ports"); @84

//     &Shell("cat ../../../src_rtl/cpu/rtl/gcr_8_golden_ports >> penta_golden_ports"); @89
//     &Shell("cat ../../../src_rtl/cpu/rtl/gcr_16_golden_ports >> penta_golden_ports"); @92
//     &Shell("cat ../../../src_rtl/cpu/rtl/gcr_32_golden_ports >> penta_golden_ports"); @95

//     &Shell("cat ../../../src_rtl/cpu/rtl/gsr_8_golden_ports >> penta_golden_ports"); @101
//     &Shell("cat ../../../src_rtl/cpu/rtl/gsr_16_golden_ports >> penta_golden_ports"); @104
//     &Shell("cat ../../../src_rtl/cpu/rtl/gsr_32_golden_ports >> penta_golden_ports"); @107

//   &Shell("cat ../../../src_rtl/cpu/rtl/gpr_sync_reset_golden_ports >> penta_golden_ports"); @112

//      &Shell("cat ../../../src_rtl/cpu/rtl/beu_golden_ports >> penta_golden_ports"); @117
//      &Shell("cat ../../../src_rtl/cpu/rtl/beu_16_golden_ports >> penta_golden_ports"); @120

//      &Shell("cat ../../../src_rtl/cpu/rtl/beu_golden_ports >> penta_golden_ports"); @126
//      &Shell("cat ../../../src_rtl/cpu/rtl/beu_16_golden_ports >> penta_golden_ports"); @129

//    &Shell("cat ../../../src_rtl/cpu/rtl/biu_par_golden_ports >> penta_golden_ports"); @134
//      &Shell("cat ../../../src_rtl/cpu/rtl/iahbl_par_golden_ports >> penta_golden_ports"); @136
//      &Shell("cat ../../../src_rtl/cpu/rtl/dahbl_par_golden_ports >> penta_golden_ports"); @139

//    &Shell("cat ../../../src_rtl/cpu/rtl/biu_pol_golden_ports >> penta_golden_ports"); @144
//      &Shell("cat ../../../src_rtl/cpu/rtl/iahbl_pol_golden_ports >> penta_golden_ports"); @146
//      &Shell("cat ../../../src_rtl/cpu/rtl/dahbl_pol_golden_ports >> penta_golden_ports"); @149

//    &Shell("cat ../../../src_rtl/cpu/rtl/biu_emmu_golden_ports >> penta_golden_ports"); @154
//      &Shell("cat ../../../src_rtl/cpu/rtl/cache_emmu_golden_ports >> penta_golden_ports"); @156
//      &Shell("cat ../../../src_rtl/cpu/rtl/iahbl_emmu_golden_ports >> penta_golden_ports"); @159

//        &Shell("cat ../../../src_rtl/cpu/rtl/smbist_2way_golden_ports >> penta_golden_ports"); @167
//        &Shell("cat ../../../src_rtl/cpu/rtl/smbist_4way_golden_ports >> penta_golden_ports"); @169
//      &Shell("cat ../../../src_rtl/cpu/rtl/smbist_2way_golden_ports >> penta_golden_ports"); @176
//      &Shell("cat ../../../src_rtl/cpu/rtl/smbist_usdf_golden_ports >> penta_golden_ports"); @178
//      &Shell("cat ../../../src_rtl/cpu/rtl/smbist_2way_golden_ports >> penta_golden_ports"); @181
//      &Shell("cat ../../../src_rtl/cpu/rtl/smbist_2way_golden_ports >> penta_golden_ports"); @184
//      &Shell("cat ../../../src_rtl/cpu/rtl/smbist_2way_golden_ports >> penta_golden_ports"); @187

//    &Shell("cat ../../../src_rtl/cpu/rtl/cache_usdf_golden_ports>> penta_golden_ports"); @194

//    &Shell("cat ../../../src_rtl/cpu/rtl/biu_dbg_golden_ports >> penta_golden_ports"); @198
//      &Shell("cat ../../../src_rtl/cpu/rtl/iahbl_dbg_golden_ports >> penta_golden_ports"); @200
//      &Shell("cat ../../../src_rtl/cpu/rtl/dahbl_dbg_golden_ports >> penta_golden_ports"); @203

// &Shell("cat ../../../src_rtl/cpu/rtl/fast_mad_32_golden_ports >> penta_golden_ports"); @208

// &Shell("cat ../../../src_rtl/cpu/rtl/fast_mad_33_golden_ports >> penta_golden_ports"); @212

// &Shell("cat ../../../src_rtl/cpu/rtl/ebmu_golden_ports >> penta_golden_ports"); @216
// &Shell("cat ../../../src_rtl/cpu/rtl/biu_ahb_golden_ports >> penta_golden_ports"); @219

// &Shell("cat ../../../src_rtl/cpu/rtl/csky_tee_golden_ports>> penta_golden_ports"); @225
// &Shell("cat ../../../src_rtl/cpu/rtl/csky_tee_cache_golden_ports>> penta_golden_ports"); @228

// &Shell("cat ../../../src_rtl/cpu/rtl/cmmu_golden_ports >> penta_golden_ports"); @233


// &Ports("compare", "penta_golden_ports"); @260
input   [31:0]  pad_biu_hrdata;                      
input           pad_biu_hready;                      
input           pad_biu_hresp;                       
input   [11:0]  pad_bmu_iahbl_base;                  
input   [11:0]  pad_bmu_iahbl_mask;                  
input   [63:0]  pad_clic_int_vld;                    
input           pad_cpu_dfs_req;                     
input           pad_cpu_ext_int_b;                   
input           pad_cpu_nmi;                         
input   [31:0]  pad_cpu_rst_addr;                    
input           pad_cpu_rst_b;                       
input   [63:0]  pad_cpu_sys_cnt;                     
input           pad_cpu_wakeup_event;                
input           pad_had_jtg_tclk;                    
input           pad_had_jtg_tms_i;                   
input           pad_had_jtg_trst_b;                  
input           pad_had_rst_b;                       
input   [31:0]  pad_iahbl_hrdata;                    
input           pad_iahbl_hready;                    
input           pad_iahbl_hresp;                     
input           pad_sysio_dbgrq_b;                   
input           pad_yy_gate_clk_en_b;                
input           pad_yy_test_mode;                    
input           pll_core_cpuclk;                     
output  [31:0]  biu_pad_haddr;                       
output  [2 :0]  biu_pad_hburst;                      
output  [3 :0]  biu_pad_hprot;                       
output  [2 :0]  biu_pad_hsize;                       
output  [1 :0]  biu_pad_htrans;                      
output  [31:0]  biu_pad_hwdata;                      
output          biu_pad_hwrite;                      
output  [31:0]  cp0_pad_mcause;                      
output  [31:0]  cp0_pad_mintstatus;                  
output  [31:0]  cp0_pad_mstatus;                     
output          cpu_pad_dfs_ack;                     
output          cpu_pad_lockup;                      
output  [1 :0]  cpu_pad_soft_rst;                    
output  [1 :0]  had_pad_jdb_pm;                      
output          had_pad_jtg_tms_o;                   
output          had_pad_jtg_tms_oe;                  
output  [31:0]  iahbl_pad_haddr;                     
output  [2 :0]  iahbl_pad_hburst;                    
output  [3 :0]  iahbl_pad_hprot;                     
output  [2 :0]  iahbl_pad_hsize;                     
output  [1 :0]  iahbl_pad_htrans;                    
output  [31:0]  iahbl_pad_hwdata;                    
output          iahbl_pad_hwrite;                    
output  [31:0]  iu_pad_gpr_data;                     
output  [4 :0]  iu_pad_gpr_index;                    
output          iu_pad_gpr_we;                       
output          iu_pad_inst_retire;                  
output          iu_pad_inst_split;                   
output  [31:0]  iu_pad_retire_pc;                    
output  [1 :0]  sysio_pad_lpmd_b;                    

// &Regs; @261

// &Wires; @262
wire    [31:0]  biu_pad_haddr;                       
wire    [2 :0]  biu_pad_hburst;                      
wire    [3 :0]  biu_pad_hprot;                       
wire    [2 :0]  biu_pad_hsize;                       
wire    [1 :0]  biu_pad_htrans;                      
wire    [31:0]  biu_pad_hwdata;                      
wire            biu_pad_hwrite;                      
wire            bmu_tcipif_dbus_acc_deny;            
wire    [31:0]  bmu_tcipif_dbus_addr;                
wire            bmu_tcipif_dbus_chk_fail;            
wire            bmu_tcipif_dbus_req;                 
wire    [1 :0]  bmu_tcipif_dbus_size;                
wire            bmu_tcipif_dbus_supv_mode;           
wire    [31:0]  bmu_tcipif_dbus_wdata;               
wire            bmu_tcipif_dbus_write;               
wire            bmu_tcipif_ibus_acc_deny;            
wire    [31:0]  bmu_tcipif_ibus_addr;                
wire            bmu_tcipif_ibus_req;                 
wire            bmu_tcipif_ibus_write;               
wire            clic_cpu_int_hv;                     
wire    [11:0]  clic_cpu_int_id;                     
wire    [7 :0]  clic_cpu_int_il;                     
wire    [1 :0]  clic_cpu_int_priv;                   
wire            clint_cpu_me_int;                    
wire            clk_en;                              
wire    [31:0]  cp0_had_cpuid_idx0;                  
wire            cp0_had_int_exit;                    
wire    [1 :0]  cp0_had_lpmd_b;                      
wire    [31:0]  cp0_had_mcause_data;                 
wire    [31:0]  cp0_pad_mcause;                      
wire    [31:0]  cp0_pad_mintstatus;                  
wire    [31:0]  cp0_pad_mstatus;                     
wire            cp0_yy_be_v2;                        
wire    [1 :0]  cp0_yy_priv_mode;                    
wire    [11:0]  cpu_clic_curid;                      
wire            cpu_clic_int_exit;                   
wire            cpu_pad_dfs_ack;                     
wire            cpu_pad_lockup;                      
wire    [1 :0]  cpu_pad_soft_rst;                    
wire            cpurst_b;                            
wire            forever_cpuclk;                      
wire            forever_cpuclk_nogated;              
wire            forever_jtgclk;                      
wire            had_core_dbg_mode_req;               
wire            had_core_exit_dbg;                   
wire    [31:0]  had_idu_wbbr_data;                   
wire            had_idu_wbbr_vld;                    
wire            had_ifu_inst_bkpt_dbq_req;           
wire            had_ifu_inst_bkpt_dbqexp_req;        
wire    [31:0]  had_ifu_ir;                          
wire            had_ifu_ir_vld;                      
wire            had_iu_bkpt_trace_en;                
wire            had_iu_dr_set_req;                   
wire            had_iu_force_dbg_en;                 
wire            had_iu_int_vld;                      
wire            had_iu_mbkpt_fsm_index_mbee;         
wire            had_iu_mem_bkpt_exp_req;             
wire            had_iu_mem_bkpt_mask;                
wire            had_iu_mem_bkpt_req;                 
wire    [30:0]  had_iu_pc;                           
wire            had_iu_rte_pc_sel;                   
wire            had_iu_trace_req;                    
wire            had_iu_trace_req_for_dbg_disable;    
wire            had_iu_xx_fdb;                       
wire            had_iu_xx_jdbreq;                    
wire    [1 :0]  had_pad_jdb_pm;                      
wire            had_pad_jtg_tms_o;                   
wire            had_pad_jtg_tms_oe;                  
wire            had_tcipif_cmplt;                    
wire    [31:0]  had_tcipif_rdata;                    
wire            had_yy_xx_dbg;                       
wire            had_yy_xx_dp_index_mbee;             
wire            hadrst_b;                            
wire    [31:0]  iahbl_pad_haddr;                     
wire    [2 :0]  iahbl_pad_hburst;                    
wire    [3 :0]  iahbl_pad_hprot;                     
wire    [2 :0]  iahbl_pad_hsize;                     
wire    [1 :0]  iahbl_pad_htrans;                    
wire    [31:0]  iahbl_pad_hwdata;                    
wire            iahbl_pad_hwrite;                    
wire            ifu_had_chg_flw_inst;                
wire            ifu_had_fetch_expt_vld;              
wire            ifu_had_inst_dbg_disable;            
wire    [31:0]  ifu_had_match_pc;                    
wire            ifu_had_split_first;                 
wire            iu_had_adr_dbg_ack;                  
wire    [31:0]  iu_had_chgflw_dst_pc;                
wire            iu_had_chgflw_vld;                   
wire            iu_had_data_bkpt_occur_vld;          
wire            iu_had_dbg_disable_for_tee;          
wire            iu_had_dr_dbg_ack;                   
wire            iu_had_expt_vld;                     
wire            iu_had_fast_retire_acc_err_pc_update; 
wire    [30:0]  iu_had_fast_retire_acc_err_pc_val;   
wire            iu_had_flush;                        
wire            iu_had_inst_bkpt_occur_vld;          
wire            iu_had_int_ack;                      
wire            iu_had_retire_with_had_int;          
wire            iu_had_trace_occur_vld;              
wire            iu_had_xx_bkpt_inst;                 
wire    [31:0]  iu_had_xx_data;                      
wire            iu_had_xx_data_vld;                  
wire            iu_had_xx_dbg_ack;                   
wire            iu_had_xx_mldst;                     
wire            iu_had_xx_retire;                    
wire            iu_had_xx_retire_normal;             
wire    [31:0]  iu_had_xx_retire_pc;                 
wire    [31:0]  iu_pad_gpr_data;                     
wire    [4 :0]  iu_pad_gpr_index;                    
wire            iu_pad_gpr_we;                       
wire            iu_pad_inst_retire;                  
wire            iu_pad_inst_split;                   
wire    [31:0]  iu_pad_retire_pc;                    
wire            iu_yy_xx_dbgon;                      
wire    [31:0]  lsu_had_addr;                        
wire            lsu_had_addr_vld;                    
wire            lsu_had_ex_cmplt;                    
wire            lsu_had_st;                          
wire    [31:0]  pad_biu_hrdata;                      
wire            pad_biu_hready;                      
wire            pad_biu_hresp;                       
wire    [11:0]  pad_bmu_iahbl_base;                  
wire    [11:0]  pad_bmu_iahbl_mask;                  
wire    [63:0]  pad_clic_int_vld;                    
wire            pad_cpu_dfs_req;                     
wire            pad_cpu_ext_int_b;                   
wire            pad_cpu_nmi;                         
wire    [31:0]  pad_cpu_rst_addr;                    
wire            pad_cpu_rst_b;                       
wire    [63:0]  pad_cpu_sys_cnt;                     
wire            pad_cpu_wakeup_event;                
wire            pad_had_jtg_tclk;                    
wire            pad_had_jtg_tms_i;                   
wire            pad_had_jtg_trst_b;                  
wire            pad_had_rst_b;                       
wire    [31:0]  pad_iahbl_hrdata;                    
wire            pad_iahbl_hready;                    
wire            pad_iahbl_hresp;                     
wire            pad_sysio_dbgrq_b;                   
wire            pad_yy_gate_clk_en_b;                
wire            pad_yy_test_mode;                    
wire            pll_core_cpuclk;                     
wire            pwrm_cpu_bus_peak_power_limit_en;    
wire            sysio_clint_me_int;                  
wire    [63:0]  sysio_clint_mtime;                   
wire            sysio_had_sdb_req_b;                 
wire    [1 :0]  sysio_pad_lpmd_b;                    
wire    [31:0]  tcip_cp0_clic_base;                  
wire            tcipif_bmu_dbus_acc_err;             
wire    [31:0]  tcipif_bmu_dbus_data;                
wire            tcipif_bmu_dbus_data_vld;            
wire            tcipif_bmu_dbus_grnt;                
wire            tcipif_bmu_dbus_trans_cmplt;         
wire            tcipif_bmu_ibus_acc_err;             
wire    [31:0]  tcipif_bmu_ibus_data;                
wire            tcipif_bmu_ibus_data_vld;            
wire            tcipif_bmu_ibus_grnt;                
wire            tcipif_bmu_ibus_trans_cmplt;         
wire    [15:0]  tcipif_had_addr;                     
wire            tcipif_had_sel;                      
wire    [31:0]  tcipif_had_wdata;                    
wire            tcipif_had_write;                    
wire            trst_b;                              


//==========================================================
//  Instance CK802 core top module
//==========================================================
// &Instance("cr_core_top"); @267
cr_core_top  x_cr_core_top (
  .biu_pad_haddr                        (biu_pad_haddr                       ),
  .biu_pad_hburst                       (biu_pad_hburst                      ),
  .biu_pad_hprot                        (biu_pad_hprot                       ),
  .biu_pad_hsize                        (biu_pad_hsize                       ),
  .biu_pad_htrans                       (biu_pad_htrans                      ),
  .biu_pad_hwdata                       (biu_pad_hwdata                      ),
  .biu_pad_hwrite                       (biu_pad_hwrite                      ),
  .bmu_tcipif_dbus_acc_deny             (bmu_tcipif_dbus_acc_deny            ),
  .bmu_tcipif_dbus_addr                 (bmu_tcipif_dbus_addr                ),
  .bmu_tcipif_dbus_chk_fail             (bmu_tcipif_dbus_chk_fail            ),
  .bmu_tcipif_dbus_req                  (bmu_tcipif_dbus_req                 ),
  .bmu_tcipif_dbus_size                 (bmu_tcipif_dbus_size                ),
  .bmu_tcipif_dbus_supv_mode            (bmu_tcipif_dbus_supv_mode           ),
  .bmu_tcipif_dbus_wdata                (bmu_tcipif_dbus_wdata               ),
  .bmu_tcipif_dbus_write                (bmu_tcipif_dbus_write               ),
  .bmu_tcipif_ibus_acc_deny             (bmu_tcipif_ibus_acc_deny            ),
  .bmu_tcipif_ibus_addr                 (bmu_tcipif_ibus_addr                ),
  .bmu_tcipif_ibus_req                  (bmu_tcipif_ibus_req                 ),
  .bmu_tcipif_ibus_write                (bmu_tcipif_ibus_write               ),
  .clic_cpu_int_hv                      (clic_cpu_int_hv                     ),
  .clic_cpu_int_id                      (clic_cpu_int_id                     ),
  .clic_cpu_int_il                      (clic_cpu_int_il                     ),
  .clic_cpu_int_priv                    (clic_cpu_int_priv                   ),
  .clint_cpu_me_int                     (clint_cpu_me_int                    ),
  .clk_en                               (clk_en                              ),
  .cp0_had_cpuid_idx0                   (cp0_had_cpuid_idx0                  ),
  .cp0_had_int_exit                     (cp0_had_int_exit                    ),
  .cp0_had_lpmd_b                       (cp0_had_lpmd_b                      ),
  .cp0_had_mcause_data                  (cp0_had_mcause_data                 ),
  .cp0_pad_mcause                       (cp0_pad_mcause                      ),
  .cp0_pad_mintstatus                   (cp0_pad_mintstatus                  ),
  .cp0_pad_mstatus                      (cp0_pad_mstatus                     ),
  .cp0_yy_be_v2                         (cp0_yy_be_v2                        ),
  .cp0_yy_priv_mode                     (cp0_yy_priv_mode                    ),
  .cpu_clic_curid                       (cpu_clic_curid                      ),
  .cpu_clic_int_exit                    (cpu_clic_int_exit                   ),
  .cpu_pad_dfs_ack                      (cpu_pad_dfs_ack                     ),
  .cpu_pad_lockup                       (cpu_pad_lockup                      ),
  .cpu_pad_soft_rst                     (cpu_pad_soft_rst                    ),
  .cpurst_b                             (cpurst_b                            ),
  .forever_cpuclk                       (forever_cpuclk                      ),
  .had_core_dbg_mode_req                (had_core_dbg_mode_req               ),
  .had_core_exit_dbg                    (had_core_exit_dbg                   ),
  .had_idu_wbbr_data                    (had_idu_wbbr_data                   ),
  .had_idu_wbbr_vld                     (had_idu_wbbr_vld                    ),
  .had_ifu_inst_bkpt_dbq_req            (had_ifu_inst_bkpt_dbq_req           ),
  .had_ifu_inst_bkpt_dbqexp_req         (had_ifu_inst_bkpt_dbqexp_req        ),
  .had_ifu_ir                           (had_ifu_ir                          ),
  .had_ifu_ir_vld                       (had_ifu_ir_vld                      ),
  .had_iu_bkpt_trace_en                 (had_iu_bkpt_trace_en                ),
  .had_iu_dr_set_req                    (had_iu_dr_set_req                   ),
  .had_iu_force_dbg_en                  (had_iu_force_dbg_en                 ),
  .had_iu_int_vld                       (had_iu_int_vld                      ),
  .had_iu_mbkpt_fsm_index_mbee          (had_iu_mbkpt_fsm_index_mbee         ),
  .had_iu_mem_bkpt_exp_req              (had_iu_mem_bkpt_exp_req             ),
  .had_iu_mem_bkpt_mask                 (had_iu_mem_bkpt_mask                ),
  .had_iu_mem_bkpt_req                  (had_iu_mem_bkpt_req                 ),
  .had_iu_pc                            (had_iu_pc                           ),
  .had_iu_rte_pc_sel                    (had_iu_rte_pc_sel                   ),
  .had_iu_trace_req                     (had_iu_trace_req                    ),
  .had_iu_trace_req_for_dbg_disable     (had_iu_trace_req_for_dbg_disable    ),
  .had_iu_xx_fdb                        (had_iu_xx_fdb                       ),
  .had_iu_xx_jdbreq                     (had_iu_xx_jdbreq                    ),
  .had_yy_xx_dbg                        (had_yy_xx_dbg                       ),
  .had_yy_xx_dp_index_mbee              (had_yy_xx_dp_index_mbee             ),
  .iahbl_pad_haddr                      (iahbl_pad_haddr                     ),
  .iahbl_pad_hburst                     (iahbl_pad_hburst                    ),
  .iahbl_pad_hprot                      (iahbl_pad_hprot                     ),
  .iahbl_pad_hsize                      (iahbl_pad_hsize                     ),
  .iahbl_pad_htrans                     (iahbl_pad_htrans                    ),
  .iahbl_pad_hwdata                     (iahbl_pad_hwdata                    ),
  .iahbl_pad_hwrite                     (iahbl_pad_hwrite                    ),
  .ifu_had_chg_flw_inst                 (ifu_had_chg_flw_inst                ),
  .ifu_had_fetch_expt_vld               (ifu_had_fetch_expt_vld              ),
  .ifu_had_inst_dbg_disable             (ifu_had_inst_dbg_disable            ),
  .ifu_had_match_pc                     (ifu_had_match_pc                    ),
  .ifu_had_split_first                  (ifu_had_split_first                 ),
  .iu_had_adr_dbg_ack                   (iu_had_adr_dbg_ack                  ),
  .iu_had_chgflw_dst_pc                 (iu_had_chgflw_dst_pc                ),
  .iu_had_chgflw_vld                    (iu_had_chgflw_vld                   ),
  .iu_had_data_bkpt_occur_vld           (iu_had_data_bkpt_occur_vld          ),
  .iu_had_dbg_disable_for_tee           (iu_had_dbg_disable_for_tee          ),
  .iu_had_dr_dbg_ack                    (iu_had_dr_dbg_ack                   ),
  .iu_had_expt_vld                      (iu_had_expt_vld                     ),
  .iu_had_fast_retire_acc_err_pc_update (iu_had_fast_retire_acc_err_pc_update),
  .iu_had_fast_retire_acc_err_pc_val    (iu_had_fast_retire_acc_err_pc_val   ),
  .iu_had_flush                         (iu_had_flush                        ),
  .iu_had_inst_bkpt_occur_vld           (iu_had_inst_bkpt_occur_vld          ),
  .iu_had_int_ack                       (iu_had_int_ack                      ),
  .iu_had_retire_with_had_int           (iu_had_retire_with_had_int          ),
  .iu_had_trace_occur_vld               (iu_had_trace_occur_vld              ),
  .iu_had_xx_bkpt_inst                  (iu_had_xx_bkpt_inst                 ),
  .iu_had_xx_data                       (iu_had_xx_data                      ),
  .iu_had_xx_data_vld                   (iu_had_xx_data_vld                  ),
  .iu_had_xx_dbg_ack                    (iu_had_xx_dbg_ack                   ),
  .iu_had_xx_mldst                      (iu_had_xx_mldst                     ),
  .iu_had_xx_retire                     (iu_had_xx_retire                    ),
  .iu_had_xx_retire_normal              (iu_had_xx_retire_normal             ),
  .iu_had_xx_retire_pc                  (iu_had_xx_retire_pc                 ),
  .iu_pad_gpr_data                      (iu_pad_gpr_data                     ),
  .iu_pad_gpr_index                     (iu_pad_gpr_index                    ),
  .iu_pad_gpr_we                        (iu_pad_gpr_we                       ),
  .iu_pad_inst_retire                   (iu_pad_inst_retire                  ),
  .iu_pad_inst_split                    (iu_pad_inst_split                   ),
  .iu_pad_retire_pc                     (iu_pad_retire_pc                    ),
  .iu_yy_xx_dbgon                       (iu_yy_xx_dbgon                      ),
  .lsu_had_addr                         (lsu_had_addr                        ),
  .lsu_had_addr_vld                     (lsu_had_addr_vld                    ),
  .lsu_had_ex_cmplt                     (lsu_had_ex_cmplt                    ),
  .lsu_had_st                           (lsu_had_st                          ),
  .pad_biu_hrdata                       (pad_biu_hrdata                      ),
  .pad_biu_hready                       (pad_biu_hready                      ),
  .pad_biu_hresp                        (pad_biu_hresp                       ),
  .pad_bmu_iahbl_base                   (pad_bmu_iahbl_base                  ),
  .pad_bmu_iahbl_mask                   (pad_bmu_iahbl_mask                  ),
  .pad_cpu_dfs_req                      (pad_cpu_dfs_req                     ),
  .pad_cpu_ext_int_b                    (pad_cpu_ext_int_b                   ),
  .pad_cpu_nmi                          (pad_cpu_nmi                         ),
  .pad_cpu_rst_addr                     (pad_cpu_rst_addr                    ),
  .pad_cpu_sys_cnt                      (pad_cpu_sys_cnt                     ),
  .pad_cpu_wakeup_event                 (pad_cpu_wakeup_event                ),
  .pad_iahbl_hrdata                     (pad_iahbl_hrdata                    ),
  .pad_iahbl_hready                     (pad_iahbl_hready                    ),
  .pad_iahbl_hresp                      (pad_iahbl_hresp                     ),
  .pad_sysio_dbgrq_b                    (pad_sysio_dbgrq_b                   ),
  .pad_yy_gate_clk_en_b                 (pad_yy_gate_clk_en_b                ),
  .pwrm_cpu_bus_peak_power_limit_en     (pwrm_cpu_bus_peak_power_limit_en    ),
  .sysio_clint_me_int                   (sysio_clint_me_int                  ),
  .sysio_clint_mtime                    (sysio_clint_mtime                   ),
  .sysio_had_sdb_req_b                  (sysio_had_sdb_req_b                 ),
  .sysio_pad_lpmd_b                     (sysio_pad_lpmd_b                    ),
  .tcip_cp0_clic_base                   (tcip_cp0_clic_base                  ),
  .tcipif_bmu_dbus_acc_err              (tcipif_bmu_dbus_acc_err             ),
  .tcipif_bmu_dbus_data                 (tcipif_bmu_dbus_data                ),
  .tcipif_bmu_dbus_data_vld             (tcipif_bmu_dbus_data_vld            ),
  .tcipif_bmu_dbus_grnt                 (tcipif_bmu_dbus_grnt                ),
  .tcipif_bmu_dbus_trans_cmplt          (tcipif_bmu_dbus_trans_cmplt         ),
  .tcipif_bmu_ibus_acc_err              (tcipif_bmu_ibus_acc_err             ),
  .tcipif_bmu_ibus_data                 (tcipif_bmu_ibus_data                ),
  .tcipif_bmu_ibus_data_vld             (tcipif_bmu_ibus_data_vld            ),
  .tcipif_bmu_ibus_grnt                 (tcipif_bmu_ibus_grnt                ),
  .tcipif_bmu_ibus_trans_cmplt          (tcipif_bmu_ibus_trans_cmplt         )
);

// &Force("output","sysio_pad_lpmd_b"); @268
// &Force("nonport","cp0_yy_machine_mode_aft_dbg"); @269

//==========================================================
//  Instance HAD module 
//==========================================================
// &Instance("cr_had_top"); @275
cr_had_top  x_cr_had_top (
  .clk_en                               (clk_en                              ),
  .cp0_had_cpuid_idx0                   (cp0_had_cpuid_idx0                  ),
  .cp0_had_int_exit                     (cp0_had_int_exit                    ),
  .cp0_had_lpmd_b                       (cp0_had_lpmd_b                      ),
  .cp0_had_mcause_data                  (cp0_had_mcause_data                 ),
  .forever_cpuclk_nogated               (forever_cpuclk_nogated              ),
  .had_core_dbg_mode_req                (had_core_dbg_mode_req               ),
  .had_idu_wbbr_data                    (had_idu_wbbr_data                   ),
  .had_idu_wbbr_vld                     (had_idu_wbbr_vld                    ),
  .had_ifu_inst_bkpt_dbq_req            (had_ifu_inst_bkpt_dbq_req           ),
  .had_ifu_inst_bkpt_dbqexp_req         (had_ifu_inst_bkpt_dbqexp_req        ),
  .had_ifu_ir                           (had_ifu_ir                          ),
  .had_ifu_ir_vld                       (had_ifu_ir_vld                      ),
  .had_iu_bkpt_trace_en                 (had_iu_bkpt_trace_en                ),
  .had_iu_dr_set_req                    (had_iu_dr_set_req                   ),
  .had_iu_force_dbg_en                  (had_iu_force_dbg_en                 ),
  .had_iu_int_vld                       (had_iu_int_vld                      ),
  .had_iu_mbkpt_fsm_index_mbee          (had_iu_mbkpt_fsm_index_mbee         ),
  .had_iu_mem_bkpt_exp_req              (had_iu_mem_bkpt_exp_req             ),
  .had_iu_mem_bkpt_mask                 (had_iu_mem_bkpt_mask                ),
  .had_iu_mem_bkpt_req                  (had_iu_mem_bkpt_req                 ),
  .had_iu_pc                            (had_iu_pc                           ),
  .had_iu_rte_pc_sel                    (had_iu_rte_pc_sel                   ),
  .had_iu_trace_req                     (had_iu_trace_req                    ),
  .had_iu_trace_req_for_dbg_disable     (had_iu_trace_req_for_dbg_disable    ),
  .had_iu_xx_fdb                        (had_iu_xx_fdb                       ),
  .had_iu_xx_jdbreq                     (had_iu_xx_jdbreq                    ),
  .had_pad_jdb_pm                       (had_pad_jdb_pm                      ),
  .had_pad_jtg_tms_o                    (had_pad_jtg_tms_o                   ),
  .had_pad_jtg_tms_oe                   (had_pad_jtg_tms_oe                  ),
  .had_tcipif_cmplt                     (had_tcipif_cmplt                    ),
  .had_tcipif_rdata                     (had_tcipif_rdata                    ),
  .had_yy_xx_dbg                        (had_yy_xx_dbg                       ),
  .had_yy_xx_dp_index_mbee              (had_yy_xx_dp_index_mbee             ),
  .had_yy_xx_exit_dbg                   (had_core_exit_dbg                   ),
  .hadrst_b                             (hadrst_b                            ),
  .ifu_had_chg_flw_inst                 (ifu_had_chg_flw_inst                ),
  .ifu_had_fetch_expt_vld               (ifu_had_fetch_expt_vld              ),
  .ifu_had_inst_dbg_disable             (ifu_had_inst_dbg_disable            ),
  .ifu_had_match_pc                     (ifu_had_match_pc                    ),
  .ifu_had_split_first                  (ifu_had_split_first                 ),
  .iu_had_adr_dbg_ack                   (iu_had_adr_dbg_ack                  ),
  .iu_had_chgflw_dst_pc                 (iu_had_chgflw_dst_pc                ),
  .iu_had_chgflw_vld                    (iu_had_chgflw_vld                   ),
  .iu_had_data_bkpt_occur_vld           (iu_had_data_bkpt_occur_vld          ),
  .iu_had_dbg_disable_for_tee           (iu_had_dbg_disable_for_tee          ),
  .iu_had_dr_dbg_ack                    (iu_had_dr_dbg_ack                   ),
  .iu_had_expt_vld                      (iu_had_expt_vld                     ),
  .iu_had_fast_retire_acc_err_pc_update (iu_had_fast_retire_acc_err_pc_update),
  .iu_had_fast_retire_acc_err_pc_val    (iu_had_fast_retire_acc_err_pc_val   ),
  .iu_had_flush                         (iu_had_flush                        ),
  .iu_had_inst_bkpt_occur_vld           (iu_had_inst_bkpt_occur_vld          ),
  .iu_had_int_ack                       (iu_had_int_ack                      ),
  .iu_had_retire_with_had_int           (iu_had_retire_with_had_int          ),
  .iu_had_trace_occur_vld               (iu_had_trace_occur_vld              ),
  .iu_had_xx_bkpt_inst                  (iu_had_xx_bkpt_inst                 ),
  .iu_had_xx_data                       (iu_had_xx_data                      ),
  .iu_had_xx_data_vld                   (iu_had_xx_data_vld                  ),
  .iu_had_xx_dbg_ack                    (iu_had_xx_dbg_ack                   ),
  .iu_had_xx_mldst                      (iu_had_xx_mldst                     ),
  .iu_had_xx_retire                     (iu_had_xx_retire                    ),
  .iu_had_xx_retire_normal              (iu_had_xx_retire_normal             ),
  .iu_had_xx_retire_pc                  (iu_had_xx_retire_pc                 ),
  .iu_yy_xx_dbgon                       (iu_yy_xx_dbgon                      ),
  .lsu_had_addr                         (lsu_had_addr                        ),
  .lsu_had_addr_vld                     (lsu_had_addr_vld                    ),
  .lsu_had_ex_cmplt                     (lsu_had_ex_cmplt                    ),
  .lsu_had_st                           (lsu_had_st                          ),
  .pad_had_jtg_tms_i                    (pad_had_jtg_tms_i                   ),
  .pad_yy_gate_clk_en_b                 (pad_yy_gate_clk_en_b                ),
  .sysio_had_sdb_req_b                  (sysio_had_sdb_req_b                 ),
  .tcipif_had_addr                      (tcipif_had_addr                     ),
  .tcipif_had_sel                       (tcipif_had_sel                      ),
  .tcipif_had_wdata                     (tcipif_had_wdata                    ),
  .tcipif_had_write                     (tcipif_had_write                    ),
  .tclk                                 (forever_jtgclk                      ),
  .trst_b                               (trst_b                              )
);

// &Connect( @276
// //         .cp0_yy_supv_mode  (cp0_had_supv_mode), @277
//          .tclk              (forever_jtgclk   ), @278
//          .had_yy_xx_exit_dbg(had_core_exit_dbg), @279
//         ); @280
// &Instance("cr_had_top_dummy"); @282

//==========================================================
//  Instance CLOCK and RST module 
//==========================================================
// &Instance("cr_clkrst_top"); @288
cr_clkrst_top  x_cr_clkrst_top (
  .cpurst_b               (cpurst_b              ),
  .forever_cpuclk         (forever_cpuclk        ),
  .forever_cpuclk_nogated (forever_cpuclk_nogated),
  .forever_jtgclk         (forever_jtgclk        ),
  .hadrst_b               (hadrst_b              ),
  .pad_cpu_rst_b          (pad_cpu_rst_b         ),
  .pad_had_jtg_tclk       (pad_had_jtg_tclk      ),
  .pad_had_jtg_trst_b     (pad_had_jtg_trst_b    ),
  .pad_had_rst_b          (pad_had_rst_b         ),
  .pad_yy_test_mode       (pad_yy_test_mode      ),
  .pll_core_cpuclk        (pll_core_cpuclk       ),
  .trst_b                 (trst_b                )
);


//==========================================================
//  Instance  TCIPIF module 
//==========================================================
// &Instance("cr_tcipif_top"); @294
cr_tcipif_top  x_cr_tcipif_top (
  .bmu_tcipif_dbus_acc_deny         (bmu_tcipif_dbus_acc_deny        ),
  .bmu_tcipif_dbus_addr             (bmu_tcipif_dbus_addr            ),
  .bmu_tcipif_dbus_chk_fail         (bmu_tcipif_dbus_chk_fail        ),
  .bmu_tcipif_dbus_req              (bmu_tcipif_dbus_req             ),
  .bmu_tcipif_dbus_size             (bmu_tcipif_dbus_size            ),
  .bmu_tcipif_dbus_supv_mode        (bmu_tcipif_dbus_supv_mode       ),
  .bmu_tcipif_dbus_wdata            (bmu_tcipif_dbus_wdata           ),
  .bmu_tcipif_dbus_write            (bmu_tcipif_dbus_write           ),
  .bmu_tcipif_ibus_acc_deny         (bmu_tcipif_ibus_acc_deny        ),
  .bmu_tcipif_ibus_addr             (bmu_tcipif_ibus_addr            ),
  .bmu_tcipif_ibus_req              (bmu_tcipif_ibus_req             ),
  .bmu_tcipif_ibus_write            (bmu_tcipif_ibus_write           ),
  .clic_cpu_int_hv                  (clic_cpu_int_hv                 ),
  .clic_cpu_int_id                  (clic_cpu_int_id                 ),
  .clic_cpu_int_il                  (clic_cpu_int_il                 ),
  .clic_cpu_int_priv                (clic_cpu_int_priv               ),
  .clint_cpu_me_int                 (clint_cpu_me_int                ),
  .cp0_yy_be_v2                     (cp0_yy_be_v2                    ),
  .cp0_yy_priv_mode                 (cp0_yy_priv_mode                ),
  .cpu_clic_curid                   (cpu_clic_curid                  ),
  .cpu_clic_int_exit                (cpu_clic_int_exit               ),
  .cpurst_b                         (cpurst_b                        ),
  .forever_cpuclk                   (forever_cpuclk                  ),
  .had_tcipif_cmplt                 (had_tcipif_cmplt                ),
  .had_tcipif_rdata                 (had_tcipif_rdata                ),
  .iu_yy_xx_dbgon                   (iu_yy_xx_dbgon                  ),
  .pad_clic_int_vld                 (pad_clic_int_vld                ),
  .pad_yy_gate_clk_en_b             (pad_yy_gate_clk_en_b            ),
  .pwrm_cpu_bus_peak_power_limit_en (pwrm_cpu_bus_peak_power_limit_en),
  .sysio_clint_me_int               (sysio_clint_me_int              ),
  .sysio_clint_mtime                (sysio_clint_mtime               ),
  .tcip_cp0_clic_base               (tcip_cp0_clic_base              ),
  .tcipif_bmu_dbus_acc_err          (tcipif_bmu_dbus_acc_err         ),
  .tcipif_bmu_dbus_data             (tcipif_bmu_dbus_data            ),
  .tcipif_bmu_dbus_data_vld         (tcipif_bmu_dbus_data_vld        ),
  .tcipif_bmu_dbus_grnt             (tcipif_bmu_dbus_grnt            ),
  .tcipif_bmu_dbus_trans_cmplt      (tcipif_bmu_dbus_trans_cmplt     ),
  .tcipif_bmu_ibus_acc_err          (tcipif_bmu_ibus_acc_err         ),
  .tcipif_bmu_ibus_data             (tcipif_bmu_ibus_data            ),
  .tcipif_bmu_ibus_data_vld         (tcipif_bmu_ibus_data_vld        ),
  .tcipif_bmu_ibus_grnt             (tcipif_bmu_ibus_grnt            ),
  .tcipif_bmu_ibus_trans_cmplt      (tcipif_bmu_ibus_trans_cmplt     ),
  .tcipif_had_addr                  (tcipif_had_addr                 ),
  .tcipif_had_sel                   (tcipif_had_sel                  ),
  .tcipif_had_wdata                 (tcipif_had_wdata                ),
  .tcipif_had_write                 (tcipif_had_write                )
);

// &Instance("cr_tcipif_top_dummy"); @296

// &Instance("cr_ebmu_top"); @303

//&Instance("nm_wic_top");
// //&Connect(.sysrst_b   (cpurst_b)); @307
// //&Connect(.pad_wic_int_vld(pad_vic_int_vld)); @308
// //&Connect(.pad_wic_int_cfg(pad_vic_int_cfg)); @309

assign clk_en = 1'b1;

// &ModuleEnd; @316
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_had_bkpt(
  bkpt_ctrl_inst_fetch_dbq_req,
  bkpt_ctrl_req,
  cpuclk,
  had_core_dbg_mode_req,
  hadrst_b,
  ifu_had_chg_flw_inst,
  ifu_had_fetch_expt_vld,
  ifu_had_inst_dbg_disable,
  ifu_had_match_pc,
  ifu_had_split_first,
  iu_had_expt_vld,
  iu_had_flush,
  iu_had_xx_mldst,
  iu_had_xx_retire,
  iu_had_xx_retire_normal,
  iu_yy_xx_dbgon,
  lsu_had_addr,
  lsu_had_addr_vld,
  lsu_had_ex_cmplt,
  lsu_had_st,
  regs_bkpt_base,
  regs_bkpt_ctrl,
  regs_bkpt_mask
);

// &Ports; @24
input           cpuclk;                      
input           had_core_dbg_mode_req;       
input           hadrst_b;                    
input           ifu_had_chg_flw_inst;        
input           ifu_had_fetch_expt_vld;      
input           ifu_had_inst_dbg_disable;    
input   [31:0]  ifu_had_match_pc;            
input           ifu_had_split_first;         
input           iu_had_expt_vld;             
input           iu_had_flush;                
input           iu_had_xx_mldst;             
input           iu_had_xx_retire;            
input           iu_had_xx_retire_normal;     
input           iu_yy_xx_dbgon;              
input   [31:0]  lsu_had_addr;                
input           lsu_had_addr_vld;            
input           lsu_had_ex_cmplt;            
input           lsu_had_st;                  
input   [31:0]  regs_bkpt_base;              
input   [2 :0]  regs_bkpt_ctrl;              
input   [7 :0]  regs_bkpt_mask;              
output          bkpt_ctrl_inst_fetch_dbq_req; 
output          bkpt_ctrl_req;               

// &Regs; @25
reg             bkpt_counter;                
reg             data_bkpt_vld_pre;           
reg             inst_fetch_bkpt_vld;         
reg             lsu_had_addr_vld_latch;      

// &Wires; @26
wire            bkpt_ctrl_inst_fetch_dbq_req; 
wire            bkpt_ctrl_req;               
wire            bkpt_en;                     
wire            bkpt_expt_reset;             
wire            counter_neg_dbg_req;         
wire            cpuclk;                      
wire            data_addr_match;             
wire            data_bkpt_dbg_req;           
wire            data_bkpt_match;             
wire            data_bkpt_match_vld;         
wire            data_bkpt_occur;             
wire            data_bkpt_vld;               
wire            had_core_dbg_mode_req;       
wire            hadrst_b;                    
wire            ifu_had_chg_flw_inst;        
wire            ifu_had_fetch_expt_vld;      
wire            ifu_had_inst_dbg_disable;    
wire    [31:0]  ifu_had_match_pc;            
wire            ifu_had_split_first;         
wire            inst_fetch_addr_match;       
wire            inst_fetch_bkpt_hit;         
wire            iu_had_expt_vld;             
wire            iu_had_flush;                
wire            iu_had_xx_mldst;             
wire            iu_had_xx_retire;            
wire            iu_had_xx_retire_normal;     
wire            iu_yy_xx_dbgon;              
wire    [31:0]  lsu_had_addr;                
wire            lsu_had_addr_vld;            
wire            lsu_had_ex_cmplt;            
wire            lsu_had_st;                  
wire    [31:0]  regs_bkpt_base;              
wire    [2 :0]  regs_bkpt_ctrl;              
wire    [7 :0]  regs_bkpt_mask;              


//==============================================================================
// memory bkpt enable condition (AND):
// 1. BC bits in HCR doesn't forbid memory bkpt;
// 2. CPUSCR CSR FDB bit is set.
//==============================================================================

assign bkpt_en = |regs_bkpt_ctrl[2:0];

//==============================================================================
// data bkpt occur condition (AND):
// 1. data address match
// 2. address from LSU is valid
//==============================================================================

assign data_addr_match = ((lsu_had_addr[31:0] & {24'hFF_FFFF,regs_bkpt_mask[7:0]})
                           == regs_bkpt_base[31:0]);

assign data_bkpt_match     = data_addr_match;
assign data_bkpt_match_vld = data_bkpt_match && lsu_had_addr_vld;

//when fast retire, data_bkpt_match_vld is 1'b1 when retire
//when no fast retire, the data_bkpt_match_vld is latched
assign data_bkpt_occur = (data_bkpt_match_vld || lsu_had_addr_vld_latch) &&
                         iu_had_xx_retire;

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    lsu_had_addr_vld_latch <= 1'b0;
  else if (lsu_had_ex_cmplt || iu_had_flush)
    lsu_had_addr_vld_latch <= 1'b0;
  else if (data_bkpt_match_vld)
    lsu_had_addr_vld_latch <= 1'b1;
  else
    lsu_had_addr_vld_latch <= lsu_had_addr_vld_latch;
end


//==============================================================================
// inst bkpt occur condition (AND):
// 1. inst retire address match
// 2. memory bkpt is enabled;
// 3. the current instruction in EX stage is retiring normally.
//==============================================================================

//assign inst_addr_match = ((iu_had_match_pc[31:0] & {24'hFF_FFFF, regs_bkpt_mask[7:0]})
//                             == regs_bkpt_base[31:0]);

//the inst bkpt hit and dbq req is judged in IF stage
assign inst_fetch_addr_match = ((ifu_had_match_pc[31:0]
                                 & {24'hFF_FFFF, regs_bkpt_mask[7:0]}
                                ) == regs_bkpt_base[31:0]
                               ); 

assign inst_fetch_bkpt_hit = inst_fetch_addr_match
                             && bkpt_en
                             && ifu_had_split_first
                             && !had_core_dbg_mode_req;

//assign had_ifu_inst_bkpt_hit_vld = inst_fetch_bkpt_vld
//                                   && !bkpt_counter_req_en;
//
////when inst bkpt hit and the counter is certain value, the bkpt will be
////triggled
//assign bkpt_ctrl_inst_fetch_dbq_req = inst_fetch_bkpt_vld
//                                      && bkpt_counter_req_en
//                                      && !ifu_had_fetch_expt_vld
//                                      && !ifu_had_inst_dbg_disable
//                                      && !iu_yy_xx_dbgon;
//
//assign bkpt_counter_req_en = bkpt_counter_eq_0
//                          || bkpt_counter_eq_1 && bkpt_counter_dec_1
//                          || bkpt_counter_eq_2 && bkpt_counter_dec_2;
//
//
////the inst bkpt counter dec is judged when inst retire
////when iu_had_inst_bkpt_hit is asserted, it means no inst fetch expt and no
////mldst inst, and the fetch addr in IF hit bkpt
//assign inst_addr_match = iu_had_inst_bkpt_hit; 
//
//assign inst_bkpt_occur = inst_addr_match
//                         && iu_had_xx_retire;
////==============================================================================
//// memory bkpt is controlled by BC bits in access property
////==============================================================================
////the inst bkpt is judge in IF, and when the inst is retired, the only job is 
////reduce the counter
//assign inst_bkpt_vld = inst_bkpt_occur;

// &CombBeg; @117
always @( regs_bkpt_ctrl[2:0]
       or ifu_had_chg_flw_inst
       or inst_fetch_bkpt_hit
       or data_bkpt_occur
       or lsu_had_st)
begin
  inst_fetch_bkpt_vld = 1'b0;
  data_bkpt_vld_pre = 1'b0;
  case (regs_bkpt_ctrl[2:0])
    3'b001: begin     // any access may cause bkpt
      inst_fetch_bkpt_vld = inst_fetch_bkpt_hit;
      data_bkpt_vld_pre = data_bkpt_occur;
    end
    3'b010:           // any instruction access may cause bkpt
      inst_fetch_bkpt_vld = inst_fetch_bkpt_hit;
    3'b011:           // any data access may cause bkpt
      data_bkpt_vld_pre = data_bkpt_occur;
    3'b100:           // any change flow instruction may casue bkpt 
      inst_fetch_bkpt_vld = inst_fetch_bkpt_hit && ifu_had_chg_flw_inst;
    3'b101:           // any store data access may cause bkpt
      data_bkpt_vld_pre = data_bkpt_occur && lsu_had_st;
    3'b110:           // any load data access may cause bkpt
      data_bkpt_vld_pre = data_bkpt_occur && !lsu_had_st;
    default: begin
      inst_fetch_bkpt_vld = 1'b0;
      data_bkpt_vld_pre = 1'b0;
    end
  endcase
// &CombEnd; @140
end

assign data_bkpt_vld = bkpt_en && data_bkpt_vld_pre;
assign bkpt_ctrl_inst_fetch_dbq_req = inst_fetch_bkpt_vld
                                  && !ifu_had_fetch_expt_vld
                                  && !ifu_had_inst_dbg_disable
                                  && !iu_yy_xx_dbgon;

assign bkpt_expt_reset = iu_had_expt_vld;
 
//the counter to record the bkpt hit when split
always @(posedge cpuclk or negedge hadrst_b)
begin
  if(!hadrst_b)
    bkpt_counter <= 1'b0;
  else if (bkpt_ctrl_req || bkpt_expt_reset)
    bkpt_counter <= 1'b0;
  else if (!bkpt_counter && data_bkpt_vld && iu_had_xx_mldst)
    bkpt_counter <= 1'b1;
  else
    bkpt_counter <= bkpt_counter;
end

assign data_bkpt_dbg_req   = !bkpt_counter && data_bkpt_vld && !iu_had_xx_mldst;

assign counter_neg_dbg_req = bkpt_counter  && !iu_had_xx_mldst
                          && iu_had_xx_retire;

// &Force("output","bkpt_ctrl_req"); @168
assign bkpt_ctrl_req =   (data_bkpt_dbg_req || counter_neg_dbg_req)
                      && !iu_yy_xx_dbgon
                      && bkpt_en
                      && iu_had_xx_retire_normal;

// &ModuleEnd; @174
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_had_ctrl(
  bkpta_ctrl_inst_fetch_dbq_req,
  bkpta_ctrl_req,
  bkptb_ctrl_inst_fetch_dbq_req,
  bkptb_ctrl_req,
  bkptc_ctrl_inst_fetch_dbq_req,
  bkptc_ctrl_req,
  bkptd_ctrl_inst_fetch_dbq_req,
  bkptd_ctrl_req,
  bkpte_ctrl_inst_fetch_dbq_req,
  bkpte_ctrl_req,
  cpuclk,
  ctrl_regs_exit_dbg,
  ctrl_regs_update_adro,
  ctrl_regs_update_dro,
  ctrl_regs_update_mbo,
  ctrl_regs_update_swo,
  ctrl_regs_update_to,
  had_ifu_inst_bkpt_dbq_req,
  had_ifu_inst_bkpt_dbqexp_req,
  had_iu_bkpt_trace_en,
  had_iu_dr_set_req,
  had_iu_mbkpt_fsm_index_mbee,
  had_iu_mem_bkpt_exp_req,
  had_iu_mem_bkpt_mask,
  had_iu_mem_bkpt_req,
  had_iu_trace_req,
  had_iu_trace_req_for_dbg_disable,
  had_iu_xx_jdbreq,
  had_yy_xx_dbg,
  had_yy_xx_dp_index_mbee,
  had_yy_xx_exit_dbg,
  hadrst_b,
  iu_had_adr_dbg_ack,
  iu_had_chgflw_dst_pc,
  iu_had_chgflw_vld,
  iu_had_data_bkpt_occur_vld,
  iu_had_dbg_disable_for_tee,
  iu_had_dr_dbg_ack,
  iu_had_inst_bkpt_occur_vld,
  iu_had_trace_occur_vld,
  iu_had_xx_bkpt_inst,
  iu_yy_xx_dbgon,
  jtag_xx_update_dr,
  pin_ctrl_jdb_req,
  regs_bkpta_bkpti_en,
  regs_ctrl_adr,
  regs_ctrl_dr,
  regs_ctrl_exit_sel,
  regs_ctrl_hacr_ex,
  regs_ctrl_hacr_go,
  regs_ctrl_had_int_on,
  regs_ctrl_mbee,
  regs_trace_en,
  sysio_had_sdb_req_b,
  trace_ctrl_req,
  trace_ctrl_req_for_dbg_disable
);

// &Ports; @21
input           bkpta_ctrl_inst_fetch_dbq_req;   
input           bkpta_ctrl_req;                  
input           bkptb_ctrl_inst_fetch_dbq_req;   
input           bkptb_ctrl_req;                  
input           bkptc_ctrl_inst_fetch_dbq_req;   
input           bkptc_ctrl_req;                  
input           bkptd_ctrl_inst_fetch_dbq_req;   
input           bkptd_ctrl_req;                  
input           bkpte_ctrl_inst_fetch_dbq_req;   
input           bkpte_ctrl_req;                  
input           cpuclk;                          
input           hadrst_b;                        
input           iu_had_adr_dbg_ack;              
input   [31:0]  iu_had_chgflw_dst_pc;            
input           iu_had_chgflw_vld;               
input           iu_had_data_bkpt_occur_vld;      
input           iu_had_dbg_disable_for_tee;      
input           iu_had_dr_dbg_ack;               
input           iu_had_inst_bkpt_occur_vld;      
input           iu_had_trace_occur_vld;          
input           iu_had_xx_bkpt_inst;             
input           iu_yy_xx_dbgon;                  
input           jtag_xx_update_dr;               
input           pin_ctrl_jdb_req;                
input           regs_bkpta_bkpti_en;             
input           regs_ctrl_adr;                   
input           regs_ctrl_dr;                    
input           regs_ctrl_exit_sel;              
input           regs_ctrl_hacr_ex;               
input           regs_ctrl_hacr_go;               
input           regs_ctrl_had_int_on;            
input   [8 :0]  regs_ctrl_mbee;                  
input           regs_trace_en;                   
input           sysio_had_sdb_req_b;             
input           trace_ctrl_req;                  
input           trace_ctrl_req_for_dbg_disable;  
output          ctrl_regs_exit_dbg;              
output          ctrl_regs_update_adro;           
output          ctrl_regs_update_dro;            
output          ctrl_regs_update_mbo;            
output          ctrl_regs_update_swo;            
output          ctrl_regs_update_to;             
output          had_ifu_inst_bkpt_dbq_req;       
output          had_ifu_inst_bkpt_dbqexp_req;    
output          had_iu_bkpt_trace_en;            
output          had_iu_dr_set_req;               
output          had_iu_mbkpt_fsm_index_mbee;     
output          had_iu_mem_bkpt_exp_req;         
output          had_iu_mem_bkpt_mask;            
output          had_iu_mem_bkpt_req;             
output          had_iu_trace_req;                
output          had_iu_trace_req_for_dbg_disable; 
output          had_iu_xx_jdbreq;                
output          had_yy_xx_dbg;                   
output          had_yy_xx_dp_index_mbee;         
output          had_yy_xx_exit_dbg;              

// &Regs; @22
reg             ctrl_exit_dbg;                   

// &Wires; @23
wire            adr_set_req;                     
wire            bkpta_ctrl_inst_fetch_dbq_req;   
wire            bkpta_ctrl_req;                  
wire            bkptb_ctrl_inst_fetch_dbq_req;   
wire            bkptb_ctrl_req;                  
wire            bkptc_ctrl_inst_fetch_dbq_req;   
wire            bkptc_ctrl_req;                  
wire            bkptd_ctrl_inst_fetch_dbq_req;   
wire            bkptd_ctrl_req;                  
wire            bkpte_ctrl_inst_fetch_dbq_req;   
wire            bkpte_ctrl_req;                  
wire            cpuclk;                          
wire            ctrl_regs_exit_dbg;              
wire            ctrl_regs_update_adro;           
wire            ctrl_regs_update_dro;            
wire            ctrl_regs_update_mbo;            
wire            ctrl_regs_update_swo;            
wire            ctrl_regs_update_to;             
wire            dr_set_req;                      
wire            exit_dbg;                        
wire            had_ifu_inst_bkpt_dbq_req;       
wire            had_ifu_inst_bkpt_dbqexp_req;    
wire            had_iu_bkpt_trace_en;            
wire            had_iu_dr_set_req;               
wire            had_iu_mbkpt_fsm_index_mbee;     
wire            had_iu_mem_bkpt_exp_req;         
wire            had_iu_mem_bkpt_mask;            
wire            had_iu_mem_bkpt_req;             
wire            had_iu_trace_req;                
wire            had_iu_trace_req_for_dbg_disable; 
wire            had_iu_xx_jdbreq;                
wire            had_yy_xx_dbg;                   
wire            had_yy_xx_dp_index_mbee;         
wire            had_yy_xx_exit_dbg;              
wire            hadrst_b;                        
wire            iu_had_adr_dbg_ack;              
wire            iu_had_data_bkpt_occur_vld;      
wire            iu_had_dbg_disable_for_tee;      
wire            iu_had_dr_dbg_ack;               
wire            iu_had_inst_bkpt_occur_vld;      
wire            iu_had_trace_occur_vld;          
wire            iu_had_xx_bkpt_inst;             
wire            iu_yy_xx_dbgon;                  
wire            jtag_xx_update_dr;               
wire            mem_bkpt_dbg_req;                
wire            mem_bkpt_dbgexp_req;             
wire            pin_ctrl_jdb_req;                
wire            regs_bkpta_bkpti_en;             
wire            regs_ctrl_adr;                   
wire            regs_ctrl_dr;                    
wire            regs_ctrl_exit_sel;              
wire            regs_ctrl_hacr_ex;               
wire            regs_ctrl_hacr_go;               
wire            regs_ctrl_had_int_on;            
wire    [8 :0]  regs_ctrl_mbee;                  
wire            regs_trace_en;                   
wire            sync_dbg_req;                    
wire            sysio_had_sdb_req_b;             
wire            trace_ctrl_req;                  
wire            trace_ctrl_req_for_dbg_disable;  
wire            trace_req;                       


//==============================================================================
// debug request to IU
//==============================================================================

//==========================================================
// Two major kinds of debug requests are sent to IU from HAD
// 1. had_iu_xx_jdbreq : asynchronous debug request
// 2. compulsive debug: DR
// 3. trace
// 4. memory bkpt
//==========================================================

// &Force("bus","regs_ctrl_mbee",8,0); @37
assign trace_req = trace_ctrl_req;

// &CombBeg; @83
// &CombEnd; @96
// &CombBeg; @100
// &CombEnd; @113
// &CombBeg; @117
// &CombEnd; @130
// &CombBeg; @171
// &CombEnd; @182
// &CombBeg; @186
// &CombEnd; @197
// &CombBeg; @201
// &CombEnd; @212
assign mem_bkpt_dbg_req    = (bkpta_ctrl_req && !regs_ctrl_mbee[0])
                          || (bkptb_ctrl_req && !regs_ctrl_mbee[1])
                          || (bkptc_ctrl_req && !regs_ctrl_mbee[2])
                          || (bkptd_ctrl_req && !regs_ctrl_mbee[3])
                          || (bkpte_ctrl_req && !regs_ctrl_mbee[4]);
assign mem_bkpt_dbgexp_req = (bkpta_ctrl_req &&  regs_ctrl_mbee[0])
                          || (bkptb_ctrl_req &&  regs_ctrl_mbee[1])
                          || (bkptc_ctrl_req &&  regs_ctrl_mbee[2])
                          || (bkptd_ctrl_req &&  regs_ctrl_mbee[3])
                          || (bkpte_ctrl_req &&  regs_ctrl_mbee[4]);
// &CombBeg; @244
// &CombEnd; @253
// &CombBeg; @257
// &CombEnd; @266
// &CombBeg; @270
// &CombEnd; @279

//the inst bkpt dbq req is judged in IF
// &Force("output","had_ifu_inst_bkpt_dbq_req"); @304
// &Force("output","had_ifu_inst_bkpt_dbqexp_req"); @305
assign had_ifu_inst_bkpt_dbq_req = ((bkpta_ctrl_inst_fetch_dbq_req
                                 && !regs_ctrl_mbee[0])
                                 || (bkptb_ctrl_inst_fetch_dbq_req
                                 && !regs_ctrl_mbee[1])
                                 || (bkptc_ctrl_inst_fetch_dbq_req
                                 && !regs_ctrl_mbee[2])
                                 || (bkptd_ctrl_inst_fetch_dbq_req
                                 && !regs_ctrl_mbee[3])
                                 || (bkpte_ctrl_inst_fetch_dbq_req
                                 && !regs_ctrl_mbee[4])
                                   ) && !regs_ctrl_had_int_on
                                     && !iu_had_dbg_disable_for_tee;

assign had_ifu_inst_bkpt_dbqexp_req = ((bkpta_ctrl_inst_fetch_dbq_req
                                    &&  regs_ctrl_mbee[0])
                                    || (bkptb_ctrl_inst_fetch_dbq_req
                                    &&  regs_ctrl_mbee[1])
                                    || (bkptc_ctrl_inst_fetch_dbq_req
                                    &&  regs_ctrl_mbee[2])
                                    || (bkptd_ctrl_inst_fetch_dbq_req
                                    &&  regs_ctrl_mbee[3])
                                    || (bkpte_ctrl_inst_fetch_dbq_req
                                    &&  regs_ctrl_mbee[4])
                                      ) && !regs_ctrl_had_int_on
                                        && !iu_had_dbg_disable_for_tee;


assign dr_set_req  = regs_ctrl_dr;

assign adr_set_req = regs_ctrl_adr;

assign sync_dbg_req = dr_set_req || !sysio_had_sdb_req_b;

assign had_iu_dr_set_req = sync_dbg_req && !iu_yy_xx_dbgon;

assign had_iu_trace_req = trace_req && !iu_yy_xx_dbgon;

assign had_iu_mem_bkpt_req = mem_bkpt_dbg_req && !iu_yy_xx_dbgon;

assign had_iu_mem_bkpt_mask = (mem_bkpt_dbg_req || mem_bkpt_dbgexp_req) && !iu_yy_xx_dbgon;

assign had_iu_mem_bkpt_exp_req = 1'b0;

assign had_iu_xx_jdbreq =  (pin_ctrl_jdb_req || adr_set_req) 
                        && !iu_yy_xx_dbgon;

//dbg diable for branch inst
assign had_iu_trace_req_for_dbg_disable = trace_ctrl_req_for_dbg_disable
                                       && !iu_yy_xx_dbgon;

//when trace and bkpt is enable, speculate stack for INT is disabled
assign had_iu_bkpt_trace_en = regs_bkpta_bkpti_en || regs_trace_en;

//==============================================================================
// debug request to CP0 to force CPU to exit low power mode 
// debug request to SYSIO to indicating CPU wake up ack 
// including sync and async dbg req ack
//==============================================================================

assign had_yy_xx_dbg = dr_set_req
                    || pin_ctrl_jdb_req
                    || adr_set_req;

//==============================================================================
// Update HCR
//==============================================================================

//==========================================================
// All the debug request will be acknowledged
//==========================================================

//======================================
// Update ADRO 
//======================================

assign ctrl_regs_update_adro = iu_had_adr_dbg_ack;

//======================================
// Update DRO 
//======================================

assign ctrl_regs_update_dro = iu_had_dr_dbg_ack;

//======================================
// Update MBO 
//======================================

assign ctrl_regs_update_mbo = iu_had_data_bkpt_occur_vld 
                           || iu_had_inst_bkpt_occur_vld;

//======================================
// Update SWO 
//======================================

assign ctrl_regs_update_swo = iu_had_xx_bkpt_inst;

//======================================
// Update TO 
//======================================

assign ctrl_regs_update_to = iu_had_trace_occur_vld;


//==============================================================================
// Exit debug mode 
//==============================================================================

//assign exit_dbg = (ir_ctrl_ex && ir_ctrl_go) && sm_ctrl_exit && iu_yy_xx_dbgon;
assign exit_dbg = (regs_ctrl_hacr_ex && regs_ctrl_hacr_go) &&
                  jtag_xx_update_dr && regs_ctrl_exit_sel  &&
                  iu_yy_xx_dbgon;
// exit_dbg is a pulse signal, flop one cylce to generate exit debug signal
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    ctrl_exit_dbg <= 1'b0;
  else 
    ctrl_exit_dbg <= exit_dbg;
end

assign ctrl_regs_exit_dbg = ctrl_exit_dbg;

assign had_yy_xx_exit_dbg = ctrl_exit_dbg;

//================================================
// Go in debug mode
//================================================
//assign ctrl_regs_go_noex = !ir_ctrl_ex && ir_ctrl_go;

//   &CombBeg; @535
//   &CombEnd; @548
  assign had_iu_mbkpt_fsm_index_mbee = 1'b0;

// &CombBeg; @558
// &CombEnd; @571
assign had_yy_xx_dp_index_mbee = 1'b0;



//==========================================================
//               pcfifo enable only for debug(not verified)
//==========================================================

// pcfifo write enable contains three conditions:
//   1. pcfifo not frozen
//   2. change flow inst retire normally
//   3. not in debug mode

//assign ctrl_pcfifo_wen = !regs_ctrl_pcfifo_frozen && !inst_bkpt_req &&
//                         rtu_had_chg_flw_inst && rtu_yy_xx_retire &&
//			 cp0_had_pcfifo_wen &&
//                         !rtu_yy_xx_dbgon;
// &Force("input","iu_had_chgflw_vld"); @622
// &Force("input","iu_had_chgflw_dst_pc"); @623
// &Force("bus","iu_had_chgflw_dst_pc",31,0); @624
// &ModuleEnd; @626
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_had_ddc(
  cpuclk,
  ddc_regs_ffy,
  ddc_regs_ir,
  ddc_regs_update_csr,
  ddc_regs_update_ir,
  hadrst_b,
  iu_had_xx_retire,
  jtag_xx_update_dr,
  regs_ddc_daddr_sel,
  regs_ddc_ddata_sel,
  regs_xx_ddc_en
);

// &Ports; @21
input           cpuclk;             
input           hadrst_b;           
input           iu_had_xx_retire;   
input           jtag_xx_update_dr;  
input           regs_ddc_daddr_sel; 
input           regs_ddc_ddata_sel; 
input           regs_xx_ddc_en;     
output          ddc_regs_ffy;       
output  [31:0]  ddc_regs_ir;        
output          ddc_regs_update_csr; 
output          ddc_regs_update_ir; 

// &Regs; @22
reg     [3 :0]  cur_st;             
reg     [3 :0]  nxt_st;             

// &Wires; @23
wire            addr_gen;           
wire            addr_ready;         
wire            addr_sel;           
wire            cpuclk;             
wire            data_ld_finish;     
wire            data_ready;         
wire            data_sel;           
wire            ddc_regs_ffy;       
wire    [31:0]  ddc_regs_ir;        
wire            ddc_regs_update_csr; 
wire            ddc_regs_update_ir; 
wire            hadrst_b;           
wire            iu_had_xx_retire;   
wire            jtag_xx_update_dr;  
wire            regs_ddc_daddr_sel; 
wire            regs_ddc_ddata_sel; 
wire            regs_xx_ddc_en;     
wire            stw_inst_retire;    
wire            stw_sel;            


//==============================================================================
//                           DDC control state machine 
//==============================================================================

parameter DDC_IDLE        = 4'h0;
parameter DDC_ADDR_WAIT   = 4'h1;
parameter DDC_ADDR_LD     = 4'h2;
parameter DDC_DATA_WAIT   = 4'h3;
parameter DDC_DATA_LD     = 4'h4;
parameter DDC_STW_WAIT    = 4'h5;
parameter DDC_STW_LD      = 4'h6;
parameter DDC_STW_FINISH  = 4'h7;
parameter DDC_ADDR_GEN    = 4'h8;

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    cur_st[3:0] <= DDC_IDLE;
  else
    cur_st[3:0] <= nxt_st[3:0];
end

always @( * )
begin
  case(cur_st[3:0])
    DDC_IDLE : begin
      if (regs_xx_ddc_en)
        nxt_st[3:0] = DDC_ADDR_WAIT;
      else
        nxt_st[3:0] = DDC_IDLE;
    end
    DDC_ADDR_WAIT : begin // wait addr be loaded into daddr
      if (addr_ready)
        nxt_st[3:0] = DDC_ADDR_LD;
      else
        nxt_st[3:0] = DDC_ADDR_WAIT;
    end
    DDC_ADDR_LD : begin  // load "mov r0, r0" to ir, ffy and wbbr
      nxt_st[3:0] = DDC_DATA_WAIT;
    end
    DDC_DATA_WAIT : begin
      // if (addr_ld_finish && data_ready) // wait base prepare finish and data ready.
      if (data_ready) // wait base prepare finish and data ready.
        nxt_st[3:0] = DDC_DATA_LD;
      else if (addr_ready) // re-prepare base
        nxt_st[3:0] = DDC_ADDR_LD;
      else if (!regs_xx_ddc_en)
        nxt_st[3:0] = DDC_IDLE;
      else
        nxt_st[3:0] = DDC_DATA_WAIT;
    end
    DDC_DATA_LD : begin
      nxt_st[3:0] = DDC_STW_WAIT; // load "mov r1, r1" to ir, ffy and wbbr
    end
    DDC_STW_WAIT : begin
      if (data_ld_finish)  // wait for "mov r1, r1" retire: data prepare finish
        nxt_st[3:0] = DDC_STW_LD;
      else
        nxt_st[3:0] = DDC_STW_WAIT;
    end
    DDC_STW_LD : begin      // load "stw r1, r0" to ir
      nxt_st[3:0] = DDC_STW_FINISH;
    end
    DDC_STW_FINISH : begin // wait for stw finish
      if (stw_inst_retire)
        nxt_st[3:0] = DDC_ADDR_GEN;
      else
        nxt_st[3:0] = DDC_STW_FINISH;
    end
    DDC_ADDR_GEN : begin   // increase addr and recycle
      nxt_st[3:0] = DDC_DATA_WAIT;
    end
    default : begin
      nxt_st[3:0] = DDC_IDLE;
    end
  endcase
end

// addr load finish
// always @(posedge cpuclk or negedge hadrst_b)
// begin
//   if (!hadrst_b)
//     addr_ld_finish <= 1'b0;
//   else if (cur_st[3:0] == DATA_WAIT) begin
//     if (iu_had_xx_retire)
//       addr_ld_finish <= 1'b1;
//     else
//       addr_ld_finish <= addr_ld_finish; // hold finish state
//   end
//   else
//     addr_ld_finish <= 1'b0;
// end

// data load finish will push state machine into next state, so the state
// needn't hold
assign data_ld_finish = iu_had_xx_retire;
assign stw_inst_retire = iu_had_xx_retire;

//==========================================================
// state machine control signals
assign addr_ready = jtag_xx_update_dr && regs_ddc_daddr_sel;
assign data_ready = jtag_xx_update_dr && regs_ddc_ddata_sel;

//==========================================================
// state machine status
assign addr_sel   = cur_st[3:0] == DDC_ADDR_LD;
assign data_sel   = cur_st[3:0] == DDC_DATA_LD;
assign stw_sel    = cur_st[3:0] == DDC_STW_LD;
assign addr_gen   = cur_st[3:0] == DDC_ADDR_GEN;

//==============================================================================
// DDC Data path
//==============================================================================

//==========================================================
// load data into DDC data reg from scan chain
//always @(posedge cpuclk)
//begin
//  if (data_ready)
//    ddata_reg[31:0] <= jtag_xx_data[31:0];
//  else
//    ddata_reg[31:0] <= ddata_reg[31:0];
//end

//==========================================================
// load address into DDC addr reg from scan chain
//always @(posedge cpuclk)
//begin
//  if (addr_ready)
//    daddr_reg[31:0] <= jtag_xx_data[31:0];
//  else if (addr_gen)
//    daddr_reg[31:0] <= daddr_reg[31:0] + 3'b100;
//  else
//    daddr_reg[31:0] <= daddr_reg[31:0];
//end

//==========================================================
// Update HAD Regs
// 1. WBBR
//assign ddc_regs_update_wbbr = addr_sel || data_sel;
//assign ddc_regs_wbbr[31:0] = addr_sel ? daddr_reg[31:0] : ddata_reg[31:0];
// 2. IR
assign ddc_regs_update_ir   = addr_sel || data_sel || stw_sel || addr_gen;
// by zhaocj for rv32 assign ddc_regs_ir[31:0] = addr_sel ? 32'hc4004820  // mov32 r0, r0
// by zhaocj for rv32                          : data_sel ? 32'hc4014821  // mov32 r1, r1
// by zhaocj for rv32                          : stw_sel  ? 32'hdc202000  // st32.w r1, r0, #0
// by zhaocj for rv32                          : 32'he4000003;  // addi32 r0, r0, 0x4
assign ddc_regs_ir[31:0] = addr_sel ? 32'h00008093  // mv x1, x1
                         : data_sel ? 32'h00010113  // mv x2, x2
                         : stw_sel  ? 32'h0020a023  // sw x2, 0x0(x1)
                         : 32'h00408093;  // addi x1, x1, 0x4

// 3. CSR
assign ddc_regs_update_csr  = addr_sel || data_sel || stw_sel || addr_gen;
assign ddc_regs_ffy = (addr_sel || data_sel) ? 1'b1 : 1'b0;
//// 4. DADDR
//assign ddc_regs_ddata[31:0] = ddata_reg[31:0];
//// 5. DDATA
//assign ddc_regs_daddr[31:0] = daddr_reg[31:0];

// &ModuleEnd; @185
endmodule




/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_had_inst_bkpt_lite(
  bkpt_ctrl_inst_fetch_dbq_req,
  bkpt_ctrl_req,
  had_core_dbg_mode_req,
  ifu_had_fetch_expt_vld,
  ifu_had_inst_dbg_disable,
  ifu_had_match_pc,
  ifu_had_split_first,
  iu_yy_xx_dbgon,
  regs_bkpt_base,
  regs_bkpt_en
);

// &Ports; @23
input           had_core_dbg_mode_req;       
input           ifu_had_fetch_expt_vld;      
input           ifu_had_inst_dbg_disable;    
input   [31:0]  ifu_had_match_pc;            
input           ifu_had_split_first;         
input           iu_yy_xx_dbgon;              
input   [31:0]  regs_bkpt_base;              
input           regs_bkpt_en;                
output          bkpt_ctrl_inst_fetch_dbq_req; 
output          bkpt_ctrl_req;               

// &Regs; @24

// &Wires; @25
wire            bkpt_ctrl_inst_fetch_dbq_req; 
wire            bkpt_ctrl_req;               
wire            bkpt_en;                     
wire            had_core_dbg_mode_req;       
wire            ifu_had_fetch_expt_vld;      
wire            ifu_had_inst_dbg_disable;    
wire    [31:0]  ifu_had_match_pc;            
wire            ifu_had_split_first;         
wire            inst_addr_match;             
wire            inst_bkpt_occur;             
wire            inst_bkpt_vld;               
wire            iu_yy_xx_dbgon;              
wire    [31:0]  regs_bkpt_base;              
wire            regs_bkpt_en;                


assign bkpt_en = regs_bkpt_en;

//==============================================================================
// inst bkpt occur condition (AND):
// 1. inst retire address match
// 2. memory bkpt is enabled;
// 3. the current instruction in EX stage is retiring normally.
//==============================================================================

//assign inst_addr_match = ((ifu_had_match_pc[31:0] & {24'hFF_FFFF, regs_bkpt_mask[7:0]})
//                             == regs_bkpt_base[31:0]);
assign inst_addr_match = (ifu_had_match_pc[31:0] == regs_bkpt_base[31:0]);                             

assign inst_bkpt_occur = inst_addr_match
                         && !ifu_had_fetch_expt_vld
                         && !ifu_had_inst_dbg_disable
                         && ifu_had_split_first
                         && !iu_yy_xx_dbgon
                         && !had_core_dbg_mode_req;
                             

assign inst_bkpt_vld = bkpt_en ? inst_bkpt_occur : 1'b0;

//==============================================================================
// memory bkpt request condition(AND):
// 1. inst_bkpt_vld or data_bkpt_vld or both vld;
// 2. not in debug mode.
//==============================================================================
assign bkpt_ctrl_inst_fetch_dbq_req = inst_bkpt_vld;

assign bkpt_ctrl_req = 1'b0;
// assign bkpt_expt_reset = iu_had_expt_vld;
// 
// //the counter to record the bkpt hit when split
// always @(posedge cpuclk or negedge hadrst_b)
// begin
//   if(!hadrst_b)
//     bkpt_counter <= 1'b0;
//   else if (bkpt_ctrl_req || bkpt_expt_reset)
//     bkpt_counter <= 1'b0;
//   else if (!bkpt_counter && data_bkpt_vld && iu_had_xx_mldst)
//     bkpt_counter <= 1'b1;
//   else
//     bkpt_counter <= bkpt_counter;
// end
// 
// assign data_bkpt_dbg_req   = !bkpt_counter && data_bkpt_vld && !iu_had_xx_mldst;
// 
// assign counter_neg_dbg_req = bkpt_counter && !iu_had_xx_mldst
//                              && iu_had_xx_retire;
// 
// // &Force("output","bkpt_ctrl_req"); @78
// assign bkpt_ctrl_req = (data_bkpt_dbg_req || counter_neg_dbg_req)
//                        && !iu_yy_xx_dbgon
//                        && iu_had_xx_retire_normal
//                        && bkpt_en;

// &ModuleEnd; @84
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_had_jtag2(
  cpuclk,
  hadrst_b,
  jtag2_pin_tms_o,
  jtag2_pin_tms_oe,
  jtag_regs_srst,
  jtag_regs_update_hacr,
  jtag_xx_capture_dr,
  jtag_xx_capture_dr_mask,
  jtag_xx_data,
  jtag_xx_update_dr,
  pin_sm_tap_en,
  pin_xx_tms_i,
  regs_jtag_data,
  regs_jtag_hacr_rw,
  regs_jtag_reg16_sel,
  regs_jtag_reg8_sel,
  sm_xx_tap_on,
  tclk,
  trst_b
);

// &Ports; @21
input           cpuclk;                 
input           hadrst_b;               
input           pin_sm_tap_en;          
input           pin_xx_tms_i;           
input   [31:0]  regs_jtag_data;         
input           regs_jtag_hacr_rw;      
input           regs_jtag_reg16_sel;    
input           regs_jtag_reg8_sel;     
input           tclk;                   
input           trst_b;                 
output          jtag2_pin_tms_o;        
output          jtag2_pin_tms_oe;       
output          jtag_regs_srst;         
output          jtag_regs_update_hacr;  
output          jtag_xx_capture_dr;     
output          jtag_xx_capture_dr_mask; 
output  [31:0]  jtag_xx_data;           
output          jtag_xx_update_dr;      
output          sm_xx_tap_on;           

// &Regs; @22
reg             parity;                 
reg     [31:0]  shifter;                
reg     [31:0]  shifter_pre;            
reg     [3 :0]  sm2_cur_st;             
reg     [4 :0]  sm2_data_counter;       
reg     [3 :0]  sm2_nxt_st;             
reg             sm2_parity;             
reg             sm2_read_vld;           
reg     [1 :0]  sm2_rs;                 
reg             sm2_rs_counter;         
reg     [6 :0]  sm2_rst_cnt;            
reg             tdo;                    
reg             tms_oe;                 

// &Wires; @23
wire            cpuclk;                 
wire            had_pad_wakeup_req_b;   
wire            hadrst_b;               
wire            jtag2_pin_tms_o;        
wire            jtag2_pin_tms_oe;       
wire            jtag_regs_srst;         
wire            jtag_regs_update_hacr;  
wire            jtag_xx_capture_dr;     
wire            jtag_xx_capture_dr_mask; 
wire    [31:0]  jtag_xx_data;           
wire            jtag_xx_update_dr;      
wire            pin_sm_tap_en;          
wire            pin_xx_tms_i;           
wire    [31:0]  regs_jtag_data;         
wire            sm2_capture_dr;         
wire            sm2_capture_dr_cpu;     
wire            sm2_capture_dr_mask;    
wire            sm2_capture_dr_mask_cpu; 
wire            sm2_load_rw;            
wire            sm2_parity_vld;         
wire            sm2_rs_cdic_dr_sel;     
wire            sm2_rs_had_dr_sel;      
wire            sm2_rs_had_ir_sel;      
wire            sm2_rst_vld;            
wire            sm2_rst_vld_cpu;        
wire            sm2_shift_dr;           
wire            sm2_shift_ir;           
wire            sm2_shift_par;          
wire            sm2_shift_sync;         
wire            sm2_shift_vld;          
wire            sm2_start_vld;          
wire            sm2_sync_vld;           
wire            sm2_trn1;               
wire            sm2_trn2;               
wire            sm2_update_dr;          
wire            sm2_update_dr_cpu;      
wire            sm2_update_ir;          
wire            sm2_update_ir_cpu;      
wire            sm_xx_tap_on;           
wire            tclk;                   
wire            tdi;                    
wire            tms_i;                  
wire            trst_b;                 


//==============================================================================
// TAP controller state encoding: using Gray code for low power
// TAP controller state machine: Tclk domain
//==============================================================================
// state machine state definition
parameter TAP2_IDLE   = 4'b0000;
parameter TAP2_START  = 4'b0001;
parameter TAP2_RW     = 4'b0011;
parameter TAP2_RS     = 4'b0010;
parameter TAP2_TRN1   = 4'b0110;
parameter TAP2_DATA   = 4'b0111;
parameter TAP2_SYNC   = 4'b0101;
parameter TAP2_PARITY = 4'b0100;
parameter TAP2_TRN2   = 4'b1100;

// state machine statement No. 1
// state machine state transfer, tclk trigged
always @(posedge tclk or negedge trst_b)
begin
  if (!trst_b)
    sm2_cur_st[3:0] <= TAP2_IDLE;
  else if (sm2_rst_vld && tms_i)
    sm2_cur_st[3:0] <= TAP2_IDLE;
  else
    sm2_cur_st[3:0] <= sm2_nxt_st[3:0];
end

// jtag2 syncronous reset logic
always @(posedge tclk or negedge trst_b)
begin
  if (!trst_b)
    sm2_rst_cnt[6:0] <= 7'd80;
  else begin
    if (!tms_i)
      sm2_rst_cnt[6:0] <= 7'd80;
    else if (sm2_rst_cnt[6:0] != 7'd0)
      sm2_rst_cnt[6:0] <= sm2_rst_cnt[6:0] - 7'd1;
    else
      sm2_rst_cnt[6:0] <= 7'd80;
  end
end

assign sm2_rst_vld = (sm2_rst_cnt[6:0] == 7'd00);

//==========================================================
// sm2_rst_vld is used to reset registers in cpuclk domain,
// thus synchronization is needed.
//==========================================================
// &Instance("cr_had_sync", "x_cr_had_sync_sm2_rst"); @73
cr_had_sync  x_cr_had_sync_sm2_rst (
  .clk1            (cpuclk         ),
  .clk2            (tclk           ),
  .rst1_b          (hadrst_b       ),
  .rst2_b          (trst_b         ),
  .sync_in         (sm2_rst_vld    ),
  .sync_out        (sm2_rst_vld_cpu)
);

// &Connect(.clk1           (cpuclk), @74
//          .clk2           (tclk), @75
//          .rst1_b         (hadrst_b), @76
//          .rst2_b         (trst_b), @77
//          .sync_in        (sm2_rst_vld), @78
//          .sync_out       (sm2_rst_vld_cpu) @79
//         ); @80
assign jtag_regs_srst = sm2_rst_vld_cpu;

// state machine statement No. 2
always @( * )
begin
  case (sm2_cur_st[3:0])
    TAP2_IDLE : begin
      if (pin_sm_tap_en) begin
        if (!tms_i)
          sm2_nxt_st[3:0] = TAP2_RW;
        else
          sm2_nxt_st[3:0] = TAP2_START;
      end
      else
        sm2_nxt_st[3:0] = TAP2_IDLE;
    end
    TAP2_START : begin
      if (!tms_i) // sample START bit, logic 0
        sm2_nxt_st[3:0] = TAP2_RW;
      else
        sm2_nxt_st[3:0] = TAP2_START;
    end
    TAP2_RW : begin  // RnW bit, 1=Read Op, 0=Write Op
      sm2_nxt_st[3:0] = TAP2_RS;
    end
    TAP2_RS : begin // RS[1:0] - Register Group Select
      if (sm2_rs_counter == 1'b0)
        sm2_nxt_st[3:0] = TAP2_TRN1;
      else
        sm2_nxt_st[3:0] = TAP2_RS;
    end
    TAP2_TRN1 : begin // Turn Around 1
      if (sm2_read_vld)  // Read operation need a sync cycle
        sm2_nxt_st[3:0] = TAP2_SYNC;
      else               // write operation
        sm2_nxt_st[3:0] = TAP2_DATA;
    end
    TAP2_SYNC : begin
      sm2_nxt_st[3:0] = TAP2_DATA;
    end
    TAP2_DATA : begin // IR or DR, Sample or Set
      if (sm2_data_counter[4:0] == 5'b0)
        sm2_nxt_st[3:0] = TAP2_PARITY;
      else
        sm2_nxt_st[3:0] = TAP2_DATA;
    end
    TAP2_PARITY : begin
      sm2_nxt_st[3:0] = TAP2_TRN2;
    end
    TAP2_TRN2 : begin
      sm2_nxt_st[3:0] = TAP2_START;
    end
    default : begin
      sm2_nxt_st[3:0] = TAP2_IDLE;
    end
  endcase
end

// state machine statement No. 3
//==========================================================
// state machine status
assign sm2_load_rw    = sm2_cur_st[3:0] == TAP2_RW;
assign sm2_trn1       = sm2_cur_st[3:0] == TAP2_TRN1;
assign sm2_trn2       = sm2_cur_st[3:0] == TAP2_TRN2;
assign sm2_start_vld  = sm2_cur_st[3:0] == TAP2_RW;
assign sm2_shift_vld  = sm2_cur_st[3:0] == TAP2_DATA;
assign sm2_parity_vld = sm2_cur_st[3:0] == TAP2_PARITY;
assign sm2_sync_vld   = sm2_cur_st[3:0] == TAP2_SYNC;

assign sm2_shift_par  = sm2_parity_vld;
assign sm2_shift_sync = sm2_sync_vld;

//======================================
// update IR, DR, sync with cpuclk
assign sm2_shift_ir   = sm2_rs_had_ir_sel && sm2_shift_vld;
assign sm2_shift_dr   = sm2_rs_had_dr_sel && sm2_shift_vld;
assign sm2_update_ir  = sm2_rs_had_ir_sel && sm2_trn2      && (!sm2_parity);
assign sm2_update_dr  = sm2_rs_had_dr_sel && !sm2_read_vld && sm2_trn2 && (!sm2_parity);
assign sm2_capture_dr = sm2_rs_had_dr_sel &&  sm2_read_vld && sm2_trn1;

// &Instance("cr_had_sync", "x_cr_had_sync_ir"); @161
cr_had_sync  x_cr_had_sync_ir (
  .clk1              (cpuclk           ),
  .clk2              (tclk             ),
  .rst1_b            (hadrst_b         ),
  .rst2_b            (trst_b           ),
  .sync_in           (sm2_update_ir    ),
  .sync_out          (sm2_update_ir_cpu)
);

// &Connect(.clk1           (cpuclk), @162
//          .clk2           (tclk), @163
//          .rst1_b         (hadrst_b), @164
//          .rst2_b         (trst_b), @165
//          .sync_in        (sm2_update_ir), @166
//          .sync_out       (sm2_update_ir_cpu) @167
//         ); @168

// &Instance("cr_had_sync", "x_cr_had_sync_dr"); @170
cr_had_sync  x_cr_had_sync_dr (
  .clk1              (cpuclk           ),
  .clk2              (tclk             ),
  .rst1_b            (hadrst_b         ),
  .rst2_b            (trst_b           ),
  .sync_in           (sm2_update_dr    ),
  .sync_out          (sm2_update_dr_cpu)
);

// &Connect(.clk1           (cpuclk), @171
//          .clk2           (tclk), @172
//          .rst1_b         (hadrst_b), @173
//          .rst2_b         (trst_b), @174
//          .sync_in        (sm2_update_dr), @175
//          .sync_out       (sm2_update_dr_cpu) @176
//         ); @177

// &Instance("cr_had_sync", "x_cr_had_sync_cap_dr"); @180
cr_had_sync  x_cr_had_sync_cap_dr (
  .clk1               (cpuclk            ),
  .clk2               (tclk              ),
  .rst1_b             (hadrst_b          ),
  .rst2_b             (trst_b            ),
  .sync_in            (sm2_capture_dr    ),
  .sync_out           (sm2_capture_dr_cpu)
);

// &Connect(.clk1           (cpuclk), @181
//          .clk2           (tclk), @182
//          .rst1_b         (hadrst_b), @183
//          .rst2_b         (trst_b), @184
//          .sync_in        (sm2_capture_dr), @185
//          .sync_out       (sm2_capture_dr_cpu) @186
//         ); @187
assign jtag_xx_capture_dr    = sm2_capture_dr_cpu; 

// &Instance("cr_had_sync", "x_cr_had_sync_cap_dr"); @194
// &Connect(.clk1           (cpuclk), @195
//          .clk2           (tclk), @196
//          .rst1_b         (hadrst_b), @197
//          .rst2_b         (trst_b), @198
//          .sync_in        (sm2_capture_dr), @199
//          .sync_out       (sm2_capture_dr_cpu) @200
//         );   @201

// &Instance("cr_had_sync_level", "x_cr_had_sync_cap_dr_mask"); @209
// &Connect(.clk1           (cpuclk), @210
//          .clk2           (tclk), @211
//          .rst1_b         (hadrst_b), @212
//          .rst2_b         (trst_b), @213
//          .sync_in        (sm2_capture_dr_mask), @214
//          .sync_out       (sm2_capture_dr_mask_cpu) @215
//         ); @216
  assign sm2_capture_dr_mask = (sm2_cur_st[3:0] == TAP2_RS)
                            || (sm2_cur_st[3:0] == TAP2_TRN1);
//   &Instance("cr_had_sync_level", "x_cr_had_sync_cap_dr_mask"); @222
cr_had_sync_level  x_cr_had_sync_cap_dr_mask (
  .clk1                    (cpuclk                 ),
  .clk2                    (tclk                   ),
  .rst1_b                  (hadrst_b               ),
  .rst2_b                  (trst_b                 ),
  .sync_in                 (sm2_capture_dr_mask    ),
  .sync_out                (sm2_capture_dr_mask_cpu)
);

//   &Connect(.clk1           (cpuclk), @223
//            .clk2           (tclk), @224
//            .rst1_b         (hadrst_b), @225
//            .rst2_b         (trst_b), @226
//            .sync_in        (sm2_capture_dr_mask), @227
//            .sync_out       (sm2_capture_dr_mask_cpu) @228
//           ); @229
  assign jtag_xx_capture_dr_mask    = sm2_capture_dr_mask_cpu;

assign jtag_regs_update_hacr = sm2_update_ir_cpu;
assign jtag_xx_update_dr     = sm2_update_dr_cpu;

//the wake up signal from jtag when CPU is in lpmd
assign had_pad_wakeup_req_b = (sm2_cur_st[3:0] == TAP2_IDLE)
                           || (sm2_cur_st[3:0] == TAP2_START);
// &Force("nonport", "had_pad_wakeup_req_b"); @240
//======================================
// load the RW
// &Force("input", "regs_jtag_hacr_rw"); @243
always @(posedge tclk)
begin
  if (sm2_load_rw)
    sm2_read_vld <= pin_xx_tms_i;
end

//======================================
// load the RS[1:0]
always @(posedge tclk)
begin
  if (sm2_start_vld)
    sm2_rs_counter <= 1'b1;
  else if (sm2_cur_st[3:0] == TAP2_RS)
    sm2_rs_counter <= 1'b0;
  else
    sm2_rs_counter <= sm2_rs_counter;
end

always @(posedge tclk)
begin
  if (sm2_cur_st[3:0] == TAP2_RS)
    sm2_rs[1:0] <= {pin_xx_tms_i, sm2_rs[1]};
  else
    sm2_rs[1:0] <= sm2_rs[1:0];
end

// assign sm2_rs_cdic_ir_sel = sm2_rs[1:0] == 2'b00;
assign sm2_rs_cdic_dr_sel = sm2_rs[1:0] == 2'b01;
assign sm2_rs_had_ir_sel  = sm2_rs[1:0] == 2'b10;
assign sm2_rs_had_dr_sel  = sm2_rs[1:0] == 2'b11;

//======================================
// DATA shift length
// 8-bit for HAD_IR, 32-bit for HAD_DR
always @(posedge tclk)
begin
  if (sm2_cur_st[3:0] == TAP2_TRN1) begin
    if (sm2_rs_had_dr_sel || sm2_rs_cdic_dr_sel)
      sm2_data_counter[4:0] <= 5'b11111;
    else
      sm2_data_counter[4:0] <= 5'b00111;
  end
  else if (sm2_shift_vld)
    sm2_data_counter[4:0] <= sm2_data_counter[4:0] - 5'b1;
end

//======================================
// TMS output Enable
always @(posedge tclk or negedge trst_b)
begin
  if (!trst_b)
    tms_oe <= 1'b0; // default is input
  else if (sm2_rst_vld)
    tms_oe <= 1'b0;
  else if (sm2_trn1 && sm2_read_vld)
    tms_oe <= 1'b1;
  else if (sm2_trn2)
    tms_oe <= 1'b0;
  else
    tms_oe <= tms_oe;
end

//======================================
// Parity Check
always @(posedge tclk)
begin
  if (sm2_start_vld)
    sm2_parity <= 1'b1;
  else if ((sm2_rs_had_dr_sel || sm2_rs_had_ir_sel) && sm2_shift_vld)
    sm2_parity <= sm2_parity ^ pin_xx_tms_i; // calculate the parity bit
  else if (sm2_parity_vld)
    sm2_parity <= sm2_parity ^ pin_xx_tms_i; // check received parity bit
  else
    sm2_parity <= sm2_parity;
end

//==============================================================================
// TAP controller on signal to enable had clock (for low power)
//==============================================================================
// &Force("output", "sm_xx_tap_on"); @326
assign sm_xx_tap_on = 1'b1;

//==============================================================================
// data shift in and out 
//==============================================================================
// &Force("input", "regs_jtag_reg8_sel"); @344
// &Force("input", "regs_jtag_reg16_sel"); @345

always @( * )
begin
  shifter_pre[31:0] = 32'b0;
  if (sm2_shift_ir)        // shift ir (ir register is write only)
    shifter_pre[7:0]  = {tdi, shifter[7:1]};
  else if (sm2_capture_dr) // capture dr
    shifter_pre[31:0] = regs_jtag_data[31:0];
  else if (sm2_shift_dr)   // shift dr
    shifter_pre[31:0] = {tdi, shifter[31:1]};
  else 
    shifter_pre[31:0] = shifter[31:0];
end

assign jtag_xx_data[31:0] = shifter[31:0];

// sample tms_i on the posedge of tclk
always @(posedge tclk)
begin
  shifter[31:0] <= shifter_pre[31:0];
end

// set tms_o on the negedge of tclk
// set tms_o to logic 1 when IDLE
always @(negedge tclk or negedge trst_b)
begin
  if (!trst_b)
    tdo <= 1'b1;
  else if (sm2_shift_sync)
    tdo <= 1'b0;
  else if (sm2_shift_dr && sm2_read_vld)
    tdo <= shifter[0];
  else if (sm2_shift_par && sm2_read_vld)
    tdo <= parity;
  else
    tdo <= 1'b1;
end

// calculate the parity bit when read DR
always @(posedge tclk)
begin
  if (sm2_capture_dr)
    parity <= 1'b1;
  else if (sm2_shift_dr && sm2_read_vld)
    parity <= parity ^ shifter[0];
  else
    parity <= parity;
end

//==============================================================================
// JTAG data input and output signal
//==============================================================================
assign jtag2_pin_tms_oe = tms_oe;
assign jtag2_pin_tms_o  = tdo;
assign tms_i            = pin_xx_tms_i;
assign tdi              = pin_xx_tms_i;

// &ModuleEnd; @403
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_had_pin(
  clk_en,
  cpuclk,
  had_pad_jdb_pm,
  had_pad_jtg_tms_o,
  had_pad_jtg_tms_oe,
  hadrst_b,
  iu_yy_xx_dbgon,
  jtag2_pin_tms_o,
  jtag2_pin_tms_oe,
  pad_had_jtg_tms_i,
  pin_ctrl_jdb_req,
  pin_sm_tap_en,
  pin_xx_tms_i,
  regs_pin_pm,
  tclk,
  trst_b
);

// &Ports; @21
input          clk_en;            
input          cpuclk;            
input          hadrst_b;          
input          iu_yy_xx_dbgon;    
input          jtag2_pin_tms_o;   
input          jtag2_pin_tms_oe;  
input          pad_had_jtg_tms_i; 
input   [1:0]  regs_pin_pm;       
input          tclk;              
input          trst_b;            
output  [1:0]  had_pad_jdb_pm;    
output         had_pad_jtg_tms_o; 
output         had_pad_jtg_tms_oe; 
output         pin_ctrl_jdb_req;  
output         pin_sm_tap_en;     
output         pin_xx_tms_i;      

// &Regs; @22
reg            had_pad_jdb_ack_b; 
reg     [1:0]  had_pad_jdb_pm;    
reg            jdb_ack_clr;       

// &Wires; @23
wire           clk_en;            
wire           cpuclk;            
wire           had_pad_jtg_tap_on; 
wire           had_pad_jtg_tms_o; 
wire           had_pad_jtg_tms_oe; 
wire           hadrst_b;          
wire           iu_yy_xx_dbgon;    
wire    [1:0]  jdb_pm;            
wire           jdb_tap_en;        
wire           jtag2_pin_tms_o;   
wire           jtag2_pin_tms_oe;  
wire           pad_had_jtg_tap_en; 
wire           pad_had_jtg_tms_i; 
wire           pin_ctrl_jdb_req;  
wire           pin_sm_tap_en;     
wire           pin_xx_tms_i;      
wire    [1:0]  regs_pin_pm;       
wire           tclk;              
wire           trst_b;            


//==============================================================================
// Had pin in
//==============================================================================
// // &Force("input","pad_had_jdb_req_b"); @28
//==========================================================
// pad_had_jdb_req_b is asynchronous with Tclk,
// flop two Tclk cycles to generate jdb_tap_en and eleminate metastability
//==========================================================

//always @(posedge tclk or negedge trst_b)
//begin
//  if (!trst_b) begin
//    jdb_req_b_ff1 <= 1'b1;
//    jdb_req_b_ff2 <= 1'b1;
//  end
//  else begin
//    jdb_req_b_ff1 <= pad_had_jdb_req_b;
//    jdb_req_b_ff2 <= jdb_req_b_ff1;
//  end
//end

//assign jdb_tap_en = !jdb_req_b_ff2;
assign jdb_tap_en = 1'b0;

//==========================================================
// Asychronous debug request generated to HAD control path.
// flop two cpuclk to generate jbd_req and eleminate metastability
//==========================================================

//always @(posedge cpuclk or negedge hadrst_b)
//begin
//  if (!hadrst_b) begin
//    jdb_req_b_ff3 <= 1'b1;
//    jdb_req_b_ff4 <= 1'b1;
//  end
//  else begin
//    jdb_req_b_ff3 <= pad_had_jdb_req_b;
//    jdb_req_b_ff4 <= jdb_req_b_ff3;
//  end
//end

//assign pin_ctrl_jdb_req = !jdb_req_b_ff4;
assign pin_ctrl_jdb_req = 1'b0;

//==========================================================
// External tap enable signal, flop two Tclk cycles to eleminate metastability
//==========================================================

// always @(posedge tclk or negedge trst_b)
// begin
//   if (!trst_b) begin
//     jtg_tap_en_ff1 <= 1'b0;
//     jtg_tap_en_ff2 <= 1'b0;
//   end
//   else begin
//     jtg_tap_en_ff1 <= pad_had_jtg_tap_en;
//     jtg_tap_en_ff2 <= jtg_tap_en_ff1;
//   end  
// end
// 
// assign jtg_tap_en = jtg_tap_en_ff2;

//==========================================================
// TAP enable signal has two sources:
// 1. jdb_tap_en
// 2. jtg_tap_en
//==========================================================

// Modified Reason: to eleminate relucdant cycles to enter IDLE state
// and keep compatability of software.
// &Force("output", "pin_sm_tap_en"); @95
//assign pin_sm_tap_en = jdb_tap_en || jtg_tap_en;
assign pad_had_jtg_tap_en = 1'b1;
assign pin_sm_tap_en = jdb_tap_en || pad_had_jtg_tap_en;

//==============================================================================
// Had pin out
//==============================================================================

//==========================================================
// CPU mode indicator, asychronous to Tclk
//==========================================================

assign jdb_pm[1:0] = regs_pin_pm[1:0];

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
  begin
   had_pad_jdb_pm[1:0] <= 2'b0;
  end
  else if(clk_en)
  begin
   had_pad_jdb_pm[1:0] <= jdb_pm[1:0];
  end
end
//==========================================================
// CPU output debug ack signal, keep at least 2 tclk LOW. 
// No sychronization is needed though iu_yy_xx_dbgon is cpuclk signal.
//==========================================================

// &Force("nonport", "had_pad_jdb_ack_b"); @126

always @(posedge tclk or negedge trst_b)
begin
  if (!trst_b)
    had_pad_jdb_ack_b <= 1'b1;
  else if (jdb_ack_clr)
    had_pad_jdb_ack_b <= 1'b1;
  else if (iu_yy_xx_dbgon)
    had_pad_jdb_ack_b <= 1'b0;
  else
    had_pad_jdb_ack_b <= had_pad_jdb_ack_b;
end

always @(posedge tclk or negedge trst_b)
begin
  if (!trst_b)
    jdb_ack_clr <= 1'b0;
  else if (!had_pad_jdb_ack_b)
    jdb_ack_clr <= 1'b1;
  else if (!iu_yy_xx_dbgon)
    jdb_ack_clr <= 1'b0;
  else
    jdb_ack_clr <= jdb_ack_clr;
end

//==========================================================
// TAP controller status indicator
//==========================================================

assign had_pad_jtg_tap_on = pin_sm_tap_en;
// &Force("nonport", "had_pad_jtg_tap_on"); @157

assign pin_xx_tms_i = pad_had_jtg_tms_i;
assign had_pad_jtg_tms_o = jtag2_pin_tms_o;
assign had_pad_jtg_tms_oe = jtag2_pin_tms_oe;

// &ModuleEnd; @170
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_had_regs(
  cp0_had_cpuid_idx0,
  cp0_had_int_exit,
  cp0_had_lpmd_b,
  cp0_had_mcause_data,
  cpuclk,
  ctrl_regs_exit_dbg,
  ctrl_regs_update_adro,
  ctrl_regs_update_dro,
  ctrl_regs_update_mbo,
  ctrl_regs_update_swo,
  ctrl_regs_update_to,
  ddc_regs_ffy,
  ddc_regs_ir,
  ddc_regs_update_csr,
  ddc_regs_update_ir,
  had_core_dbg_mode_req,
  had_idu_wbbr_data,
  had_idu_wbbr_vld,
  had_ifu_ir,
  had_ifu_ir_vld,
  had_iu_force_dbg_en,
  had_iu_int_vld,
  had_iu_pc,
  had_iu_rte_pc_sel,
  had_iu_xx_fdb,
  had_tcipif_cmplt,
  had_tcipif_rdata,
  hadrst_b,
  iu_had_fast_retire_acc_err_pc_update,
  iu_had_fast_retire_acc_err_pc_val,
  iu_had_int_ack,
  iu_had_retire_with_had_int,
  iu_had_xx_data,
  iu_had_xx_data_vld,
  iu_had_xx_dbg_ack,
  iu_had_xx_retire_pc,
  iu_yy_xx_dbgon,
  jtag_regs_srst,
  jtag_regs_update_hacr,
  jtag_xx_capture_dr,
  jtag_xx_capture_dr_mask,
  jtag_xx_data,
  jtag_xx_update_dr,
  regs_bkpta_base,
  regs_bkpta_bkpti_en,
  regs_bkpta_ctrl,
  regs_bkpta_mask,
  regs_bkptb_base,
  regs_bkptb_ctrl,
  regs_bkptb_mask,
  regs_bkptc_base,
  regs_bkptc_en,
  regs_bkptd_base,
  regs_bkptd_en,
  regs_bkpte_base,
  regs_bkpte_en,
  regs_ctrl_adr,
  regs_ctrl_dr,
  regs_ctrl_exit_sel,
  regs_ctrl_hacr_ex,
  regs_ctrl_hacr_go,
  regs_ctrl_had_int_on,
  regs_ctrl_mbee,
  regs_ddc_daddr_sel,
  regs_ddc_ddata_sel,
  regs_jtag_data,
  regs_jtag_hacr_rw,
  regs_jtag_reg16_sel,
  regs_jtag_reg8_sel,
  regs_pin_pm,
  regs_trace_en,
  regs_xx_ddc_en,
  tcipif_had_addr,
  tcipif_had_sel,
  tcipif_had_wdata,
  tcipif_had_write
);

// &Ports; @23
input   [31:0]  cp0_had_cpuid_idx0;                  
input           cp0_had_int_exit;                    
input   [1 :0]  cp0_had_lpmd_b;                      
input   [31:0]  cp0_had_mcause_data;                 
input           cpuclk;                              
input           ctrl_regs_exit_dbg;                  
input           ctrl_regs_update_adro;               
input           ctrl_regs_update_dro;                
input           ctrl_regs_update_mbo;                
input           ctrl_regs_update_swo;                
input           ctrl_regs_update_to;                 
input           ddc_regs_ffy;                        
input   [31:0]  ddc_regs_ir;                         
input           ddc_regs_update_csr;                 
input           ddc_regs_update_ir;                  
input           hadrst_b;                            
input           iu_had_fast_retire_acc_err_pc_update; 
input   [30:0]  iu_had_fast_retire_acc_err_pc_val;   
input           iu_had_int_ack;                      
input           iu_had_retire_with_had_int;          
input   [31:0]  iu_had_xx_data;                      
input           iu_had_xx_data_vld;                  
input           iu_had_xx_dbg_ack;                   
input   [31:0]  iu_had_xx_retire_pc;                 
input           iu_yy_xx_dbgon;                      
input           jtag_regs_srst;                      
input           jtag_regs_update_hacr;               
input           jtag_xx_capture_dr;                  
input           jtag_xx_capture_dr_mask;             
input   [31:0]  jtag_xx_data;                        
input           jtag_xx_update_dr;                   
input   [15:0]  tcipif_had_addr;                     
input           tcipif_had_sel;                      
input   [31:0]  tcipif_had_wdata;                    
input           tcipif_had_write;                    
output          had_core_dbg_mode_req;               
output  [31:0]  had_idu_wbbr_data;                   
output          had_idu_wbbr_vld;                    
output  [31:0]  had_ifu_ir;                          
output          had_ifu_ir_vld;                      
output          had_iu_force_dbg_en;                 
output          had_iu_int_vld;                      
output  [30:0]  had_iu_pc;                           
output          had_iu_rte_pc_sel;                   
output          had_iu_xx_fdb;                       
output          had_tcipif_cmplt;                    
output  [31:0]  had_tcipif_rdata;                    
output  [31:0]  regs_bkpta_base;                     
output          regs_bkpta_bkpti_en;                 
output  [2 :0]  regs_bkpta_ctrl;                     
output  [7 :0]  regs_bkpta_mask;                     
output  [31:0]  regs_bkptb_base;                     
output  [2 :0]  regs_bkptb_ctrl;                     
output  [7 :0]  regs_bkptb_mask;                     
output  [31:0]  regs_bkptc_base;                     
output          regs_bkptc_en;                       
output  [31:0]  regs_bkptd_base;                     
output          regs_bkptd_en;                       
output  [31:0]  regs_bkpte_base;                     
output          regs_bkpte_en;                       
output          regs_ctrl_adr;                       
output          regs_ctrl_dr;                        
output          regs_ctrl_exit_sel;                  
output          regs_ctrl_hacr_ex;                   
output          regs_ctrl_hacr_go;                   
output          regs_ctrl_had_int_on;                
output  [8 :0]  regs_ctrl_mbee;                      
output          regs_ddc_daddr_sel;                  
output          regs_ddc_ddata_sel;                  
output  [31:0]  regs_jtag_data;                      
output          regs_jtag_hacr_rw;                   
output          regs_jtag_reg16_sel;                 
output          regs_jtag_reg8_sel;                  
output  [1 :0]  regs_pin_pm;                         
output          regs_trace_en;                       
output          regs_xx_ddc_en;                      

// &Regs; @24
reg             adro;                                
reg     [31:0]  baba_reg;                            
reg     [31:0]  babb_reg;                            
reg     [31:0]  babc_reg;                            
reg     [31:0]  babd_reg;                            
reg     [31:0]  babe_reg;                            
reg     [7 :0]  bama_reg;                            
reg     [7 :0]  bamb_reg;                            
reg     [1 :0]  bsel;                                
reg     [31:0]  ddera_reg;                           
reg             ddera_vld;                           
reg     [31:0]  dderb_reg;                           
reg             dderb_vld;                           
reg             dro;                                 
reg             fdb;                                 
reg             ffy;                                 
reg     [7 :0]  hacr_reg;                            
reg     [7 :0]  had_mcause_mil;                      
reg             had_mcause_mpie;                     
reg     [1 :0]  had_mcause_mpp;                      
reg             had_mcause_mpsp;                     
reg             hcr_adr;                             
reg     [2 :0]  hcr_bca;                             
reg     [2 :0]  hcr_bcb;                             
reg             hcr_bxen_bkptc;                      
reg             hcr_bxen_bkptd;                      
reg             hcr_bxen_bkpte;                      
reg             hcr_ddcen;                           
reg             hcr_dr;                              
reg             hcr_jtgr_int_en;                     
reg             hcr_jtgw_int_en;                     
reg             hcr_tme;                             
reg             jr_active;                           
reg             jr_pending;                          
reg             jw_active;                           
reg             jw_pending;                          
reg             mbo;                                 
reg     [30:0]  pc;                                  
reg             pm_dbg_mode;                         
reg     [31:0]  regs_rdata;                          
reg             rte_pc_sel;                          
reg             swo;                                 
reg             to;                                  
reg     [31:0]  wbbr_reg;                            

// &Wires; @25
wire            baba_wen;                            
wire            babb_wen;                            
wire            babc_wen;                            
wire            babd_wen;                            
wire            babe_wen;                            
wire    [31:0]  babf_reg;                            
wire    [31:0]  babg_reg;                            
wire    [31:0]  babh_reg;                            
wire    [31:0]  babi_reg;                            
wire            bama_wen;                            
wire            bamb_wen;                            
wire    [7 :0]  bamc_reg;                            
wire    [7 :0]  bamd_reg;                            
wire    [7 :0]  bame_reg;                            
wire    [7 :0]  bamf_reg;                            
wire    [7 :0]  bamg_reg;                            
wire    [7 :0]  bamh_reg;                            
wire    [7 :0]  bami_reg;                            
wire            bsel_0;                              
wire            bsel_0_jtg;                          
wire            bsel_0_tcipif;                       
wire            bsel_1;                              
wire            bsel_1_jtg;                          
wire            bsel_1_tcipif;                       
wire    [1 :0]  bsel_val;                            
wire            bsel_wen;                            
wire    [31:0]  cp0_had_cpuid_idx0;                  
wire            cp0_had_int_exit;                    
wire    [1 :0]  cp0_had_lpmd_b;                      
wire    [31:0]  cp0_had_mcause_data;                 
wire            cp0_had_secu_dbg_en;                 
wire            cpu_hsr2_wen;                        
wire            cpuclk;                              
wire    [15:0]  csr_reg;                             
wire            csr_wen;                             
wire            ctrl_regs_exit_dbg;                  
wire            ctrl_regs_update_adro;               
wire            ctrl_regs_update_dro;                
wire            ctrl_regs_update_mbo;                
wire            ctrl_regs_update_swo;                
wire            ctrl_regs_update_to;                 
wire    [31:0]  dacsr_rd_val;                        
wire    [31:0]  dacsr_reg;                           
wire    [31:0]  darwr_reg;                           
wire    [31:0]  datr_reg;                            
wire    [31:0]  dbg_ctrl_reg;                        
wire            dbgexp_regs_updt_vld;                
wire            dcc_regs_updt_vld;                   
wire            ddc_regs_ffy;                        
wire    [31:0]  ddc_regs_ir;                         
wire            ddc_regs_update_csr;                 
wire            ddc_regs_update_ir;                  
wire    [31:0]  dder_rd_val;                         
wire            ddera_ren;                           
wire            ddera_wen;                           
wire            dderb_ren;                           
wire            dderb_wen;                           
wire    [31:0]  force_reg;                           
wire            hacr_ex;                             
wire            hacr_go;                             
wire            hacr_indx_baba_sel;                  
wire            hacr_indx_baba_sel_rd;               
wire            hacr_indx_babb_sel;                  
wire            hacr_indx_babb_sel_rd;               
wire            hacr_indx_babc_sel;                  
wire            hacr_indx_babc_sel_rd;               
wire            hacr_indx_babd_sel;                  
wire            hacr_indx_babd_sel_rd;               
wire            hacr_indx_babe_sel;                  
wire            hacr_indx_babe_sel_rd;               
wire            hacr_indx_babf_sel;                  
wire            hacr_indx_babf_sel_rd;               
wire            hacr_indx_babg_sel;                  
wire            hacr_indx_babg_sel_rd;               
wire            hacr_indx_babh_sel;                  
wire            hacr_indx_babh_sel_rd;               
wire            hacr_indx_babi_sel;                  
wire            hacr_indx_babi_sel_rd;               
wire            hacr_indx_bama_sel;                  
wire            hacr_indx_bama_sel_rd;               
wire            hacr_indx_bamb_sel;                  
wire            hacr_indx_bamb_sel_rd;               
wire            hacr_indx_bamc_sel;                  
wire            hacr_indx_bamc_sel_rd;               
wire            hacr_indx_bamd_sel;                  
wire            hacr_indx_bamd_sel_rd;               
wire            hacr_indx_bame_sel;                  
wire            hacr_indx_bame_sel_rd;               
wire            hacr_indx_bamf_sel;                  
wire            hacr_indx_bamf_sel_rd;               
wire            hacr_indx_bamg_sel;                  
wire            hacr_indx_bamg_sel_rd;               
wire            hacr_indx_bamh_sel;                  
wire            hacr_indx_bamh_sel_rd;               
wire            hacr_indx_bami_sel;                  
wire            hacr_indx_bami_sel_rd;               
wire            hacr_indx_bsel_sel;                  
wire            hacr_indx_bsel_sel_rd;               
wire            hacr_indx_bypass_sel;                
wire            hacr_indx_csr_sel;                   
wire            hacr_indx_csr_sel_rd;                
wire            hacr_indx_dacsr_sel;                 
wire            hacr_indx_dacsr_sel_rd;              
wire            hacr_indx_daddr_sel;                 
wire            hacr_indx_daddr_sel_rd;              
wire            hacr_indx_darwr_sel;                 
wire            hacr_indx_darwr_sel_rd;              
wire            hacr_indx_datr_sel;                  
wire            hacr_indx_datr_sel_rd;               
wire            hacr_indx_dbg_ctrl_sel;              
wire            hacr_indx_dbg_ctrl_sel_rd;           
wire            hacr_indx_ddata_sel;                 
wire            hacr_indx_ddata_sel_rd;              
wire            hacr_indx_dder_sel;                  
wire            hacr_indx_dder_sel_rd;               
wire            hacr_indx_force_reg_sel;             
wire            hacr_indx_force_reg_sel_rd;          
wire            hacr_indx_hcr_sel;                   
wire            hacr_indx_hcr_sel_rd;                
wire            hacr_indx_hsr2_sel;                  
wire            hacr_indx_hsr2_sel_rd;               
wire            hacr_indx_hsr_sel;                   
wire            hacr_indx_hsr_sel_rd;                
wire            hacr_indx_id_sel;                    
wire            hacr_indx_id_sel_rd;                 
wire            hacr_indx_ir_sel;                    
wire            hacr_indx_mbca_sel;                  
wire            hacr_indx_mbca_sel_rd;               
wire            hacr_indx_mbcb_sel;                  
wire            hacr_indx_mbcb_sel_rd;               
wire            hacr_indx_mbee_sel;                  
wire            hacr_indx_mbee_sel_rd;               
wire            hacr_indx_mbir_sel;                  
wire            hacr_indx_mbir_sel_rd;               
wire            hacr_indx_mbse_sel;                  
wire            hacr_indx_mbse_sel_rd;               
wire            hacr_indx_pc_sel;                    
wire            hacr_indx_pc_sel_rd;                 
wire            hacr_indx_prof_cnt_sel;              
wire            hacr_indx_prof_cnt_sel_rd;           
wire            hacr_indx_psr_sel;                   
wire            hacr_indx_psr_sel_rd;                
wire    [4 :0]  hacr_indx_reuse;                     
wire            hacr_indx_sysrsv_sel;                
wire            hacr_indx_sysrsv_sel_rd;             
wire            hacr_indx_tc_sel;                    
wire            hacr_indx_tc_sel_rd;                 
wire            hacr_indx_wbbr_sel;                  
wire            hacr_indx_wbbr_sel_rd;               
wire            hacr_rw;                             
wire            had_core_dbg_mode_req;               
wire    [31:0]  had_idu_wbbr_data;                   
wire            had_idu_wbbr_vld;                    
wire    [31:0]  had_ifu_ir;                          
wire            had_ifu_ir_vld;                      
wire            had_iu_force_dbg_en;                 
wire            had_iu_int_vld;                      
wire    [30:0]  had_iu_pc;                           
wire            had_iu_rte_pc_sel;                   
wire            had_iu_xx_fdb;                       
wire            had_tcipif_cmplt;                    
wire    [31:0]  had_tcipif_rdata;                    
wire            hadrst_b;                            
wire            hcr_bca_wen;                         
wire            hcr_bcb_wen;                         
wire    [6 :0]  hcr_bxen;                            
wire    [2 :0]  hcr_bxen_bkpt4;                      
wire    [3 :0]  hcr_bxen_bkpt8;                      
wire            hcr_bxen_bkptc_wen;                  
wire            hcr_bxen_bkptd_wen;                  
wire            hcr_bxen_bkpte_wen;                  
wire            hcr_dcc_wen;                         
wire            hcr_ddae;                            
wire    [31:0]  hcr_reg;                             
wire            hcr_wen_jtg_only;                    
wire    [31:0]  hsr2_reg;                            
wire            hsr_dbg_dis;                         
wire    [15:0]  hsr_reg;                             
wire    [31:0]  id_reg;                              
wire            iu_had_fast_retire_acc_err_pc_update; 
wire    [30:0]  iu_had_fast_retire_acc_err_pc_val;   
wire            iu_had_int_ack;                      
wire            iu_had_retire_with_had_int;          
wire    [31:0]  iu_had_xx_data;                      
wire            iu_had_xx_data_vld;                  
wire            iu_had_xx_dbg_ack;                   
wire    [31:0]  iu_had_xx_retire_pc;                 
wire            iu_yy_xx_dbgon;                      
wire            jtag_psr_pc_wen;                     
wire            jtag_regs_srst;                      
wire            jtag_regs_update_hacr;               
wire            jtag_xx_capture_dr;                  
wire            jtag_xx_capture_dr_mask;             
wire    [31:0]  jtag_xx_data;                        
wire            jtag_xx_update_dr;                   
wire    [31:0]  mbee_reg;                            
wire    [3 :0]  mbir_reg;                            
wire    [31:0]  mbse_reg;                            
wire    [31:0]  pc_reg;                              
wire            pc_wen;                              
wire    [1 :0]  pm;                                  
wire            pm_lowpwr_mode;                      
wire            prof_cnt_en;                         
wire    [31:0]  prof_cnt_reg;                        
wire    [31:0]  psr_reg;                             
wire            psr_wen;                             
wire    [31:0]  regs_bkpta_base;                     
wire            regs_bkpta_bkpti_en;                 
wire    [2 :0]  regs_bkpta_ctrl;                     
wire    [7 :0]  regs_bkpta_mask;                     
wire    [31:0]  regs_bkptb_base;                     
wire    [2 :0]  regs_bkptb_ctrl;                     
wire    [7 :0]  regs_bkptb_mask;                     
wire    [31:0]  regs_bkptc_base;                     
wire            regs_bkptc_en;                       
wire    [31:0]  regs_bkptd_base;                     
wire            regs_bkptd_en;                       
wire    [31:0]  regs_bkpte_base;                     
wire            regs_bkpte_en;                       
wire            regs_ctrl_adr;                       
wire            regs_ctrl_dr;                        
wire            regs_ctrl_exit_sel;                  
wire            regs_ctrl_hacr_ex;                   
wire            regs_ctrl_hacr_go;                   
wire            regs_ctrl_had_int_on;                
wire    [8 :0]  regs_ctrl_mbee;                      
wire            regs_ddc_daddr_sel;                  
wire            regs_ddc_ddata_sel;                  
wire    [31:0]  regs_jtag_data;                      
wire            regs_jtag_hacr_rw;                   
wire            regs_jtag_reg16_sel;                 
wire            regs_jtag_reg8_sel;                  
wire    [1 :0]  regs_pin_pm;                         
wire            regs_trace_en;                       
wire            regs_xx_ddc_en;                      
wire    [31:0]  regs_xx_wdata;                       
wire            sec_bit_jtag;                        
wire            sec_jtag;                            
wire            secure_mode_match_jtag;              
wire            tcipif_dcc_read_vld;                 
wire            tcipif_dcc_updt_vld;                 
wire    [15:0]  tcipif_had_addr;                     
wire            tcipif_had_sel;                      
wire    [31:0]  tcipif_had_wdata;                    
wire            tcipif_had_write;                    
wire            tcipif_psr_pc_wen;                   
wire            tcipif_reg_sel;                      
wire            wbbr_wen;                            


// &Force("input","tcipif_had_write"); @28
//   &Force("input","tcipif_xx_dbus_sec"); @30

//==============================================================================
//  HACR
//==============================================================================
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    hacr_reg[7:0] <= 8'h82; // point to HAD_ID, read op
  else if (jtag_regs_srst)
    hacr_reg[7:0] <= 8'h82;
  else if (jtag_regs_update_hacr)
    hacr_reg[7:0] <= jtag_xx_data[7:0];
  else
    hacr_reg[7:0] <= hacr_reg[7:0];
end

assign hacr_rw = hacr_reg[7];
assign hacr_go = hacr_reg[6];
assign hacr_ex = hacr_reg[5];

assign tcipif_reg_sel       = tcipif_had_sel
                         && !jtag_xx_update_dr
                         && !jtag_xx_capture_dr_mask;
assign hacr_indx_reuse[4:0] = tcipif_reg_sel ?  tcipif_had_addr[6:2] : hacr_reg[4:0];

//==============================================================================
//  HAD Bank Seleect Register
//==============================================================================
assign bsel_wen = jtag_xx_update_dr && hacr_indx_bsel_sel;
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    bsel[1:0] <= 2'b0;
  else if (jtag_regs_srst)
    bsel[1:0] <= 2'b0;
  else if (bsel_wen)
    bsel[1:0] <= jtag_xx_data[1:0];
  else
    bsel[1:0] <= bsel[1:0];
end

//area optimization for bsel registers
  assign bsel_val[1:0] = {1'b0, bsel[0]};

// &Force("bus","tcipif_had_addr",15,0); @98
assign bsel_0_jtg    = bsel_val[1:0] == 2'b0;
assign bsel_0_tcipif = tcipif_had_addr[11:7] == 5'b0;
assign bsel_0        = tcipif_reg_sel ? bsel_0_tcipif : bsel_0_jtg;

    assign bsel_1_jtg    = bsel_val[1:0] == 2'b1;
    assign bsel_1_tcipif = tcipif_had_addr[11:7] == 5'b1;
    assign bsel_1        = tcipif_reg_sel ? bsel_1_tcipif : bsel_1_jtg;


assign hacr_indx_bsel_sel     = (hacr_indx_reuse[4:0] == 5'b11110); //for any bank

//decode for register bank 0
assign hacr_indx_id_sel       = (hacr_indx_reuse[4:0] == 5'b00010) && bsel_0;
assign hacr_indx_tc_sel       = 1'b0;
assign hacr_indx_bypass_sel   = (hacr_indx_reuse[4:0] == 5'b01100) && bsel_0;
assign hacr_indx_hsr_sel      = (hacr_indx_reuse[4:0] == 5'b01110) && bsel_0;
assign hacr_indx_wbbr_sel     = (hacr_indx_reuse[4:0] == 5'b10001) && bsel_0;
assign hacr_indx_ir_sel       = (hacr_indx_reuse[4:0] == 5'b10100) && bsel_0;
assign hacr_indx_csr_sel      = (hacr_indx_reuse[4:0] == 5'b10101) && bsel_0;
assign hacr_indx_daddr_sel    = (hacr_indx_reuse[4:0] == 5'b11000) && bsel_0;
assign hacr_indx_ddata_sel    = (hacr_indx_reuse[4:0] == 5'b11001) && bsel_0;
assign hacr_indx_sysrsv_sel   = (hacr_indx_reuse[4:0] == 5'b11111) && bsel_0;

assign hacr_indx_psr_sel      = (hacr_indx_reuse[4:0] == 5'b10010) && bsel_0;
assign hacr_indx_pc_sel       = (hacr_indx_reuse[4:0] == 5'b10011) && bsel_0;
assign hacr_indx_hcr_sel      = (hacr_indx_reuse[4:0] == 5'b01101) && bsel_0;
assign hacr_indx_hsr2_sel     = (hacr_indx_reuse[4:0] == 5'b01111) && bsel_0;
assign hacr_indx_dder_sel     = (hacr_indx_reuse[4:0] == 5'b10110) && bsel_0;

assign hacr_indx_mbca_sel     = 1'b0;
assign hacr_indx_mbcb_sel     = 1'b0;
assign hacr_indx_baba_sel     = (hacr_indx_reuse[4:0] == 5'b00111) && bsel_0;
assign hacr_indx_bama_sel     = (hacr_indx_reuse[4:0] == 5'b01001) && bsel_0;

assign hacr_indx_babb_sel     = (hacr_indx_reuse[4:0] == 5'b01000) && bsel_0;
assign hacr_indx_bamb_sel     = (hacr_indx_reuse[4:0] == 5'b01010) && bsel_0;

// decode for register bank 1
assign hacr_indx_babc_sel     = (hacr_indx_reuse[4:0] == 5'b00000) && bsel_1;
assign hacr_indx_babd_sel     = (hacr_indx_reuse[4:0] == 5'b00010) && bsel_1;
assign hacr_indx_babe_sel     = (hacr_indx_reuse[4:0] == 5'b00100) && bsel_1;
assign hacr_indx_bamc_sel     = 1'b0;
assign hacr_indx_bamd_sel     = 1'b0;
assign hacr_indx_bame_sel     = 1'b0;

assign hacr_indx_babf_sel     = 1'b0;
assign hacr_indx_babg_sel     = 1'b0;
assign hacr_indx_babh_sel     = 1'b0;
assign hacr_indx_babi_sel     = 1'b0;
assign hacr_indx_bamf_sel     = 1'b0;
assign hacr_indx_bamg_sel     = 1'b0;
assign hacr_indx_bamh_sel     = 1'b0;
assign hacr_indx_bami_sel     = 1'b0;

assign hacr_indx_dacsr_sel    = 1'b0;
assign hacr_indx_datr_sel     = 1'b0;
assign hacr_indx_darwr_sel    = 1'b0;

assign hacr_indx_mbir_sel     = 1'b0;
assign hacr_indx_mbee_sel     = 1'b0;
assign hacr_indx_mbse_sel     = 1'b0;

//decode for register bank 2
assign hacr_indx_dbg_ctrl_sel  = 1'b0;
assign hacr_indx_prof_cnt_sel  = 1'b0;
assign hacr_indx_force_reg_sel = 1'b0;

  assign tcipif_dcc_updt_vld         = tcipif_reg_sel && tcipif_had_write;
  assign tcipif_dcc_read_vld         = tcipif_reg_sel && !tcipif_had_write;

assign dcc_regs_updt_vld             = jtag_xx_update_dr || tcipif_dcc_updt_vld;


assign dbgexp_regs_updt_vld          = jtag_xx_update_dr;

assign regs_xx_wdata[31:0]       = tcipif_reg_sel ? tcipif_had_wdata[31:0]
                                                  : jtag_xx_data[31:0];
//==============================================================================
//  HAD DR Bank 0
//==============================================================================
//==========================================================
// HAD_ID register
//==========================================================
// +-------+-----+---------+-------+------+-----+-----+
// | 31:28 |27:26|  25:18  | 17 | 16 | 15:12 | 11:8 | 7:4 | 3:0 |
// +-------+-----+---------+----+----+-------+------+-----+-----+
//     |      |              |    |      |       |    |     |
//     |      |              |    |      |       |    |     +--- ID_VERSION
//     |      |              |    |      |       |    +--------- HAD_VERSION
//     |      |              |    |      |       +-------------- HAD_REVISION
//     |      |              |    |      +---------------------- BKPT_NUM
//     |      |              |    +----------------------------- DDC
//     |      |              +---------------------------------- BANK1
//     |      +--------------------------------------- CPU Inst. Arch                               
//     +---------------------------------------------- JTAG InterfaceType

// &Force("bus", "cp0_had_cpuid_idx0", 31, 0); @319

assign id_reg[31:28] = 4'b0001; // JTAG_2 interface

assign id_reg[27:26] = cp0_had_cpuid_idx0[27:26];

assign id_reg[25:18] = 8'b0;

assign id_reg[17]    = 1'b0;

assign id_reg[16]    = 1'b0;

assign id_reg[15:12] = 4'd5;

//------------------------------------------------
// initial version: 2.0
// huanghuanhuan
//------------------------------------------------
// version 2.1
// huanghuanhuan, 2014/03/10
// add 4 registers for mem-bkpt-c and mem-bkpt-d
// add 2 ctrl bits in hcr to enable bkpt-c and bkpt-d
//------------------------------------------------
// version 2.2
// huanghuanhuan, 2014/03/14
// 1. add SRST status bit in HSR
//    SRST indicates CPU is reset by software
// 2. seperate hadrst_b and cpurst_b
//    cpurst_b cannot reset had registers
//------------------------------------------------
// version 2.3
// huanghuanhuan, 2014/04/04
// 1. add 4 more bkpt, there are 9 bkpt now
// 2. add BSEL register for register bank select
// 3. add BKPT_NUM field in ID register
//------------------------------------------------
// version 2.4
// huanghuanhuan, 2014/06/30
// 1. add one more register, HSR2;
// 2. define a status bit in HSR2 to indicate CPU
//    is in debug forbidden region
//------------------------------------------------
// version 2.5
// huanghuanhuan, 2014/07/08
// 1. add HAD_BKPT_9 macro
// ------------------------------------------------
// version 2.6
// chenchen, 2015/05/13
// 1. add HAD tcip img
// 2. add profiling cnt
// ------------------------------------------------
// version 2.7
// chenchen, 2016/01/05
// 1. add DCC function
// 2. add TEE support
// ------------------------------------------------
// version 2.8
// chenchen, 2016/10/09
// 1. fix trace on ldst
// ------------------------------------------------
// version 2.9
// chenchen, 2016/12/27
// 1. add dbg expt
// 2. add DDMA
// ------------------------------------------------
// version 2.10
// reserve for the difference between
// trunk code and branch code
// ------------------------------------------------
// version 2.11
// wangs, 2017/09/05
// 1. had area optimization
// 2. tcip and jtag reuse read/write port
// 3. add the mechanism between DBG_EXP and TEE
assign id_reg[11:8]  = 4'd11;
assign id_reg[7:4]   = 4'b0011; // HAD_V4, for RV

//------------------------------------------------
// V1
assign id_reg[3:0]   = 4'b0001;
//------------------------------------------------
// V2
// add BKPT_NUM, DDC, BANK1 field
//assign id_reg[3:0] = 4'd2;

//==========================================================
// BABA -- Base Address of Breakpoint A
//==========================================================
assign baba_wen = dbgexp_regs_updt_vld && hacr_indx_baba_sel;

always @(posedge cpuclk)
begin
  if (baba_wen)
    baba_reg[31:0] <= regs_xx_wdata[31:0];
  else
    baba_reg[31:0] <= baba_reg[31:0];
end

//==========================================================
// BAMA -- Base Address Mask of Breakpoint A
//==========================================================
// reset BAMA to zero for low power design
assign bama_wen = dbgexp_regs_updt_vld && hacr_indx_bama_sel;

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    bama_reg[7:0] <= 8'b0;
  else if (bama_wen)
    bama_reg[7:0] <= regs_xx_wdata[7:0];
  else
    bama_reg[7:0] <= bama_reg[7:0];
end

//==========================================================
// BABB -- Base Address of Breakpoint B
//==========================================================
assign babb_wen = dbgexp_regs_updt_vld && hacr_indx_babb_sel;

always @(posedge cpuclk)
begin
  if (babb_wen)
    babb_reg[31:0] <= regs_xx_wdata[31:0];
  else
    babb_reg[31:0] <= babb_reg[31:0];
end

//==========================================================
// BAMB -- Base Address Mask of Breakpoint B
//==========================================================
// reset BAMB to zero for low power design
assign bamb_wen = dbgexp_regs_updt_vld && hacr_indx_bamb_sel;

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    bamb_reg[7:0] <= 8'b0;
  else if (bamb_wen)
    bamb_reg[7:0] <= regs_xx_wdata[7:0];
  else
    bamb_reg[7:0] <= bamb_reg[7:0];
end

//==========================================================
// WBBR -- Write Back Bus Register
//==========================================================
assign wbbr_wen = jtag_xx_update_dr && (hacr_indx_wbbr_sel
                                     || hacr_indx_daddr_sel
                                     || hacr_indx_ddata_sel);
always @(posedge cpuclk)
begin
  if (wbbr_wen)
    wbbr_reg[31:0] <= jtag_xx_data[31:0];
//  else if (ddc_regs_update_wbbr)
//    wbbr_reg[31:0] <= ddc_regs_wbbr[31:0];
  else if (iu_had_xx_data_vld)
    wbbr_reg[31:0] <= iu_had_xx_data[31:0];
  else
    wbbr_reg[31:0] <= wbbr_reg[31:0];
end

// &Force("bus", "cp0_had_psr_data", 31, 0); @542
//==========================================================                                        
// PSR -- Processor Status Register
// as the psr nolong exist when processor enter debug mode
// it only exist when had int happen
//==========================================================
assign jtag_psr_pc_wen   = jtag_xx_update_dr && iu_yy_xx_dbgon;
assign tcipif_psr_pc_wen = tcipif_dcc_updt_vld && !iu_had_retire_with_had_int;
assign psr_wen = ((jtag_psr_pc_wen && cp0_had_secu_dbg_en) || tcipif_psr_pc_wen)
               && hacr_indx_psr_sel;


//always @(posedge cpuclk)
//begin
//  if (iu_had_xx_dbg_ack) begin
//    psr_s        <= cp0_had_psr_data[31];
//    psr_vec[7:0] <= cp0_had_psr_data[23:16];
//    psr_mm       <= cp0_had_psr_data[9];
//    psr_ee       <= cp0_had_psr_data[8];
//    psr_ic       <= cp0_had_psr_data[7];
//    psr_ie       <= cp0_had_psr_data[6];
//    psr_c        <= cp0_had_psr_data[0];
//  end
//  else if (iu_had_int_ack) begin
//    psr_s        <= cp0_had_spsr_data[31];
//    psr_vec[7:0] <= cp0_had_spsr_data[23:16];
//    psr_mm       <= cp0_had_spsr_data[9];
//    psr_ee       <= cp0_had_spsr_data[8];
//    psr_ic       <= cp0_had_spsr_data[7];
//    psr_ie       <= cp0_had_spsr_data[6];
//    psr_c        <= cp0_had_spsr_data[0];
//  end
//  else if (psr_wen) begin
//    psr_s        <= regs_xx_wdata[31];
//    psr_vec[7:0] <= regs_xx_wdata[23:16];
//    psr_mm       <= regs_xx_wdata[9];
//    psr_ee       <= regs_xx_wdata[8];
//    psr_ic       <= regs_xx_wdata[7];
//    psr_ie       <= regs_xx_wdata[6];
//    psr_c        <= regs_xx_wdata[0];
//  end
//end
//
//assign psr_se = 1'b0;
//assign psr_sp = 1'b0;
//assign psr_hs = 1'b0;
//assign psr_sc = 1'b0;
//
//assign psr_prgsign_ins_cnt_en = 1'b0;
//assign psr_prgsign_strong     = 1'b0;
//assign psr_prgisgn_en         = 1'b0;
//
//assign psr_bm = 1'b0;
//
//assign psr_af = 1'b0;
//
//assign psr_reg[31:0] = {psr_s , psr_se, psr_sp, psr_hs,
//                        psr_sc, psr_prgsign_ins_cnt_en,
//                        psr_prgsign_strong, psr_prgisgn_en,
//                        psr_vec[7:0], 6'b0,
//                        psr_mm, psr_ee, psr_ic, psr_ie, 
//                        3'b0, psr_bm, psr_af, psr_c};
//
// &Force("bus", "cp0_had_mcause_data", 31, 0); @676
always @(posedge cpuclk)
begin
  if (iu_had_int_ack) begin
    had_mcause_mpp[1:0]     <= cp0_had_mcause_data[29:28];
    had_mcause_mil[7:0]     <= cp0_had_mcause_data[23:16];
    had_mcause_mpie         <= cp0_had_mcause_data[27];
    had_mcause_mpsp         <= cp0_had_mcause_data[26];
  end
  else if (psr_wen) begin
    had_mcause_mpp[1:0]     <= regs_xx_wdata[29:28];
    had_mcause_mil[7:0]     <= regs_xx_wdata[23:16];
    had_mcause_mpie         <= regs_xx_wdata[27];
    had_mcause_mpsp         <= regs_xx_wdata[26];
  end
end
assign psr_reg[31:0]      = {1'b0,1'b0,had_mcause_mpp[1:0],had_mcause_mpie,had_mcause_mpsp,2'b0,had_mcause_mil[7:0],16'b0};
//==========================================================
// PC
//==========================================================
// &Force("bus", "iu_had_xx_retire_pc", 31, 0); @696
assign pc_wen = (jtag_psr_pc_wen || tcipif_psr_pc_wen)
              && hacr_indx_pc_sel;
always @(posedge cpuclk)
begin
  if (iu_had_fast_retire_acc_err_pc_update || iu_had_int_ack)
    pc[30:0] <= iu_had_fast_retire_acc_err_pc_val[30:0];
  else if (iu_had_xx_dbg_ack)
    pc[30:0] <= iu_had_xx_retire_pc[31:1];
  else if (pc_wen)
    pc[30:0] <= regs_xx_wdata[31:1];
  else
    pc[30:0] <= pc[30:0];
end

assign pc_reg[31:0] = {pc[30:0], 1'b0};

//==========================================================
// IR
//==========================================================

//==========================================================
// CSR
//==========================================================
assign csr_wen = jtag_xx_update_dr && hacr_indx_csr_sel;
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b) begin
    ffy         <= 1'b0;
    fdb         <= 1'b0;
  end
  else if (csr_wen) begin
    ffy         <= jtag_xx_data[8];
    fdb         <= jtag_xx_data[7];
  end
  else if (ddc_regs_update_csr) begin
    ffy         <= ddc_regs_ffy;
    fdb         <= 1'b0;
  end
  else begin
    ffy         <= ffy;
    fdb         <= fdb;
  end
end

assign csr_reg[15:0] = {7'b0, ffy, fdb, 7'b0};

//==========================================================
// HCR -- Had Control Reigster
//==========================================================
// +-------+------+---+---+------+---+---+---+---+---+-----+--+----+
// | 31:29 |28:22 |21 |20 |19:16 |15 |14 |13 |12 |11 |10:6 |5 |4:0 |
// +-------+------+---+---+------+---+---+---+---+---+-----+--+----+
//            |     |   |          |       |       |    |   |   |
//            |     |   |          |       |       |    |   |   +---- BCA
//            |     |   |          |       |       |    |   +-------- RCA
//            |     |   |          |       |       |    +------------ BCB
//            |     |   |          |       |       +----------------- RCB
//            |     |   |          |       +------------------------- TME
//            |     |   |          +--------------------------------- DR
//            |     |   +-------------------------------------------- DDCEN
//            |     +------------------------------------------------ ADR
//            +------------------------------------------------------ BxEN
// BCA: BKPTA Mode Ctrl
// RCA: BKPTA Region Ctrl
// BCB: BKPTB Mode Ctrl
// RCB: BKPTB Region Ctrl
// TME: Trace Mode Enable
// DR : Debug Request
// DDCEN : DDC Mode Enable
// ADR : Async Debug Request
// BxEN : BKPTC - BKPTH Enable, BxEN[0] = BCEN, ... BxEN[5] = BHEN

//jtag write only
assign hcr_wen_jtg_only = jtag_xx_update_dr && hacr_indx_hcr_sel;
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b) begin
    hcr_adr      <= 1'b0; // Debug Request when CPU Dead
    hcr_ddcen    <= 1'b0; // DDC mode Enable
    hcr_dr       <= 1'b0; // Debug Request
    hcr_tme      <= 1'b0; // Trace Mode Enable
  end
  else if (hcr_wen_jtg_only) begin
    hcr_adr      <= jtag_xx_data[21];
    hcr_ddcen    <= jtag_xx_data[20];
    hcr_dr       <= jtag_xx_data[15];
    hcr_tme      <= jtag_xx_data[13];
  end
  else begin
    hcr_adr      <= hcr_adr;
    hcr_ddcen    <= hcr_ddcen;
    hcr_dr       <= hcr_dr;
    hcr_tme      <= hcr_tme;
  end
end

assign hcr_bca_wen = dbgexp_regs_updt_vld && hacr_indx_hcr_sel;

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b) begin
    hcr_bca[2:0] <= 3'b0; // memory Breakpoint Cotrol A
  end
  else if (hcr_bca_wen) begin
    hcr_bca[2:0] <= regs_xx_wdata[2:0];
  end
  else begin
    hcr_bca[2:0] <= hcr_bca[2:0];
  end
end

  assign hcr_bcb_wen = dbgexp_regs_updt_vld && hacr_indx_hcr_sel;

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b) begin
    hcr_bcb[2:0]  <= 3'b0;
  end
  else if (hcr_bcb_wen) begin
    hcr_bcb[2:0]  <= regs_xx_wdata[8:6];
  end
  else begin
    hcr_bcb[2:0]  <= hcr_bcb[2:0];
  end
end

//hcr_bxen_bkpt for mbkpt c/d/e
assign hcr_bxen_bkptc_wen = dbgexp_regs_updt_vld && hacr_indx_hcr_sel;

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    hcr_bxen_bkptc <= 1'b0;
  else if (hcr_bxen_bkptc_wen)
    hcr_bxen_bkptc <= regs_xx_wdata[22];
  else
    hcr_bxen_bkptc <= hcr_bxen_bkptc;
end

assign hcr_bxen_bkptd_wen = dbgexp_regs_updt_vld && hacr_indx_hcr_sel;

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    hcr_bxen_bkptd <= 1'b0;
  else if (hcr_bxen_bkptd_wen)
    hcr_bxen_bkptd <= regs_xx_wdata[23];
  else
    hcr_bxen_bkptd <= hcr_bxen_bkptd;
end

assign hcr_bxen_bkpte_wen = dbgexp_regs_updt_vld && hacr_indx_hcr_sel;

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    hcr_bxen_bkpte <= 1'b0;
  else if (hcr_bxen_bkpte_wen)
    hcr_bxen_bkpte <= regs_xx_wdata[24];
  else
    hcr_bxen_bkpte <= hcr_bxen_bkpte;
end

assign hcr_bxen_bkpt4[2:0] = {hcr_bxen_bkpte, hcr_bxen_bkptd, hcr_bxen_bkptc};

assign hcr_bxen_bkpt8[3:0] = 4'b0;

assign hcr_bxen[6:0] = {hcr_bxen_bkpt8[3:0], hcr_bxen_bkpt4[2:0]};

assign hcr_ddae = 1'b0;

assign hcr_dcc_wen = dcc_regs_updt_vld && hacr_indx_hcr_sel;
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b) begin
    hcr_jtgw_int_en <= 1'b0;
    hcr_jtgr_int_en <= 1'b0;
  end
  else if (hcr_dcc_wen) begin
    hcr_jtgw_int_en <= regs_xx_wdata[18];
    hcr_jtgr_int_en <= regs_xx_wdata[19];
  end
  else begin
    hcr_jtgw_int_en <= hcr_jtgw_int_en;
    hcr_jtgr_int_en <= hcr_jtgr_int_en;
  end
end  

assign hcr_reg[31:0] = {2'b0, hcr_ddae, hcr_bxen[6:0], hcr_adr, hcr_ddcen,
                        hcr_jtgr_int_en, hcr_jtgw_int_en, 2'b0, hcr_dr, 1'b0,
                        hcr_tme, 4'b0, hcr_bcb[2:0], 3'b0, hcr_bca[2:0]};

assign regs_bkpta_bkpti_en = (hcr_bxen[6:0] != 7'b0)
                          || (hcr_bcb[2:0]  != 3'b0)
                          || (hcr_bca[2:0]  != 3'b0);

//==========================================================
// HSR -- Had Status Reigster
//==========================================================
// +-------+----+----+---+---+---+---+---+-----+-----+
// | 15:12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4:2 | 1:0 |
// +-------+----+----+---+---+---+---+---+-----+-----+
//           |         |   |   |   |   |          |
//           |         |   |   |   |   |          +---- PM
//           |         |   |   |   |   +--------------- TO
//           |         |   |   |   +------------------- SWO
//           |         |   |   +----------------------- MBO
//           |         |   +--------------------------- DRO
//           |         +------------------------------- HDRO
//           +----------------------------------------- SRST
// PM   - Processor Mode
// TO   - Trace Debug Occurrence
// SWO  - Software Debug Occurrence
// MBO  - Memory Breakpoint Occurrence                                                              
// DRO  - Compulsive Debug Request Occurrence
// HDRO - Hardware Debug Request Occurrence
// SRST - CPU has been reset by SRST inst

//// SRST - CPU has been reset by SRST inst
//always @(posedge cpuclk or negedge hadrst_b)
//begin
//  if (!hadrst_b)
//    srst <= 1'b0;
//  else if (iu_had_soft_rst)
//    srst <= 1'b1;
//  else if (ctrl_regs_exit_dbg)
//    srst <= 1'b0;
//  else
//    srst <= srst;
//end

// HDRO - Hardware Debug Request Occurrence
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    adro <= 1'b0;
  else if (ctrl_regs_update_adro)
    adro <= 1'b1;
  else if (ctrl_regs_exit_dbg)
    adro <= 1'b0;
  else
    adro <= adro;
end

// DRO - Compulsive Debug Request Occurrence
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    dro <= 1'b0;
  else if (ctrl_regs_update_dro)
    dro <= 1'b1;
  else if (ctrl_regs_exit_dbg)
    dro <= 1'b0;
  else
    dro <= dro;
end

// MBO - Memory Breakpoint Occurrence
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    mbo <= 1'b0;
  else if (ctrl_regs_update_mbo)
    mbo <= 1'b1;
  else if (ctrl_regs_exit_dbg)
    mbo <= 1'b0;
  else
    mbo <= mbo;
end

// SWO - Software Debug Occurrence
always @(posedge cpuclk or negedge hadrst_b)
begin                                                                                               
  if (!hadrst_b)
    swo <= 1'b0;
  else if (ctrl_regs_update_swo)
    swo <= 1'b1;
  else if (ctrl_regs_exit_dbg)
    swo <= 1'b0;
  else
    swo <= swo;
end

// TO - Trace Debug Occurrence
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    to <= 1'b0;
  else if (ctrl_regs_update_to)
    to <= 1'b1;
  else if (ctrl_regs_exit_dbg)
    to <= 1'b0;
  else
    to <= to;
end

// PM - Processor Mode
// PM[0] : Low-power Mode
assign pm_lowpwr_mode = !cp0_had_lpmd_b[1] || !cp0_had_lpmd_b[0];

// PM[1] : Debug Mode
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
  begin
    pm_dbg_mode <= 1'b0;
  end
  else
  begin
    if (ctrl_regs_exit_dbg)
      pm_dbg_mode <= 1'b0;
    else if (iu_yy_xx_dbgon)
      pm_dbg_mode <= 1'b1;
    else
      pm_dbg_mode <= pm_dbg_mode;
  end
end

assign pm[1:0] = {pm_dbg_mode, pm_lowpwr_mode};

//always @(posedge cpuclk or negedge hadrst_b)
//begin
//  if (!hadrst_b)
//    pm[1:0] <= 2'b0;
//  else if (iu_yy_xx_dbgon) // Debug Mode 2'b10
//    pm[1:0] <= 2'b10;
//  else if (!cp0_had_lpmd_b[1] || !cp0_had_lpmd_b[0]) // Low-power mode 2'b01
//    pm[1:0] <= 2'b01;
//  else  // Normal mode
//    pm[1:0] <= 2'b00;                                                                             
//end

assign had_core_dbg_mode_req = pm_dbg_mode && !iu_yy_xx_dbgon;
assign hsr_reg[15:0] = {6'b0, adro, dro,
                        mbo, swo, to, 3'b0, pm[1:0]};

//==========================================================
// EHSR
//==========================================================
assign hsr_dbg_dis = 1'b0;

//dder valid
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    ddera_vld <= 1'b0;
  else if(ddera_wen)
    ddera_vld <= 1'b1;
  else if(ddera_ren)
    ddera_vld <= 1'b0;
  else
    ddera_vld <= ddera_vld;
end

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    dderb_vld <= 1'b0;
  else if(dderb_wen)
    dderb_vld <= 1'b1;
  else if(dderb_ren)
    dderb_vld <= 1'b0;
  else
    dderb_vld <= dderb_vld;
end

//jw jr int state
assign cpu_hsr2_wen = tcipif_dcc_updt_vld && hacr_indx_hsr2_sel;
always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    jw_pending <= 1'b0;
  else if (ddera_wen && hcr_jtgw_int_en)
    jw_pending <= 1'b1;
  else if (iu_had_int_ack && jw_pending)
    jw_pending <= 1'b0;
  else
    jw_pending <= jw_pending;
end

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    jw_active <= 1'b0;
  else if (cpu_hsr2_wen)
    jw_active <= tcipif_had_wdata[3];
  else if (iu_had_int_ack && jw_pending)
    jw_active <= 1'b1;
  else if (cp0_had_int_exit && jw_active && rte_pc_sel)
    jw_active <= 1'b0;
  else 
    jw_active <= jw_active;
end

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    jr_pending <= 1'b0;
  else if (dderb_ren && hcr_jtgr_int_en)
    jr_pending <= 1'b1;
  else if (iu_had_int_ack && jr_pending && !jw_pending)
    jr_pending <= 1'b0;
  else
    jr_pending <= jr_pending;
end

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    jr_active <= 1'b0;
  else if (cpu_hsr2_wen)
    jr_active <= tcipif_had_wdata[4];
  else if (iu_had_int_ack && jr_pending && !jw_pending)
    jr_active <= 1'b1;
  else if (cp0_had_int_exit && jr_active && rte_pc_sel)
    jr_active <= 1'b0;
  else
    jr_active <= jr_active;
end

assign had_iu_int_vld = (jw_pending || jr_pending) 
                     && (!jw_active && !jr_active);

always @(posedge cpuclk or negedge hadrst_b)
begin
  if (!hadrst_b)
    rte_pc_sel <= 1'b0;
  else if (cpu_hsr2_wen)
    rte_pc_sel <= tcipif_had_wdata[5];
  else if (iu_had_int_ack)
    rte_pc_sel <= 1'b1;
  else if (cp0_had_int_exit && rte_pc_sel)
    rte_pc_sel <= 1'b0;
  else 
    rte_pc_sel <= rte_pc_sel;
end    

assign regs_ctrl_had_int_on = rte_pc_sel;
assign had_iu_rte_pc_sel = rte_pc_sel;
// &Force("input","cp0_had_int_exit"); @1382

assign hsr2_reg[31:0] = {26'b0, rte_pc_sel,
                         jr_active, jw_active, 
                         dderb_vld, ddera_vld, hsr_dbg_dis};

//==========================================================
// DDER
//==========================================================
assign ddera_wen = jtag_xx_update_dr   && hacr_indx_dder_sel;
assign ddera_ren = tcipif_dcc_read_vld && hacr_indx_dder_sel;

always @(posedge cpuclk)
begin
  if (ddera_wen)
    ddera_reg[31:0] <= jtag_xx_data[31:0];
  else
    ddera_reg[31:0] <= ddera_reg[31:0];
end

assign dderb_wen = tcipif_dcc_updt_vld && hacr_indx_dder_sel;
assign dderb_ren = jtag_xx_capture_dr  && hacr_indx_dder_sel;

always @(posedge cpuclk)
begin
  if (dderb_wen)
    dderb_reg[31:0] <= tcipif_had_wdata[31:0];
  else
    dderb_reg[31:0] <= dderb_reg[31:0];
end

// &CombBeg; @1530
// &CombEnd; @1536
// &CombBeg; @1543
// &CombEnd; @1549
// &CombBeg; @1572
// &CombEnd; @1597
// &CombBeg; @1599
// &CombEnd; @1624
assign dacsr_reg[31:0] = 32'b0;
assign darwr_reg[31:0] = 32'b0;
assign datr_reg[31:0]  = 32'b0;

assign sec_jtag = 1'b0;
assign cp0_had_secu_dbg_en = 1'b1;

assign secure_mode_match_jtag = cp0_had_secu_dbg_en || ~(cp0_had_secu_dbg_en || sec_jtag);
assign sec_bit_jtag = cp0_had_secu_dbg_en? dacsr_reg[10] : 1'b0; 

//==============================================================================
//  HAD DR Bank 1
//==============================================================================
//======================================
//BKPTC
//======================================
assign babc_wen = dbgexp_regs_updt_vld && hacr_indx_babc_sel;

always @(posedge cpuclk)
begin
  if (babc_wen)
    babc_reg[31:0] <= regs_xx_wdata[31:0];
  else
    babc_reg[31:0] <= babc_reg[31:0];
end

//assign bamc_wen = regs_updt_vld && bsel_1 && hacr_indx_bamc_sel;
//
//always @(posedge cpuclk)
//begin
//  if (bamc_wen)
//    bamc_reg[7:0] <= regs_xx_wdata[7:0];
//  else
//    bamc_reg[7:0] <= bamc_reg[7:0];
//end

//======================================
//BKPTD
//======================================
assign babd_wen = dbgexp_regs_updt_vld && hacr_indx_babd_sel;

always @(posedge cpuclk)
begin
  if (babd_wen)
    babd_reg[31:0] <= regs_xx_wdata[31:0];
  else
    babd_reg[31:0] <= babd_reg[31:0];
end

//assign bamd_wen = regs_updt_vld && bsel_1 && hacr_indx_bamd_sel;
//
//always @(posedge cpuclk)
//begin
//  if (bamd_wen)
//    bamd_reg[7:0] <= regs_xx_wdata[7:0];
//  else
//    bamd_reg[7:0] <= bamd_reg[7:0];
//end

//======================================
//BKPTE
//======================================
assign babe_wen = dbgexp_regs_updt_vld && hacr_indx_babe_sel;

always @(posedge cpuclk)
begin
  if (babe_wen)
    babe_reg[31:0] <= regs_xx_wdata[31:0];
  else
    babe_reg[31:0] <= babe_reg[31:0];
end

//assign bame_wen = regs_updt_vld && bsel_1 && hacr_indx_bame_sel;
//
//always @(posedge cpuclk)
//begin
//  if (bame_wen)
//    bame_reg[7:0] <= regs_xx_wdata[7:0];
//  else
//    bame_reg[7:0] <= bame_reg[7:0];
//end

assign babf_reg[31:0] = 32'b0;
assign babg_reg[31:0] = 32'b0;
assign babh_reg[31:0] = 32'b0;
assign babi_reg[31:0] = 32'b0;

assign bamc_reg[7:0] = 8'b0;
assign bamd_reg[7:0] = 8'b0;
assign bame_reg[7:0] = 8'b0;
assign bamf_reg[7:0] = 8'b0;
assign bamg_reg[7:0] = 8'b0;
assign bamh_reg[7:0] = 8'b0;
assign bami_reg[7:0] = 8'b0;

assign mbir_reg[3:0]  = 4'b0;
assign mbee_reg[31:0] = 32'b0;
assign mbse_reg[31:0] = 32'b0;

//==============================================================================
//  HAD DR Bank 2
//==============================================================================
//==========================================================
//  DEBUG CONTROL register
//==========================================================
assign prof_cnt_en        = 1'b0;
assign prof_cnt_reg[31:0] = 32'b0;

assign dbg_ctrl_reg[31:0] = {31'b0, prof_cnt_en};

//==========================================================
//  Force register
//==========================================================
assign had_iu_force_dbg_en = 1'b0;
assign force_reg[31:0] = 32'b0;

//==============================================================================
// Read port for HAD registers
//==============================================================================
assign hacr_indx_bsel_sel_rd      = hacr_indx_bsel_sel   && !tcipif_reg_sel;
assign hacr_indx_id_sel_rd        = hacr_indx_id_sel     && !tcipif_reg_sel;
assign hacr_indx_tc_sel_rd        = 1'b0;
assign hacr_indx_hsr_sel_rd       = hacr_indx_hsr_sel    && !tcipif_reg_sel;
assign hacr_indx_wbbr_sel_rd      = hacr_indx_wbbr_sel   && !tcipif_reg_sel;
// &Force("output","hacr_indx_pcfifo_sel_rd"); @2455
assign hacr_indx_csr_sel_rd       = hacr_indx_csr_sel    && !tcipif_reg_sel;
assign hacr_indx_daddr_sel_rd     = hacr_indx_daddr_sel  && !tcipif_reg_sel;
assign hacr_indx_ddata_sel_rd     = hacr_indx_ddata_sel  && !tcipif_reg_sel;
assign hacr_indx_sysrsv_sel_rd    = hacr_indx_sysrsv_sel && !tcipif_reg_sel;

   assign hacr_indx_psr_sel_rd    = hacr_indx_psr_sel;
//                                && (tcipif_reg_sel || iu_yy_xx_dbgon);
   assign hacr_indx_pc_sel_rd     = hacr_indx_pc_sel;
//                                && (tcipif_reg_sel || iu_yy_xx_dbgon);
   assign hacr_indx_hsr2_sel_rd   = hacr_indx_hsr2_sel;
   assign hacr_indx_dder_sel_rd   = hacr_indx_dder_sel;

  assign hacr_indx_hcr_sel_rd     = hacr_indx_hcr_sel;

assign hacr_indx_mbca_sel_rd      = 1'b0;
assign hacr_indx_mbcb_sel_rd      = 1'b0;
assign hacr_indx_bamc_sel_rd      = 1'b0;
assign hacr_indx_bamd_sel_rd      = 1'b0;
assign hacr_indx_bame_sel_rd      = 1'b0;
assign hacr_indx_bamf_sel_rd      = 1'b0;
assign hacr_indx_bamg_sel_rd      = 1'b0;
assign hacr_indx_bamh_sel_rd      = 1'b0;
assign hacr_indx_bami_sel_rd      = 1'b0;
assign hacr_indx_baba_sel_rd      = hacr_indx_baba_sel && !tcipif_reg_sel;
assign hacr_indx_bama_sel_rd      = hacr_indx_bama_sel && !tcipif_reg_sel;
assign hacr_indx_babb_sel_rd      = hacr_indx_babb_sel && !tcipif_reg_sel;
assign hacr_indx_bamb_sel_rd      = hacr_indx_bamb_sel && !tcipif_reg_sel;
assign hacr_indx_babc_sel_rd      = hacr_indx_babc_sel && !tcipif_reg_sel;
assign hacr_indx_babd_sel_rd      = hacr_indx_babd_sel && !tcipif_reg_sel;
assign hacr_indx_babe_sel_rd      = hacr_indx_babe_sel && !tcipif_reg_sel;
assign hacr_indx_babf_sel_rd      = hacr_indx_babf_sel && !tcipif_reg_sel;
assign hacr_indx_babg_sel_rd      = hacr_indx_babg_sel && !tcipif_reg_sel;
assign hacr_indx_babh_sel_rd      = hacr_indx_babh_sel && !tcipif_reg_sel;
assign hacr_indx_babi_sel_rd      = hacr_indx_babi_sel && !tcipif_reg_sel;

assign hacr_indx_dacsr_sel_rd     = hacr_indx_dacsr_sel && !tcipif_reg_sel;
assign hacr_indx_datr_sel_rd      = hacr_indx_datr_sel  && !tcipif_reg_sel;
assign hacr_indx_darwr_sel_rd     = hacr_indx_darwr_sel && !tcipif_reg_sel
                                 && secure_mode_match_jtag;

assign hacr_indx_mbir_sel_rd      = hacr_indx_mbir_sel;
assign hacr_indx_mbee_sel_rd      = hacr_indx_mbee_sel;
assign hacr_indx_mbse_sel_rd      = hacr_indx_mbse_sel;

assign hacr_indx_dbg_ctrl_sel_rd  = hacr_indx_dbg_ctrl_sel  && !tcipif_reg_sel;
assign hacr_indx_prof_cnt_sel_rd  = hacr_indx_prof_cnt_sel  && !tcipif_reg_sel;
assign hacr_indx_force_reg_sel_rd = hacr_indx_force_reg_sel && !tcipif_reg_sel;

// special read data
assign dder_rd_val[31:0]  = tcipif_reg_sel ? ddera_reg[31:0] : dderb_reg[31:0];
assign dacsr_rd_val[31:0] = {dacsr_reg[31:11], sec_bit_jtag, dacsr_reg[9:0]};

always @( * )
begin
  case (1'b1)
    hacr_indx_bsel_sel_rd :
      regs_rdata[31:0] = {30'b0, bsel_val[1:0]};
//bank 0
    hacr_indx_id_sel_rd :
      regs_rdata[31:0] = id_reg[31:0];
    hacr_indx_tc_sel_rd :
      regs_rdata[31:0] = 32'b0;
    hacr_indx_mbca_sel_rd :
      regs_rdata[31:0] = 32'b0;
    hacr_indx_baba_sel_rd :
      regs_rdata[31:0] = baba_reg[31:0];
    hacr_indx_bama_sel_rd :
      regs_rdata[31:0] = {24'b0, bama_reg[7:0]};
    hacr_indx_hcr_sel_rd :
      regs_rdata[31:0] = hcr_reg[31:0];
    hacr_indx_hsr_sel_rd :
      regs_rdata[31:0] = {16'b0, hsr_reg[15:0]};
    hacr_indx_hsr2_sel_rd :
      regs_rdata[31:0] = hsr2_reg[31:0];
    hacr_indx_wbbr_sel_rd :
      regs_rdata[31:0] = wbbr_reg[31:0];
    hacr_indx_psr_sel_rd :
      regs_rdata[31:0] = {32{cp0_had_secu_dbg_en}} & psr_reg[31:0];
    hacr_indx_pc_sel_rd :
      regs_rdata[31:0] = pc_reg[31:0];
    hacr_indx_csr_sel_rd :
      regs_rdata[31:0] = {16'b0, csr_reg[15:0]};
    hacr_indx_dder_sel_rd :
      regs_rdata[31:0] = dder_rd_val[31:0];
    hacr_indx_daddr_sel_rd :
      regs_rdata[31:0] = wbbr_reg[31:0];
    hacr_indx_ddata_sel_rd :
      regs_rdata[31:0] = wbbr_reg[31:0];
    hacr_indx_sysrsv_sel_rd :
      regs_rdata[31:0] = id_reg[31:0];
    hacr_indx_mbcb_sel_rd :
      regs_rdata[31:0] = 32'b0;
    hacr_indx_babb_sel_rd:
      regs_rdata[31:0] = babb_reg[31:0];
    hacr_indx_bamb_sel_rd:
      regs_rdata[31:0] = {24'b0, bamb_reg[7:0]};
//bank 1
    hacr_indx_babc_sel_rd :
      regs_rdata[31:0] = babc_reg[31:0];
    hacr_indx_bamc_sel_rd :
      regs_rdata[31:0] = {24'b0, bamc_reg[7:0]};
    hacr_indx_babd_sel_rd :
      regs_rdata[31:0] = babd_reg[31:0];
    hacr_indx_bamd_sel_rd :
      regs_rdata[31:0] = {24'b0, bamd_reg[7:0]};
    hacr_indx_babe_sel_rd :
      regs_rdata[31:0] = babe_reg[31:0];
    hacr_indx_bame_sel_rd :
      regs_rdata[31:0] = {24'b0, bame_reg[7:0]};
    hacr_indx_babf_sel_rd :
      regs_rdata[31:0] = babf_reg[31:0];
    hacr_indx_bamf_sel_rd :
      regs_rdata[31:0] = {24'b0, bamf_reg[7:0]};
    hacr_indx_babg_sel_rd :
      regs_rdata[31:0] = babg_reg[31:0];
    hacr_indx_bamg_sel_rd :
      regs_rdata[31:0] = {24'b0, bamg_reg[7:0]};
    hacr_indx_babh_sel_rd :
      regs_rdata[31:0] = babh_reg[31:0];
    hacr_indx_bamh_sel_rd :
      regs_rdata[31:0] = {24'b0, bamh_reg[7:0]};
    hacr_indx_babi_sel_rd :
      regs_rdata[31:0] = babi_reg[31:0];
    hacr_indx_bami_sel_rd :
      regs_rdata[31:0] = {24'b0, bami_reg[7:0]};
    hacr_indx_dacsr_sel_rd :
      regs_rdata[31:0] = dacsr_rd_val[31:0];
    hacr_indx_datr_sel_rd :
      regs_rdata[31:0] = datr_reg[31:0];
    hacr_indx_darwr_sel_rd :
      regs_rdata[31:0] = darwr_reg[31:0];
    hacr_indx_mbir_sel_rd :
      regs_rdata[31:0] = {28'b0, mbir_reg[3:0]};
    hacr_indx_mbee_sel_rd :
      regs_rdata[31:0] = mbee_reg[31:0];
    hacr_indx_mbse_sel_rd :
      regs_rdata[31:0] = mbse_reg[31:0];
//bank 2
    hacr_indx_dbg_ctrl_sel_rd :
      regs_rdata[31:0] = dbg_ctrl_reg[31:0];
    hacr_indx_prof_cnt_sel_rd :
      regs_rdata[31:0] = prof_cnt_reg[31:0];
    hacr_indx_force_reg_sel_rd :
      regs_rdata[31:0] = force_reg[31:0];
    default :
      regs_rdata[31:0] = 32'b0;
  endcase
end

//==============================================================================
// Output signals to other modules
//==============================================================================
// to CPU Core
//======================================
// 1. to IFU
assign had_ifu_ir[31:0] = ddc_regs_update_ir ? ddc_regs_ir[31:0]
                                             : jtag_xx_data[31:0];
assign had_ifu_ir_vld   =
  ((jtag_xx_update_dr && hacr_indx_ir_sel && hacr_go && !hacr_ex) ||
  (ddc_regs_update_ir && hcr_ddcen)) && iu_yy_xx_dbgon;

// 2. to IU
assign had_iu_pc[30:0] = pc_reg[31:1];
assign had_iu_xx_fdb   = fdb;
                                                                                                    
// 3. to IDU
assign had_idu_wbbr_data[31:0] = wbbr_reg[31:0];
assign had_idu_wbbr_vld        = ffy && iu_yy_xx_dbgon;

// 4. to CP0
//5. to TCIP
assign had_tcipif_cmplt       = tcipif_reg_sel;
assign had_tcipif_rdata[31:0] = regs_rdata[31:0];

// to HAD internal modules
//======================================
// 1. to jtag
assign regs_jtag_data[31:0]  = regs_rdata[31:0];
assign regs_jtag_hacr_rw     = hacr_rw;
assign regs_jtag_reg8_sel    = hacr_indx_mbca_sel ||
                               hacr_indx_mbcb_sel ||
                               hacr_indx_bama_sel ||
                               hacr_indx_bamb_sel ||
                               hacr_indx_tc_sel   ||
                               hacr_indx_bamc_sel ||
                               hacr_indx_bamd_sel ||
                               hacr_indx_bame_sel ||
                               hacr_indx_bamf_sel ||
                               hacr_indx_bamg_sel ||
                               hacr_indx_bamh_sel ||
                               hacr_indx_bami_sel;

assign regs_jtag_reg16_sel   = hacr_indx_hsr_sel ||
                               hacr_indx_csr_sel;
// 2. to ctrl
assign regs_ctrl_hacr_go     = hacr_go;
assign regs_ctrl_hacr_ex     = hacr_ex;
assign regs_ctrl_dr          = hcr_dr;
assign regs_ctrl_adr         = hcr_adr;
assign regs_ctrl_exit_sel    = hacr_indx_pc_sel    ||
                               hacr_indx_ir_sel    ||
                               hacr_indx_wbbr_sel  ||
                               hacr_indx_psr_sel   ||
                               hacr_indx_csr_sel   ||
                               hacr_indx_bypass_sel;
//assign regs_xx_fdb           = fdb;
// 3. to ddc
assign regs_ddc_daddr_sel    = hacr_indx_daddr_sel;
assign regs_ddc_ddata_sel    = hacr_indx_ddata_sel;
assign regs_xx_ddc_en        = hcr_ddcen;
// 4. to trace
//assign regs_trace_cnt_sel    = regs_updt_vld && bsel_0 && hacr_indx_tc_sel;
assign regs_trace_en         = hcr_tme;
// 5. to pin
assign regs_pin_pm[1:0]      = pm[1:0];
// 6. to bkpt
assign regs_bkpta_base[31:0] = baba_reg[31:0];
assign regs_bkpta_mask[7:0]  = bama_reg[7:0];
assign regs_bkpta_ctrl[2:0]  = hcr_bca[2:0];
//assign regs_bkpta_region     = hcr_rca;
//assign regs_bkpta_cnt_sel    = regs_updt_vld && bsel_0 && hacr_indx_mbca_sel;

assign regs_bkptb_base[31:0] = babb_reg[31:0];
assign regs_bkptb_mask[7:0]  = bamb_reg[7:0];
assign regs_bkptb_ctrl[2:0]  = hcr_bcb[2:0];
//assign regs_bkptb_region     = hcr_rcb;                                                             
//assign regs_bkptb_cnt_sel    = regs_updt_vld && bsel_0 && hacr_indx_mbcb_sel;

assign regs_bkptc_base[31:0] = babc_reg[31:0];
//assign regs_bkptc_mask[7:0]  = bamc_reg[7:0];
assign regs_bkptc_en         = hcr_bxen[0];

assign regs_bkptd_base[31:0] = babd_reg[31:0];
//assign regs_bkptd_mask[7:0]  = bamd_reg[7:0];
assign regs_bkptd_en         = hcr_bxen[1];

assign regs_bkpte_base[31:0] = babe_reg[31:0];
//assign regs_bkpte_mask[7:0]  = bame_reg[7:0];
assign regs_bkpte_en         = hcr_bxen[2];



assign regs_ctrl_mbee[8:0]   = mbee_reg[8:0];

// &ModuleEnd; @2847
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module cr_had_sync(
  clk1,
  clk2,
  rst1_b,
  rst2_b,
  sync_in,
  sync_out
);

// &Ports; @25
input        clk1;         
input        clk2;         
input        rst1_b;       
input        rst2_b;       
input        sync_in;      
output       sync_out;     

// &Regs; @26
reg          sync_ff1_clk1; 
reg          sync_ff2_clk1; 
reg          sync_ff3_clk1; 
reg          sync_ff_clk2; 

// &Wires; @27
wire         clk1;         
wire         clk2;         
wire         rst1_b;       
wire         rst2_b;       
wire         sync_in;      
wire         sync_out;     


//==============================================================================
// sync logic from clk2 to clk1
// step 1. flop once in clk2 domain
// step 2. flop twice in clk1 domain
// result: a pulse signal in clk1 domain
// constraint: slow clock --> fast clock
//==============================================================================

always @(posedge clk2 or negedge rst2_b)
begin
  if (!rst2_b)
    sync_ff_clk2 <= 1'b0;
  else
    sync_ff_clk2 <= sync_in;
end

always @(posedge clk1 or negedge rst1_b)
begin
  if (!rst1_b) begin
    sync_ff1_clk1 <= 1'b0;
    sync_ff2_clk1 <= 1'b0;
  end
  else begin
    sync_ff1_clk1 <= sync_ff_clk2;
    sync_ff2_clk1 <= sync_ff1_clk1;
  end   
end

// generates a pulse signal in clk1 domain
always @(posedge clk1 or negedge rst1_b)
begin
  if (!rst1_b)
    sync_ff3_clk1 <= 1'b0;
  else
    sync_ff3_clk1 <= sync_ff2_clk1;
end

assign sync_out = !sync_ff3_clk1 && sync_ff2_clk1;

// &ModuleEnd; @68
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module cr_had_sync_level(
  clk1,
  clk2,
  rst1_b,
  rst2_b,
  sync_in,
  sync_out
);

// &Ports; @25
input        clk1;         
input        clk2;         
input        rst1_b;       
input        rst2_b;       
input        sync_in;      
output       sync_out;     

// &Regs; @26
reg          sync_ff1_clk1; 
reg          sync_ff2_clk1; 
reg          sync_ff_clk2; 

// &Wires; @27
wire         clk1;         
wire         clk2;         
wire         rst1_b;       
wire         rst2_b;       
wire         sync_in;      
wire         sync_out;     


//==============================================================================
// sync logic from clk2 to clk1
// step 1. flop once in clk2 domain
// step 2. flop twice in clk1 domain
// constraint: slow clock --> fast clock
//==============================================================================

always @(posedge clk2 or negedge rst2_b)
begin
  if (!rst2_b)
    sync_ff_clk2 <= 1'b0;
  else
    sync_ff_clk2 <= sync_in;
end

always @(posedge clk1 or negedge rst1_b)
begin
  if (!rst1_b) begin
    sync_ff1_clk1 <= 1'b0;
    sync_ff2_clk1 <= 1'b0;
  end
  else begin
    sync_ff1_clk1 <= sync_ff_clk2;
    sync_ff2_clk1 <= sync_ff1_clk1;
  end   
end

assign sync_out = sync_ff2_clk1;

// &ModuleEnd; @58
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_had_top(
  clk_en,
  cp0_had_cpuid_idx0,
  cp0_had_int_exit,
  cp0_had_lpmd_b,
  cp0_had_mcause_data,
  forever_cpuclk_nogated,
  had_core_dbg_mode_req,
  had_idu_wbbr_data,
  had_idu_wbbr_vld,
  had_ifu_inst_bkpt_dbq_req,
  had_ifu_inst_bkpt_dbqexp_req,
  had_ifu_ir,
  had_ifu_ir_vld,
  had_iu_bkpt_trace_en,
  had_iu_dr_set_req,
  had_iu_force_dbg_en,
  had_iu_int_vld,
  had_iu_mbkpt_fsm_index_mbee,
  had_iu_mem_bkpt_exp_req,
  had_iu_mem_bkpt_mask,
  had_iu_mem_bkpt_req,
  had_iu_pc,
  had_iu_rte_pc_sel,
  had_iu_trace_req,
  had_iu_trace_req_for_dbg_disable,
  had_iu_xx_fdb,
  had_iu_xx_jdbreq,
  had_pad_jdb_pm,
  had_pad_jtg_tms_o,
  had_pad_jtg_tms_oe,
  had_tcipif_cmplt,
  had_tcipif_rdata,
  had_yy_xx_dbg,
  had_yy_xx_dp_index_mbee,
  had_yy_xx_exit_dbg,
  hadrst_b,
  ifu_had_chg_flw_inst,
  ifu_had_fetch_expt_vld,
  ifu_had_inst_dbg_disable,
  ifu_had_match_pc,
  ifu_had_split_first,
  iu_had_adr_dbg_ack,
  iu_had_chgflw_dst_pc,
  iu_had_chgflw_vld,
  iu_had_data_bkpt_occur_vld,
  iu_had_dbg_disable_for_tee,
  iu_had_dr_dbg_ack,
  iu_had_expt_vld,
  iu_had_fast_retire_acc_err_pc_update,
  iu_had_fast_retire_acc_err_pc_val,
  iu_had_flush,
  iu_had_inst_bkpt_occur_vld,
  iu_had_int_ack,
  iu_had_retire_with_had_int,
  iu_had_trace_occur_vld,
  iu_had_xx_bkpt_inst,
  iu_had_xx_data,
  iu_had_xx_data_vld,
  iu_had_xx_dbg_ack,
  iu_had_xx_mldst,
  iu_had_xx_retire,
  iu_had_xx_retire_normal,
  iu_had_xx_retire_pc,
  iu_yy_xx_dbgon,
  lsu_had_addr,
  lsu_had_addr_vld,
  lsu_had_ex_cmplt,
  lsu_had_st,
  pad_had_jtg_tms_i,
  pad_yy_gate_clk_en_b,
  sysio_had_sdb_req_b,
  tcipif_had_addr,
  tcipif_had_sel,
  tcipif_had_wdata,
  tcipif_had_write,
  tclk,
  trst_b
);

// &Ports; @24
input           clk_en;                              
input   [31:0]  cp0_had_cpuid_idx0;                  
input           cp0_had_int_exit;                    
input   [1 :0]  cp0_had_lpmd_b;                      
input   [31:0]  cp0_had_mcause_data;                 
input           forever_cpuclk_nogated;              
input           hadrst_b;                            
input           ifu_had_chg_flw_inst;                
input           ifu_had_fetch_expt_vld;              
input           ifu_had_inst_dbg_disable;            
input   [31:0]  ifu_had_match_pc;                    
input           ifu_had_split_first;                 
input           iu_had_adr_dbg_ack;                  
input   [31:0]  iu_had_chgflw_dst_pc;                
input           iu_had_chgflw_vld;                   
input           iu_had_data_bkpt_occur_vld;          
input           iu_had_dbg_disable_for_tee;          
input           iu_had_dr_dbg_ack;                   
input           iu_had_expt_vld;                     
input           iu_had_fast_retire_acc_err_pc_update; 
input   [30:0]  iu_had_fast_retire_acc_err_pc_val;   
input           iu_had_flush;                        
input           iu_had_inst_bkpt_occur_vld;          
input           iu_had_int_ack;                      
input           iu_had_retire_with_had_int;          
input           iu_had_trace_occur_vld;              
input           iu_had_xx_bkpt_inst;                 
input   [31:0]  iu_had_xx_data;                      
input           iu_had_xx_data_vld;                  
input           iu_had_xx_dbg_ack;                   
input           iu_had_xx_mldst;                     
input           iu_had_xx_retire;                    
input           iu_had_xx_retire_normal;             
input   [31:0]  iu_had_xx_retire_pc;                 
input           iu_yy_xx_dbgon;                      
input   [31:0]  lsu_had_addr;                        
input           lsu_had_addr_vld;                    
input           lsu_had_ex_cmplt;                    
input           lsu_had_st;                          
input           pad_had_jtg_tms_i;                   
input           pad_yy_gate_clk_en_b;                
input           sysio_had_sdb_req_b;                 
input   [15:0]  tcipif_had_addr;                     
input           tcipif_had_sel;                      
input   [31:0]  tcipif_had_wdata;                    
input           tcipif_had_write;                    
input           tclk;                                
input           trst_b;                              
output          had_core_dbg_mode_req;               
output  [31:0]  had_idu_wbbr_data;                   
output          had_idu_wbbr_vld;                    
output          had_ifu_inst_bkpt_dbq_req;           
output          had_ifu_inst_bkpt_dbqexp_req;        
output  [31:0]  had_ifu_ir;                          
output          had_ifu_ir_vld;                      
output          had_iu_bkpt_trace_en;                
output          had_iu_dr_set_req;                   
output          had_iu_force_dbg_en;                 
output          had_iu_int_vld;                      
output          had_iu_mbkpt_fsm_index_mbee;         
output          had_iu_mem_bkpt_exp_req;             
output          had_iu_mem_bkpt_mask;                
output          had_iu_mem_bkpt_req;                 
output  [30:0]  had_iu_pc;                           
output          had_iu_rte_pc_sel;                   
output          had_iu_trace_req;                    
output          had_iu_trace_req_for_dbg_disable;    
output          had_iu_xx_fdb;                       
output          had_iu_xx_jdbreq;                    
output  [1 :0]  had_pad_jdb_pm;                      
output          had_pad_jtg_tms_o;                   
output          had_pad_jtg_tms_oe;                  
output          had_tcipif_cmplt;                    
output  [31:0]  had_tcipif_rdata;                    
output          had_yy_xx_dbg;                       
output          had_yy_xx_dp_index_mbee;             
output          had_yy_xx_exit_dbg;                  

// &Regs; @25

// &Wires; @26
wire            bkpta_ctrl_inst_fetch_dbq_req;       
wire            bkpta_ctrl_req;                      
wire            bkptb_ctrl_inst_fetch_dbq_req;       
wire            bkptb_ctrl_req;                      
wire            bkptc_ctrl_inst_fetch_dbq_req;       
wire            bkptc_ctrl_req;                      
wire            bkptd_ctrl_inst_fetch_dbq_req;       
wire            bkptd_ctrl_req;                      
wire            bkpte_ctrl_inst_fetch_dbq_req;       
wire            bkpte_ctrl_req;                      
wire            clk_en;                              
wire    [31:0]  cp0_had_cpuid_idx0;                  
wire            cp0_had_int_exit;                    
wire    [1 :0]  cp0_had_lpmd_b;                      
wire    [31:0]  cp0_had_mcause_data;                 
wire            cpuclk;                              
wire            ctrl_regs_exit_dbg;                  
wire            ctrl_regs_update_adro;               
wire            ctrl_regs_update_dro;                
wire            ctrl_regs_update_mbo;                
wire            ctrl_regs_update_swo;                
wire            ctrl_regs_update_to;                 
wire            ddc_regs_ffy;                        
wire    [31:0]  ddc_regs_ir;                         
wire            ddc_regs_update_csr;                 
wire            ddc_regs_update_ir;                  
wire            forever_cpuclk_nogated;              
wire            had_clk_en;                          
wire            had_core_dbg_mode_req;               
wire    [31:0]  had_idu_wbbr_data;                   
wire            had_idu_wbbr_vld;                    
wire            had_ifu_inst_bkpt_dbq_req;           
wire            had_ifu_inst_bkpt_dbqexp_req;        
wire    [31:0]  had_ifu_ir;                          
wire            had_ifu_ir_vld;                      
wire            had_iu_bkpt_trace_en;                
wire            had_iu_dr_set_req;                   
wire            had_iu_force_dbg_en;                 
wire            had_iu_int_vld;                      
wire            had_iu_mbkpt_fsm_index_mbee;         
wire            had_iu_mem_bkpt_exp_req;             
wire            had_iu_mem_bkpt_mask;                
wire            had_iu_mem_bkpt_req;                 
wire    [30:0]  had_iu_pc;                           
wire            had_iu_rte_pc_sel;                   
wire            had_iu_trace_req;                    
wire            had_iu_trace_req_for_dbg_disable;    
wire            had_iu_xx_fdb;                       
wire            had_iu_xx_jdbreq;                    
wire    [1 :0]  had_pad_jdb_pm;                      
wire            had_pad_jtg_tms_o;                   
wire            had_pad_jtg_tms_oe;                  
wire            had_tcipif_cmplt;                    
wire    [31:0]  had_tcipif_rdata;                    
wire            had_yy_xx_dbg;                       
wire            had_yy_xx_dp_index_mbee;             
wire            had_yy_xx_exit_dbg;                  
wire            hadrst_b;                            
wire            ifu_had_chg_flw_inst;                
wire            ifu_had_fetch_expt_vld;              
wire            ifu_had_inst_dbg_disable;            
wire    [31:0]  ifu_had_match_pc;                    
wire            ifu_had_split_first;                 
wire            iu_had_adr_dbg_ack;                  
wire    [31:0]  iu_had_chgflw_dst_pc;                
wire            iu_had_chgflw_vld;                   
wire            iu_had_data_bkpt_occur_vld;          
wire            iu_had_dbg_disable_for_tee;          
wire            iu_had_dr_dbg_ack;                   
wire            iu_had_expt_vld;                     
wire            iu_had_fast_retire_acc_err_pc_update; 
wire    [30:0]  iu_had_fast_retire_acc_err_pc_val;   
wire            iu_had_flush;                        
wire            iu_had_inst_bkpt_occur_vld;          
wire            iu_had_int_ack;                      
wire            iu_had_retire_with_had_int;          
wire            iu_had_trace_occur_vld;              
wire            iu_had_xx_bkpt_inst;                 
wire    [31:0]  iu_had_xx_data;                      
wire            iu_had_xx_data_vld;                  
wire            iu_had_xx_dbg_ack;                   
wire            iu_had_xx_mldst;                     
wire            iu_had_xx_retire;                    
wire            iu_had_xx_retire_normal;             
wire    [31:0]  iu_had_xx_retire_pc;                 
wire            iu_yy_xx_dbgon;                      
wire            jtag2_pin_tms_o;                     
wire            jtag2_pin_tms_oe;                    
wire            jtag_regs_srst;                      
wire            jtag_regs_update_hacr;               
wire            jtag_xx_capture_dr;                  
wire            jtag_xx_capture_dr_mask;             
wire    [31:0]  jtag_xx_data;                        
wire            jtag_xx_update_dr;                   
wire    [31:0]  lsu_had_addr;                        
wire            lsu_had_addr_vld;                    
wire            lsu_had_ex_cmplt;                    
wire            lsu_had_st;                          
wire            pad_had_jtg_tms_i;                   
wire            pad_yy_gate_clk_en_b;                
wire            pin_ctrl_jdb_req;                    
wire            pin_sm_tap_en;                       
wire            pin_xx_tms_i;                        
wire    [31:0]  regs_bkpta_base;                     
wire            regs_bkpta_bkpti_en;                 
wire    [2 :0]  regs_bkpta_ctrl;                     
wire    [7 :0]  regs_bkpta_mask;                     
wire    [31:0]  regs_bkptb_base;                     
wire    [2 :0]  regs_bkptb_ctrl;                     
wire    [7 :0]  regs_bkptb_mask;                     
wire    [31:0]  regs_bkptc_base;                     
wire            regs_bkptc_en;                       
wire    [31:0]  regs_bkptd_base;                     
wire            regs_bkptd_en;                       
wire    [31:0]  regs_bkpte_base;                     
wire            regs_bkpte_en;                       
wire            regs_ctrl_adr;                       
wire            regs_ctrl_dr;                        
wire            regs_ctrl_exit_sel;                  
wire            regs_ctrl_hacr_ex;                   
wire            regs_ctrl_hacr_go;                   
wire            regs_ctrl_had_int_on;                
wire    [8 :0]  regs_ctrl_mbee;                      
wire            regs_ddc_daddr_sel;                  
wire            regs_ddc_ddata_sel;                  
wire    [31:0]  regs_jtag_data;                      
wire            regs_jtag_hacr_rw;                   
wire            regs_jtag_reg16_sel;                 
wire            regs_jtag_reg8_sel;                  
wire    [1 :0]  regs_pin_pm;                         
wire            regs_trace_en;                       
wire            regs_xx_ddc_en;                      
wire            sm_xx_tap_on;                        
wire            sysio_had_sdb_req_b;                 
wire    [15:0]  tcipif_had_addr;                     
wire            tcipif_had_sel;                      
wire    [31:0]  tcipif_had_wdata;                    
wire            tcipif_had_write;                    
wire            tclk;                                
wire            trace_ctrl_req;                      
wire            trace_ctrl_req_for_dbg_disable;      
wire            trst_b;                              


// &Instance("gated_clk_cell", "x_cr_had_gated_clk"); @28
gated_clk_cell  x_cr_had_gated_clk (
  .clk_in                 (forever_cpuclk_nogated),
  .clk_out                (cpuclk                ),
  .external_en            (1'b0                  ),
  .global_en              (1'b1                  ),
  .local_en               (1'b0                  ),
  .module_en              (had_clk_en            ),
  .pad_yy_gate_clk_en_b   (pad_yy_gate_clk_en_b  )
);

// &Connect(.clk_in             (forever_cpuclk_nogated), @29
//          .clk_out            (cpuclk), @30
//          .external_en        (1'b0), @31
//          .global_en          (1'b1), @32
//          .local_en           (1'b0), @33
//          .module_en          (had_clk_en) @34
//         ); @35
assign had_clk_en = sm_xx_tap_on || tcipif_had_sel;

// &ConnRule("s/bkpt/bkpta/"); @42
// &Instance("cr_had_bkpt", "x_cr_had_bkpta"); @43
cr_had_bkpt  x_cr_had_bkpta (
  .bkpt_ctrl_inst_fetch_dbq_req  (bkpta_ctrl_inst_fetch_dbq_req),
  .bkpt_ctrl_req                 (bkpta_ctrl_req               ),
  .cpuclk                        (cpuclk                       ),
  .had_core_dbg_mode_req         (had_core_dbg_mode_req        ),
  .hadrst_b                      (hadrst_b                     ),
  .ifu_had_chg_flw_inst          (ifu_had_chg_flw_inst         ),
  .ifu_had_fetch_expt_vld        (ifu_had_fetch_expt_vld       ),
  .ifu_had_inst_dbg_disable      (ifu_had_inst_dbg_disable     ),
  .ifu_had_match_pc              (ifu_had_match_pc             ),
  .ifu_had_split_first           (ifu_had_split_first          ),
  .iu_had_expt_vld               (iu_had_expt_vld              ),
  .iu_had_flush                  (iu_had_flush                 ),
  .iu_had_xx_mldst               (iu_had_xx_mldst              ),
  .iu_had_xx_retire              (iu_had_xx_retire             ),
  .iu_had_xx_retire_normal       (iu_had_xx_retire_normal      ),
  .iu_yy_xx_dbgon                (iu_yy_xx_dbgon               ),
  .lsu_had_addr                  (lsu_had_addr                 ),
  .lsu_had_addr_vld              (lsu_had_addr_vld             ),
  .lsu_had_ex_cmplt              (lsu_had_ex_cmplt             ),
  .lsu_had_st                    (lsu_had_st                   ),
  .regs_bkpt_base                (regs_bkpta_base              ),
  .regs_bkpt_ctrl                (regs_bkpta_ctrl              ),
  .regs_bkpt_mask                (regs_bkpta_mask              )
);


// &ConnRule("s/bkpt/bkptb/"); @46
// &Instance("cr_had_bkpt", "x_cr_had_bkptb"); @47
cr_had_bkpt  x_cr_had_bkptb (
  .bkpt_ctrl_inst_fetch_dbq_req  (bkptb_ctrl_inst_fetch_dbq_req),
  .bkpt_ctrl_req                 (bkptb_ctrl_req               ),
  .cpuclk                        (cpuclk                       ),
  .had_core_dbg_mode_req         (had_core_dbg_mode_req        ),
  .hadrst_b                      (hadrst_b                     ),
  .ifu_had_chg_flw_inst          (ifu_had_chg_flw_inst         ),
  .ifu_had_fetch_expt_vld        (ifu_had_fetch_expt_vld       ),
  .ifu_had_inst_dbg_disable      (ifu_had_inst_dbg_disable     ),
  .ifu_had_match_pc              (ifu_had_match_pc             ),
  .ifu_had_split_first           (ifu_had_split_first          ),
  .iu_had_expt_vld               (iu_had_expt_vld              ),
  .iu_had_flush                  (iu_had_flush                 ),
  .iu_had_xx_mldst               (iu_had_xx_mldst              ),
  .iu_had_xx_retire              (iu_had_xx_retire             ),
  .iu_had_xx_retire_normal       (iu_had_xx_retire_normal      ),
  .iu_yy_xx_dbgon                (iu_yy_xx_dbgon               ),
  .lsu_had_addr                  (lsu_had_addr                 ),
  .lsu_had_addr_vld              (lsu_had_addr_vld             ),
  .lsu_had_ex_cmplt              (lsu_had_ex_cmplt             ),
  .lsu_had_st                    (lsu_had_st                   ),
  .regs_bkpt_base                (regs_bkptb_base              ),
  .regs_bkpt_ctrl                (regs_bkptb_ctrl              ),
  .regs_bkpt_mask                (regs_bkptb_mask              )
);


// &ConnRule("s/bkpt/bkptc/"); @49
// &Instance("cr_had_inst_bkpt_lite", "x_cr_had_bkptc"); @50
cr_had_inst_bkpt_lite  x_cr_had_bkptc (
  .bkpt_ctrl_inst_fetch_dbq_req  (bkptc_ctrl_inst_fetch_dbq_req),
  .bkpt_ctrl_req                 (bkptc_ctrl_req               ),
  .had_core_dbg_mode_req         (had_core_dbg_mode_req        ),
  .ifu_had_fetch_expt_vld        (ifu_had_fetch_expt_vld       ),
  .ifu_had_inst_dbg_disable      (ifu_had_inst_dbg_disable     ),
  .ifu_had_match_pc              (ifu_had_match_pc             ),
  .ifu_had_split_first           (ifu_had_split_first          ),
  .iu_yy_xx_dbgon                (iu_yy_xx_dbgon               ),
  .regs_bkpt_base                (regs_bkptc_base              ),
  .regs_bkpt_en                  (regs_bkptc_en                )
);


// &ConnRule("s/bkpt/bkptd/"); @52
// &Instance("cr_had_inst_bkpt_lite", "x_cr_had_bkptd"); @53
cr_had_inst_bkpt_lite  x_cr_had_bkptd (
  .bkpt_ctrl_inst_fetch_dbq_req  (bkptd_ctrl_inst_fetch_dbq_req),
  .bkpt_ctrl_req                 (bkptd_ctrl_req               ),
  .had_core_dbg_mode_req         (had_core_dbg_mode_req        ),
  .ifu_had_fetch_expt_vld        (ifu_had_fetch_expt_vld       ),
  .ifu_had_inst_dbg_disable      (ifu_had_inst_dbg_disable     ),
  .ifu_had_match_pc              (ifu_had_match_pc             ),
  .ifu_had_split_first           (ifu_had_split_first          ),
  .iu_yy_xx_dbgon                (iu_yy_xx_dbgon               ),
  .regs_bkpt_base                (regs_bkptd_base              ),
  .regs_bkpt_en                  (regs_bkptd_en                )
);


// &ConnRule("s/bkpt/bkpte/"); @55
// &Instance("cr_had_inst_bkpt_lite", "x_cr_had_bkpte"); @56
cr_had_inst_bkpt_lite  x_cr_had_bkpte (
  .bkpt_ctrl_inst_fetch_dbq_req  (bkpte_ctrl_inst_fetch_dbq_req),
  .bkpt_ctrl_req                 (bkpte_ctrl_req               ),
  .had_core_dbg_mode_req         (had_core_dbg_mode_req        ),
  .ifu_had_fetch_expt_vld        (ifu_had_fetch_expt_vld       ),
  .ifu_had_inst_dbg_disable      (ifu_had_inst_dbg_disable     ),
  .ifu_had_match_pc              (ifu_had_match_pc             ),
  .ifu_had_split_first           (ifu_had_split_first          ),
  .iu_yy_xx_dbgon                (iu_yy_xx_dbgon               ),
  .regs_bkpt_base                (regs_bkpte_base              ),
  .regs_bkpt_en                  (regs_bkpte_en                )
);


// &ConnRule("s/bkpt/bkptf/"); @60
// &Instance("cr_had_inst_bkpt_lite", "x_cr_had_bkptf"); @61
// &ConnRule("s/bkpt/bkptg/"); @63
// &Instance("cr_had_inst_bkpt_lite", "x_cr_had_bkptg"); @64

// &ConnRule("s/bkpt/bkptf/"); @68
// &Instance("cr_had_inst_bkpt_lite", "x_cr_had_bkptf"); @69
// &ConnRule("s/bkpt/bkptg/"); @71
// &Instance("cr_had_inst_bkpt_lite", "x_cr_had_bkptg"); @72
// &ConnRule("s/bkpt/bkpth/"); @74
// &Instance("cr_had_inst_bkpt_lite", "x_cr_had_bkpth"); @75
// &ConnRule("s/bkpt/bkpti/"); @77
// &Instance("cr_had_inst_bkpt_lite", "x_cr_had_bkpti"); @78

// &Instance("cr_had_ctrl"); @81
cr_had_ctrl  x_cr_had_ctrl (
  .bkpta_ctrl_inst_fetch_dbq_req    (bkpta_ctrl_inst_fetch_dbq_req   ),
  .bkpta_ctrl_req                   (bkpta_ctrl_req                  ),
  .bkptb_ctrl_inst_fetch_dbq_req    (bkptb_ctrl_inst_fetch_dbq_req   ),
  .bkptb_ctrl_req                   (bkptb_ctrl_req                  ),
  .bkptc_ctrl_inst_fetch_dbq_req    (bkptc_ctrl_inst_fetch_dbq_req   ),
  .bkptc_ctrl_req                   (bkptc_ctrl_req                  ),
  .bkptd_ctrl_inst_fetch_dbq_req    (bkptd_ctrl_inst_fetch_dbq_req   ),
  .bkptd_ctrl_req                   (bkptd_ctrl_req                  ),
  .bkpte_ctrl_inst_fetch_dbq_req    (bkpte_ctrl_inst_fetch_dbq_req   ),
  .bkpte_ctrl_req                   (bkpte_ctrl_req                  ),
  .cpuclk                           (cpuclk                          ),
  .ctrl_regs_exit_dbg               (ctrl_regs_exit_dbg              ),
  .ctrl_regs_update_adro            (ctrl_regs_update_adro           ),
  .ctrl_regs_update_dro             (ctrl_regs_update_dro            ),
  .ctrl_regs_update_mbo             (ctrl_regs_update_mbo            ),
  .ctrl_regs_update_swo             (ctrl_regs_update_swo            ),
  .ctrl_regs_update_to              (ctrl_regs_update_to             ),
  .had_ifu_inst_bkpt_dbq_req        (had_ifu_inst_bkpt_dbq_req       ),
  .had_ifu_inst_bkpt_dbqexp_req     (had_ifu_inst_bkpt_dbqexp_req    ),
  .had_iu_bkpt_trace_en             (had_iu_bkpt_trace_en            ),
  .had_iu_dr_set_req                (had_iu_dr_set_req               ),
  .had_iu_mbkpt_fsm_index_mbee      (had_iu_mbkpt_fsm_index_mbee     ),
  .had_iu_mem_bkpt_exp_req          (had_iu_mem_bkpt_exp_req         ),
  .had_iu_mem_bkpt_mask             (had_iu_mem_bkpt_mask            ),
  .had_iu_mem_bkpt_req              (had_iu_mem_bkpt_req             ),
  .had_iu_trace_req                 (had_iu_trace_req                ),
  .had_iu_trace_req_for_dbg_disable (had_iu_trace_req_for_dbg_disable),
  .had_iu_xx_jdbreq                 (had_iu_xx_jdbreq                ),
  .had_yy_xx_dbg                    (had_yy_xx_dbg                   ),
  .had_yy_xx_dp_index_mbee          (had_yy_xx_dp_index_mbee         ),
  .had_yy_xx_exit_dbg               (had_yy_xx_exit_dbg              ),
  .hadrst_b                         (hadrst_b                        ),
  .iu_had_adr_dbg_ack               (iu_had_adr_dbg_ack              ),
  .iu_had_chgflw_dst_pc             (iu_had_chgflw_dst_pc            ),
  .iu_had_chgflw_vld                (iu_had_chgflw_vld               ),
  .iu_had_data_bkpt_occur_vld       (iu_had_data_bkpt_occur_vld      ),
  .iu_had_dbg_disable_for_tee       (iu_had_dbg_disable_for_tee      ),
  .iu_had_dr_dbg_ack                (iu_had_dr_dbg_ack               ),
  .iu_had_inst_bkpt_occur_vld       (iu_had_inst_bkpt_occur_vld      ),
  .iu_had_trace_occur_vld           (iu_had_trace_occur_vld          ),
  .iu_had_xx_bkpt_inst              (iu_had_xx_bkpt_inst             ),
  .iu_yy_xx_dbgon                   (iu_yy_xx_dbgon                  ),
  .jtag_xx_update_dr                (jtag_xx_update_dr               ),
  .pin_ctrl_jdb_req                 (pin_ctrl_jdb_req                ),
  .regs_bkpta_bkpti_en              (regs_bkpta_bkpti_en             ),
  .regs_ctrl_adr                    (regs_ctrl_adr                   ),
  .regs_ctrl_dr                     (regs_ctrl_dr                    ),
  .regs_ctrl_exit_sel               (regs_ctrl_exit_sel              ),
  .regs_ctrl_hacr_ex                (regs_ctrl_hacr_ex               ),
  .regs_ctrl_hacr_go                (regs_ctrl_hacr_go               ),
  .regs_ctrl_had_int_on             (regs_ctrl_had_int_on            ),
  .regs_ctrl_mbee                   (regs_ctrl_mbee                  ),
  .regs_trace_en                    (regs_trace_en                   ),
  .sysio_had_sdb_req_b              (sysio_had_sdb_req_b             ),
  .trace_ctrl_req                   (trace_ctrl_req                  ),
  .trace_ctrl_req_for_dbg_disable   (trace_ctrl_req_for_dbg_disable  )
);


// &Instance("cr_had_ddc"); @83
cr_had_ddc  x_cr_had_ddc (
  .cpuclk              (cpuclk             ),
  .ddc_regs_ffy        (ddc_regs_ffy       ),
  .ddc_regs_ir         (ddc_regs_ir        ),
  .ddc_regs_update_csr (ddc_regs_update_csr),
  .ddc_regs_update_ir  (ddc_regs_update_ir ),
  .hadrst_b            (hadrst_b           ),
  .iu_had_xx_retire    (iu_had_xx_retire   ),
  .jtag_xx_update_dr   (jtag_xx_update_dr  ),
  .regs_ddc_daddr_sel  (regs_ddc_daddr_sel ),
  .regs_ddc_ddata_sel  (regs_ddc_ddata_sel ),
  .regs_xx_ddc_en      (regs_xx_ddc_en     )
);


// &Instance("cr_had_pin"); @85
cr_had_pin  x_cr_had_pin (
  .clk_en             (clk_en            ),
  .cpuclk             (cpuclk            ),
  .had_pad_jdb_pm     (had_pad_jdb_pm    ),
  .had_pad_jtg_tms_o  (had_pad_jtg_tms_o ),
  .had_pad_jtg_tms_oe (had_pad_jtg_tms_oe),
  .hadrst_b           (hadrst_b          ),
  .iu_yy_xx_dbgon     (iu_yy_xx_dbgon    ),
  .jtag2_pin_tms_o    (jtag2_pin_tms_o   ),
  .jtag2_pin_tms_oe   (jtag2_pin_tms_oe  ),
  .pad_had_jtg_tms_i  (pad_had_jtg_tms_i ),
  .pin_ctrl_jdb_req   (pin_ctrl_jdb_req  ),
  .pin_sm_tap_en      (pin_sm_tap_en     ),
  .pin_xx_tms_i       (pin_xx_tms_i      ),
  .regs_pin_pm        (regs_pin_pm       ),
  .tclk               (tclk              ),
  .trst_b             (trst_b            )
);


// &Instance("cr_had_regs"); @87
cr_had_regs  x_cr_had_regs (
  .cp0_had_cpuid_idx0                   (cp0_had_cpuid_idx0                  ),
  .cp0_had_int_exit                     (cp0_had_int_exit                    ),
  .cp0_had_lpmd_b                       (cp0_had_lpmd_b                      ),
  .cp0_had_mcause_data                  (cp0_had_mcause_data                 ),
  .cpuclk                               (cpuclk                              ),
  .ctrl_regs_exit_dbg                   (ctrl_regs_exit_dbg                  ),
  .ctrl_regs_update_adro                (ctrl_regs_update_adro               ),
  .ctrl_regs_update_dro                 (ctrl_regs_update_dro                ),
  .ctrl_regs_update_mbo                 (ctrl_regs_update_mbo                ),
  .ctrl_regs_update_swo                 (ctrl_regs_update_swo                ),
  .ctrl_regs_update_to                  (ctrl_regs_update_to                 ),
  .ddc_regs_ffy                         (ddc_regs_ffy                        ),
  .ddc_regs_ir                          (ddc_regs_ir                         ),
  .ddc_regs_update_csr                  (ddc_regs_update_csr                 ),
  .ddc_regs_update_ir                   (ddc_regs_update_ir                  ),
  .had_core_dbg_mode_req                (had_core_dbg_mode_req               ),
  .had_idu_wbbr_data                    (had_idu_wbbr_data                   ),
  .had_idu_wbbr_vld                     (had_idu_wbbr_vld                    ),
  .had_ifu_ir                           (had_ifu_ir                          ),
  .had_ifu_ir_vld                       (had_ifu_ir_vld                      ),
  .had_iu_force_dbg_en                  (had_iu_force_dbg_en                 ),
  .had_iu_int_vld                       (had_iu_int_vld                      ),
  .had_iu_pc                            (had_iu_pc                           ),
  .had_iu_rte_pc_sel                    (had_iu_rte_pc_sel                   ),
  .had_iu_xx_fdb                        (had_iu_xx_fdb                       ),
  .had_tcipif_cmplt                     (had_tcipif_cmplt                    ),
  .had_tcipif_rdata                     (had_tcipif_rdata                    ),
  .hadrst_b                             (hadrst_b                            ),
  .iu_had_fast_retire_acc_err_pc_update (iu_had_fast_retire_acc_err_pc_update),
  .iu_had_fast_retire_acc_err_pc_val    (iu_had_fast_retire_acc_err_pc_val   ),
  .iu_had_int_ack                       (iu_had_int_ack                      ),
  .iu_had_retire_with_had_int           (iu_had_retire_with_had_int          ),
  .iu_had_xx_data                       (iu_had_xx_data                      ),
  .iu_had_xx_data_vld                   (iu_had_xx_data_vld                  ),
  .iu_had_xx_dbg_ack                    (iu_had_xx_dbg_ack                   ),
  .iu_had_xx_retire_pc                  (iu_had_xx_retire_pc                 ),
  .iu_yy_xx_dbgon                       (iu_yy_xx_dbgon                      ),
  .jtag_regs_srst                       (jtag_regs_srst                      ),
  .jtag_regs_update_hacr                (jtag_regs_update_hacr               ),
  .jtag_xx_capture_dr                   (jtag_xx_capture_dr                  ),
  .jtag_xx_capture_dr_mask              (jtag_xx_capture_dr_mask             ),
  .jtag_xx_data                         (jtag_xx_data                        ),
  .jtag_xx_update_dr                    (jtag_xx_update_dr                   ),
  .regs_bkpta_base                      (regs_bkpta_base                     ),
  .regs_bkpta_bkpti_en                  (regs_bkpta_bkpti_en                 ),
  .regs_bkpta_ctrl                      (regs_bkpta_ctrl                     ),
  .regs_bkpta_mask                      (regs_bkpta_mask                     ),
  .regs_bkptb_base                      (regs_bkptb_base                     ),
  .regs_bkptb_ctrl                      (regs_bkptb_ctrl                     ),
  .regs_bkptb_mask                      (regs_bkptb_mask                     ),
  .regs_bkptc_base                      (regs_bkptc_base                     ),
  .regs_bkptc_en                        (regs_bkptc_en                       ),
  .regs_bkptd_base                      (regs_bkptd_base                     ),
  .regs_bkptd_en                        (regs_bkptd_en                       ),
  .regs_bkpte_base                      (regs_bkpte_base                     ),
  .regs_bkpte_en                        (regs_bkpte_en                       ),
  .regs_ctrl_adr                        (regs_ctrl_adr                       ),
  .regs_ctrl_dr                         (regs_ctrl_dr                        ),
  .regs_ctrl_exit_sel                   (regs_ctrl_exit_sel                  ),
  .regs_ctrl_hacr_ex                    (regs_ctrl_hacr_ex                   ),
  .regs_ctrl_hacr_go                    (regs_ctrl_hacr_go                   ),
  .regs_ctrl_had_int_on                 (regs_ctrl_had_int_on                ),
  .regs_ctrl_mbee                       (regs_ctrl_mbee                      ),
  .regs_ddc_daddr_sel                   (regs_ddc_daddr_sel                  ),
  .regs_ddc_ddata_sel                   (regs_ddc_ddata_sel                  ),
  .regs_jtag_data                       (regs_jtag_data                      ),
  .regs_jtag_hacr_rw                    (regs_jtag_hacr_rw                   ),
  .regs_jtag_reg16_sel                  (regs_jtag_reg16_sel                 ),
  .regs_jtag_reg8_sel                   (regs_jtag_reg8_sel                  ),
  .regs_pin_pm                          (regs_pin_pm                         ),
  .regs_trace_en                        (regs_trace_en                       ),
  .regs_xx_ddc_en                       (regs_xx_ddc_en                      ),
  .tcipif_had_addr                      (tcipif_had_addr                     ),
  .tcipif_had_sel                       (tcipif_had_sel                      ),
  .tcipif_had_wdata                     (tcipif_had_wdata                    ),
  .tcipif_had_write                     (tcipif_had_write                    )
);

// &Force("output","had_core_dbg_mode_req"); @88

// &Instance("cr_had_jtag2"); @91
cr_had_jtag2  x_cr_had_jtag2 (
  .cpuclk                  (cpuclk                 ),
  .hadrst_b                (hadrst_b               ),
  .jtag2_pin_tms_o         (jtag2_pin_tms_o        ),
  .jtag2_pin_tms_oe        (jtag2_pin_tms_oe       ),
  .jtag_regs_srst          (jtag_regs_srst         ),
  .jtag_regs_update_hacr   (jtag_regs_update_hacr  ),
  .jtag_xx_capture_dr      (jtag_xx_capture_dr     ),
  .jtag_xx_capture_dr_mask (jtag_xx_capture_dr_mask),
  .jtag_xx_data            (jtag_xx_data           ),
  .jtag_xx_update_dr       (jtag_xx_update_dr      ),
  .pin_sm_tap_en           (pin_sm_tap_en          ),
  .pin_xx_tms_i            (pin_xx_tms_i           ),
  .regs_jtag_data          (regs_jtag_data         ),
  .regs_jtag_hacr_rw       (regs_jtag_hacr_rw      ),
  .regs_jtag_reg16_sel     (regs_jtag_reg16_sel    ),
  .regs_jtag_reg8_sel      (regs_jtag_reg8_sel     ),
  .sm_xx_tap_on            (sm_xx_tap_on           ),
  .tclk                    (tclk                   ),
  .trst_b                  (trst_b                 )
);

// &Instance("cr_had_jtag5"); @93

// &Instance("cr_had_trace"); @96
cr_had_trace  x_cr_had_trace (
  .had_core_dbg_mode_req          (had_core_dbg_mode_req         ),
  .iu_had_xx_mldst                (iu_had_xx_mldst               ),
  .iu_had_xx_retire               (iu_had_xx_retire              ),
  .iu_had_xx_retire_normal        (iu_had_xx_retire_normal       ),
  .iu_yy_xx_dbgon                 (iu_yy_xx_dbgon                ),
  .regs_trace_en                  (regs_trace_en                 ),
  .trace_ctrl_req                 (trace_ctrl_req                ),
  .trace_ctrl_req_for_dbg_disable (trace_ctrl_req_for_dbg_disable)
);

// &Instance("cr_had_pcfifo"); @98
// &ModuleEnd; @100
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_had_trace(
  had_core_dbg_mode_req,
  iu_had_xx_mldst,
  iu_had_xx_retire,
  iu_had_xx_retire_normal,
  iu_yy_xx_dbgon,
  regs_trace_en,
  trace_ctrl_req,
  trace_ctrl_req_for_dbg_disable
);

// &Ports; @24
input        had_core_dbg_mode_req;         
input        iu_had_xx_mldst;               
input        iu_had_xx_retire;              
input        iu_had_xx_retire_normal;       
input        iu_yy_xx_dbgon;                
input        regs_trace_en;                 
output       trace_ctrl_req;                
output       trace_ctrl_req_for_dbg_disable; 

// &Regs; @25

// &Wires; @26
wire         had_core_dbg_mode_req;         
wire         iu_had_xx_mldst;               
wire         iu_had_xx_retire;              
wire         iu_had_xx_retire_normal;       
wire         iu_yy_xx_dbgon;                
wire         regs_trace_en;                 
wire         trace_counter_eq_0;            
wire         trace_ctrl_req;                
wire         trace_ctrl_req_for_dbg_disable; 
wire         trace_en;                      
wire         trace_vld;                     


//==============================================================================
// trace valid conditions(AND):
// 1. retire normally, without exception.
// 2. not a lls instruction or the last of the lls instruction.
// 3. not in debug mode.
// 4. trace mode enable.
// The last condition is designed for low power.
//==============================================================================

assign trace_en  = !iu_yy_xx_dbgon
                && regs_trace_en
                && !had_core_dbg_mode_req;

assign trace_vld =    iu_had_xx_retire
                  && !iu_had_xx_mldst
                  && trace_en;
//==============================================================================
// trace counter decrease condition (AND):
// 1. trace valid
// 2. trace counter dosen't equal to zero.
//==============================================================================

//assign trace_counter_dec = (trace_vld || iu_had_expt_during_split && trace_en)
//                           && !trace_counter_eq_0;

//==============================================================================
// trace counter logic
//==============================================================================

// //&Force("bus", "regs_xx_wdata", 31, 0); @57
//
//always @(posedge cpuclk)
//begin
//  if (regs_trace_cnt_sel)
//    trace_counter[7:0] <= regs_xx_wdata[7:0];
//  else if (trace_counter_dec)
//    trace_counter[7:0] <= trace_counter[7:0] - 1'b1;
//  else
//    trace_counter[7:0] <= trace_counter[7:0];
//end                           

//==============================================================================
// trace counter to regs
//==============================================================================

//assign trace_regs_counter[7:0] = trace_counter[7:0];

//==============================================================================
// trace counter equals to zero
//==============================================================================

//assign trace_counter_eq_0 = (trace_counter[7:0] == 8'b0);

assign trace_counter_eq_0 = 1'b1;

//==============================================================================
// trace request to HAD control path conditions (AND):
// 1. trace_vld
// 2. trace counter equals to zero.
//==============================================================================

assign trace_ctrl_req = trace_vld && trace_counter_eq_0
                        && iu_had_xx_retire_normal;

assign trace_ctrl_req_for_dbg_disable = 1'b0;


// &ModuleEnd; @99
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_iahbl_top(
  ahblif_idle,
  bmu_iahbl_dbus_acc_deny,
  bmu_iahbl_dbus_addr,
  bmu_iahbl_dbus_chk_fail,
  bmu_iahbl_dbus_prot,
  bmu_iahbl_dbus_req,
  bmu_iahbl_dbus_req_without_cmplt,
  bmu_iahbl_dbus_size,
  bmu_iahbl_dbus_wdata,
  bmu_iahbl_dbus_write,
  bmu_iahbl_ibus_acc_deny,
  bmu_iahbl_ibus_addr,
  bmu_iahbl_ibus_hit,
  bmu_iahbl_ibus_prot,
  bmu_iahbl_ibus_req,
  bmu_iahbl_ibus_req_no_hit,
  bmu_iahbl_ibus_size,
  bmu_iahbl_ibus_vec_redirect,
  cpurst_b,
  dahblif_other_mask,
  forever_cpuclk,
  iahbl_bmu_dbus_acc_err,
  iahbl_bmu_dbus_data,
  iahbl_bmu_dbus_data_vld,
  iahbl_bmu_dbus_grnt,
  iahbl_bmu_dbus_trans_cmplt,
  iahbl_bmu_ibus_acc_err,
  iahbl_bmu_ibus_data,
  iahbl_bmu_ibus_data_vld,
  iahbl_bmu_ibus_grnt,
  iahbl_bmu_ibus_trans_cmplt,
  iahbl_pad_haddr,
  iahbl_pad_hburst,
  iahbl_pad_hprot,
  iahbl_pad_hsize,
  iahbl_pad_htrans,
  iahbl_pad_hwdata,
  iahbl_pad_hwrite,
  iahblif_other_mask,
  pad_cpu_halt_ff2,
  pad_iahbl_hrdata,
  pad_iahbl_hready,
  pad_iahbl_hresp,
  pad_yy_gate_clk_en_b,
  pwrm_cpu_bus_peak_power_limit_en,
  sahblif_iahblif_mask
);

// &Ports; @23
input           bmu_iahbl_dbus_acc_deny;         
input   [31:0]  bmu_iahbl_dbus_addr;             
input           bmu_iahbl_dbus_chk_fail;         
input   [3 :0]  bmu_iahbl_dbus_prot;             
input           bmu_iahbl_dbus_req;              
input           bmu_iahbl_dbus_req_without_cmplt; 
input   [1 :0]  bmu_iahbl_dbus_size;             
input   [31:0]  bmu_iahbl_dbus_wdata;            
input           bmu_iahbl_dbus_write;            
input           bmu_iahbl_ibus_acc_deny;         
input   [31:0]  bmu_iahbl_ibus_addr;             
input           bmu_iahbl_ibus_hit;              
input   [3 :0]  bmu_iahbl_ibus_prot;             
input           bmu_iahbl_ibus_req;              
input           bmu_iahbl_ibus_req_no_hit;       
input   [1 :0]  bmu_iahbl_ibus_size;             
input           bmu_iahbl_ibus_vec_redirect;     
input           cpurst_b;                        
input           dahblif_other_mask;              
input           forever_cpuclk;                  
input           pad_cpu_halt_ff2;                
input   [31:0]  pad_iahbl_hrdata;                
input           pad_iahbl_hready;                
input           pad_iahbl_hresp;                 
input           pad_yy_gate_clk_en_b;            
input           pwrm_cpu_bus_peak_power_limit_en; 
input           sahblif_iahblif_mask;            
output          ahblif_idle;                     
output          iahbl_bmu_dbus_acc_err;          
output  [31:0]  iahbl_bmu_dbus_data;             
output          iahbl_bmu_dbus_data_vld;         
output          iahbl_bmu_dbus_grnt;             
output          iahbl_bmu_dbus_trans_cmplt;      
output          iahbl_bmu_ibus_acc_err;          
output  [31:0]  iahbl_bmu_ibus_data;             
output          iahbl_bmu_ibus_data_vld;         
output          iahbl_bmu_ibus_grnt;             
output          iahbl_bmu_ibus_trans_cmplt;      
output  [31:0]  iahbl_pad_haddr;                 
output  [2 :0]  iahbl_pad_hburst;                
output  [3 :0]  iahbl_pad_hprot;                 
output  [2 :0]  iahbl_pad_hsize;                 
output  [1 :0]  iahbl_pad_htrans;                
output  [31:0]  iahbl_pad_hwdata;                
output          iahbl_pad_hwrite;                
output          iahblif_other_mask;              

// &Regs; @24

// &Wires; @25
wire            ahbl_clk_en;                     
wire            ahbl_gated_clk;                  
wire            ahblif_busy;                     
wire            ahblif_idle;                     
wire            ahblif_power_mask;               
wire            bmu_iahbl_dbus_acc_deny;         
wire    [31:0]  bmu_iahbl_dbus_addr;             
wire            bmu_iahbl_dbus_chk_fail;         
wire    [3 :0]  bmu_iahbl_dbus_prot;             
wire            bmu_iahbl_dbus_req;              
wire            bmu_iahbl_dbus_req_without_cmplt; 
wire    [1 :0]  bmu_iahbl_dbus_size;             
wire    [31:0]  bmu_iahbl_dbus_wdata;            
wire            bmu_iahbl_dbus_write;            
wire            bmu_iahbl_ibus_acc_deny;         
wire    [31:0]  bmu_iahbl_ibus_addr;             
wire            bmu_iahbl_ibus_hit;              
wire    [3 :0]  bmu_iahbl_ibus_prot;             
wire            bmu_iahbl_ibus_req;              
wire            bmu_iahbl_ibus_req_no_hit;       
wire    [1 :0]  bmu_iahbl_ibus_size;             
wire            bmu_iahbl_ibus_vec_redirect;     
wire            cpu_acc_err;                     
wire    [31:0]  cpu_addr;                        
wire            cpu_data_vld;                    
wire    [3 :0]  cpu_prot;                        
wire    [31:0]  cpu_rdata;                       
wire            cpu_req;                         
wire            cpu_req_for_grnt;                
wire            cpu_req_for_peak_power;          
wire            cpu_req_grnt;                    
wire            cpu_req_power_masked;            
wire            cpu_sec;                         
wire    [1 :0]  cpu_size;                        
wire            cpu_trans_cmplt;                 
wire            cpu_vec_redirect;                
wire    [31:0]  cpu_wdata;                       
wire            cpu_wdata_sel;                   
wire    [31:0]  cpu_wr_data;                     
wire            cpu_write;                       
wire            cpurst_b;                        
wire            dahblif_other_mask;              
wire            dbus_mask;                       
wire            forever_cpuclk;                  
wire            iahbl_bmu_dbus_acc_err;          
wire    [31:0]  iahbl_bmu_dbus_data;             
wire            iahbl_bmu_dbus_data_vld;         
wire            iahbl_bmu_dbus_grnt;             
wire            iahbl_bmu_dbus_trans_cmplt;      
wire            iahbl_bmu_ibus_acc_err;          
wire    [31:0]  iahbl_bmu_ibus_data;             
wire            iahbl_bmu_ibus_data_vld;         
wire            iahbl_bmu_ibus_grnt;             
wire            iahbl_bmu_ibus_trans_cmplt;      
wire    [31:0]  iahbl_pad_haddr;                 
wire    [2 :0]  iahbl_pad_hburst;                
wire    [3 :0]  iahbl_pad_hprot;                 
wire    [2 :0]  iahbl_pad_hsize;                 
wire    [1 :0]  iahbl_pad_htrans;                
wire    [31:0]  iahbl_pad_hwdata;                
wire            iahbl_pad_hwrite;                
wire            iahblif_other_mask;              
wire            ibus_not_granted;                
wire            pad_cpu_halt_ff2;                
wire    [31:0]  pad_iahbl_hrdata;                
wire            pad_iahbl_hready;                
wire            pad_iahbl_hresp;                 
wire            pad_yy_gate_clk_en_b;            
wire            pwrm_cpu_bus_peak_power_limit_en; 
wire            sahblif_iahblif_mask;            


//assign pad_iahbl_hsec = 1'b0;

 //==========================================================
 //  Instance Gated Cell for Most Common Use
 //==========================================================
//  &Instance("gated_clk_cell", "x_gated_ahbl_cpuclk_cell"); @41
gated_clk_cell  x_gated_ahbl_cpuclk_cell (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (ahbl_gated_clk      ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (dbus_mask           ),
  .module_en            (ahbl_clk_en         ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

//  &Connect(.clk_in     (forever_cpuclk), @42
//           .global_en  (1'b1          ), @43
//           .module_en  (ahbl_clk_en   ), @44
//           .local_en   (dbus_mask     ), @45
//           .external_en(1'b0          ), @46
//           .clk_out    (ahbl_gated_clk)); @47
 
//==========================================================
//  Instance Request Arbiter module 
//==========================================================
// &Instance("cr_ahbl_req_arb_fo_cache"); @54
// &Instance("cr_ahbl_req_arb_fo"); @56
// &Connect(.cpu_req_bus_sel (cpu_req_bus_grnt)); @58
// &Force("nonport", "cpu_req_bus_ff"); @59
// &Force("input", "bmu_iahbl_ibus_req_no_hit"); @60
// &Force("nonport", "uncmplt_mask"); @64
// &Instance("cr_ahbl_req_arb_cache"); @68
// &Instance("cr_ahbl_req_arb"); @70
cr_ahbl_req_arb  x_cr_ahbl_req_arb (
  .ahbl_bmu_dbus_acc_err                   (iahbl_bmu_dbus_acc_err                 ),
  .ahbl_bmu_dbus_data                      (iahbl_bmu_dbus_data                    ),
  .ahbl_bmu_dbus_data_vld                  (iahbl_bmu_dbus_data_vld                ),
  .ahbl_bmu_dbus_grnt                      (iahbl_bmu_dbus_grnt                    ),
  .ahbl_bmu_dbus_trans_cmplt               (iahbl_bmu_dbus_trans_cmplt             ),
  .ahbl_bmu_ibus_acc_err                   (iahbl_bmu_ibus_acc_err                 ),
  .ahbl_bmu_ibus_data                      (iahbl_bmu_ibus_data                    ),
  .ahbl_bmu_ibus_data_vld                  (iahbl_bmu_ibus_data_vld                ),
  .ahbl_bmu_ibus_grnt                      (iahbl_bmu_ibus_grnt                    ),
  .ahbl_bmu_ibus_trans_cmplt               (iahbl_bmu_ibus_trans_cmplt             ),
  .ahbl_gated_clk                          (ahbl_gated_clk                         ),
  .bmu_ahbl_dbus_acc_deny                  (bmu_iahbl_dbus_acc_deny                ),
  .bmu_ahbl_dbus_addr                      (bmu_iahbl_dbus_addr                    ),
  .bmu_ahbl_dbus_chk_fail                  (bmu_iahbl_dbus_chk_fail                ),
  .bmu_ahbl_dbus_prot                      (bmu_iahbl_dbus_prot                    ),
  .bmu_ahbl_dbus_req                       (bmu_iahbl_dbus_req                     ),
  .bmu_ahbl_dbus_req_without_cmplt         (bmu_iahbl_dbus_req_without_cmplt       ),
  .bmu_ahbl_dbus_req_without_deny_chk_fail (bmu_iahbl_dbus_req                     ),
  .bmu_ahbl_dbus_size                      (bmu_iahbl_dbus_size                    ),
  .bmu_ahbl_dbus_write                     (bmu_iahbl_dbus_write                   ),
  .bmu_ahbl_ibus_acc_deny                  (bmu_iahbl_ibus_acc_deny                ),
  .bmu_ahbl_ibus_addr                      (bmu_iahbl_ibus_addr                    ),
  .bmu_ahbl_ibus_hit                       (bmu_iahbl_ibus_hit                     ),
  .bmu_ahbl_ibus_prot                      (bmu_iahbl_ibus_prot                    ),
  .bmu_ahbl_ibus_req                       (bmu_iahbl_ibus_req                     ),
  .bmu_ahbl_ibus_req_no_hit                (bmu_iahbl_ibus_req_no_hit              ),
  .bmu_ahbl_ibus_size                      (bmu_iahbl_ibus_size                    ),
  .bmu_ahbl_ibus_vec_redirect              (bmu_iahbl_ibus_vec_redirect            ),
  .bmu_ahbl_ibus_write                     (1'b0                                   ),
  .bmu_ahbl_wdata                          (bmu_iahbl_dbus_wdata                   ),
  .cpu_acc_err                             (cpu_acc_err                            ),
  .cpu_addr                                (cpu_addr                               ),
  .cpu_data_vld                            (cpu_data_vld                           ),
  .cpu_prot                                (cpu_prot                               ),
  .cpu_rdata                               (cpu_rdata                              ),
  .cpu_req                                 (cpu_req                                ),
  .cpu_req_for_grnt                        (cpu_req_for_grnt                       ),
  .cpu_req_for_peak_power                  (cpu_req_for_peak_power                 ),
  .cpu_req_grnt                            (cpu_req_grnt                           ),
  .cpu_sec                                 (cpu_sec                                ),
  .cpu_size                                (cpu_size                               ),
  .cpu_trans_cmplt                         (cpu_trans_cmplt                        ),
  .cpu_vec_redirect                        (cpu_vec_redirect                       ),
  .cpu_wdata                               (cpu_wdata                              ),
  .cpu_write                               (cpu_write                              ),
  .cpurst_b                                (cpurst_b                               ),
  .ibus_not_granted                        (ibus_not_granted                       )
);

assign dbus_mask = ibus_not_granted;
// &Force("nonport", "cpu_req_for_peak_power"); @74
// &Connect( .ahbl_bmu_bus_check_fail   (ahbl_cache_bus_check_fail), @76
//           .ahbl_bmu_ibus_acc_err     (ahbl_cache_lf_acc_err    ), @77
//           .ahbl_bmu_ibus_sec         (ahbl_cache_lf_sec        ), @78
//           .ahbl_bmu_ibus_data        (ahbl_cache_lf_data       ), @79
//           .ahbl_bmu_ibus_data_vld    (ahbl_cache_lf_data_vld   ), @80
//           .ahbl_bmu_ibus_grnt        (ahbl_cache_lf_grnt       ), @81
//           .ahbl_bmu_ibus_trans_cmplt (ahbl_cache_lf_trans_cmplt), @82
//           .ahbl_bmu_dbus_acc_err     (ahbl_cache_uc_acc_err    ), @83
//           .ahbl_bmu_dbus_data        (ahbl_cache_uc_data       ), @84
//           .ahbl_bmu_dbus_data_vld    (ahbl_cache_uc_data_vld   ), @85
//           .ahbl_bmu_dbus_trans_cmplt (ahbl_cache_uc_trans_cmplt), @86
//           .ahbl_bmu_dbus_grnt        (ahbl_cache_uc_grnt       ), @87
//           .bmu_ahbl_ibus_acc_deny    (1'b0                     ), @88
//           .bmu_ahbl_ibus_addr        (cache_ahbl_lf_addr       ), @89
//           .bmu_ahbl_ibus_prot        (cache_ahbl_lf_prot       ), @90
//           .bmu_ahbl_ibus_req         (cache_ahbl_lf_req        ), @91
//           .bmu_ahbl_ibus_req_no_hit  (cache_ahbl_lf_req        ), @92
//           .bmu_ahbl_ibus_size        (cache_ahbl_lf_size       ), @93
//           .bmu_ahbl_ibus_write       (1'b0                     ), @94
//           .bmu_ahbl_wdata            (cache_ahbl_uc_wdata      ), @95
//           .bmu_ahbl_dbus_acc_deny    (1'b0                     ), @96
//           .bmu_ahbl_dbus_chk_fail    (1'b0                     ), @97
//           .bmu_ahbl_dbus_addr        (cache_ahbl_uc_addr       ), @98
//           .bmu_ahbl_dbus_prot        (cache_ahbl_uc_prot       ), @99
//           .bmu_ahbl_dbus_req         (cache_ahbl_uc_req        ), @100
//           .bmu_ahbl_dbus_req_without_deny_chk_fail(cache_ahbl_uc_req_without_cmplt), @101
//           .bmu_ahbl_dbus_req_without_cmplt (cache_ahbl_uc_req_without_cmplt), @102
//           .bmu_ahbl_dbus_size        (cache_ahbl_uc_size       ), @103
//           .bmu_ahbl_ibus_vec_redirect (cache_ahbl_uc_vec_redirect), @104
//           .bmu_ahbl_dbus_write       (cache_ahbl_uc_write      )); @105
// &Connect( .ahbl_bmu_ibus_data_pol    (ahbl_cache_lf_data_pol   ), @107
//           .ahbl_bmu_dbus_data_pol    (ahbl_cache_uc_data_pol   ), @108
//           .bmu_ahbl_wdata_pol        (cache_ahbl_uc_wdata_pol  )); @109
// &Connect( .bmu_ahbl_dbus_source_pc   (cache_ahbl_uc_source_pc  ), @112
//           .bmu_ahbl_dbus_load        (cache_ahbl_uc_load       ), @113
//           .bmu_ahbl_dbus_store       (cache_ahbl_uc_store      ), @114
//           .bmu_ahbl_dbus_inst_fetch_chk (cache_ahbl_uc_inst_fetch_chk)); @115
// &Connect( .bmu_ahbl_ibus_source_pc   (cache_ahbl_lf_source_pc  ), @116
//           .bmu_ahbl_ibus_load        (1'b0                     ), @117
//           .bmu_ahbl_ibus_store       (1'b0                     ), @118
//           .bmu_ahbl_ibus_inst_fetch_chk (cache_ahbl_lf_inst_fetch_chk)); @119
// &Connect( .ahbl_bmu_ibus_inst_dbg_disable (ahbl_cache_bus_inst_dbg_disable )); @122
// &Connect( .bmu_ahbl_ibus_hit (cache_ahbl_lf_req)); @124
// &Connect( .ahbl_bmu_bus_check_fail   (iahbl_bmu_bus_check_fail   ), @126
//           .ahbl_bmu_dbus_acc_err     (iahbl_bmu_dbus_acc_err     ), @127
//           .ahbl_bmu_dbus_data        (iahbl_bmu_dbus_data        ), @128
//           .ahbl_bmu_dbus_data_vld    (iahbl_bmu_dbus_data_vld    ), @129
//           .ahbl_bmu_dbus_grnt        (iahbl_bmu_dbus_grnt        ), @130
//           .ahbl_bmu_dbus_trans_cmplt (iahbl_bmu_dbus_trans_cmplt ), @131
//           .ahbl_bmu_ibus_acc_err     (iahbl_bmu_ibus_acc_err     ), @132
//           .ahbl_bmu_ibus_data        (iahbl_bmu_ibus_data        ), @133
//           .ahbl_bmu_ibus_data_vld    (iahbl_bmu_ibus_data_vld    ), @134
//           .ahbl_bmu_ibus_grnt        (iahbl_bmu_ibus_grnt        ), @135
//           .ahbl_bmu_ibus_trans_cmplt (iahbl_bmu_ibus_trans_cmplt ), @136
//           .bmu_ahbl_dbus_acc_deny    (bmu_iahbl_dbus_acc_deny    ), @137
//           .bmu_ahbl_dbus_chk_fail    (bmu_iahbl_dbus_chk_fail    ), @138
//           .bmu_ahbl_dbus_addr        (bmu_iahbl_dbus_addr        ), @139
//           .bmu_ahbl_dbus_prot        (bmu_iahbl_dbus_prot        ), @140
//           .bmu_ahbl_dbus_req         (bmu_iahbl_dbus_req         ), @141
//           .bmu_ahbl_dbus_req_without_deny_chk_fail(bmu_iahbl_dbus_req), @142
//           .bmu_ahbl_dbus_req_without_cmplt (bmu_iahbl_dbus_req_without_cmplt), @143
//           .bmu_ahbl_dbus_size        (bmu_iahbl_dbus_size        ), @144
//           .bmu_ahbl_wdata            (bmu_iahbl_dbus_wdata       ), @145
//           .bmu_ahbl_dbus_write       (bmu_iahbl_dbus_write       ), @146
//           .bmu_ahbl_ibus_acc_deny    (bmu_iahbl_ibus_acc_deny    ), @147
//           .bmu_ahbl_ibus_addr        (bmu_iahbl_ibus_addr        ), @148
//           .bmu_ahbl_ibus_prot        (bmu_iahbl_ibus_prot        ), @149
//           .bmu_ahbl_ibus_req         (bmu_iahbl_ibus_req         ), @150
//           .bmu_ahbl_ibus_req_no_hit  (bmu_iahbl_ibus_req_no_hit  ), @151
//           .bmu_ahbl_ibus_size        (bmu_iahbl_ibus_size        ), @152
//           .bmu_ahbl_ibus_vec_redirect (bmu_iahbl_ibus_vec_redirect), @153
//           .bmu_ahbl_ibus_write       (1'b0                       )); @154
// &Connect( .ahbl_bmu_dbus_data_pol    (iahbl_bmu_dbus_data_pol    ), @156
//           .ahbl_bmu_ibus_data_pol    (iahbl_bmu_ibus_data_pol    ), @157
//           .bmu_ahbl_wdata_pol        (bmu_iahbl_dbus_wdata_pol   )); @158
// &Connect( .ahbl_bmu_had_acc_err      (iahbl_bmu_had_acc_err      ), @161
//           .ahbl_bmu_had_data         (iahbl_bmu_had_data         ), @162
//           .ahbl_bmu_had_data_vld     (iahbl_bmu_had_data_vld     ), @163
//           .ahbl_bmu_had_grnt         (iahbl_bmu_had_grnt         ), @164
//           .ahbl_bmu_had_trans_cmplt  (iahbl_bmu_had_trans_cmplt  ), @165
//           .bmu_ahbl_had_addr         (bmu_iahbl_had_addr         ), @166
//           .bmu_ahbl_had_prot         (bmu_iahbl_had_prot         ), @167
//           .bmu_ahbl_had_req          (bmu_iahbl_had_req          ), @168
//           .bmu_ahbl_had_req_without_cmplt   (bmu_iahbl_had_req_without_cmplt), @169
//           .bmu_ahbl_had_size         (bmu_iahbl_had_size         ), @170
//           .bmu_ahbl_had_wdata        (bmu_iahbl_had_wdata        ), @171
//           .bmu_ahbl_had_write        (bmu_iahbl_had_write        )); @172
// &Force("bus", "bmu_iahbl_ibus_source_pc", 31, 0); @175
// &Force("bus", "bmu_iahbl_dbus_source_pc", 31, 0); @176
// &Connect( .bmu_ahbl_ibus_source_pc   (bmu_iahbl_ibus_source_pc[29:8]), @177
//           .bmu_ahbl_ibus_load        (1'b0                       ), @178
//           .bmu_ahbl_ibus_store       (1'b0                       ), @179
//           .bmu_ahbl_ibus_inst_fetch_chk (bmu_iahbl_ibus_inst_fetch_chk )); @180
// &Connect( .bmu_ahbl_dbus_source_pc   (bmu_iahbl_dbus_source_pc[29:8]), @181
//           .bmu_ahbl_dbus_load        (bmu_iahbl_dbus_load        ), @182
//           .bmu_ahbl_dbus_store       (bmu_iahbl_dbus_store       ), @183
//           .bmu_ahbl_dbus_inst_fetch_chk (bmu_iahbl_dbus_inst_fetch_chk )); @184
// &Connect( .ahbl_bmu_ibus_inst_dbg_disable (iahbl_bmu_ibus_inst_dbg_disable )); @189
// &Connect( .bmu_ahbl_ibus_hit (bmu_iahbl_ibus_hit)); @191

//==========================================================
//  Instance Bus Interface module
//  Width Adjust Module is needed for 16-bits BUS 
//==========================================================
// &Instance("cr_ahbl_wid_adj_fo"); @200
// &Connect(.clk_en          (iahbl_clk_en       )); @201
// &Instance("cr_ahbl_if_fo_hw"); @202
// &Connect(.cpu_addr        (cpu_addr_raw       ), @203
//          .cpu_prot        (cpu_prot_raw       ), @204
//          .cpu_req         (cpu_req_raw        ), @205
//          .cpu_size        (cpu_size_raw       ), @206
//          .cpu_wdata       (cpu_wdata_raw      ), @207
//          .cpu_write       (cpu_write_raw      ), @208
//          .cpu_acc_err     (cpu_acc_err_raw    ), @209
//          .cpu_data_vld    (cpu_data_vld_raw   ), @210
//          .cpu_rdata       (cpu_rdata_raw      ), @211
//          .cpu_req_grnt    (cpu_req_grnt_raw   ), @212
//          .cpu_trans_cmplt (cpu_trans_cmplt_raw) @213
// ); @214
// &Connect(.ahbLif_ahbl_haddr      (iahbl_pad_haddr         ), @215
//          .ahbLif_ahbl_hburst     (iahbl_pad_hburst        ), @216
//          .ahbLif_ahbl_hprot      (iahbl_pad_hprot         ), @217
//          .ahbLif_ahbl_hsize      (iahbl_pad_hsize         ), @218
//          .ahbLif_ahbl_htrans     (iahbl_pad_htrans        ), @219
//          .ahbLif_ahbl_hwdata     (iahbl_pad_hwdata        ), @220
//          .ahbLif_ahbl_hwrite     (iahbl_pad_hwrite        ), @221
//          .ahbl_ahbLif_hrdata     (pad_iahbl_hrdata        ), @222
//          .ahbl_ahbLif_hready     (pad_iahbl_hready        ), @223
//          .ahbl_ahbLif_hsec       (pad_iahbl_hsec          ), @224
//          .ahbl_ahbLif_hresp      (pad_iahbl_hresp         )); @225
// &Connect(.clk_en                 (iahbl_clk_en            )); @226
// &Connect(.ahbLif_ahbl_haddr_pol  (iahbl_pad_haddr_pol     ), @228
//          .ahbLif_ahbl_hwdata_pol (iahbl_pad_hwdata_pol    ), @229
//          .ahbl_ahbLif_hrdata_pol (pad_iahbl_hrdata_pol    )); @230
// &Connect(.ahbLif_ahbl_hwdata_par (iahbl_pad_hwdata_par    ), @233
//          .ahbl_ahbLif_hrdata_par (pad_iahbl_hrdata_par    )); @234
// &Connect(.ahbl_ahbLif_inst_dbg_disable (pad_iahbl_inst_dbg_disable )); @237
// &Instance("cr_ahbl_wid_adj"); @240
// &Instance("cr_ahbl_if_hw"); @241
// &Connect(.cpu_addr        (cpu_addr_raw       ), @242
//          .cpu_prot        (cpu_prot_raw       ), @243
//          .cpu_req         (cpu_req_raw        ), @244
//          .cpu_size        (cpu_size_raw       ), @245
//          .cpu_wdata       (cpu_wdata_raw      ), @246
//          .cpu_write       (cpu_write_raw      ), @247
//          .cpu_acc_err     (cpu_acc_err_raw    ), @248
//          .cpu_data_vld    (cpu_data_vld_raw   ), @249
//          .cpu_rdata       (cpu_rdata_raw      ), @250
//          .cpu_req_grnt    (cpu_req_grnt_raw   ), @251
//          .cpu_trans_cmplt (cpu_trans_cmplt_raw) @252
// ); @253
// &Connect(.ahbLif_ahbl_haddr      (iahbl_pad_haddr         ), @254
//          .ahbLif_ahbl_hburst     (iahbl_pad_hburst        ), @255
//          .ahbLif_ahbl_hprot      (iahbl_pad_hprot         ), @256
//          .ahbLif_ahbl_hsize      (iahbl_pad_hsize         ), @257
//          .ahbLif_ahbl_htrans     (iahbl_pad_htrans        ), @258
//          .ahbLif_ahbl_hwdata     (iahbl_pad_hwdata        ), @259
//          .ahbLif_ahbl_hwrite     (iahbl_pad_hwrite        ), @260
//          .ahbl_ahbLif_hrdata     (pad_iahbl_hrdata        ), @261
//          .ahbl_ahbLif_hready     (pad_iahbl_hready        ), @262
//          .ahbl_ahbLif_hsec       (pad_iahbl_hsec          ), @263
//          .ahbl_ahbLif_hresp      (pad_iahbl_hresp         )); @264
// &Connect(.ahbLif_ahbl_haddr_pol  (iahbl_pad_haddr_pol     ), @266
//          .ahbLif_ahbl_hwdata_pol (iahbl_pad_hwdata_pol    ), @267
//          .ahbl_ahbLif_hrdata_pol (pad_iahbl_hrdata_pol    )); @268
// &Connect(.ahbLif_ahbl_hwdata_par (iahbl_pad_hwdata_par    ), @271
//          .ahbl_ahbLif_hrdata_par (pad_iahbl_hrdata_par    )); @272
// &Connect(.ahbl_ahbLif_inst_dbg_disable (pad_iahbl_inst_dbg_disable )); @275

// &Instance("cr_ahb_if_fo"); @282
// &Connect(.clk_en                 (iahbl_clk_en            )); @283
// &Connect(.uncmplt_mask (cache_uncmplt_mask)); @287
// &Force("input", "sahblif_iahblif_mask"); @290
// &Instance("cr_ahb_if"); @292
// &Connect(.ahb_gated_clk        (ahbl_gated_clk        )); @298
// &Connect(.ahb_clk_en           (ahbl_clk_en           )); @299
// &Connect(.ahbif_busy           (ahblif_busy           )); @300
// &Connect(.ahbif_power_mask     (ahblif_power_mask     )); @301
// &Connect(.ahbif_ahb_haddr      (iahb_ebmu_haddr         ), @302
//          .ahbif_ahb_hburst     (iahb_ebmu_hburst        ), @303
//          .ahbif_ahb_hprot      (iahb_ebmu_hprot         ), @304
//          .ahbif_ahb_hsize      (iahb_ebmu_hsize         ), @305
//          .ahbif_ahb_htrans     (iahb_ebmu_htrans        ), @306
//          .ahbif_ahb_hbusreq    (iahb_ebmu_hbusreq       ), @307
//          .ahbif_ahb_hwdata     (iahb_ebmu_hwdata        ), @308
//          .ahbif_ahb_hwrite     (iahb_ebmu_hwrite        ), @309
//          .ahbif_wfd            (iahb_ebmu_wfd        ), @310
//          .ahb_ahbif_hrdata     (ebmu_iahb_hrdata        ), @311
//          .ahb_ahbif_hready     (ebmu_iahb_hready        ), @312
//          .ahb_ahbif_hgrant     (ebmu_iahb_hgrant        ), @313
//          .ahb_ahbif_hresp      (ebmu_iahb_hresp         )); @314
// &Connect(.ahbif_ahb_haddr_pol  (iahb_ebmu_haddr_pol     ), @316
//          .ahbif_ahb_hwdata_pol (iahb_ebmu_hwdata_pol    ), @317
//          .ahb_ahbif_hrdata_pol (ebmu_iahb_hrdata_pol    )); @318
// &Connect(.ahbif_ahb_hwdata_par (iahb_ebmu_hwdata_par    ), @321
//          .ahb_ahbif_hrdata_par (ebmu_iahb_hrdata_par    )); @322
// &Connect(.ahb_ahbif_inst_dbg_disable (ebmu_iahb_inst_dbg_disable )); @325
// &Connect(.ahbif_ahb_source_pc   (iahb_ebmu_source_pc    ), @328
//          .ahbif_ahb_load        (iahb_ebmu_load         ), @329
//          .ahbif_ahb_store       (iahb_ebmu_store        ), @330
//          .ahbif_ahb_inst_fetch_chk (iahb_ebmu_inst_fetch_chk  )); @331
// &Connect(.ahbif_ahb_vec_redrct (iahb_ebmu_vec_redrct)); @333
// &Force("nonport", "cpu_req_for_grnt"); @335
// &Instance("cr_ahbl_if_fo"); @338
// &Connect(.clk_en                 (iahbl_clk_en            )); @339
// &Connect(.uncmplt_mask (cache_uncmplt_mask)); @343
// &Force("input", "sahblif_iahblif_mask"); @346
// &Instance("cr_ahbl_if"); @348
cr_ahbl_if  x_cr_ahbl_if (
  .ahbLif_ahbl_haddr    (iahbl_pad_haddr     ),
  .ahbLif_ahbl_hburst   (iahbl_pad_hburst    ),
  .ahbLif_ahbl_hprot    (iahbl_pad_hprot     ),
  .ahbLif_ahbl_hsize    (iahbl_pad_hsize     ),
  .ahbLif_ahbl_htrans   (iahbl_pad_htrans    ),
  .ahbLif_ahbl_hwdata   (iahbl_pad_hwdata    ),
  .ahbLif_ahbl_hwrite   (iahbl_pad_hwrite    ),
  .ahbl_ahbLif_hrdata   (pad_iahbl_hrdata    ),
  .ahbl_ahbLif_hready   (pad_iahbl_hready    ),
  .ahbl_ahbLif_hresp    (pad_iahbl_hresp     ),
  .ahbl_clk_en          (ahbl_clk_en         ),
  .ahbl_gated_clk       (ahbl_gated_clk      ),
  .ahblif_busy          (ahblif_busy         ),
  .ahblif_idle          (ahblif_idle         ),
  .ahblif_power_mask    (ahblif_power_mask   ),
  .cpu_acc_err          (cpu_acc_err         ),
  .cpu_addr             (cpu_addr            ),
  .cpu_data_vld         (cpu_data_vld        ),
  .cpu_prot             (cpu_prot            ),
  .cpu_rdata            (cpu_rdata           ),
  .cpu_req              (cpu_req             ),
  .cpu_req_grnt         (cpu_req_grnt        ),
  .cpu_req_power_masked (cpu_req_power_masked),
  .cpu_sec              (cpu_sec             ),
  .cpu_size             (cpu_size            ),
  .cpu_trans_cmplt      (cpu_trans_cmplt     ),
  .cpu_vec_redirect     (cpu_vec_redirect    ),
  .cpu_wdata_sel        (cpu_wdata_sel       ),
  .cpu_wr_data          (cpu_wr_data         ),
  .cpu_write            (cpu_write           ),
  .cpurst_b             (cpurst_b            ),
  .pad_cpu_halt_ff2     (pad_cpu_halt_ff2    )
);

assign cpu_wr_data[31:0] = {32{cpu_wdata_sel}} & cpu_wdata[31:0];
assign iahblif_other_mask = ahblif_busy && pwrm_cpu_bus_peak_power_limit_en;
assign ahblif_power_mask  = sahblif_iahblif_mask || dahblif_other_mask;
assign cpu_req_power_masked = cpu_req && !ahblif_power_mask;
// &Connect(.ahbLif_ahbl_haddr      (iahbl_pad_haddr         ), @354
//          .ahbLif_ahbl_hburst     (iahbl_pad_hburst        ), @355
//          .ahbLif_ahbl_hprot      (iahbl_pad_hprot         ), @356
//          .ahbLif_ahbl_hsize      (iahbl_pad_hsize         ), @357
//          .ahbLif_ahbl_htrans     (iahbl_pad_htrans        ), @358
//          .ahbLif_ahbl_hwdata     (iahbl_pad_hwdata        ), @359
//          .ahbLif_ahbl_hwrite     (iahbl_pad_hwrite        ), @360
//          .ahbl_ahbLif_hrdata     (pad_iahbl_hrdata        ), @361
//          .ahbl_ahbLif_hready     (pad_iahbl_hready        ), @362
//          .ahbl_ahbLif_hsec       (pad_iahbl_hsec          ), @363
//          .ahbl_ahbLif_hresp      (pad_iahbl_hresp         )); @364
// &Connect(.ahbLif_ahbl_haddr_pol  (iahbl_pad_haddr_pol     ), @366
//          .ahbLif_ahbl_hwdata_pol (iahbl_pad_hwdata_pol    ), @367
//          .ahbl_ahbLif_hrdata_pol (pad_iahbl_hrdata_pol    )); @368
// &Connect(.ahbLif_ahbl_hwdata_par (iahbl_pad_hwdata_par    ), @371
//          .ahbl_ahbLif_hrdata_par (pad_iahbl_hrdata_par    )); @372
// &Connect(.ahbl_ahbLif_inst_dbg_disable (pad_iahbl_inst_dbg_disable )); @375
// &Connect(.ahbLif_ahbl_source_pc   (iahbl_pad_source_pc    ), @378
//          .ahbLif_ahbl_load        (iahbl_pad_load         ), @379
//          .ahbLif_ahbl_store       (iahbl_pad_store        ), @380
//          .ahbLif_ahbl_inst_fetch_chk (iahbl_pad_inst_fetch_chk  )); @381
// &Connect(.ahbLif_ahbl_vec_redrct (iahbl_pad_vec_redrct)); @383

// &ModuleEnd; @387
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_ifu_ibuf(
  cp0_yy_clk_en,
  cpuclk,
  cpurst_b,
  forever_cpuclk,
  had_ifu_ir,
  had_ifu_ir_vld,
  ibuf_ibusif_inst_fetch,
  ibuf_ifctrl_inst32_low,
  ibuf_ifctrl_inst_vld,
  ibuf_ifctrl_pop0_mad32_low,
  ibuf_ifdp_inst_dbg_disable,
  ibuf_top_clk_en,
  ibuf_xx_empty,
  ibusif_ibuf_no_trans,
  ibusif_xx_16bit_inst,
  ibusif_xx_acc_err,
  ibusif_xx_data,
  ibusif_xx_ibus_idle,
  ibusif_xx_trans_cmplt,
  ibusif_xx_unalign_fetch,
  ifctrl_ibuf_bypass_vld,
  ifctrl_ibuf_inst_pipe_down,
  ifctrl_ibuf_pop_en,
  ifctrl_xx_ifcancel,
  ifu_had_fetch_expt_vld,
  ifu_iu_ex_expt_cur,
  ifu_iu_ex_expt_vld,
  ifu_iu_ex_inst,
  ifu_misc_clk,
  iu_ifu_ex_stall_noinput,
  iu_ifu_ex_vld,
  iu_ifu_inst_fetch,
  iu_ifu_lsu_inst,
  iu_ifu_wb_ldst,
  iu_ifu_wb_stall,
  iu_yy_xx_dbgon,
  pad_yy_gate_clk_en_b,
  randclk_ibuf_entry_data_mod_en_w16,
  randclk_ibuf_pop_mod_en_w3,
  randclk_ibuf_push_mod_en_w3
);

// &Ports; @24
input           cp0_yy_clk_en;                     
input           cpuclk;                            
input           cpurst_b;                          
input           forever_cpuclk;                    
input   [31:0]  had_ifu_ir;                        
input           had_ifu_ir_vld;                    
input           ibusif_ibuf_no_trans;              
input           ibusif_xx_16bit_inst;              
input           ibusif_xx_acc_err;                 
input   [31:0]  ibusif_xx_data;                    
input           ibusif_xx_ibus_idle;               
input           ibusif_xx_trans_cmplt;             
input           ibusif_xx_unalign_fetch;           
input           ifctrl_ibuf_bypass_vld;            
input           ifctrl_ibuf_inst_pipe_down;        
input           ifctrl_ibuf_pop_en;                
input           ifctrl_xx_ifcancel;                
input           ifu_misc_clk;                      
input           iu_ifu_ex_stall_noinput;           
input           iu_ifu_ex_vld;                     
input           iu_ifu_inst_fetch;                 
input           iu_ifu_lsu_inst;                   
input           iu_ifu_wb_ldst;                    
input           iu_ifu_wb_stall;                   
input           iu_yy_xx_dbgon;                    
input           pad_yy_gate_clk_en_b;              
input   [3 :0]  randclk_ibuf_entry_data_mod_en_w16; 
input           randclk_ibuf_pop_mod_en_w3;        
input           randclk_ibuf_push_mod_en_w3;       
output          ibuf_ibusif_inst_fetch;            
output          ibuf_ifctrl_inst32_low;            
output          ibuf_ifctrl_inst_vld;              
output          ibuf_ifctrl_pop0_mad32_low;        
output          ibuf_ifdp_inst_dbg_disable;        
output          ibuf_top_clk_en;                   
output          ibuf_xx_empty;                     
output          ifu_had_fetch_expt_vld;            
output          ifu_iu_ex_expt_cur;                
output          ifu_iu_ex_expt_vld;                
output  [31:0]  ifu_iu_ex_inst;                    

// &Regs; @25
reg     [5 :0]  pop0;                              
reg             pop0_acc_err;                      
reg     [15:0]  pop0_inst;                         
reg     [5 :0]  pop0_shift;                        
reg     [15:0]  pop0_shift_inst;                   
reg             pop0_shift_vld;                    
reg             pop0_vld;                          
reg             pop1_acc_err;                      
reg     [15:0]  pop1_inst;                         
reg             pop1_shift_vld;                    
reg             pop1_vld;                          
reg     [5 :0]  push0;                             
reg     [5 :0]  push0_shift;                       

// &Wires; @26
wire            acc_err_upd_en;                    
wire            align_fetch_bypass_32bit;          
wire            cp0_yy_clk_en;                     
wire            cpuclk;                            
wire            cpurst_b;                          
wire            entry0_acc_err;                    
wire            entry0_create0_en;                 
wire            entry0_create1_en;                 
wire    [16:0]  entry0_inst;                       
wire            entry0_part_flush;                 
wire            entry0_randclk_data_mod_en_w16;    
wire            entry0_retire0_en;                 
wire            entry0_retire1_en;                 
wire            entry0_vld;                        
wire            entry1_acc_err;                    
wire            entry1_create0_en;                 
wire            entry1_create1_en;                 
wire    [16:0]  entry1_inst;                       
wire            entry1_part_flush;                 
wire            entry1_randclk_data_mod_en_w16;    
wire            entry1_retire0_en;                 
wire            entry1_retire1_en;                 
wire            entry1_vld;                        
wire            entry2_acc_err;                    
wire            entry2_create0_en;                 
wire            entry2_create1_en;                 
wire    [16:0]  entry2_inst;                       
wire            entry2_part_flush;                 
wire            entry2_randclk_data_mod_en_w16;    
wire            entry2_retire0_en;                 
wire            entry2_retire1_en;                 
wire            entry2_vld;                        
wire            entry3_acc_err;                    
wire            entry3_create0_en;                 
wire            entry3_create1_en;                 
wire    [16:0]  entry3_inst;                       
wire            entry3_part_flush;                 
wire            entry3_randclk_data_mod_en_w16;    
wire            entry3_retire0_en;                 
wire            entry3_retire1_en;                 
wire            entry3_vld;                        
wire            entry4_acc_err;                    
wire            entry4_create0_en;                 
wire            entry4_create1_en;                 
wire    [16:0]  entry4_inst;                       
wire            entry4_part_flush;                 
wire            entry4_randclk_data_mod_en_w16;    
wire            entry4_retire0_en;                 
wire            entry4_retire1_en;                 
wire            entry4_vld;                        
wire            entry5_acc_err;                    
wire            entry5_create0_en;                 
wire            entry5_create1_en;                 
wire    [16:0]  entry5_inst;                       
wire            entry5_part_flush;                 
wire            entry5_randclk_data_mod_en_w16;    
wire            entry5_retire0_en;                 
wire            entry5_retire1_en;                 
wire            entry5_vld;                        
wire    [5 :0]  flush_4_entry_ptr;                 
wire    [5 :0]  flush_5_entry_ptr;                 
wire            forever_cpuclk;                    
wire            had_create0_en;                    
wire            had_create1_en;                    
wire    [31:0]  had_ifu_ir;                        
wire            had_ifu_ir_vld;                    
wire            ibuf_acc_err;                      
wire            ibuf_create0_en;                   
wire            ibuf_create1_en;                   
wire            ibuf_empty;                        
wire            ibuf_fetch_empty;                  
wire            ibuf_fetch_full;                   
wire            ibuf_fetch_more_than_two;          
wire            ibuf_fetch_one;                    
wire            ibuf_five_avalbe;                  
wire            ibuf_flush;                        
wire            ibuf_four_avalbe;                  
wire            ibuf_full;                         
wire            ibuf_ibusif_inst_fetch;            
wire            ibuf_ifctrl_inst32_low;            
wire            ibuf_ifctrl_inst_vld;              
wire            ibuf_ifctrl_pop0_mad32_low;        
wire            ibuf_ifdp_inst_dbg_disable;        
wire            ibuf_inst16;                       
wire            ibuf_inst32;                       
wire            ibuf_inst_32_vld;                  
wire            ibuf_inst_fetch;                   
wire            ibuf_no_inst;                      
wire            ibuf_no_inst_during_pipe_down;     
wire            ibuf_one_avalbe;                   
wire    [5 :0]  ibuf_part_flush_ptr;               
wire            ibuf_pop0_mad32_low;               
wire            ibuf_pop0_sys32_low;               
wire            ibuf_pop_upd_clk;                  
wire            ibuf_pop_upd_en;                   
wire            ibuf_push_upd_clk;                 
wire            ibuf_push_upd_en;                  
wire            ibuf_retire0_en;                   
wire            ibuf_retire0_en_vld;               
wire            ibuf_retire1_en;                   
wire            ibuf_three_avalbe;                 
wire            ibuf_top_clk_en;                   
wire            ibuf_two_avalbe;                   
wire    [2 :0]  ibuf_vld_num;                      
wire            ibuf_xx_empty;                     
wire            ibus_create0_en;                   
wire            ibus_create1_en;                   
wire            ibusif_ibuf_no_trans;              
wire            ibusif_xx_16bit_inst;              
wire            ibusif_xx_acc_err;                 
wire    [31:0]  ibusif_xx_data;                    
wire            ibusif_xx_ibus_idle;               
wire            ibusif_xx_trans_cmplt;             
wire            ibusif_xx_unalign_fetch;           
wire            ifctrl_ibuf_bypass_vld;            
wire            ifctrl_ibuf_inst_pipe_down;        
wire            ifctrl_ibuf_pop_en;                
wire            ifctrl_xx_ifcancel;                
wire            ifu_had_fetch_expt_vld;            
wire            ifu_iu_ex_expt_cur;                
wire            ifu_iu_ex_expt_vld;                
wire    [31:0]  ifu_iu_ex_inst;                    
wire            ifu_misc_clk;                      
wire            iu_ifu_ex_stall_noinput;           
wire            iu_ifu_ex_vld;                     
wire            iu_ifu_inst_fetch;                 
wire            iu_ifu_lsu_inst;                   
wire            iu_ifu_wb_ldst;                    
wire            iu_ifu_wb_stall;                   
wire            iu_yy_xx_dbgon;                    
wire            pad_yy_gate_clk_en_b;              
wire            pop0_inst_32;                      
wire            pop0_shift_lsu_inst;               
wire            pop0_shift_mad_low;                
wire            pop0_shift_sys_low;                
wire    [5 :0]  pop1;                              
wire    [5 :0]  pop1_shift;                        
wire    [5 :0]  push1;                             
wire    [3 :0]  randclk_ibuf_entry_data_mod_en_w16; 
wire            randclk_ibuf_pop_mod_en_w3;        
wire            randclk_ibuf_push_mod_en_w3;       
wire            unalign_fetch_bypass_16bit;        



parameter IDLE     = 2'b00,
          POP1_EN  = 2'b01,
          POP2_EN  = 2'b10,
          FLUSH    = 2'b11;

//==============================================================================
//                            Gated Clock
//==============================================================================
// &Instance("gated_clk_cell", "x_ibuf_push_upd_clkhdr"); @37
gated_clk_cell  x_ibuf_push_upd_clkhdr (
  .clk_in                      (forever_cpuclk             ),
  .clk_out                     (ibuf_push_upd_clk          ),
  .external_en                 (1'b0                       ),
  .global_en                   (cp0_yy_clk_en              ),
  .local_en                    (ibuf_push_upd_en           ),
  .module_en                   (randclk_ibuf_push_mod_en_w3),
  .pad_yy_gate_clk_en_b        (pad_yy_gate_clk_en_b       )
);

// &Connect(.clk_in(forever_cpuclk), @38
//          .external_en(1'b0), @39
//          .global_en(cp0_yy_clk_en), @40
//          .module_en(randclk_ibuf_push_mod_en_w3), @41
//          .local_en(ibuf_push_upd_en), @42
//          .clk_out(ibuf_push_upd_clk) @43
//         ); @44
assign ibuf_push_upd_en = ibuf_flush || ibuf_create0_en || iu_ifu_inst_fetch;

// &Instance("gated_clk_cell", "x_ibuf_pop_upd_clkhdr"); @47
gated_clk_cell  x_ibuf_pop_upd_clkhdr (
  .clk_in                     (forever_cpuclk            ),
  .clk_out                    (ibuf_pop_upd_clk          ),
  .external_en                (1'b0                      ),
  .global_en                  (cp0_yy_clk_en             ),
  .local_en                   (ibuf_pop_upd_en           ),
  .module_en                  (randclk_ibuf_pop_mod_en_w3),
  .pad_yy_gate_clk_en_b       (pad_yy_gate_clk_en_b      )
);

// &Connect(.clk_in(forever_cpuclk), @48
//          .external_en(1'b0), @49
//          .global_en(cp0_yy_clk_en), @50
//          .module_en(randclk_ibuf_pop_mod_en_w3), @51
//          .local_en(ibuf_pop_upd_en), @52
//          .clk_out(ibuf_pop_upd_clk) @53
//         ); @54
assign ibuf_pop_upd_en = ibuf_retire0_en_vld && !ibuf_flush;

assign acc_err_upd_en = iu_yy_xx_dbgon
                     || ibusif_xx_trans_cmplt
                          && (ibusif_xx_acc_err ||
                              entry0_acc_err    ||
                              entry1_acc_err    ||
                              entry2_acc_err    || 
                              entry3_acc_err    || 
                              entry4_acc_err    || 
                              entry5_acc_err    
                             );

assign ibuf_top_clk_en = acc_err_upd_en;

parameter ENTRY_NUM = 6;

////////////////////////////////////////////////////////////////////////////////
//                              Data Path                                     //
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
// Instance the entries
//==============================================================================
// &Instance("cr_ifu_ibuf_entry", "x_ibuf_entry_0"); @94
cr_ifu_ibuf_entry  x_ibuf_entry_0 (
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .cpuclk                         (cpuclk                        ),
  .cpurst_b                       (cpurst_b                      ),
  .entry_acc_err                  (entry0_acc_err                ),
  .entry_create0_en               (entry0_create0_en             ),
  .entry_create1_en               (entry0_create1_en             ),
  .entry_inst                     (entry0_inst                   ),
  .entry_part_flush               (entry0_part_flush             ),
  .entry_randclk_data_mod_en_w16  (entry0_randclk_data_mod_en_w16),
  .entry_retire0_en               (entry0_retire0_en             ),
  .entry_retire1_en               (entry0_retire1_en             ),
  .entry_vld                      (entry0_vld                    ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .had_ifu_ir                     (had_ifu_ir                    ),
  .ibuf_flush                     (ibuf_flush                    ),
  .ibuf_no_inst_during_pipe_down  (ibuf_no_inst_during_pipe_down ),
  .ibusif_xx_acc_err              (ibusif_xx_acc_err             ),
  .ibusif_xx_data                 (ibusif_xx_data                ),
  .ifu_misc_clk                   (ifu_misc_clk                  ),
  .iu_yy_xx_dbgon                 (iu_yy_xx_dbgon                ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          )
);

// &Connect(.entry_create0_en             (entry0_create0_en), @95
//          .entry_create1_en             (entry0_create1_en), @96
//          .entry_randclk_data_mod_en_w16(entry0_randclk_data_mod_en_w16), @97
//          .entry_retire0_en             (entry0_retire0_en), @98
//          .entry_retire1_en             (entry0_retire1_en), @99
//          .entry_acc_err                (entry0_acc_err), @100
//          .entry_inst                   (entry0_inst), @101
//          .entry_part_flush             (entry0_part_flush), @102
//          .entry_vld                    (entry0_vld) @103
//         ); @104
// &Connect(.entry_inst_dbg_disable            (entry0_inst_dbg_disable)); @106

// &Instance("cr_ifu_ibuf_entry", "x_ibuf_entry_1"); @109
cr_ifu_ibuf_entry  x_ibuf_entry_1 (
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .cpuclk                         (cpuclk                        ),
  .cpurst_b                       (cpurst_b                      ),
  .entry_acc_err                  (entry1_acc_err                ),
  .entry_create0_en               (entry1_create0_en             ),
  .entry_create1_en               (entry1_create1_en             ),
  .entry_inst                     (entry1_inst                   ),
  .entry_part_flush               (entry1_part_flush             ),
  .entry_randclk_data_mod_en_w16  (entry1_randclk_data_mod_en_w16),
  .entry_retire0_en               (entry1_retire0_en             ),
  .entry_retire1_en               (entry1_retire1_en             ),
  .entry_vld                      (entry1_vld                    ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .had_ifu_ir                     (had_ifu_ir                    ),
  .ibuf_flush                     (ibuf_flush                    ),
  .ibuf_no_inst_during_pipe_down  (ibuf_no_inst_during_pipe_down ),
  .ibusif_xx_acc_err              (ibusif_xx_acc_err             ),
  .ibusif_xx_data                 (ibusif_xx_data                ),
  .ifu_misc_clk                   (ifu_misc_clk                  ),
  .iu_yy_xx_dbgon                 (iu_yy_xx_dbgon                ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          )
);

// &Connect(.entry_create0_en             (entry1_create0_en), @110
//          .entry_create1_en             (entry1_create1_en), @111
//          .entry_randclk_data_mod_en_w16(entry1_randclk_data_mod_en_w16), @112
//          .entry_retire0_en             (entry1_retire0_en), @113
//          .entry_retire1_en             (entry1_retire1_en), @114
//          .entry_acc_err                (entry1_acc_err), @115
//          .entry_inst                   (entry1_inst), @116
//          .entry_part_flush             (entry1_part_flush), @117
//          .entry_vld                    (entry1_vld) @118
//         ); @119
// &Connect(.entry_inst_dbg_disable            (entry1_inst_dbg_disable)); @121

// &Instance("cr_ifu_ibuf_entry", "x_ibuf_entry_2"); @124
cr_ifu_ibuf_entry  x_ibuf_entry_2 (
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .cpuclk                         (cpuclk                        ),
  .cpurst_b                       (cpurst_b                      ),
  .entry_acc_err                  (entry2_acc_err                ),
  .entry_create0_en               (entry2_create0_en             ),
  .entry_create1_en               (entry2_create1_en             ),
  .entry_inst                     (entry2_inst                   ),
  .entry_part_flush               (entry2_part_flush             ),
  .entry_randclk_data_mod_en_w16  (entry2_randclk_data_mod_en_w16),
  .entry_retire0_en               (entry2_retire0_en             ),
  .entry_retire1_en               (entry2_retire1_en             ),
  .entry_vld                      (entry2_vld                    ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .had_ifu_ir                     (had_ifu_ir                    ),
  .ibuf_flush                     (ibuf_flush                    ),
  .ibuf_no_inst_during_pipe_down  (ibuf_no_inst_during_pipe_down ),
  .ibusif_xx_acc_err              (ibusif_xx_acc_err             ),
  .ibusif_xx_data                 (ibusif_xx_data                ),
  .ifu_misc_clk                   (ifu_misc_clk                  ),
  .iu_yy_xx_dbgon                 (iu_yy_xx_dbgon                ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          )
);

// &Connect(.entry_create0_en             (entry2_create0_en), @125
//          .entry_create1_en             (entry2_create1_en), @126
//          .entry_randclk_data_mod_en_w16(entry2_randclk_data_mod_en_w16), @127
//          .entry_retire0_en             (entry2_retire0_en), @128
//          .entry_retire1_en             (entry2_retire1_en), @129
//          .entry_acc_err                (entry2_acc_err), @130
//          .entry_inst                   (entry2_inst), @131
//          .entry_part_flush             (entry2_part_flush), @132
//          .entry_vld                    (entry2_vld) @133
//         ); @134
// &Connect(.entry_inst_dbg_disable            (entry2_inst_dbg_disable)); @136

// &Instance("cr_ifu_ibuf_entry", "x_ibuf_entry_3"); @139
cr_ifu_ibuf_entry  x_ibuf_entry_3 (
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .cpuclk                         (cpuclk                        ),
  .cpurst_b                       (cpurst_b                      ),
  .entry_acc_err                  (entry3_acc_err                ),
  .entry_create0_en               (entry3_create0_en             ),
  .entry_create1_en               (entry3_create1_en             ),
  .entry_inst                     (entry3_inst                   ),
  .entry_part_flush               (entry3_part_flush             ),
  .entry_randclk_data_mod_en_w16  (entry3_randclk_data_mod_en_w16),
  .entry_retire0_en               (entry3_retire0_en             ),
  .entry_retire1_en               (entry3_retire1_en             ),
  .entry_vld                      (entry3_vld                    ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .had_ifu_ir                     (had_ifu_ir                    ),
  .ibuf_flush                     (ibuf_flush                    ),
  .ibuf_no_inst_during_pipe_down  (ibuf_no_inst_during_pipe_down ),
  .ibusif_xx_acc_err              (ibusif_xx_acc_err             ),
  .ibusif_xx_data                 (ibusif_xx_data                ),
  .ifu_misc_clk                   (ifu_misc_clk                  ),
  .iu_yy_xx_dbgon                 (iu_yy_xx_dbgon                ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          )
);

// &Connect(.entry_create0_en             (entry3_create0_en), @140
//          .entry_create1_en             (entry3_create1_en), @141
//          .entry_randclk_data_mod_en_w16(entry3_randclk_data_mod_en_w16), @142
//          .entry_retire0_en             (entry3_retire0_en), @143
//          .entry_retire1_en             (entry3_retire1_en), @144
//          .entry_acc_err                (entry3_acc_err), @145
//          .entry_inst                   (entry3_inst), @146
//          .entry_part_flush             (entry3_part_flush), @147
//          .entry_vld                    (entry3_vld) @148
//         ); @149
// &Connect(.entry_inst_dbg_disable            (entry3_inst_dbg_disable)); @151

// &Instance("cr_ifu_ibuf_entry", "x_ibuf_entry_4"); @154
cr_ifu_ibuf_entry  x_ibuf_entry_4 (
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .cpuclk                         (cpuclk                        ),
  .cpurst_b                       (cpurst_b                      ),
  .entry_acc_err                  (entry4_acc_err                ),
  .entry_create0_en               (entry4_create0_en             ),
  .entry_create1_en               (entry4_create1_en             ),
  .entry_inst                     (entry4_inst                   ),
  .entry_part_flush               (entry4_part_flush             ),
  .entry_randclk_data_mod_en_w16  (entry4_randclk_data_mod_en_w16),
  .entry_retire0_en               (entry4_retire0_en             ),
  .entry_retire1_en               (entry4_retire1_en             ),
  .entry_vld                      (entry4_vld                    ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .had_ifu_ir                     (had_ifu_ir                    ),
  .ibuf_flush                     (ibuf_flush                    ),
  .ibuf_no_inst_during_pipe_down  (ibuf_no_inst_during_pipe_down ),
  .ibusif_xx_acc_err              (ibusif_xx_acc_err             ),
  .ibusif_xx_data                 (ibusif_xx_data                ),
  .ifu_misc_clk                   (ifu_misc_clk                  ),
  .iu_yy_xx_dbgon                 (iu_yy_xx_dbgon                ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          )
);

// &Connect(.entry_create0_en             (entry4_create0_en), @155
//          .entry_create1_en             (entry4_create1_en), @156
//          .entry_randclk_data_mod_en_w16(entry4_randclk_data_mod_en_w16), @157
//          .entry_retire0_en             (entry4_retire0_en), @158
//          .entry_retire1_en             (entry4_retire1_en), @159
//          .entry_acc_err                (entry4_acc_err), @160
//          .entry_inst                   (entry4_inst), @161
//          .entry_part_flush             (entry4_part_flush), @162
//          .entry_vld                    (entry4_vld) @163
//         ); @164
// &Instance("cr_ifu_ibuf_entry", "x_ibuf_entry_5"); @165
cr_ifu_ibuf_entry  x_ibuf_entry_5 (
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .cpuclk                         (cpuclk                        ),
  .cpurst_b                       (cpurst_b                      ),
  .entry_acc_err                  (entry5_acc_err                ),
  .entry_create0_en               (entry5_create0_en             ),
  .entry_create1_en               (entry5_create1_en             ),
  .entry_inst                     (entry5_inst                   ),
  .entry_part_flush               (entry5_part_flush             ),
  .entry_randclk_data_mod_en_w16  (entry5_randclk_data_mod_en_w16),
  .entry_retire0_en               (entry5_retire0_en             ),
  .entry_retire1_en               (entry5_retire1_en             ),
  .entry_vld                      (entry5_vld                    ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .had_ifu_ir                     (had_ifu_ir                    ),
  .ibuf_flush                     (ibuf_flush                    ),
  .ibuf_no_inst_during_pipe_down  (ibuf_no_inst_during_pipe_down ),
  .ibusif_xx_acc_err              (ibusif_xx_acc_err             ),
  .ibusif_xx_data                 (ibusif_xx_data                ),
  .ifu_misc_clk                   (ifu_misc_clk                  ),
  .iu_yy_xx_dbgon                 (iu_yy_xx_dbgon                ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          )
);

// &Connect(.entry_create0_en             (entry5_create0_en), @166
//          .entry_create1_en             (entry5_create1_en), @167
//          .entry_randclk_data_mod_en_w16(entry5_randclk_data_mod_en_w16), @168
//          .entry_retire0_en             (entry5_retire0_en), @169
//          .entry_retire1_en             (entry5_retire1_en), @170
//          .entry_acc_err                (entry5_acc_err), @171
//          .entry_inst                   (entry5_inst), @172
//          .entry_part_flush             (entry5_part_flush), @173
//          .entry_vld                    (entry5_vld) @174
//         ); @175
//==============================================================================
//                  entry gate clock module enable signal
//==============================================================================
assign entry0_randclk_data_mod_en_w16 = randclk_ibuf_entry_data_mod_en_w16[0];
assign entry1_randclk_data_mod_en_w16 = randclk_ibuf_entry_data_mod_en_w16[1];
assign entry2_randclk_data_mod_en_w16 = randclk_ibuf_entry_data_mod_en_w16[2];
assign entry3_randclk_data_mod_en_w16 = randclk_ibuf_entry_data_mod_en_w16[3];
assign entry4_randclk_data_mod_en_w16 = randclk_ibuf_entry_data_mod_en_w16[3];
assign entry5_randclk_data_mod_en_w16 = randclk_ibuf_entry_data_mod_en_w16[3];

//==============================================================================
//                  Extract Information from Prefetch Buffer
//==============================================================================
//The infornation which is index by pop0 pointer
// &CombBeg; @190
always @( entry3_acc_err
       or entry1_vld
       or entry1_acc_err
       or entry2_inst[15:0]
       or entry5_inst[15:0]
       or entry4_acc_err
       or entry0_acc_err
       or entry5_acc_err
       or entry5_vld
       or entry4_inst[15:0]
       or entry0_vld
       or entry2_vld
       or entry1_inst[15:0]
       or entry3_vld
       or entry2_acc_err
       or entry4_vld
       or entry3_inst[15:0]
       or pop0[5:0]
       or entry0_inst[15:0])
begin
  case(pop0[ENTRY_NUM-1:0])
  6'b0001:
  begin
    pop0_vld          = entry0_vld;
    pop0_inst[15:0]   = entry0_inst[15:0];
    pop0_acc_err      = entry0_acc_err;
  end
  6'b0010:
  begin
    pop0_vld          = entry1_vld;
    pop0_inst[15:0]   = entry1_inst[15:0];
    pop0_acc_err      = entry1_acc_err;
  end
  6'b0100:
  begin
    pop0_vld          = entry2_vld;
    pop0_inst[15:0]   = entry2_inst[15:0];
    pop0_acc_err      = entry2_acc_err;
  end
  6'b1000:
  begin
    pop0_vld          = entry3_vld;
    pop0_inst[15:0]   = entry3_inst[15:0];
    pop0_acc_err      = entry3_acc_err;
  end
  6'b10000:
  begin
    pop0_vld          = entry4_vld;
    pop0_inst[15:0]   = entry4_inst[15:0];
    pop0_acc_err      = entry4_acc_err;
  end
  6'b100000:
  begin
    pop0_vld          = entry5_vld;
    pop0_inst[15:0]   = entry5_inst[15:0];
    pop0_acc_err      = entry5_acc_err;
  end
  default:
  begin
    pop0_vld          = 1'bx;
    pop0_inst[15:0]   = 16'bx;
    pop0_acc_err      = 1'bx;
  end
  endcase
// &CombEnd; @235
end

//The information which is index by pop1 pointer
// &CombBeg; @238
always @( entry3_acc_err
       or entry1_vld
       or entry1_acc_err
       or entry2_inst[15:0]
       or entry5_inst[15:0]
       or entry4_acc_err
       or entry0_acc_err
       or entry5_vld
       or entry5_acc_err
       or entry4_inst[15:0]
       or entry2_vld
       or entry0_vld
       or entry1_inst[15:0]
       or entry3_vld
       or entry4_vld
       or entry2_acc_err
       or entry3_inst[15:0]
       or pop1[5:0]
       or entry0_inst[15:0])
begin
  case(pop1[ENTRY_NUM-1:0])
  6'b0001:
  begin
    pop1_vld          = entry0_vld;
    pop1_inst[15:0]   = entry0_inst[15:0];
    pop1_acc_err      = entry0_acc_err;
  end
  6'b0010:
  begin
    pop1_vld          = entry1_vld;
    pop1_inst[15:0]   = entry1_inst[15:0];
    pop1_acc_err      = entry1_acc_err;
  end
  6'b0100:
  begin
    pop1_vld          = entry2_vld;
    pop1_inst[15:0]   = entry2_inst[15:0];
    pop1_acc_err      = entry2_acc_err;
  end
  6'b1000:
  begin
   pop1_vld          = entry3_vld;
   pop1_inst[15:0]   = entry3_inst[15:0];
   pop1_acc_err      = entry3_acc_err;
  end
  6'b10000:
  begin
   pop1_vld          = entry4_vld;
   pop1_inst[15:0]   = entry4_inst[15:0];
   pop1_acc_err      = entry4_acc_err;
  end
  6'b100000:
  begin
   pop1_vld          = entry5_vld;
   pop1_inst[15:0]   = entry5_inst[15:0];
   pop1_acc_err      = entry5_acc_err;
  end
  default:
  begin
    pop1_vld          = 1'bx;
    pop1_inst[15:0]   = 16'bx;
    pop1_acc_err      = 1'bx;
  end
  endcase
// &CombEnd; @283
end

// &CombBeg; @286
// &CombEnd; @309
// &CombBeg; @311
// &CombEnd; @334

////////////////////////////////////////////////////////////////////////////////
//                              Control Logic                                 //
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
//                  Create Information into Prefetch Buffer
//==============================================================================
//the instruction created into inst buf may come from IBUS or HAD
//the create0 signal
assign align_fetch_bypass_32bit   = ibuf_empty && !ibusif_xx_16bit_inst;
assign unalign_fetch_bypass_16bit = ibusif_xx_unalign_fetch;

//either create 16 bit or 32 bit into inst buf, the create0 is always asserted
//when bypass happens, except whole word is bypassed or 16bit inst is bypassed
//in unalign mode, the create0 is enabled
//assign ibus_create0_en = ibusif_xx_trans_cmplt &&
//                         (!ifctrl_ibuf_bypass_vld ||
//                          !(align_fetch_bypass_32bit ||
//                            unalign_fetch_bypass_16bit
//                           )
//                         );
assign ibus_create0_en = ibusif_xx_trans_cmplt && !(ifctrl_ibuf_bypass_vld && 
                                                   (align_fetch_bypass_32bit 
                                               || unalign_fetch_bypass_16bit));
assign had_create0_en = iu_yy_xx_dbgon && had_ifu_ir_vld;

assign ibuf_create0_en = ibus_create0_en || had_create0_en;

//the create1 signal
//only create 32 bit into inst buf, the create1 signal will be asserted
assign ibus_create1_en = ibusif_xx_trans_cmplt &&
                         !ifctrl_ibuf_bypass_vld &&
                         !ibusif_xx_unalign_fetch;
// &Force("bus", "had_ifu_ir", 31, 0); @369
assign had_create1_en = had_create0_en && had_ifu_ir[1:0] == 2'b11;

assign ibuf_create1_en = ibus_create1_en || had_create1_en;

//==========================================================
//         Generate Entry Create Signal for Each Entry 
//==========================================================
//push0
always @(posedge ibuf_push_upd_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    push0[ENTRY_NUM-1:0] <= {{(ENTRY_NUM-1){1'b0}}, 1'b1};
  else if(iu_ifu_inst_fetch && iu_ifu_wb_stall)
    push0[ENTRY_NUM-1:0] <= pop0_shift[ENTRY_NUM-1:0];
  else if(ibuf_flush)
    push0[ENTRY_NUM-1:0] <= pop0[ENTRY_NUM-1:0];
  else if(ibuf_create0_en)
    push0[ENTRY_NUM-1:0] <= push0_shift[ENTRY_NUM-1:0];
end

// &CombBeg; @390
always @( push0[5:0]
       or ibuf_create1_en)
begin
  if(ibuf_create1_en)
    push0_shift[ENTRY_NUM-1:0] = {push0[ENTRY_NUM-3:0],
                                  push0[ENTRY_NUM-1:ENTRY_NUM-2]};
  else
    push0_shift[ENTRY_NUM-1:0] = {push0[ENTRY_NUM-2:0],
                                  push0[ENTRY_NUM-1]};
// &CombEnd; @397
end

//create0
assign {entry5_create0_en,
        entry4_create0_en,
        entry3_create0_en,
        entry2_create0_en,
        entry1_create0_en,
        entry0_create0_en} = push0[ENTRY_NUM-1:0] &
                             {ENTRY_NUM{ibuf_create0_en}};

//push1
assign push1[ENTRY_NUM-1:0] = {push0[ENTRY_NUM-2:0],
                               push0[ENTRY_NUM-1]};

//create1
assign {entry5_create1_en,
        entry4_create1_en,
        entry3_create1_en,
        entry2_create1_en,
        entry1_create1_en,
        entry0_create1_en} = push1[ENTRY_NUM-1:0] &
                             {ENTRY_NUM{ibuf_create1_en}};


//==============================================================================
//                  Retire Information out of Instruction Buffer
//==============================================================================
//The instruction will be retired in inst buf when it can be piped down
//to EX stage, when the instrcution is SPLIT inst, it will be retire when the 
//last sub-inst can be piped down.
assign ibuf_retire0_en = pop0_vld && ifctrl_ibuf_pop_en;

assign ibuf_retire1_en = ibuf_inst32 && ifctrl_ibuf_pop_en;

//==========================================================
//         Generate Entry retire Signal for Each Entry 
//==========================================================
assign ibuf_retire0_en_vld = ibuf_retire0_en;
assign ibuf_inst_32_vld = ibuf_inst32;

//pop0
always @(posedge ibuf_pop_upd_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    pop0[ENTRY_NUM-1:0] <= {{(ENTRY_NUM-1){1'b0}}, 1'b1};
  else if(ibuf_flush)
    pop0[ENTRY_NUM-1:0] <= pop0[ENTRY_NUM-1:0];
  else if(ibuf_retire0_en_vld)
    pop0[ENTRY_NUM-1:0] <= pop0_shift[ENTRY_NUM-1:0];
end

// &CombBeg; @449
always @( pop0[5:0]
       or ibuf_inst_32_vld)
begin
  if(ibuf_inst_32_vld)
    pop0_shift[ENTRY_NUM-1:0] = {pop0[ENTRY_NUM-3:0],
                                 pop0[ENTRY_NUM-1:ENTRY_NUM-2]};
  else
    pop0_shift[ENTRY_NUM-1:0] = {pop0[ENTRY_NUM-2:0],
                                 pop0[ENTRY_NUM-1]};
// &CombEnd; @456
end

//retire0
assign {entry5_retire0_en,
        entry4_retire0_en,
        entry3_retire0_en,
        entry2_retire0_en,
        entry1_retire0_en,
        entry0_retire0_en} = pop0[ENTRY_NUM-1:0] & {ENTRY_NUM{ibuf_retire0_en}};

//pop1
assign pop1[ENTRY_NUM-1:0] = {pop0[ENTRY_NUM-2:0],
                              pop0[ENTRY_NUM-1]};

//retire1
assign {entry5_retire1_en,
        entry4_retire1_en,
        entry3_retire1_en,
        entry2_retire1_en,
        entry1_retire1_en,
        entry0_retire1_en} = pop1[ENTRY_NUM-1:0] &
                             {ENTRY_NUM{ibuf_retire1_en}};

//flush 4-5 entries when if change flow but iu stall
assign flush_4_entry_ptr[ENTRY_NUM-1:0] = ~(pop0[ENTRY_NUM-1:0] | pop1[ENTRY_NUM-1:0]);
assign flush_5_entry_ptr[ENTRY_NUM-1:0] = ~pop0[ENTRY_NUM-1:0];
assign ibuf_part_flush_ptr[ENTRY_NUM-1:0] = ibuf_inst32
                                             ? flush_4_entry_ptr[ENTRY_NUM-1:0]
                                             : flush_5_entry_ptr[ENTRY_NUM-1:0];
assign {entry5_part_flush,
        entry4_part_flush,
        entry3_part_flush,
        entry2_part_flush,
        entry1_part_flush,
        entry0_part_flush} = ibuf_part_flush_ptr[ENTRY_NUM-1:0] &
                             {ENTRY_NUM{iu_ifu_inst_fetch && iu_ifu_wb_stall}};

//==============================================================================
//              Some Control Signal
//==============================================================================
//The oldest instruction in ibuffer is a 32-bit inst
assign pop0_inst_32 = pop0_inst[1:0] == 2'b11;
assign ibuf_inst32 = pop0_vld && pop1_vld && pop0_inst_32;

//The oldest instruction in ibuffer is a 16-bit inst
assign ibuf_inst16 = pop0_vld && !pop0_inst_32;

//Thre inst buffer will be flushed when:
//1.flow change happens
//2.IU send the exception valid signal to IFU
assign ibuf_flush = ifctrl_xx_ifcancel;

//==========================================================
//              The inst buffer status signal
//==========================================================
assign ibuf_vld_num[2:0] = {2'b0, entry0_vld} + {2'b0, entry1_vld}
                         + {2'b0, entry2_vld} + {2'b0, entry3_vld}
                         + {2'b0, entry4_vld} + {2'b0, entry5_vld};

// only 1 entry avalable
assign ibuf_one_avalbe   = (ibuf_vld_num[2:0] == 3'b101); 
assign ibuf_full         = (ibuf_vld_num[2:0] == 3'b110); 
//assign ibuf_full = entry0_vld && entry1_vld && entry2_vld && entry3_vld; 
assign ibuf_no_inst_during_pipe_down = ifctrl_ibuf_inst_pipe_down && ibuf_no_inst && 1'b0;

// 2 entry avalable
assign ibuf_two_avalbe   = ibuf_vld_num[2:0] == 3'b100; 
assign ibuf_three_avalbe = ibuf_vld_num[2:0] == 3'b011;       
assign ibuf_four_avalbe  = ibuf_vld_num[2:0] == 3'b010;       
assign ibuf_five_avalbe  = ibuf_vld_num[2:0] == 3'b001;       

//ibuf full

//ibuf empty
//assign ibuf_empty = !(entry0_vld || entry1_vld || entry2_vld || entry3_vld);
assign ibuf_empty = ibuf_vld_num[2:0] == 3'b000;
//assign ibuf_empty = !pop0_vld;

assign ibuf_no_inst = !ibuf_inst32 && !ibuf_inst16;

assign ibuf_acc_err = (ibuf_inst32 && (pop0_acc_err || pop1_acc_err)) ||
                      (ibuf_inst16 && pop0_acc_err);

//==========================================================
//             The inst fetch request from ibuffer 
//==========================================================
//the inst fetch request is devided into 2 conditions:
//0.the buffer is empty
assign ibuf_fetch_empty = ibuf_empty;

// test 
// &CombBeg; @548
always @( entry1_vld
       or pop0_shift[5:0]
       or entry2_inst[15:0]
       or entry5_inst[15:0]
       or entry5_vld
       or entry4_inst[15:0]
       or entry0_vld
       or entry2_vld
       or entry1_inst[15:0]
       or entry3_vld
       or entry4_vld
       or entry3_inst[15:0]
       or entry0_inst[15:0])
begin
  case(pop0_shift[ENTRY_NUM-1:0])
  6'b0001:
  begin
    pop0_shift_vld          = entry0_vld;
    pop0_shift_inst[15:0]   = entry0_inst[15:0];
  end
  6'b0010:
  begin
    pop0_shift_vld          = entry1_vld;
    pop0_shift_inst[15:0]   = entry1_inst[15:0];
  end
  6'b0100:
  begin
    pop0_shift_vld          = entry2_vld;
    pop0_shift_inst[15:0]   = entry2_inst[15:0];
  end
  6'b1000:
  begin
    pop0_shift_vld          = entry3_vld;
    pop0_shift_inst[15:0]   = entry3_inst[15:0];
  end
  6'b10000:
  begin
    pop0_shift_vld          = entry4_vld;
    pop0_shift_inst[15:0]   = entry4_inst[15:0];
  end
  6'b100000:
  begin
    pop0_shift_vld          = entry5_vld;
    pop0_shift_inst[15:0]   = entry5_inst[15:0];
  end
  default:
  begin
    pop0_shift_vld          = 1'bx;
    pop0_shift_inst[15:0]   = 16'bx;
  end
  endcase
// &CombEnd; @586
end

assign pop1_shift[ENTRY_NUM-1:0] = {pop0_shift[ENTRY_NUM-2:0], pop0_shift[ENTRY_NUM-1]};
//The information which is index by pop1 pointer
// &CombBeg; @590
always @( entry1_vld
       or pop1_shift[5:0]
       or entry5_vld
       or entry0_vld
       or entry2_vld
       or entry3_vld
       or entry4_vld)
begin
  case(pop1_shift[ENTRY_NUM-1:0])
  6'b0001:
  begin
    pop1_shift_vld          = entry0_vld;
  end
  6'b0010:
  begin
    pop1_shift_vld          = entry1_vld;
  end
  6'b0100:
  begin
    pop1_shift_vld          = entry2_vld;
  end
  6'b1000:
  begin
   pop1_shift_vld          = entry3_vld;
  end
  6'b10000:
  begin
   pop1_shift_vld          = entry4_vld;
  end
  6'b100000:
  begin
   pop1_shift_vld          = entry5_vld;
  end
  default:
  begin
    pop1_shift_vld          = 1'bx;
  end
  endcase
// &CombEnd; @621
end

// &Force("input", "iu_ifu_lsu_inst"); @624
assign pop0_shift_mad_low = pop0_shift_vld && pop0_shift_inst[6:0] == 7'b0110011;
assign pop0_shift_sys_low = pop0_shift_vld && 
                           (pop0_shift_inst[6:0] == 7'b1110011
                         || pop0_shift_inst[6:0] == 7'b0001111  
                         || pop0_shift_inst[6:0] == 7'b0001011);
assign pop0_shift_lsu_inst = pop0_shift_vld && 
                            (pop0_shift_inst[6:0] == 7'b0100011
                          || pop0_shift_inst[6:0] == 7'b0000011
                          || {pop0_shift_inst[14:13],pop0_shift_inst[0]} == 3'b100);
assign ibuf_fetch_more_than_two = ibuf_two_avalbe && ibusif_ibuf_no_trans
                               || ibuf_two_avalbe && ibusif_xx_ibus_idle &&
                                 !iu_ifu_wb_ldst && !iu_ifu_ex_stall_noinput &&
                                 //!(iu_ifu_lsu_inst && ibuf_inst16)
                                 !(pop0_shift_lsu_inst && ibuf_inst16) &&
                                 !(pop0_shift_mad_low && ibuf_inst16) && //mad32
                                 !(pop0_shift_sys_low && ibuf_inst16) // mad32
                               || ibuf_three_avalbe && ibusif_ibuf_no_trans
                               || ibuf_three_avalbe && ibusif_xx_ibus_idle &&
                                 !ibuf_pop0_mad32_low &&
                                 !ibuf_pop0_sys32_low &&
                                 !(iu_ifu_lsu_inst && iu_ifu_ex_stall_noinput) &&
                                (!iu_ifu_wb_ldst && !iu_ifu_ex_stall_noinput
                                 );

//2.onlu 1 entry avalable
assign ibuf_fetch_one           = ibuf_one_avalbe && ibusif_ibuf_no_trans &&
                                (!iu_ifu_wb_ldst && !iu_ifu_ex_stall_noinput
                                   || !iu_ifu_ex_vld) 
                               || ibuf_one_avalbe && ibusif_xx_ibus_idle &&
                                  (ibuf_inst32 || pop0_shift_vld 
                                  && pop0_shift_inst[1:0] == 2'b11) &&
                                 !iu_ifu_lsu_inst &&
                                 !pop0_shift_sys_low && 
                                 !pop0_shift_lsu_inst &&
                                 !pop0_shift_mad_low && // mad32
                                (!iu_ifu_wb_ldst && !iu_ifu_ex_stall_noinput
                                 );

//3.ibuf is full
assign ibuf_fetch_full           = ibuf_full && ibusif_ibuf_no_trans &&
                                  (ibuf_inst32 || pop0_shift_vld 
                                  && pop0_shift_inst[1:0] == 2'b11) &&
                                 !iu_ifu_lsu_inst &&
                                 !pop0_shift_sys_low &&
                                 !pop0_shift_lsu_inst &&
                                 !pop0_shift_mad_low && // mad32
                                 !iu_ifu_wb_ldst && !iu_ifu_ex_stall_noinput;
// &Force("nonport", "pop0_shift_vld"); @673
// &Force("nonport", "pop0_shift_inst"); @674
// &Force("nonport", "ibuf_full"); @675
// &Force("input", "iu_ifu_ex_vld"); @676
// &Force("input", "iu_ifu_wb_ldst"); @677
assign ibuf_inst_fetch = ibuf_fetch_empty ||
                         ibuf_five_avalbe ||
                         ibuf_four_avalbe ||
                         ibuf_fetch_one ||
                         ibuf_fetch_full ||
                         ibuf_fetch_more_than_two;

//==========================================================
//                Predecode
//==========================================================
//when the pop0 inst is mls32 or mad32-high(when SLOW MULT)
//and pop1 not valid, bypass can not happen
assign ibuf_pop0_mad32_low = pop0_inst[6:2] == 5'b01100;
assign ibuf_pop0_sys32_low = pop0_inst[6:2] == 5'b11100;

////////////////////////////////////////////////////////////////////////////////
//                              Interface                                     //
////////////////////////////////////////////////////////////////////////////////
//==========================================================
//                Globle Signal
//==========================================================
//assign ibuf_xx_pop0_vld = pop0_shift_vld;
//assign ibuf_xx_pop1_vld = pop1_shift_vld;
assign ibuf_xx_empty = iu_ifu_ex_vld ? !pop0_shift_vld : ibuf_empty;
//assign ibuf_xx_pop0_vld = pop0_vld;
//assign ibuf_xx_pop1_vld = pop1_vld;

//==========================================================
//                  Interface to I-BUS Interface 
//==========================================================
assign ibuf_ibusif_inst_fetch = ibuf_inst_fetch;

//==========================================================
//                  Interface to If Stage Control Logic 
//==========================================================
assign ibuf_ifctrl_inst_vld   = pop0_shift_vld && pop1_shift_vld && pop0_shift_inst[1:0] == 2'b11
                             || pop0_shift_vld && pop0_shift_inst[1:0] != 2'b11;
assign ibuf_ifctrl_inst32_low = iu_ifu_ex_vld ? pop0_shift_vld && !pop1_shift_vld && pop0_shift_inst[1:0] == 2'b11 :
                                pop0_vld && !pop1_vld && !ibuf_inst16;
assign ibuf_ifctrl_pop0_mad32_low = ibuf_pop0_mad32_low;

//==========================================================
//               Interface to Ex Stage 
//==========================================================
assign ifu_iu_ex_inst[31:0] = {pop1_inst[15:0], pop0_inst[15:0]};
assign ifu_iu_ex_expt_vld = ibuf_acc_err;
assign ifu_iu_ex_expt_cur = pop0_acc_err;

assign ifu_had_fetch_expt_vld = ibuf_acc_err;
assign ibuf_ifdp_inst_dbg_disable = 1'b0;

// &ModuleEnd; @822
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_ifu_ibuf_entry(
  cp0_yy_clk_en,
  cpuclk,
  cpurst_b,
  entry_acc_err,
  entry_create0_en,
  entry_create1_en,
  entry_inst,
  entry_part_flush,
  entry_randclk_data_mod_en_w16,
  entry_retire0_en,
  entry_retire1_en,
  entry_vld,
  forever_cpuclk,
  had_ifu_ir,
  ibuf_flush,
  ibuf_no_inst_during_pipe_down,
  ibusif_xx_acc_err,
  ibusif_xx_data,
  ifu_misc_clk,
  iu_yy_xx_dbgon,
  pad_yy_gate_clk_en_b
);

// &Ports; @24
input           cp0_yy_clk_en;                
input           cpuclk;                       
input           cpurst_b;                     
input           entry_create0_en;             
input           entry_create1_en;             
input           entry_part_flush;             
input           entry_randclk_data_mod_en_w16; 
input           entry_retire0_en;             
input           entry_retire1_en;             
input           forever_cpuclk;               
input   [31:0]  had_ifu_ir;                   
input           ibuf_flush;                   
input           ibuf_no_inst_during_pipe_down; 
input           ibusif_xx_acc_err;            
input   [31:0]  ibusif_xx_data;               
input           ifu_misc_clk;                 
input           iu_yy_xx_dbgon;               
input           pad_yy_gate_clk_en_b;         
output          entry_acc_err;                
output  [16:0]  entry_inst;                   
output          entry_vld;                    

// &Regs; @25
reg             entry_acc_err;                
reg     [16:0]  entry_inst;                   
reg             entry_vld;                    

// &Wires; @26
wire            cp0_yy_clk_en;                
wire            cpuclk;                       
wire            cpurst_b;                     
wire            entry_create;                 
wire            entry_create0_en;             
wire            entry_create1_en;             
wire            entry_part_flush;             
wire            entry_randclk_data_mod_en_w16; 
wire            entry_retire;                 
wire            entry_retire0_en;             
wire            entry_retire1_en;             
wire            forever_cpuclk;               
wire    [31:0]  had_ifu_ir;                   
wire            ibuf_data_upd_clk;            
wire            ibuf_data_upd_en;             
wire            ibuf_flush;                   
wire            ibuf_no_inst_during_pipe_down; 
wire    [16:0]  ibus_inst_info_high;          
wire    [16:0]  ibus_inst_info_low;           
wire            ibusif_xx_acc_err;            
wire    [31:0]  ibusif_xx_data;               
wire            ifu_misc_clk;                 
wire            iu_yy_xx_dbgon;               
wire            pad_yy_gate_clk_en_b;         


//==============================================================================
//                            Gated Clock
//==============================================================================
// &Instance("gated_clk_cell", "x_ibuf_data_upd_clkhdr"); @31
gated_clk_cell  x_ibuf_data_upd_clkhdr (
  .clk_in                        (forever_cpuclk               ),
  .clk_out                       (ibuf_data_upd_clk            ),
  .external_en                   (1'b0                         ),
  .global_en                     (cp0_yy_clk_en                ),
  .local_en                      (ibuf_data_upd_en             ),
  .module_en                     (entry_randclk_data_mod_en_w16),
  .pad_yy_gate_clk_en_b          (pad_yy_gate_clk_en_b         )
);

// &Connect(.clk_in(forever_cpuclk), @32
//          .external_en(1'b0), @33
//          .global_en(cp0_yy_clk_en), @34
//          .module_en(entry_randclk_data_mod_en_w16), @35
//          .local_en(ibuf_data_upd_en), @36
//          .clk_out(ibuf_data_upd_clk) @37
//         ); @38
assign ibuf_data_upd_en = entry_create0_en || entry_create1_en;

//==============================================================================
//Prefetch Buffer Entry Fields Description:
//+-------------------+-----------------+--------------+
//|     entry_vld     |     acc_err     |     inst     |
//+-------------------+-----------------+--------------+
//==============================================================================

//==============================================================================
//                       Entry Create and Retire Signal
//==============================================================================
assign entry_create  = entry_create0_en || entry_create1_en;
assign entry_retire  = entry_retire0_en || entry_retire1_en;

//==============================================================================
//                       Entry Infomation Update
//==============================================================================
// &Force("output", "entry_vld"); @57
// &Force("output", "entry_inst"); @58
// &Force("output", "entry_acc_err"); @59
//==========================================================
//                  Entry Valid Signal
//==========================================================
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    entry_vld <= 1'b0;
  else if(entry_part_flush)
    entry_vld <= 1'b0;
  else if(ibuf_flush)
    entry_vld <= 1'b0;
  else if(entry_create)
    entry_vld <= 1'b1;
  else if(entry_retire)
    entry_vld <= 1'b0;
  else
    entry_vld <= entry_vld;
end

//==========================================================
//                  Entry Instruction Signal
//==========================================================
assign ibus_inst_info_high[16:0] = {1'b0, ibusif_xx_data[15:0]};
assign ibus_inst_info_low[16:0]  = {1'b0, ibusif_xx_data[31:16]};

// &Force("input", "ibuf_no_inst_during_pipe_down"); @86
always @(posedge ibuf_data_upd_clk)
begin
  if(iu_yy_xx_dbgon)
    begin
      if(entry_create0_en)
        entry_inst[16:0] <= {1'b0, had_ifu_ir[15:0]};
      else if(entry_create1_en)
        entry_inst[16:0] <= {1'b0, had_ifu_ir[31:16]};
      else
        entry_inst[16:0] <= entry_inst[16:0];
    end
  else
    begin
      if(entry_create0_en)
        begin
          if(ibuf_no_inst_during_pipe_down)
            entry_inst[16:0] <= ibus_inst_info_low[16:0];
          else
            entry_inst[16:0] <= ibus_inst_info_high[16:0];
        end
      else if(entry_create1_en)
        entry_inst[16:0] <= ibus_inst_info_low[16:0];
      else
        entry_inst[16:0] <= entry_inst[16:0];
    end
end

//==========================================================
//                  Other Instruction Related Signal
//==========================================================
//When in debug mode, the access error point exception will not happen.
//When not in debug mode, the access error come from I-BUS.
always @(posedge ifu_misc_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    entry_acc_err <= 1'b0;
  else if(entry_create)
    entry_acc_err <= ibusif_xx_acc_err;
  else
    entry_acc_err <= entry_acc_err;
end

// &Force("output", "entry_inst_dbg_disable"); @141

// &ModuleEnd; @153
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_ifu_ibusif(
  bmu_xx_ibus_acc_err,
  bmu_xx_ibus_data,
  bmu_xx_ibus_grnt,
  bmu_xx_ibus_trans_cmplt,
  cp0_ifu_in_lpmd,
  cp0_ifu_lpmd_req,
  cp0_ifu_rst_inv_done,
  cp0_ifu_srst_mask,
  cp0_ifu_srst_req,
  cp0_yy_clk_en,
  cp0_yy_machine_mode_aft_dbg,
  cpurst_b,
  forever_cpuclk,
  ibuf_ibusif_inst_fetch,
  ibusif_ibuf_no_trans,
  ibusif_ifctrl_inst_mad32_high,
  ibusif_ifctrl_inst_no_bypass,
  ibusif_top_clk_en,
  ibusif_xx_16bit_inst,
  ibusif_xx_acc_err,
  ibusif_xx_data,
  ibusif_xx_ibus_idle,
  ibusif_xx_trans_cmplt,
  ibusif_xx_unalign_fetch,
  ifu_bmu_addr,
  ifu_bmu_idle,
  ifu_bmu_prot,
  ifu_bmu_req,
  ifu_bmu_wfd1,
  ifu_cp0_lpmd_ack,
  ifu_cp0_rst_inv_req,
  ifu_cp0_srst_ack,
  ifu_iu_ibus_idle,
  ifu_iu_lockup_ack,
  ifu_iu_vector_ibus_in_idle,
  ifu_iu_xx_ibus_data,
  ifu_misc_clk,
  iu_ifu_addr,
  iu_ifu_data_fetch,
  iu_ifu_data_fetch_for_data,
  iu_ifu_inst_fetch,
  iu_ifu_inst_fetch_for_data,
  iu_ifu_inst_fetch_mask,
  iu_ifu_lockup_mask,
  iu_ifu_lockup_on,
  iu_ifu_lockup_req,
  iu_ifu_reset_vld,
  iu_ifu_security_violation,
  iu_yy_xx_dbgon,
  pad_yy_gate_clk_en_b,
  pmp_ifu_acc_scu,
  sysio_ifu_rst_addr,
  sysmap_ifu_acc_ca
);

// &Ports; @24
input           bmu_xx_ibus_acc_err;          
input   [31:0]  bmu_xx_ibus_data;             
input           bmu_xx_ibus_grnt;             
input           bmu_xx_ibus_trans_cmplt;      
input           cp0_ifu_in_lpmd;              
input           cp0_ifu_lpmd_req;             
input           cp0_ifu_rst_inv_done;         
input           cp0_ifu_srst_mask;            
input           cp0_ifu_srst_req;             
input           cp0_yy_clk_en;                
input           cp0_yy_machine_mode_aft_dbg;  
input           cpurst_b;                     
input           forever_cpuclk;               
input           ibuf_ibusif_inst_fetch;       
input           ifu_misc_clk;                 
input   [30:0]  iu_ifu_addr;                  
input           iu_ifu_data_fetch;            
input           iu_ifu_data_fetch_for_data;   
input           iu_ifu_inst_fetch;            
input           iu_ifu_inst_fetch_for_data;   
input           iu_ifu_inst_fetch_mask;       
input           iu_ifu_lockup_mask;           
input           iu_ifu_lockup_on;             
input           iu_ifu_lockup_req;            
input           iu_ifu_reset_vld;             
input           iu_ifu_security_violation;    
input           iu_yy_xx_dbgon;               
input           pad_yy_gate_clk_en_b;         
input           pmp_ifu_acc_scu;              
input   [31:0]  sysio_ifu_rst_addr;           
input           sysmap_ifu_acc_ca;            
output          ibusif_ibuf_no_trans;         
output          ibusif_ifctrl_inst_mad32_high; 
output          ibusif_ifctrl_inst_no_bypass; 
output          ibusif_top_clk_en;            
output          ibusif_xx_16bit_inst;         
output          ibusif_xx_acc_err;            
output  [31:0]  ibusif_xx_data;               
output          ibusif_xx_ibus_idle;          
output          ibusif_xx_trans_cmplt;        
output          ibusif_xx_unalign_fetch;      
output  [31:0]  ifu_bmu_addr;                 
output          ifu_bmu_idle;                 
output  [3 :0]  ifu_bmu_prot;                 
output          ifu_bmu_req;                  
output          ifu_bmu_wfd1;                 
output          ifu_cp0_lpmd_ack;             
output          ifu_cp0_rst_inv_req;          
output          ifu_cp0_srst_ack;             
output          ifu_iu_ibus_idle;             
output          ifu_iu_lockup_ack;            
output          ifu_iu_vector_ibus_in_idle;   
output  [31:0]  ifu_iu_xx_ibus_data;          

// &Regs; @25
reg             abort_cur_st;                 
reg             abort_nxt_st;                 
reg     [29:0]  addr_cnt;                     
reg     [2 :0]  cur_st;                       
reg     [3 :0]  ibus_prot_reg;                
reg     [2 :0]  nxt_st;                       
reg             unalign_fetch_reg;            

// &Wires; @26
wire            addr_cnt_high_icg_en;         
wire            addr_cnt_high_upd_clk;        
wire            addr_cnt_high_upd_en;         
wire            addr_cnt_high_upd_en_local;   
wire            addr_cnt_low_icg_en;          
wire            addr_cnt_low_upd_clk;         
wire            addr_cnt_low_upd_en;          
wire            addr_cnt_upd_en;              
wire            bmu_xx_ibus_acc_err;          
wire    [31:0]  bmu_xx_ibus_data;             
wire    [31:0]  bmu_xx_ibus_data_aft_pol;     
wire            bmu_xx_ibus_grnt;             
wire            bmu_xx_ibus_trans_cmplt;      
wire            change_flow_vld;              
wire            cp0_ifu_in_lpmd;              
wire            cp0_ifu_lpmd_req;             
wire            cp0_ifu_rst_inv_done;         
wire            cp0_ifu_srst_mask;            
wire            cp0_ifu_srst_req;             
wire            cp0_yy_clk_en;                
wire            cp0_yy_machine_mode_aft_dbg;  
wire            cpurst_b;                     
wire            flop_out_bus;                 
wire            forever_cpuclk;               
wire            ibuf_ibusif_inst_fetch;       
wire            ibus_abort_trig;              
wire            ibus_acc_err;                 
wire    [30:0]  ibus_addr;                    
wire            ibus_busy;                    
wire    [31:0]  ibus_data;                    
wire            ibus_inst_fetch_cmplt;        
wire            ibus_inst_mad;                
wire            ibus_inst_mad32_high;         
wire            ibus_inst_no_bypass;          
wire            ibus_inst_req;                
wire            ibus_no_outstanding;          
wire    [30:0]  ibus_nonseq_addr;             
wire    [3 :0]  ibus_prot;                    
wire            ibus_prot_buf;                
wire            ibus_prot_buf_sel;            
wire            ibus_req;                     
wire    [30:0]  ibus_seq_addr;                
wire            ibus_trans_abort;             
wire            ibusif_ibuf_no_trans;         
wire            ibusif_ifctrl_inst_mad32_high; 
wire            ibusif_ifctrl_inst_no_bypass; 
wire            ibusif_top_clk_en;            
wire            ibusif_xx_16bit_inst;         
wire            ibusif_xx_acc_err;            
wire    [31:0]  ibusif_xx_data;               
wire            ibusif_xx_ibus_idle;          
wire            ibusif_xx_trans_cmplt;        
wire            ibusif_xx_unalign_fetch;      
wire    [31:0]  ifu_bmu_addr;                 
wire            ifu_bmu_idle;                 
wire    [3 :0]  ifu_bmu_prot;                 
wire            ifu_bmu_req;                  
wire            ifu_bmu_wfd1;                 
wire            ifu_cp0_lpmd_ack;             
wire            ifu_cp0_rst_inv_req;          
wire            ifu_cp0_srst_ack;             
wire            ifu_iu_ibus_idle;             
wire            ifu_iu_lockup_ack;            
wire            ifu_iu_vector_ibus_in_idle;   
wire    [31:0]  ifu_iu_xx_ibus_data;          
wire            ifu_misc_clk;                 
wire    [29:0]  inc_addr;                     
wire            inst_chgflw_for_data;         
wire            internal_inst_fetch;          
wire            internal_inst_fetch_pre;      
wire    [30:0]  iu_ifu_addr;                  
wire            iu_ifu_data_fetch;            
wire            iu_ifu_data_fetch_for_data;   
wire            iu_ifu_inst_fetch;            
wire            iu_ifu_inst_fetch_for_data;   
wire            iu_ifu_inst_fetch_mask;       
wire            iu_ifu_lockup_mask;           
wire            iu_ifu_lockup_on;             
wire            iu_ifu_lockup_req;            
wire            iu_ifu_reset_vld;             
wire            iu_ifu_security_violation;    
wire            iu_yy_xx_dbgon;               
wire            lpmd_mask;                    
wire            pad_yy_gate_clk_en_b;         
wire            pmp_ifu_acc_scu;              
wire            sm_upd_clk;                   
wire            sm_upd_en;                    
wire    [31:0]  sysio_ifu_rst_addr;           
wire            sysmap_ifu_acc_ca;            



//==========================================================
//               Parameter Definition
//==========================================================
parameter IDLE     = 3'b001,
          WFG1     = 3'b010,
          WFD1     = 3'b011,
          WFD1WFG2 = 3'b000,
          WFD1WFD2 = 3'b110,
          RESET    = 3'b100;

parameter ABORT_IDLE = 1'b0,
          ABORT_VLD  = 1'b1;

//==============================================================================
//                            Gated Clock
//==============================================================================
//Depending on principle of locality ,the program will execute in certain pc range,
//so the changing frequency of high bit of addr_cnt[29:0] will be rather small. As
//a result ,we separate addr_cnt[29:0] into two part to reduce power
assign addr_cnt_low_icg_en = addr_cnt_low_upd_en || iu_ifu_reset_vld;
// &Instance("gated_clk_cell", "x_ibus_addr_cnt_low_clkhdr"); @49
gated_clk_cell  x_ibus_addr_cnt_low_clkhdr (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (addr_cnt_low_upd_clk),
  .external_en          (1'b0                ),
  .global_en            (cp0_yy_clk_en       ),
  .local_en             (addr_cnt_low_icg_en ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in(forever_cpuclk), @50
//          .external_en(1'b0), @51
//          .global_en(cp0_yy_clk_en), @52
//          .module_en(1'b0), @53
//          .local_en(addr_cnt_low_icg_en), @54
//          .clk_out(addr_cnt_low_upd_clk) @55
//         ); @56
assign addr_cnt_high_icg_en = addr_cnt_high_upd_en || iu_ifu_reset_vld;
// &Instance("gated_clk_cell", "x_ibus_addr_cnt_high_clkhdr"); @60
gated_clk_cell  x_ibus_addr_cnt_high_clkhdr (
  .clk_in                (forever_cpuclk       ),
  .clk_out               (addr_cnt_high_upd_clk),
  .external_en           (1'b0                 ),
  .global_en             (cp0_yy_clk_en        ),
  .local_en              (addr_cnt_high_icg_en ),
  .module_en             (1'b0                 ),
  .pad_yy_gate_clk_en_b  (pad_yy_gate_clk_en_b )
);

// &Connect(.clk_in(forever_cpuclk), @61
//          .external_en(1'b0), @62
//          .global_en(cp0_yy_clk_en), @63
//          .module_en(1'b0), @64
//          .local_en(addr_cnt_high_icg_en), @65
//          .clk_out(addr_cnt_high_upd_clk) @66
//         ); @67

// &Instance("gated_clk_cell", "x_sm_upd_clkhdr"); @70
gated_clk_cell  x_sm_upd_clkhdr (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (sm_upd_clk          ),
  .external_en          (1'b0                ),
  .global_en            (cp0_yy_clk_en       ),
  .local_en             (sm_upd_en           ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in(forever_cpuclk), @71
//          .external_en(1'b0), @72
//          .global_en(cp0_yy_clk_en), @73
//          .module_en(1'b0), @74
//          .local_en(sm_upd_en), @75
//          .clk_out(sm_upd_clk) @76
//         ); @77
assign sm_upd_en = ibus_req || iu_ifu_inst_fetch_for_data ||
                   bmu_xx_ibus_trans_cmplt || 
                   (cur_st != IDLE);

////////////////////////////////////////////////////////////////////////////////
//                              Data Path                                     //
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
//               Address MUX of Instruction Fetch
//==============================================================================
//The PC load has two sources
//1.the sequential source from IFU itself
//2.the non-sequential source from IU, whihc may be the change flow address
//  or the mid-address of JSRI, LRW and VEC SM
assign ibus_seq_addr[30:0] = {addr_cnt[29:0], 1'b0};

assign ibus_nonseq_addr[30:0] = iu_ifu_addr[30:0];

assign ibus_addr[30:0] = (iu_ifu_inst_fetch_for_data
                          || iu_ifu_data_fetch_for_data)
                                      ? ibus_nonseq_addr[30:0]
                                      : ibus_seq_addr[30:0];

//==============================================================================
//               The Address Counter
//==============================================================================
//the addr_cnt needs to hold the address to ibus, when grnt signal is asserted,
//the counter can be updated, so the next cycle a back to back request can be
//sent
// //&Force("output", "addr_cnt_high_upd_en"); @107
assign change_flow_vld = iu_ifu_inst_fetch;
assign addr_cnt_upd_en = change_flow_vld || (!iu_ifu_data_fetch_for_data && bmu_xx_ibus_grnt);
assign addr_cnt_high_upd_en = change_flow_vld ||
                              bmu_xx_ibus_grnt && (addr_cnt[10] ^ inc_addr[10]);

assign addr_cnt_low_upd_en  = addr_cnt_upd_en;

// &Force("bus", "sysio_ifu_rst_addr", 31, 0); @115
always @(posedge addr_cnt_low_upd_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    addr_cnt[9:0] <= 10'b0;
  else if(iu_ifu_reset_vld)
    addr_cnt[9:0] <= sysio_ifu_rst_addr[11:2];
  else if(addr_cnt_low_upd_en)
    addr_cnt[9:0] <= inc_addr[9:0];
end

assign addr_cnt_high_upd_en_local = 1'b0;
always @(posedge addr_cnt_high_upd_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    addr_cnt[29:10] <= 20'b0;
  else if(iu_ifu_reset_vld)
    addr_cnt[29:10] <= sysio_ifu_rst_addr[31:12];
  else if(addr_cnt_high_upd_en)
    addr_cnt[29:10] <= inc_addr[29:10];
end

assign inc_addr[29:0] = ibus_addr[30:1] + {29'b0, bmu_xx_ibus_grnt};

//==============================================================================
//               The Relust from I-BUS
//==============================================================================
//the data from ibus come with the buspol info
assign bmu_xx_ibus_data_aft_pol[31:0] = bmu_xx_ibus_data[31:0];

assign ibus_data[31:0] = {bmu_xx_ibus_data_aft_pol[31:16], unalign_fetch_reg ?
                          bmu_xx_ibus_data_aft_pol[31:16] :
                          bmu_xx_ibus_data_aft_pol[15:0]}; 

////////////////////////////////////////////////////////////////////////////////
//                              Control Logic                                 //
////////////////////////////////////////////////////////////////////////////////

//==============================================================================
//               I-BUS Fetch Mode: Align or Unalign (for inst fetch only)
//==============================================================================
//When the requset address is not word aligned, only half of
//the word fed back will be creat into instruction buffer.
always @(posedge sm_upd_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    unalign_fetch_reg <= 1'b0;
  else if(change_flow_vld)
    unalign_fetch_reg <= ibus_addr[0];
  else if(ibus_inst_fetch_cmplt)
    unalign_fetch_reg <= 1'b0;
end    

assign ibus_prot[3:0] = {sysmap_ifu_acc_ca,
                         pmp_ifu_acc_scu,
                         cp0_yy_machine_mode_aft_dbg,
                         1'b0};

// for bus protocol, the request should remain the same when wait for grant
always @(posedge sm_upd_clk)
begin
  if(ibus_prot_buf)
    ibus_prot_reg[3:0] <= ibus_prot[3:0];
end

//==============================================================================
//               The Internal Instruction Request
//==============================================================================
//the insternal inst fetch req has two sources:
//1.the sequentail req from inst_buf
//2.the change flow req from IU
//when the lpmd req is asserted from cp0, the internal req will not be asserted
//the req can not be sent when in dbg mode
assign inst_chgflw_for_data = iu_ifu_inst_fetch_for_data;
assign internal_inst_fetch_pre = ibuf_ibusif_inst_fetch 
                                    && !inst_chgflw_for_data
                                    && !addr_cnt_high_upd_en_local
                              || iu_ifu_inst_fetch;

assign internal_inst_fetch = internal_inst_fetch_pre &&
                             !lpmd_mask &&
                             !iu_yy_xx_dbgon &&
                             !iu_ifu_lockup_on &&
                             !iu_ifu_inst_fetch_mask &&
                             !iu_ifu_security_violation;

assign lpmd_mask = cp0_ifu_in_lpmd || cp0_ifu_lpmd_req || cp0_ifu_srst_req || cp0_ifu_srst_mask || iu_ifu_lockup_req;

//==============================================================================
//               The IBUS State Machine
//==============================================================================
//==========================================================
//               Main State Machine 
//==========================================================
assign flop_out_bus = 1'b0;

always @(posedge sm_upd_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    cur_st[2:0] <= RESET;
  else
    cur_st[2:0]  <= nxt_st[2:0];
end


// &CombBeg; @252
always @( internal_inst_fetch
       or bmu_xx_ibus_trans_cmplt
       or bmu_xx_ibus_grnt
       or flop_out_bus
       or cp0_ifu_rst_inv_done
       or cur_st)
begin
case(cur_st)
RESET:
begin
  if(cp0_ifu_rst_inv_done)
    nxt_st = IDLE;
  else
    nxt_st = RESET;
end
IDLE:
begin
  if(internal_inst_fetch)
    begin
      if(bmu_xx_ibus_grnt)
        nxt_st = WFD1;
      else
        nxt_st = WFG1;
    end
  else
    nxt_st = IDLE;
end
WFG1:
begin
  if(bmu_xx_ibus_grnt)
    nxt_st = WFD1;
  else
    nxt_st = WFG1;
end
WFD1:
begin
  if(bmu_xx_ibus_trans_cmplt)
    begin
      if(internal_inst_fetch)
        begin
          if(bmu_xx_ibus_grnt)
            nxt_st = WFD1;
          else
            nxt_st = WFG1;
        end
      else
        nxt_st = IDLE;
    end
  else if(internal_inst_fetch && flop_out_bus)
    begin //flop out bus can grant 2 outstanding inst fetch
      if(bmu_xx_ibus_grnt)
        nxt_st = WFD1WFD2;
      else
        nxt_st = WFD1WFG2;
    end
  else if(internal_inst_fetch)
    nxt_st = WFD1WFG2;
  else
    nxt_st = WFD1;
end
WFD1WFG2:
begin
  if(bmu_xx_ibus_trans_cmplt)
    begin
      if(bmu_xx_ibus_grnt)
        nxt_st = WFD1;
      else
        nxt_st = WFG1;
    end
  else
    begin
      if(bmu_xx_ibus_grnt && flop_out_bus)
        nxt_st = WFD1WFD2;
      else
        nxt_st = WFD1WFG2;
    end
end
WFD1WFD2:
begin
  if(bmu_xx_ibus_trans_cmplt)
    nxt_st = WFD1;
  else
    nxt_st = WFD1WFD2;
end
default:
begin
  nxt_st = IDLE;
end
endcase
// &CombEnd; @335
end

assign ibus_busy = !cur_st[0];

assign ibus_inst_fetch_cmplt = ((cur_st == WFD1) 
                             || (cur_st == WFD1WFG2)
                             || (cur_st == WFD1WFD2)
                               )  && bmu_xx_ibus_trans_cmplt
                                  && !ibus_trans_abort;
assign ibus_acc_err = ((cur_st == WFD1)
                    || (cur_st == WFD1WFG2)
                    || (cur_st == WFD1WFD2)
                      )  &&  bmu_xx_ibus_acc_err;
assign ibus_inst_req = (cur_st == IDLE)
                         && internal_inst_fetch
                    || (cur_st == WFG1)
                    || (cur_st == WFD1)
                         && internal_inst_fetch
                    || (cur_st == WFD1WFG2);
                    
assign ibus_abort_trig = (cur_st == WFD1)
                           && !bmu_xx_ibus_trans_cmplt
//                           && internal_inst_fetch
                           && change_flow_vld; 

assign ibus_no_outstanding = (cur_st == IDLE)
                          || (cur_st == WFG1)
                          || (cur_st == WFD1)
                               && bmu_xx_ibus_trans_cmplt
                          || (cur_st == WFD1WFG2)
                               && bmu_xx_ibus_trans_cmplt;

assign ibus_prot_buf = ((cur_st == IDLE) || (cur_st == WFD1))
                    && ((nxt_st == WFG1) || (nxt_st == WFD1WFG2));

assign ibus_prot_buf_sel = (cur_st == WFG1) || (cur_st == WFD1WFG2);

assign ibus_req = ibus_inst_req || iu_ifu_data_fetch;


//the abort SM
always @(posedge ifu_misc_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    abort_cur_st <= ABORT_IDLE;
  else
    abort_cur_st <= abort_nxt_st;
end

// &CombBeg; @384
always @( abort_cur_st
       or bmu_xx_ibus_trans_cmplt
       or ibus_abort_trig)
begin
case(abort_cur_st)
ABORT_IDLE:
begin
  abort_nxt_st = ABORT_IDLE;
  if(ibus_abort_trig)
    abort_nxt_st = ABORT_VLD;
end
ABORT_VLD:
begin
  abort_nxt_st = ABORT_VLD;
  if(bmu_xx_ibus_trans_cmplt)
    abort_nxt_st = ABORT_IDLE;
end
default:
begin
  abort_nxt_st = ABORT_IDLE;
end
endcase
// &CombEnd; @403
end

assign ibus_trans_abort = (abort_cur_st == ABORT_VLD);

assign ibusif_top_clk_en = ibus_abort_trig || ibus_trans_abort;

//==============================================================================
//               Pre-decode of inst from IBUS
//==============================================================================
// when the data from ibus is MULT(when no multiplier) or DIV or branch/jump, 
// the inst can not be bypassed
assign ibus_inst_no_bypass = ibus_inst_mad;
//mad cannot be bypassed in IF stage
//assign ibus_inst_mad = ibus_data[6:0] == 7'b0110011 && ibus_data[25];
//assign ibus_inst_mad32_high = ibus_data[9];
assign ibus_inst_mad = 1'b0;
assign ibus_inst_mad32_high = 1'b0;
//when ibuf only has high half of 32bit inst, but the inst is mad, bypass not
//happen

////////////////////////////////////////////////////////////////////////////////
//                              Interface                                     //
////////////////////////////////////////////////////////////////////////////////
//==========================================================
//               Interface to BMU 
//==========================================================
assign ifu_bmu_req = ibus_req;
assign ifu_bmu_idle = ibus_no_outstanding;
//when data fetch for expt, the ibus SM is in IDLE, acc deny need to cmplt
assign ifu_bmu_wfd1 = (cur_st == WFD1) || (cur_st == IDLE);
assign ifu_bmu_addr[31:0] = {ibus_addr[30:1], 2'b0};
assign ifu_bmu_prot[3:0] = ibus_prot_buf_sel ? ibus_prot_reg[3:0]
                                             : ibus_prot[3:0];

//==========================================================
//               Interface to IF ctrl 
//==========================================================
assign ibusif_ifctrl_inst_no_bypass = ibus_inst_no_bypass;
assign ibusif_ifctrl_inst_mad32_high = ibus_inst_mad32_high;
//assign ibufif_ifctrl_unalign_16bit_inst = !(ibus_data[31:30] == 2'b11);

//==========================================================
//               Interface to inst buffer
//==========================================================
assign ibusif_ibuf_no_trans = (cur_st == IDLE);

//==========================================================
//               Interface to Multi Modules
//==========================================================
assign ibusif_xx_ibus_idle = !ibus_busy;
assign ibusif_xx_data[31:0] = ibus_data[31:0];
assign ibusif_xx_acc_err = ibus_acc_err && !iu_yy_xx_dbgon;
assign ibusif_xx_unalign_fetch = unalign_fetch_reg;
//the cmplt signal is not useful when in dbg mode
assign ibusif_xx_trans_cmplt = ibus_inst_fetch_cmplt
                           && !iu_ifu_inst_fetch_mask //when expt no inst to ifu is valid
                           && !iu_ifu_lockup_mask //when expt no inst to ifu is valid
                           && !iu_yy_xx_dbgon;
assign ibusif_xx_16bit_inst = !(ibus_data[1:0] == 2'b11);

//==========================================================
//               Interface to IU
//==========================================================
//assign ifu_iu_ibus_idle = cur_st == IDLE;
assign ifu_iu_ibus_idle = !ibus_busy;
assign ifu_iu_vector_ibus_in_idle = (cur_st == IDLE);
assign ifu_iu_xx_ibus_data[31:0]  = bmu_xx_ibus_data_aft_pol[31:0];
//assign ifu_iu_xx_ibus_acc_err  = ibus_acc_err;
//==========================================================
//               Interface to CP0
//==========================================================
assign ifu_cp0_lpmd_ack = cp0_ifu_lpmd_req && (cur_st == IDLE);
assign ifu_cp0_srst_ack = cp0_ifu_srst_req && (cur_st == IDLE);
assign ifu_iu_lockup_ack = iu_ifu_lockup_req && (cur_st == IDLE);
assign ifu_cp0_rst_inv_req = cur_st == RESET;

// &ModuleEnd; @494
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_ifu_ifctrl(
  cpuclk,
  cpurst_b,
  had_ifu_ir_vld,
  ibuf_ifctrl_inst32_low,
  ibuf_ifctrl_inst_vld,
  ibuf_ifctrl_pop0_mad32_low,
  ibuf_ifdp_inst_dbg_disable,
  ibuf_xx_empty,
  ibusif_ifctrl_inst_mad32_high,
  ibusif_ifctrl_inst_no_bypass,
  ibusif_xx_16bit_inst,
  ibusif_xx_trans_cmplt,
  ibusif_xx_unalign_fetch,
  ifctrl_ibuf_bypass_vld,
  ifctrl_ibuf_inst_pipe_down,
  ifctrl_ibuf_pop_en,
  ifctrl_xx_ifcancel,
  ifu_iu_ex_inst_vld,
  ifu_iu_inst_buf_inst_dbg_disable,
  ifu_iu_inst_buf_inst_vld,
  iu_ifu_ex_stall,
  iu_ifu_inst_fetch,
  iu_ifu_inst_fetch_without_dbg_disable,
  iu_ifu_wb_stall,
  iu_yy_xx_dbgon,
  iu_yy_xx_flush,
  split_ifctrl_hs_stall,
  split_ifctrl_hs_stall_part
);

// &Ports; @24
input        cpuclk;                               
input        cpurst_b;                             
input        had_ifu_ir_vld;                       
input        ibuf_ifctrl_inst32_low;               
input        ibuf_ifctrl_inst_vld;                 
input        ibuf_ifctrl_pop0_mad32_low;           
input        ibuf_ifdp_inst_dbg_disable;           
input        ibuf_xx_empty;                        
input        ibusif_ifctrl_inst_mad32_high;        
input        ibusif_ifctrl_inst_no_bypass;         
input        ibusif_xx_16bit_inst;                 
input        ibusif_xx_trans_cmplt;                
input        ibusif_xx_unalign_fetch;              
input        iu_ifu_ex_stall;                      
input        iu_ifu_inst_fetch;                    
input        iu_ifu_inst_fetch_without_dbg_disable; 
input        iu_ifu_wb_stall;                      
input        iu_yy_xx_dbgon;                       
input        iu_yy_xx_flush;                       
input        split_ifctrl_hs_stall;                
input        split_ifctrl_hs_stall_part;           
output       ifctrl_ibuf_bypass_vld;               
output       ifctrl_ibuf_inst_pipe_down;           
output       ifctrl_ibuf_pop_en;                   
output       ifctrl_xx_ifcancel;                   
output       ifu_iu_ex_inst_vld;                   
output       ifu_iu_inst_buf_inst_dbg_disable;     
output       ifu_iu_inst_buf_inst_vld;             

// &Regs; @25
reg          ex_inst_vld;                          

// &Wires; @26
wire         cpuclk;                               
wire         cpurst_b;                             
wire         had_ifu_ir_vld;                       
wire         ibuf_bypass_vld;                      
wire         ibuf_ifctrl_inst32_low;               
wire         ibuf_ifctrl_inst_vld;                 
wire         ibuf_ifctrl_pop0_mad32_low;           
wire         ibuf_ifdp_inst_dbg_disable;           
wire         ibuf_inst_vld;                        
wire         ibuf_pop_en;                          
wire         ibuf_xx_empty;                        
wire         ibus_bypass_inst_vld;                 
wire         ibusif_ifctrl_inst_mad32_high;        
wire         ibusif_ifctrl_inst_no_bypass;         
wire         ibusif_xx_16bit_inst;                 
wire         ibusif_xx_trans_cmplt;                
wire         ibusif_xx_unalign_fetch;              
wire         if_cancel;                            
wire         if_cancel_for_pipeline;               
wire         if_inst_stall;                        
wire         if_inst_vld;                          
wire         if_inst_vld_for_ex;                   
wire         if_inst_vld_for_ex_aft_hs;            
wire         if_pipe_down;                         
wire         ifctrl_ibuf_bypass_vld;               
wire         ifctrl_ibuf_inst_pipe_down;           
wire         ifctrl_ibuf_pop_en;                   
wire         ifctrl_xx_ifcancel;                   
wire         ifu_iu_ex_inst_vld;                   
wire         ifu_iu_inst_buf_inst_dbg_disable;     
wire         ifu_iu_inst_buf_inst_vld;             
wire         inst_vld;                             
wire         iu_ifu_ex_stall;                      
wire         iu_ifu_inst_fetch;                    
wire         iu_ifu_inst_fetch_without_dbg_disable; 
wire         iu_ifu_wb_stall;                      
wire         iu_yy_xx_dbgon;                       
wire         iu_yy_xx_flush;                       
wire         random_inst_vld;                      
wire         split_ifctrl_hs_inst_vld;             
wire         split_ifctrl_hs_stall;                
wire         split_ifctrl_hs_stall_part;           
wire         split_ifctrl_mad_stall;               
wire         split_ifctrl_push_pop_stall;          


//==============================================================================
//                            Instruction Valid
//==============================================================================
assign ibuf_inst_vld = ibuf_ifctrl_inst_vld && !split_ifctrl_hs_stall;

//the inst of IF stage come from 3 sources, so the valid signal will condifer
//all these sources
assign inst_vld = ibuf_inst_vld || ibus_bypass_inst_vld
               || iu_yy_xx_dbgon && had_ifu_ir_vld;

//the bypass inst is valid when:
//1.the ibus trasacntion is completed
//2.ibuf is empty or only has one entry valid and it is high half of 32bit inst
//3.the ibus transaction is word algin
//4.the inst from ibus is not a split inst(mls or mad)
assign ibus_bypass_inst_vld = ibusif_xx_trans_cmplt &&
                              !split_ifctrl_hs_stall_part && 
//conditoin1: ibuf is empty, the inst from ibus
                              ( (ibuf_xx_empty &&
                                 (!ibusif_xx_unalign_fetch ||
                                  ibusif_xx_16bit_inst 
                                 ) &&
                                 !ibusif_ifctrl_inst_no_bypass
                                ) ||
//condition2: ibuf only have one entry valid and it is high half of 32-bit
//            inst, so half of the inst from ibuf and half of the inst from
//            ibus
                                (ibuf_ifctrl_inst32_low &&
                                 !(ibuf_ifctrl_pop0_mad32_low &&
                                   ibusif_ifctrl_inst_mad32_high
                                  )
                                )
                              );

//the inst at IF stage is only valid when no IF cancel signal is asserted
assign if_inst_vld = inst_vld && !if_cancel; 
                 
//the valid signal for ex is assert when no branch or jmp x1 stall asserted
assign if_inst_vld_for_ex = if_inst_vld && !if_inst_stall;

assign if_inst_stall = split_ifctrl_push_pop_stall ||
                       split_ifctrl_mad_stall;

//==============================================================================
//                            IF Cancel Signal
//==============================================================================
//IF stage will be cenceled when IU asserts the inst fetch signal or flush
// signal
assign if_cancel = iu_ifu_inst_fetch || iu_yy_xx_flush;

assign if_cancel_for_pipeline = iu_ifu_inst_fetch_without_dbg_disable 
                                && !split_ifctrl_hs_stall_part 
                             || iu_yy_xx_flush;


//==============================================================================
//                            IF Stage Pipe Down
//==============================================================================
//the inst at IF stage can only be piped down to EX when:
//1.the inst at IF is valid
//2.IU not stall
assign if_pipe_down = ex_inst_vld && !iu_ifu_ex_stall;

assign split_ifctrl_hs_inst_vld = 1'b0;
assign split_ifctrl_mad_stall = 1'b0;
assign split_ifctrl_push_pop_stall = 1'b0;
//assign if_pipe_down_for_hs = split_ifctrl_hs_inst_vld && !iu_ifu_ex_stall;

//==============================================================================
//                            Instruction Valid to EX Stage
//==============================================================================
assign if_inst_vld_for_ex_aft_hs = if_inst_vld_for_ex
                                || split_ifctrl_hs_inst_vld;
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    ex_inst_vld <= 1'b0;
  else if(if_cancel_for_pipeline)
    ex_inst_vld <= 1'b0;
  else if(!iu_ifu_ex_stall)
    ex_inst_vld <= if_inst_vld_for_ex_aft_hs;
end

assign ifu_iu_ex_inst_vld = ex_inst_vld;

assign ifu_iu_inst_buf_inst_vld = ibuf_inst_vld;
assign ifu_iu_inst_buf_inst_dbg_disable = ibuf_ifdp_inst_dbg_disable;


//==============================================================================
//                Control Signal of Inst Buf
//==============================================================================
//==========================================================
//                Bypass Signal if Ibuf
//==========================================================
//the inst buf will be bypassed when:
//1.the bypass inst is valid
//2.the IU not stall
//3.no random inst is valid
assign ibuf_bypass_vld = if_pipe_down &&
                         ibus_bypass_inst_vld &&
                         !random_inst_vld;

//==========================================================
//                Pop Enable of Ibuf
//==========================================================
assign ibuf_pop_en = if_pipe_down &&
                     !random_inst_vld;// &&
//                     !split_xx_stall;

//assign ibuf_inst_vld_after_cancel = ibuf_inst_vld && !if_cancel;


//==============================================================================
//                Interface to Other Module 
//==============================================================================
//==========================================================
//                Globle Signal
//==========================================================
assign random_inst_vld = 1'b0;
//assign ifctrl_xx_ifcancel = iu_yy_xx_flush || iu_ifu_inst_fetch_without_dbg_disable;
assign ifctrl_xx_ifcancel = iu_yy_xx_flush || iu_ifu_inst_fetch && !iu_ifu_wb_stall;
//assign ifctrl_xx_random_inst_vld = random_inst_vld;

//==========================================================
//                Interface to Ibuf
//==========================================================
//assign ibuf_empty = !ibuf_inst_vld;
assign ifctrl_ibuf_bypass_vld = ibuf_bypass_vld && 1'b0;
assign ifctrl_ibuf_inst_pipe_down = if_pipe_down && !random_inst_vld;
assign ifctrl_ibuf_pop_en = ibuf_pop_en;

//==========================================================
//                Interface to Split
//==========================================================
//the split inst can only come from ibuf
//assign ifctrl_split_inst_vld_no_cancel = ibuf_inst_vld 								
//                                      && !split_ifctrl_hs_stall;

//==========================================================
//                Interface to IF Data Path
//==========================================================
//assign ifctrl_ifdp_pipe_down = if_inst_vld_for_ex_aft_hs && !iu_ifu_ex_stall && !if_cancel_for_pipeline;
//assign ifctrl_ifdp_pipe_down_for_hs = if_pipe_down_for_hs;

// &ModuleEnd; @188
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_ifu_ifdp(
  had_core_dbg_mode_req,
  had_ifu_inst_bkpt_dbq_req,
  had_ifu_inst_bkpt_dbqexp_req,
  had_yy_xx_dp_index_mbee,
  ifu_had_inst_dbg_disable,
  ifu_had_split_first,
  ifu_iu_ex_inst_bkpt,
  ifu_iu_ex_inst_dbg_disable,
  ifu_iu_ex_int_spcu_mask,
  ifu_iu_ex_int_spcu_vld,
  ifu_iu_ex_ni,
  ifu_iu_ex_prvlg_expt_vld,
  ifu_iu_ex_rand_vld,
  ifu_iu_ex_sp_oper,
  ifu_iu_inst_bkpt_dbg_occur_vld,
  ifu_iu_inst_bkpt_dbgexp_occur_vld,
  ifu_iu_spcu_retire_mask,
  iu_ifu_kill_inst
);

// &Ports; @23
input        had_core_dbg_mode_req;            
input        had_ifu_inst_bkpt_dbq_req;        
input        had_ifu_inst_bkpt_dbqexp_req;     
input        had_yy_xx_dp_index_mbee;          
input        iu_ifu_kill_inst;                 
output       ifu_had_inst_dbg_disable;         
output       ifu_had_split_first;              
output       ifu_iu_ex_inst_bkpt;              
output       ifu_iu_ex_inst_dbg_disable;       
output       ifu_iu_ex_int_spcu_mask;          
output       ifu_iu_ex_int_spcu_vld;           
output       ifu_iu_ex_ni;                     
output       ifu_iu_ex_prvlg_expt_vld;         
output       ifu_iu_ex_rand_vld;               
output       ifu_iu_ex_sp_oper;                
output       ifu_iu_inst_bkpt_dbg_occur_vld;   
output       ifu_iu_inst_bkpt_dbgexp_occur_vld; 
output       ifu_iu_spcu_retire_mask;          

// &Regs; @24

// &Wires; @25
wire         had_core_dbg_mode_req;            
wire         had_ifu_inst_bkpt_dbq_req;        
wire         had_ifu_inst_bkpt_dbqexp_req;     
wire         had_yy_xx_dp_index_mbee;          
wire         if_bkpt_vld;                      
wire         ifu_had_inst_dbg_disable;         
wire         ifu_had_split_first;              
wire         ifu_iu_ex_inst_bkpt;              
wire         ifu_iu_ex_inst_dbg_disable;       
wire         ifu_iu_ex_int_spcu_mask;          
wire         ifu_iu_ex_int_spcu_vld;           
wire         ifu_iu_ex_ni;                     
wire         ifu_iu_ex_prvlg_expt_vld;         
wire         ifu_iu_ex_rand_vld;               
wire         ifu_iu_ex_sp_oper;                
wire         ifu_iu_inst_bkpt_dbg_occur_vld;   
wire         ifu_iu_inst_bkpt_dbgexp_occur_vld; 
wire         ifu_iu_spcu_retire_mask;          
wire         inst_bkpt;                        
wire         inst_bkpt_aft_hs;                 
wire         iu_ifu_kill_inst;                 


parameter EBREAK = 32'h00100073;

// &CombBeg; @30
// &CombEnd; @37

//when HAD assert the had_core_dbg_mode_req or had_ifu_inst_bkpt_dbq_req, 
//the inst in IF stage will be replaced as ebreak, then when this
//inst get to EX stage, cpu will enter into dbg mode
assign if_bkpt_vld = had_core_dbg_mode_req || had_ifu_inst_bkpt_dbq_req
                  || had_ifu_inst_bkpt_dbqexp_req
                  || iu_ifu_kill_inst && had_yy_xx_dp_index_mbee;

assign inst_bkpt = if_bkpt_vld;

//==========================================================
//               Other Signal
//==========================================================
//The singal below seldom vary ,they should be clock gated

// &Force("output","ifu_iu_ex_inst_dbg_disable"); @63
// &Instance("gated_clk_cell", "x_ifdp_other_info_upd_clkhdr"); @65
// &Connect(.clk_in(forever_cpuclk), @66
//          .external_en(1'b0), @67
//          .global_en(cp0_yy_clk_en), @68
//          .module_en(randclk_ifdp_other_info_mod_en_w8), @69
//          .local_en(ifdp_other_info_upd_en), @70
//          .clk_out(ifdp_other_info_upd_clk) @71
//         ); @72
assign ifu_iu_ex_inst_dbg_disable  = 1'b0;
//assign inst_dbg_disable = 1'b0;

// &Force("output","ifu_iu_ex_inst_bkpt"); @89
assign inst_bkpt_aft_hs = inst_bkpt;
assign ifu_iu_ex_inst_bkpt = inst_bkpt_aft_hs;

assign ifu_iu_ex_int_spcu_mask = 1'b0;
assign ifu_iu_ex_int_spcu_vld = 1'b0;
assign ifu_iu_ex_ni = 1'b0;
assign ifu_iu_ex_prvlg_expt_vld = 1'b0;
assign ifu_iu_ex_rand_vld = 1'b0;
assign ifu_iu_ex_sp_oper = 1'b0;
assign ifu_iu_spcu_retire_mask = 1'b0;

//==============================================================================
//               Interface to other Module
//==============================================================================
//for HAD inst bkpt
assign ifu_had_split_first    = 1'b1;
assign ifu_had_inst_dbg_disable = 1'b0;
assign ifu_iu_inst_bkpt_dbg_occur_vld = had_ifu_inst_bkpt_dbq_req;

assign ifu_iu_inst_bkpt_dbgexp_occur_vld = 1'b0;


// &ModuleEnd; @135
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module cr_ifu_randclk(
  randclk_ibuf_entry_data_mod_en_w16,
  randclk_ibuf_pop_mod_en_w3,
  randclk_ibuf_push_mod_en_w3
);

// &Ports; @25
output  [3:0]  randclk_ibuf_entry_data_mod_en_w16; 
output         randclk_ibuf_pop_mod_en_w3;        
output         randclk_ibuf_push_mod_en_w3;       

// &Regs; @26

// &Wires; @27
wire    [3:0]  randclk_ibuf_entry_data_mod_en_w16; 
wire           randclk_ibuf_pop_mod_en_w3;        
wire           randclk_ibuf_push_mod_en_w3;       


// &Force("bus","seu_ifu_randclk_mod_en",31,0); @31

assign randclk_ibuf_push_mod_en_w3             = 1'b0;
assign randclk_ibuf_pop_mod_en_w3              = 1'b0;
assign randclk_ibuf_entry_data_mod_en_w16[3:0] = 4'b0;
//assign randclk_ibuf_acc_err_mod_en_w3          = 1'b0;



// &ModuleEnd; @77
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_ifu_top(
  bmu_xx_ibus_acc_err,
  bmu_xx_ibus_data,
  bmu_xx_ibus_grnt,
  bmu_xx_ibus_trans_cmplt,
  cp0_ifu_in_lpmd,
  cp0_ifu_lpmd_req,
  cp0_ifu_rst_inv_done,
  cp0_ifu_srst_mask,
  cp0_ifu_srst_req,
  cp0_yy_clk_en,
  cp0_yy_machine_mode_aft_dbg,
  cpurst_b,
  forever_cpuclk,
  had_core_dbg_mode_req,
  had_ifu_inst_bkpt_dbq_req,
  had_ifu_inst_bkpt_dbqexp_req,
  had_ifu_ir,
  had_ifu_ir_vld,
  had_yy_xx_dp_index_mbee,
  ifu_bmu_addr,
  ifu_bmu_idle,
  ifu_bmu_prot,
  ifu_bmu_req,
  ifu_bmu_wfd1,
  ifu_cp0_lpmd_ack,
  ifu_cp0_rst_inv_req,
  ifu_cp0_srst_ack,
  ifu_had_fetch_expt_vld,
  ifu_had_inst_dbg_disable,
  ifu_had_split_first,
  ifu_iu_ex_expt_cur,
  ifu_iu_ex_expt_vld,
  ifu_iu_ex_inst,
  ifu_iu_ex_inst_bkpt,
  ifu_iu_ex_inst_dbg_disable,
  ifu_iu_ex_inst_vld,
  ifu_iu_ex_int_spcu_mask,
  ifu_iu_ex_int_spcu_vld,
  ifu_iu_ex_ni,
  ifu_iu_ex_prvlg_expt_vld,
  ifu_iu_ex_rand_vld,
  ifu_iu_ex_sp_oper,
  ifu_iu_ibus_idle,
  ifu_iu_inst_bkpt_dbg_occur_vld,
  ifu_iu_inst_bkpt_dbgexp_occur_vld,
  ifu_iu_inst_buf_inst_dbg_disable,
  ifu_iu_inst_buf_inst_vld,
  ifu_iu_lockup_ack,
  ifu_iu_spcu_retire_mask,
  ifu_iu_vector_ibus_in_idle,
  ifu_iu_xx_ibus_data,
  iu_ifu_addr,
  iu_ifu_data_fetch,
  iu_ifu_data_fetch_for_data,
  iu_ifu_ex_stall,
  iu_ifu_ex_stall_noinput,
  iu_ifu_ex_vld,
  iu_ifu_inst_fetch,
  iu_ifu_inst_fetch_for_data,
  iu_ifu_inst_fetch_mask,
  iu_ifu_inst_fetch_without_dbg_disable,
  iu_ifu_kill_inst,
  iu_ifu_lockup_mask,
  iu_ifu_lockup_on,
  iu_ifu_lockup_req,
  iu_ifu_lsu_inst,
  iu_ifu_reset_vld,
  iu_ifu_security_violation,
  iu_ifu_wb_ldst,
  iu_ifu_wb_stall,
  iu_yy_xx_dbgon,
  iu_yy_xx_flush,
  pad_yy_gate_clk_en_b,
  pmp_ifu_acc_scu,
  split_ifctrl_hs_stall,
  split_ifctrl_hs_stall_part,
  sysio_ifu_rst_addr,
  sysmap_ifu_acc_ca
);

// &Ports; @24
input           bmu_xx_ibus_acc_err;                  
input   [31:0]  bmu_xx_ibus_data;                     
input           bmu_xx_ibus_grnt;                     
input           bmu_xx_ibus_trans_cmplt;              
input           cp0_ifu_in_lpmd;                      
input           cp0_ifu_lpmd_req;                     
input           cp0_ifu_rst_inv_done;                 
input           cp0_ifu_srst_mask;                    
input           cp0_ifu_srst_req;                     
input           cp0_yy_clk_en;                        
input           cp0_yy_machine_mode_aft_dbg;          
input           cpurst_b;                             
input           forever_cpuclk;                       
input           had_core_dbg_mode_req;                
input           had_ifu_inst_bkpt_dbq_req;            
input           had_ifu_inst_bkpt_dbqexp_req;         
input   [31:0]  had_ifu_ir;                           
input           had_ifu_ir_vld;                       
input           had_yy_xx_dp_index_mbee;              
input   [30:0]  iu_ifu_addr;                          
input           iu_ifu_data_fetch;                    
input           iu_ifu_data_fetch_for_data;           
input           iu_ifu_ex_stall;                      
input           iu_ifu_ex_stall_noinput;              
input           iu_ifu_ex_vld;                        
input           iu_ifu_inst_fetch;                    
input           iu_ifu_inst_fetch_for_data;           
input           iu_ifu_inst_fetch_mask;               
input           iu_ifu_inst_fetch_without_dbg_disable; 
input           iu_ifu_kill_inst;                     
input           iu_ifu_lockup_mask;                   
input           iu_ifu_lockup_on;                     
input           iu_ifu_lockup_req;                    
input           iu_ifu_lsu_inst;                      
input           iu_ifu_reset_vld;                     
input           iu_ifu_security_violation;            
input           iu_ifu_wb_ldst;                       
input           iu_ifu_wb_stall;                      
input           iu_yy_xx_dbgon;                       
input           iu_yy_xx_flush;                       
input           pad_yy_gate_clk_en_b;                 
input           pmp_ifu_acc_scu;                      
input           split_ifctrl_hs_stall;                
input           split_ifctrl_hs_stall_part;           
input   [31:0]  sysio_ifu_rst_addr;                   
input           sysmap_ifu_acc_ca;                    
output  [31:0]  ifu_bmu_addr;                         
output          ifu_bmu_idle;                         
output  [3 :0]  ifu_bmu_prot;                         
output          ifu_bmu_req;                          
output          ifu_bmu_wfd1;                         
output          ifu_cp0_lpmd_ack;                     
output          ifu_cp0_rst_inv_req;                  
output          ifu_cp0_srst_ack;                     
output          ifu_had_fetch_expt_vld;               
output          ifu_had_inst_dbg_disable;             
output          ifu_had_split_first;                  
output          ifu_iu_ex_expt_cur;                   
output          ifu_iu_ex_expt_vld;                   
output  [31:0]  ifu_iu_ex_inst;                       
output          ifu_iu_ex_inst_bkpt;                  
output          ifu_iu_ex_inst_dbg_disable;           
output          ifu_iu_ex_inst_vld;                   
output          ifu_iu_ex_int_spcu_mask;              
output          ifu_iu_ex_int_spcu_vld;               
output          ifu_iu_ex_ni;                         
output          ifu_iu_ex_prvlg_expt_vld;             
output          ifu_iu_ex_rand_vld;                   
output          ifu_iu_ex_sp_oper;                    
output          ifu_iu_ibus_idle;                     
output          ifu_iu_inst_bkpt_dbg_occur_vld;       
output          ifu_iu_inst_bkpt_dbgexp_occur_vld;    
output          ifu_iu_inst_buf_inst_dbg_disable;     
output          ifu_iu_inst_buf_inst_vld;             
output          ifu_iu_lockup_ack;                    
output          ifu_iu_spcu_retire_mask;              
output          ifu_iu_vector_ibus_in_idle;           
output  [31:0]  ifu_iu_xx_ibus_data;                  

// &Regs; @25

// &Wires; @26
wire            bmu_xx_ibus_acc_err;                  
wire    [31:0]  bmu_xx_ibus_data;                     
wire            bmu_xx_ibus_grnt;                     
wire            bmu_xx_ibus_trans_cmplt;              
wire            cp0_ifu_in_lpmd;                      
wire            cp0_ifu_lpmd_req;                     
wire            cp0_ifu_rst_inv_done;                 
wire            cp0_ifu_srst_mask;                    
wire            cp0_ifu_srst_req;                     
wire            cp0_yy_clk_en;                        
wire            cp0_yy_machine_mode_aft_dbg;          
wire            cpurst_b;                             
wire            forever_cpuclk;                       
wire            forever_cpuclk_gated_ifu;             
wire            had_core_dbg_mode_req;                
wire            had_ifu_inst_bkpt_dbq_req;            
wire            had_ifu_inst_bkpt_dbqexp_req;         
wire    [31:0]  had_ifu_ir;                           
wire            had_ifu_ir_vld;                       
wire            had_yy_xx_dp_index_mbee;              
wire            ibuf_ibusif_inst_fetch;               
wire            ibuf_ifctrl_inst32_low;               
wire            ibuf_ifctrl_inst_vld;                 
wire            ibuf_ifctrl_pop0_mad32_low;           
wire            ibuf_ifdp_inst_dbg_disable;           
wire            ibuf_top_clk_en;                      
wire            ibuf_xx_empty;                        
wire            ibusif_ibuf_no_trans;                 
wire            ibusif_ifctrl_inst_mad32_high;        
wire            ibusif_ifctrl_inst_no_bypass;         
wire            ibusif_top_clk_en;                    
wire            ibusif_xx_16bit_inst;                 
wire            ibusif_xx_acc_err;                    
wire    [31:0]  ibusif_xx_data;                       
wire            ibusif_xx_ibus_idle;                  
wire            ibusif_xx_trans_cmplt;                
wire            ibusif_xx_unalign_fetch;              
wire            ifctrl_ibuf_bypass_vld;               
wire            ifctrl_ibuf_inst_pipe_down;           
wire            ifctrl_ibuf_pop_en;                   
wire            ifctrl_xx_ifcancel;                   
wire    [31:0]  ifu_bmu_addr;                         
wire            ifu_bmu_idle;                         
wire    [3 :0]  ifu_bmu_prot;                         
wire            ifu_bmu_req;                          
wire            ifu_bmu_wfd1;                         
wire            ifu_cp0_lpmd_ack;                     
wire            ifu_cp0_rst_inv_req;                  
wire            ifu_cp0_srst_ack;                     
wire            ifu_had_fetch_expt_vld;               
wire            ifu_had_inst_dbg_disable;             
wire            ifu_had_split_first;                  
wire            ifu_iu_ex_expt_cur;                   
wire            ifu_iu_ex_expt_vld;                   
wire    [31:0]  ifu_iu_ex_inst;                       
wire            ifu_iu_ex_inst_bkpt;                  
wire            ifu_iu_ex_inst_dbg_disable;           
wire            ifu_iu_ex_inst_vld;                   
wire            ifu_iu_ex_int_spcu_mask;              
wire            ifu_iu_ex_int_spcu_vld;               
wire            ifu_iu_ex_ni;                         
wire            ifu_iu_ex_prvlg_expt_vld;             
wire            ifu_iu_ex_rand_vld;                   
wire            ifu_iu_ex_sp_oper;                    
wire            ifu_iu_ibus_idle;                     
wire            ifu_iu_inst_bkpt_dbg_occur_vld;       
wire            ifu_iu_inst_bkpt_dbgexp_occur_vld;    
wire            ifu_iu_inst_buf_inst_dbg_disable;     
wire            ifu_iu_inst_buf_inst_vld;             
wire            ifu_iu_lockup_ack;                    
wire            ifu_iu_spcu_retire_mask;              
wire            ifu_iu_vector_ibus_in_idle;           
wire    [31:0]  ifu_iu_xx_ibus_data;                  
wire            ifu_misc_clk;                         
wire            ifu_misc_upd_en;                      
wire    [30:0]  iu_ifu_addr;                          
wire            iu_ifu_data_fetch;                    
wire            iu_ifu_data_fetch_for_data;           
wire            iu_ifu_ex_stall;                      
wire            iu_ifu_ex_stall_noinput;              
wire            iu_ifu_ex_vld;                        
wire            iu_ifu_inst_fetch;                    
wire            iu_ifu_inst_fetch_for_data;           
wire            iu_ifu_inst_fetch_mask;               
wire            iu_ifu_inst_fetch_without_dbg_disable; 
wire            iu_ifu_kill_inst;                     
wire            iu_ifu_lockup_mask;                   
wire            iu_ifu_lockup_on;                     
wire            iu_ifu_lockup_req;                    
wire            iu_ifu_lsu_inst;                      
wire            iu_ifu_reset_vld;                     
wire            iu_ifu_security_violation;            
wire            iu_ifu_wb_ldst;                       
wire            iu_ifu_wb_stall;                      
wire            iu_yy_xx_dbgon;                       
wire            iu_yy_xx_flush;                       
wire            pad_yy_gate_clk_en_b;                 
wire            pmp_ifu_acc_scu;                      
wire    [3 :0]  randclk_ibuf_entry_data_mod_en_w16;   
wire            randclk_ibuf_pop_mod_en_w3;           
wire            randclk_ibuf_push_mod_en_w3;          
wire            split_ifctrl_hs_stall;                
wire            split_ifctrl_hs_stall_part;           
wire    [31:0]  sysio_ifu_rst_addr;                   
wire            sysmap_ifu_acc_ca;                    



//==============================================================================
//                             IFU Module Gated Cell
//==============================================================================
// &Instance("gated_clk_cell","x_gated_cpuclk_cell_ifu"); @32
gated_clk_cell  x_gated_cpuclk_cell_ifu (
  .clk_in                   (forever_cpuclk          ),
  .clk_out                  (forever_cpuclk_gated_ifu),
  .external_en              (1'b0                    ),
  .global_en                (cp0_yy_clk_en           ),
  .local_en                 (1'b1                    ),
  .module_en                (1'b1                    ),
  .pad_yy_gate_clk_en_b     (pad_yy_gate_clk_en_b    )
);

// &Connect( @33
//   .clk_in              (forever_cpuclk          ), @34
//   .clk_out             (forever_cpuclk_gated_ifu), @35
//   .external_en         (1'b0                    ), @36
//   .global_en           (cp0_yy_clk_en           ), @37
//   .local_en            (1'b1                    ), @38
//   .module_en           (1'b1                    ) @39
// ); @40

// &Instance("gated_clk_cell", "x_entry_ifu_misc_clkhdr"); @42
gated_clk_cell  x_entry_ifu_misc_clkhdr (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (ifu_misc_clk        ),
  .external_en          (1'b0                ),
  .global_en            (cp0_yy_clk_en       ),
  .local_en             (ifu_misc_upd_en     ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in(forever_cpuclk), @43
//          .external_en(1'b0), @44
//          .global_en(cp0_yy_clk_en), @45
//          .module_en(1'b0), @46
//          .local_en(ifu_misc_upd_en), @47
//          .clk_out(ifu_misc_clk) @48
//         ); @49

assign ifu_misc_upd_en = ibuf_top_clk_en
                      || ibusif_top_clk_en;

//==============================================================================
//                             IFU Module Instance
//==============================================================================
// &Instance("cr_ifu_ibusif","x_ibusif"); @57
cr_ifu_ibusif  x_ibusif (
  .bmu_xx_ibus_acc_err           (bmu_xx_ibus_acc_err          ),
  .bmu_xx_ibus_data              (bmu_xx_ibus_data             ),
  .bmu_xx_ibus_grnt              (bmu_xx_ibus_grnt             ),
  .bmu_xx_ibus_trans_cmplt       (bmu_xx_ibus_trans_cmplt      ),
  .cp0_ifu_in_lpmd               (cp0_ifu_in_lpmd              ),
  .cp0_ifu_lpmd_req              (cp0_ifu_lpmd_req             ),
  .cp0_ifu_rst_inv_done          (cp0_ifu_rst_inv_done         ),
  .cp0_ifu_srst_mask             (cp0_ifu_srst_mask            ),
  .cp0_ifu_srst_req              (cp0_ifu_srst_req             ),
  .cp0_yy_clk_en                 (cp0_yy_clk_en                ),
  .cp0_yy_machine_mode_aft_dbg   (cp0_yy_machine_mode_aft_dbg  ),
  .cpurst_b                      (cpurst_b                     ),
  .forever_cpuclk                (forever_cpuclk               ),
  .ibuf_ibusif_inst_fetch        (ibuf_ibusif_inst_fetch       ),
  .ibusif_ibuf_no_trans          (ibusif_ibuf_no_trans         ),
  .ibusif_ifctrl_inst_mad32_high (ibusif_ifctrl_inst_mad32_high),
  .ibusif_ifctrl_inst_no_bypass  (ibusif_ifctrl_inst_no_bypass ),
  .ibusif_top_clk_en             (ibusif_top_clk_en            ),
  .ibusif_xx_16bit_inst          (ibusif_xx_16bit_inst         ),
  .ibusif_xx_acc_err             (ibusif_xx_acc_err            ),
  .ibusif_xx_data                (ibusif_xx_data               ),
  .ibusif_xx_ibus_idle           (ibusif_xx_ibus_idle          ),
  .ibusif_xx_trans_cmplt         (ibusif_xx_trans_cmplt        ),
  .ibusif_xx_unalign_fetch       (ibusif_xx_unalign_fetch      ),
  .ifu_bmu_addr                  (ifu_bmu_addr                 ),
  .ifu_bmu_idle                  (ifu_bmu_idle                 ),
  .ifu_bmu_prot                  (ifu_bmu_prot                 ),
  .ifu_bmu_req                   (ifu_bmu_req                  ),
  .ifu_bmu_wfd1                  (ifu_bmu_wfd1                 ),
  .ifu_cp0_lpmd_ack              (ifu_cp0_lpmd_ack             ),
  .ifu_cp0_rst_inv_req           (ifu_cp0_rst_inv_req          ),
  .ifu_cp0_srst_ack              (ifu_cp0_srst_ack             ),
  .ifu_iu_ibus_idle              (ifu_iu_ibus_idle             ),
  .ifu_iu_lockup_ack             (ifu_iu_lockup_ack            ),
  .ifu_iu_vector_ibus_in_idle    (ifu_iu_vector_ibus_in_idle   ),
  .ifu_iu_xx_ibus_data           (ifu_iu_xx_ibus_data          ),
  .ifu_misc_clk                  (ifu_misc_clk                 ),
  .iu_ifu_addr                   (iu_ifu_addr                  ),
  .iu_ifu_data_fetch             (iu_ifu_data_fetch            ),
  .iu_ifu_data_fetch_for_data    (iu_ifu_data_fetch_for_data   ),
  .iu_ifu_inst_fetch             (iu_ifu_inst_fetch            ),
  .iu_ifu_inst_fetch_for_data    (iu_ifu_inst_fetch_for_data   ),
  .iu_ifu_inst_fetch_mask        (iu_ifu_inst_fetch_mask       ),
  .iu_ifu_lockup_mask            (iu_ifu_lockup_mask           ),
  .iu_ifu_lockup_on              (iu_ifu_lockup_on             ),
  .iu_ifu_lockup_req             (iu_ifu_lockup_req            ),
  .iu_ifu_reset_vld              (iu_ifu_reset_vld             ),
  .iu_ifu_security_violation     (iu_ifu_security_violation    ),
  .iu_yy_xx_dbgon                (iu_yy_xx_dbgon               ),
  .pad_yy_gate_clk_en_b          (pad_yy_gate_clk_en_b         ),
  .pmp_ifu_acc_scu               (pmp_ifu_acc_scu              ),
  .sysio_ifu_rst_addr            (sysio_ifu_rst_addr           ),
  .sysmap_ifu_acc_ca             (sysmap_ifu_acc_ca            )
);


// &Connect(.pmp_ifu_acc_scu(1'b0)); @63


// &Connect(.cru_ifu_acc_ca(1'b0)); @70

// &Instance("cr_ifu_ibuf","x_ibuf"); @73
cr_ifu_ibuf  x_ibuf (
  .cp0_yy_clk_en                      (cp0_yy_clk_en                     ),
  .cpuclk                             (forever_cpuclk_gated_ifu          ),
  .cpurst_b                           (cpurst_b                          ),
  .forever_cpuclk                     (forever_cpuclk                    ),
  .had_ifu_ir                         (had_ifu_ir                        ),
  .had_ifu_ir_vld                     (had_ifu_ir_vld                    ),
  .ibuf_ibusif_inst_fetch             (ibuf_ibusif_inst_fetch            ),
  .ibuf_ifctrl_inst32_low             (ibuf_ifctrl_inst32_low            ),
  .ibuf_ifctrl_inst_vld               (ibuf_ifctrl_inst_vld              ),
  .ibuf_ifctrl_pop0_mad32_low         (ibuf_ifctrl_pop0_mad32_low        ),
  .ibuf_ifdp_inst_dbg_disable         (ibuf_ifdp_inst_dbg_disable        ),
  .ibuf_top_clk_en                    (ibuf_top_clk_en                   ),
  .ibuf_xx_empty                      (ibuf_xx_empty                     ),
  .ibusif_ibuf_no_trans               (ibusif_ibuf_no_trans              ),
  .ibusif_xx_16bit_inst               (ibusif_xx_16bit_inst              ),
  .ibusif_xx_acc_err                  (ibusif_xx_acc_err                 ),
  .ibusif_xx_data                     (ibusif_xx_data                    ),
  .ibusif_xx_ibus_idle                (ibusif_xx_ibus_idle               ),
  .ibusif_xx_trans_cmplt              (ibusif_xx_trans_cmplt             ),
  .ibusif_xx_unalign_fetch            (ibusif_xx_unalign_fetch           ),
  .ifctrl_ibuf_bypass_vld             (ifctrl_ibuf_bypass_vld            ),
  .ifctrl_ibuf_inst_pipe_down         (ifctrl_ibuf_inst_pipe_down        ),
  .ifctrl_ibuf_pop_en                 (ifctrl_ibuf_pop_en                ),
  .ifctrl_xx_ifcancel                 (ifctrl_xx_ifcancel                ),
  .ifu_had_fetch_expt_vld             (ifu_had_fetch_expt_vld            ),
  .ifu_iu_ex_expt_cur                 (ifu_iu_ex_expt_cur                ),
  .ifu_iu_ex_expt_vld                 (ifu_iu_ex_expt_vld                ),
  .ifu_iu_ex_inst                     (ifu_iu_ex_inst                    ),
  .ifu_misc_clk                       (ifu_misc_clk                      ),
  .iu_ifu_ex_stall_noinput            (iu_ifu_ex_stall_noinput           ),
  .iu_ifu_ex_vld                      (iu_ifu_ex_vld                     ),
  .iu_ifu_inst_fetch                  (iu_ifu_inst_fetch                 ),
  .iu_ifu_lsu_inst                    (iu_ifu_lsu_inst                   ),
  .iu_ifu_wb_ldst                     (iu_ifu_wb_ldst                    ),
  .iu_ifu_wb_stall                    (iu_ifu_wb_stall                   ),
  .iu_yy_xx_dbgon                     (iu_yy_xx_dbgon                    ),
  .pad_yy_gate_clk_en_b               (pad_yy_gate_clk_en_b              ),
  .randclk_ibuf_entry_data_mod_en_w16 (randclk_ibuf_entry_data_mod_en_w16),
  .randclk_ibuf_pop_mod_en_w3         (randclk_ibuf_pop_mod_en_w3        ),
  .randclk_ibuf_push_mod_en_w3        (randclk_ibuf_push_mod_en_w3       )
);

// &Connect(.cpuclk (forever_cpuclk_gated_ifu)); @74

//&Instance("cr_ifu_addrgen","x_addrgen");
// //&Connect(.cpuclk (forever_cpuclk_gated_ifu)); @77

//&Instance("cr_ifu_split","x_split");

// &Instance("cr_ifu_ifdp","x_ifdp"); @81
cr_ifu_ifdp  x_ifdp (
  .had_core_dbg_mode_req             (had_core_dbg_mode_req            ),
  .had_ifu_inst_bkpt_dbq_req         (had_ifu_inst_bkpt_dbq_req        ),
  .had_ifu_inst_bkpt_dbqexp_req      (had_ifu_inst_bkpt_dbqexp_req     ),
  .had_yy_xx_dp_index_mbee           (had_yy_xx_dp_index_mbee          ),
  .ifu_had_inst_dbg_disable          (ifu_had_inst_dbg_disable         ),
  .ifu_had_split_first               (ifu_had_split_first              ),
  .ifu_iu_ex_inst_bkpt               (ifu_iu_ex_inst_bkpt              ),
  .ifu_iu_ex_inst_dbg_disable        (ifu_iu_ex_inst_dbg_disable       ),
  .ifu_iu_ex_int_spcu_mask           (ifu_iu_ex_int_spcu_mask          ),
  .ifu_iu_ex_int_spcu_vld            (ifu_iu_ex_int_spcu_vld           ),
  .ifu_iu_ex_ni                      (ifu_iu_ex_ni                     ),
  .ifu_iu_ex_prvlg_expt_vld          (ifu_iu_ex_prvlg_expt_vld         ),
  .ifu_iu_ex_rand_vld                (ifu_iu_ex_rand_vld               ),
  .ifu_iu_ex_sp_oper                 (ifu_iu_ex_sp_oper                ),
  .ifu_iu_inst_bkpt_dbg_occur_vld    (ifu_iu_inst_bkpt_dbg_occur_vld   ),
  .ifu_iu_inst_bkpt_dbgexp_occur_vld (ifu_iu_inst_bkpt_dbgexp_occur_vld),
  .ifu_iu_spcu_retire_mask           (ifu_iu_spcu_retire_mask          ),
  .iu_ifu_kill_inst                  (iu_ifu_kill_inst                 )
);


// &Instance("cr_ifu_ifctrl","x_ifctrl"); @83
cr_ifu_ifctrl  x_ifctrl (
  .cpuclk                                (forever_cpuclk_gated_ifu             ),
  .cpurst_b                              (cpurst_b                             ),
  .had_ifu_ir_vld                        (had_ifu_ir_vld                       ),
  .ibuf_ifctrl_inst32_low                (ibuf_ifctrl_inst32_low               ),
  .ibuf_ifctrl_inst_vld                  (ibuf_ifctrl_inst_vld                 ),
  .ibuf_ifctrl_pop0_mad32_low            (ibuf_ifctrl_pop0_mad32_low           ),
  .ibuf_ifdp_inst_dbg_disable            (ibuf_ifdp_inst_dbg_disable           ),
  .ibuf_xx_empty                         (ibuf_xx_empty                        ),
  .ibusif_ifctrl_inst_mad32_high         (ibusif_ifctrl_inst_mad32_high        ),
  .ibusif_ifctrl_inst_no_bypass          (ibusif_ifctrl_inst_no_bypass         ),
  .ibusif_xx_16bit_inst                  (ibusif_xx_16bit_inst                 ),
  .ibusif_xx_trans_cmplt                 (ibusif_xx_trans_cmplt                ),
  .ibusif_xx_unalign_fetch               (ibusif_xx_unalign_fetch              ),
  .ifctrl_ibuf_bypass_vld                (ifctrl_ibuf_bypass_vld               ),
  .ifctrl_ibuf_inst_pipe_down            (ifctrl_ibuf_inst_pipe_down           ),
  .ifctrl_ibuf_pop_en                    (ifctrl_ibuf_pop_en                   ),
  .ifctrl_xx_ifcancel                    (ifctrl_xx_ifcancel                   ),
  .ifu_iu_ex_inst_vld                    (ifu_iu_ex_inst_vld                   ),
  .ifu_iu_inst_buf_inst_dbg_disable      (ifu_iu_inst_buf_inst_dbg_disable     ),
  .ifu_iu_inst_buf_inst_vld              (ifu_iu_inst_buf_inst_vld             ),
  .iu_ifu_ex_stall                       (iu_ifu_ex_stall                      ),
  .iu_ifu_inst_fetch                     (iu_ifu_inst_fetch                    ),
  .iu_ifu_inst_fetch_without_dbg_disable (iu_ifu_inst_fetch_without_dbg_disable),
  .iu_ifu_wb_stall                       (iu_ifu_wb_stall                      ),
  .iu_yy_xx_dbgon                        (iu_yy_xx_dbgon                       ),
  .iu_yy_xx_flush                        (iu_yy_xx_flush                       ),
  .split_ifctrl_hs_stall                 (split_ifctrl_hs_stall                ),
  .split_ifctrl_hs_stall_part            (split_ifctrl_hs_stall_part           )
);

// &Connect(.cpuclk (forever_cpuclk_gated_ifu)); @84

// &Instance("cr_ifu_randclk","x_randclk"); @86
cr_ifu_randclk  x_randclk (
  .randclk_ibuf_entry_data_mod_en_w16 (randclk_ibuf_entry_data_mod_en_w16),
  .randclk_ibuf_pop_mod_en_w3         (randclk_ibuf_pop_mod_en_w3        ),
  .randclk_ibuf_push_mod_en_w3        (randclk_ibuf_push_mod_en_w3       )
);


// &ModuleEnd; @88
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @27
module cr_iu_alu(
  alu_branch_adder_rst,
  alu_branch_rst_sign,
  alu_branch_rst_unsign,
  alu_branch_xor_rst,
  alu_mad_adder_of,
  alu_mad_adder_rst,
  alu_mad_rst_cout,
  alu_rbus_data,
  alu_rbus_data_vld,
  alu_rbus_req,
  branch_alu_adder_cmp,
  branch_alu_adder_sel,
  branch_alu_logic_nz,
  branch_alu_logic_sel,
  branch_alu_pc_sel,
  ctrl_alu_ex_sel,
  ctrl_alu_mad_oper_mux_en,
  ctrl_alu_oper_mux_en,
  ctrl_mad_ex_data_sel,
  decd_alu_dst_vld,
  decd_alu_func,
  decd_alu_rs2_imm_vld,
  decd_alu_sub_func,
  ifu_iu_ex_cnt,
  iu_lsu_adder_rst,
  lsu_iu_alu_sel,
  lsu_iu_mad_buf,
  mad_alu_data_vld,
  mad_alu_div_rs2,
  mad_alu_div_shift,
  mad_alu_fst_add,
  mad_alu_imm_vld,
  mad_alu_rs1,
  mad_alu_rs1_cst_0,
  mad_alu_rs1_vld,
  mad_alu_rs2_cst_0,
  mad_alu_rst,
  mad_alu_rst_vld,
  oper_alu_rs1_reg,
  oper_alu_rs2_imm,
  oper_alu_rs2_reg,
  pcgen_xx_cur_pc
);

// &Ports; @28
input           branch_alu_adder_cmp;         
input           branch_alu_adder_sel;         
input           branch_alu_logic_nz;          
input           branch_alu_logic_sel;         
input           branch_alu_pc_sel;            
input           ctrl_alu_ex_sel;              
input           ctrl_alu_mad_oper_mux_en;     
input           ctrl_alu_oper_mux_en;         
input           ctrl_mad_ex_data_sel;         
input           decd_alu_dst_vld;             
input   [2 :0]  decd_alu_func;                
input           decd_alu_rs2_imm_vld;         
input   [3 :0]  decd_alu_sub_func;            
input   [4 :0]  ifu_iu_ex_cnt;                
input           lsu_iu_alu_sel;               
input   [31:0]  lsu_iu_mad_buf;               
input           mad_alu_data_vld;             
input   [31:0]  mad_alu_div_rs2;              
input           mad_alu_div_shift;            
input           mad_alu_fst_add;              
input           mad_alu_imm_vld;              
input   [31:0]  mad_alu_rs1;                  
input           mad_alu_rs1_cst_0;            
input           mad_alu_rs1_vld;              
input           mad_alu_rs2_cst_0;            
input   [31:0]  mad_alu_rst;                  
input           mad_alu_rst_vld;              
input   [31:0]  oper_alu_rs1_reg;             
input   [31:0]  oper_alu_rs2_imm;             
input   [31:0]  oper_alu_rs2_reg;             
input   [30:0]  pcgen_xx_cur_pc;              
output  [31:0]  alu_branch_adder_rst;         
output          alu_branch_rst_sign;          
output          alu_branch_rst_unsign;        
output  [31:0]  alu_branch_xor_rst;           
output          alu_mad_adder_of;             
output  [31:0]  alu_mad_adder_rst;            
output          alu_mad_rst_cout;             
output  [31:0]  alu_rbus_data;                
output          alu_rbus_data_vld;            
output          alu_rbus_req;                 
output  [31:0]  iu_lsu_adder_rst;             

// &Regs; @29
reg     [31:0]  alu_shifter_right_rst;        

// &Wires; @30
wire    [1 :0]  alu_adder_c_sel;              
wire            alu_adder_reverse;            
wire    [31:0]  alu_adder_rs1;                
wire    [31:0]  alu_adder_rs2;                
wire    [31:0]  alu_adder_rs2_pre_val;        
wire            alu_adder_rst_cmp_signed_lt;  
wire            alu_adder_rst_cmp_unsigned_lt; 
wire            alu_adder_rst_cout;           
wire    [31:0]  alu_adder_rst_out;            
wire            alu_adder_sel;                
wire    [31:0]  alu_adder_shared_rst_out;     
wire    [31:0]  alu_branch_adder_rst;         
wire            alu_branch_rst_sign;          
wire            alu_branch_rst_unsign;        
wire    [31:0]  alu_branch_xor_rst;           
wire            alu_dst_vld;                  
wire    [2 :0]  alu_func;                     
wire    [31:0]  alu_logic_rs1;                
wire    [31:0]  alu_logic_rs2;                
wire    [31:0]  alu_logic_rst_out;            
wire    [31:0]  alu_logic_rst_out_and;        
wire    [31:0]  alu_logic_rst_out_mov;        
wire    [31:0]  alu_logic_rst_out_or;         
wire    [31:0]  alu_logic_rst_out_xor;        
wire    [3 :0]  alu_logic_rst_sel;            
wire            alu_logic_sel;                
wire            alu_mad_adder_of;             
wire    [31:0]  alu_mad_adder_rst;            
wire            alu_mad_rst_cout;             
wire    [31:0]  alu_mux_rs1;                  
wire    [31:0]  alu_mux_rs2;                  
wire    [31:0]  alu_prepare_rs1;              
wire            alu_prepare_rs1_sel;          
wire    [31:0]  alu_prepare_rs2;              
wire            alu_prepare_rs2_sel;          
wire    [31:0]  alu_rbus_data;                
wire            alu_rbus_data_vld;            
wire            alu_rbus_req;                 
wire    [31:0]  alu_rs1;                      
wire            alu_rs1_pre_cst_0;            
wire    [31:0]  alu_rs2;                      
wire            alu_rs2_imm_sel;              
wire            alu_rs2_pre_cst_0;            
wire            alu_sel;                      
wire            alu_shared_adder_cout;        
wire    [31:0]  alu_shared_adder_rs1;         
wire    [31:0]  alu_shared_adder_rs2;         
wire    [31:0]  alu_shared_adder_rst;         
wire            alu_shared_adder_srcc;        
wire            alu_shifter_right_in;         
wire    [31:0]  alu_shifter_right_in_mask;    
wire    [31:0]  alu_shifter_rs1;              
wire    [31:0]  alu_shifter_rs1_pre;          
wire    [31:0]  alu_shifter_rs1_reverse;      
wire    [4 :0]  alu_shifter_rs2;              
wire    [31:0]  alu_shifter_rst_left_out;     
wire    [31:0]  alu_shifter_rst_out;          
wire    [31:0]  alu_shifter_rst_right_out;    
wire            alu_shifter_rst_sel;          
wire            alu_shifter_sel;              
wire            alu_shifter_shift_dr;         
wire            alu_shifter_shift_in;         
wire    [3 :0]  alu_sub_func;                 
wire            branch_alu_adder_cmp;         
wire            branch_alu_adder_sel;         
wire            branch_alu_logic_nz;          
wire            branch_alu_logic_sel;         
wire            branch_alu_pc_sel;            
wire            ctrl_alu_ex_sel;              
wire            ctrl_alu_mad_oper_mux_en;     
wire            ctrl_alu_oper_mux_en;         
wire            ctrl_mad_ex_data_sel;         
wire            decd_alu_dst_vld;             
wire    [2 :0]  decd_alu_func;                
wire            decd_alu_rs2_imm_vld;         
wire    [3 :0]  decd_alu_sub_func;            
wire    [4 :0]  ifu_iu_ex_cnt;                
wire    [31:0]  iu_lsu_adder_rst;             
wire            logic_rs1_sel;                
wire            lsu_iu_alu_sel;               
wire    [31:0]  lsu_iu_mad_buf;               
wire            mad_alu_data_vld;             
wire    [31:0]  mad_alu_div_rs2;              
wire            mad_alu_div_shift;            
wire            mad_alu_fst_add;              
wire            mad_alu_imm_vld;              
wire    [31:0]  mad_alu_rs1;                  
wire            mad_alu_rs1_cst_0;            
wire            mad_alu_rs1_vld;              
wire            mad_alu_rs2_cst_0;            
wire    [31:0]  mad_alu_rst;                  
wire            mad_alu_rst_vld;              
wire    [31:0]  oper_alu_rs1_reg;             
wire    [31:0]  oper_alu_rs2_imm;             
wire    [31:0]  oper_alu_rs2_reg;             
wire    [30:0]  pcgen_xx_cur_pc;              


//==============================================================================
//                          Operand Prepare Logic
//==============================================================================

//==========================================================
//            Register and Immediate Selection
//==========================================================
//the source 0 is always from source register
assign alu_mux_rs1[31:0] = mad_alu_rs1_vld ? mad_alu_rs1[31:0] 
                         : branch_alu_pc_sel ?{pcgen_xx_cur_pc[30:0], 1'b0}
                         : oper_alu_rs1_reg[31:0];
//the source 1 may from immediate when alu except ff1 of MAD
assign alu_rs2_imm_sel   = decd_alu_rs2_imm_vld || mad_alu_imm_vld
                            || lsu_iu_alu_sel || branch_alu_pc_sel;
assign alu_mux_rs2[31:0] = alu_rs2_imm_sel ? mad_alu_imm_vld ? lsu_iu_mad_buf[31:0] 
                                                             : oper_alu_rs2_imm[31:0]
                                           : oper_alu_rs2_reg[31:0];

//==========================================================
//              Operand Mux of Prepare Logic
//==========================================================
// &Force("input", "mad_alu_rs1_cst_0"); @54
assign alu_prepare_rs1_sel   = ctrl_alu_oper_mux_en || ctrl_alu_mad_oper_mux_en
                            || mad_alu_rs1_cst_0 || branch_alu_adder_sel
                            || lsu_iu_alu_sel || branch_alu_logic_sel;
assign alu_prepare_rs2_sel   = alu_prepare_rs1_sel || branch_alu_adder_sel
                            || lsu_iu_alu_sel || branch_alu_logic_sel;
assign alu_prepare_rs1[31:0] = {32{alu_prepare_rs1_sel}} & alu_mux_rs1[31:0];
assign alu_prepare_rs2[31:0] = {32{alu_prepare_rs2_sel}} & alu_mux_rs2[31:0];

//==========================================================
//                    DEST VLD prepare
//==========================================================
assign alu_dst_vld = decd_alu_dst_vld;

//==========================================================
//                    RS1   prepare
//==========================================================
assign alu_rs1_pre_cst_0 = mad_alu_rs1_cst_0;
//ALU source 1 prepare
assign alu_rs1[31:0]     = {32{~alu_rs1_pre_cst_0}} & alu_prepare_rs1[31:0];

//==========================================================
//                    RS2   prepare
//==========================================================
assign alu_rs2_pre_cst_0 = mad_alu_rs2_cst_0;
assign alu_rs2[31:0]     = {32{~alu_rs2_pre_cst_0}} & alu_prepare_rs2[31:0];

//==============================================================================
// ALU func and sub_func
//==============================================================================
assign alu_func[2:0]     = decd_alu_func[2:0];
assign alu_sub_func[3:0] = decd_alu_sub_func[3:0];

//==============================================================================
// Rename Input Signals
//==============================================================================
assign alu_sel         = ctrl_alu_ex_sel;
assign alu_adder_sel   = ctrl_alu_oper_mux_en && alu_func[0] 
                      || ctrl_alu_mad_oper_mux_en
                      || branch_alu_adder_sel 
                      || lsu_iu_alu_sel;
assign alu_logic_sel   = ctrl_alu_oper_mux_en && alu_func[1]
                      || branch_alu_logic_nz;
assign alu_shifter_sel = ctrl_alu_oper_mux_en && alu_func[2]
                      || ctrl_alu_mad_oper_mux_en && mad_alu_div_shift;
assign alu_shifter_rst_sel = ctrl_alu_oper_mux_en && alu_func[2];

//==============================================================================
// Adder
//==============================================================================
// &Force("bus","alu_sub_func",3,0); @116
assign alu_adder_c_sel[1:0] = {2{alu_adder_sel}} & alu_sub_func[2:1];

//================================================
// Adder Operand Mux
//================================================
//operand MUX to 0 if not selected, reducing power
assign alu_adder_rs1[31:0]         = {32{alu_adder_sel}} & alu_rs1[31:0];
assign alu_adder_rs2_pre_val[31:0] = {32{alu_adder_sel}} & (mad_alu_div_shift ?
                                               alu_shifter_rst_left_out[31:0]:
                                                                alu_rs2[31:0]);
//================================================
// Adder Operand Prepare
//================================================
assign alu_adder_reverse = !alu_sub_func[0] && !mad_alu_fst_add && !lsu_iu_alu_sel
                        || branch_alu_adder_cmp;
assign alu_adder_rs2[31:0] = alu_adder_reverse ? ~alu_adder_rs2_pre_val[31:0] 
                                               :  alu_adder_rs2_pre_val[31:0];

//================================================
// Implement of IU Shared Adder
//================================================
//operand mux between alu branch and lsu
assign alu_shared_adder_rs1[31:0] = alu_adder_rs1[31:0];
assign alu_shared_adder_rs2[31:0] = alu_adder_rs2[31:0];
assign alu_shared_adder_srcc      = alu_adder_reverse;

//implement of shared adder
assign {alu_shared_adder_cout,alu_shared_adder_rst[31:0]} =
       {1'b0, alu_shared_adder_rs1[31:0]} + {1'b0, alu_shared_adder_rs2[31:0]}
       + {32'b0, alu_shared_adder_srcc};
//out put rename
assign alu_adder_rst_out[31:0]    = alu_shared_adder_rst[31:0];

assign alu_adder_rst_cmp_unsigned_lt = !alu_shared_adder_cout;
//signed less than zero:
//if sign bit is same, see to result MSB
//otherwise see to source sign bits
assign alu_adder_rst_cmp_signed_lt = (alu_adder_rs1[31] & alu_adder_rs2[31])
                                  | ((alu_adder_rs1[31] ^ alu_adder_rs2[31])
                                        & alu_adder_rst_out[31]);

assign alu_adder_rst_cout = alu_adder_c_sel[0] && alu_adder_rst_cmp_unsigned_lt
                         || alu_adder_c_sel[1] && alu_adder_rst_cmp_signed_lt;

//==============================================================================
// Logic
//==============================================================================
//result selection bwtween MOV, AND, OR and XOR
assign alu_logic_rst_sel[3:0] = {4{alu_logic_sel}} & alu_sub_func[3:0];

//================================================
// Logic Operand Mux
//================================================
//operand MUX to 0 if not selected, reducing power
assign logic_rs1_sel = alu_logic_sel
                    || branch_alu_logic_sel;
assign alu_logic_rs1[31:0] = {32{logic_rs1_sel}} & alu_rs1[31:0];
assign alu_logic_rs2[31:0] = {32{alu_logic_sel}} & alu_rs2[31:0];

//================================================
// Logic Operation
//================================================
assign alu_logic_rst_out_mov[31:0] = alu_logic_rs2[31:0];
assign alu_logic_rst_out_and[31:0] = alu_logic_rs1[31:0] & alu_logic_rs2[31:0];
assign alu_logic_rst_out_or[31:0]  = alu_logic_rs1[31:0] | alu_logic_rs2[31:0];
assign alu_logic_rst_out_xor[31:0] = alu_logic_rs1[31:0] ^ alu_logic_rs2[31:0];

//================================================
// Logic result select
//================================================
assign alu_logic_rst_out[31:0] =
       {32{alu_logic_rst_sel[0]}} & alu_logic_rst_out_mov[31:0]
     | {32{alu_logic_rst_sel[1]}} & alu_logic_rst_out_and[31:0]
     | {32{alu_logic_rst_sel[2]}} & alu_logic_rst_out_or[31:0]
     | {32{alu_logic_rst_sel[3]}} & alu_logic_rst_out_xor[31:0];

//==============================================================================
// Shifter
//==============================================================================

//=========================================================
// Rename Input Signals
//=========================================================
//shift direction: 0 for left, 1 for right
assign alu_shifter_shift_dr    = alu_shifter_sel && !alu_sub_func[1];
//shift in bit: 0 for zero, 1 for sign bits
assign alu_shifter_shift_in    = alu_shifter_sel && alu_sub_func[0];

//operand MUX to 0 if not selected, reducing power
assign alu_shifter_rs1_pre[31:0] = {32{alu_shifter_sel}} & (mad_alu_div_shift ?
                                                            mad_alu_div_rs2[31:0] :
                                                            alu_rs1[31:0]);
assign alu_shifter_rs2[4:0]      =  {5{alu_shifter_sel}} & (mad_alu_div_shift ?
                                                           (ifu_iu_ex_cnt[4:0]): 
                                                            alu_rs2[4:0]);

//==========================================================
// SHIFTER RS1 Prepare
//==========================================================
assign alu_shifter_rs1_reverse[31:0] = {alu_shifter_rs1_pre[0],  alu_shifter_rs1_pre[1],
                                        alu_shifter_rs1_pre[2],  alu_shifter_rs1_pre[3],
                                        alu_shifter_rs1_pre[4],  alu_shifter_rs1_pre[5],
                                        alu_shifter_rs1_pre[6],  alu_shifter_rs1_pre[7],
                                        alu_shifter_rs1_pre[8],  alu_shifter_rs1_pre[9],
                                        alu_shifter_rs1_pre[10], alu_shifter_rs1_pre[11],
                                        alu_shifter_rs1_pre[12], alu_shifter_rs1_pre[13],
                                        alu_shifter_rs1_pre[14], alu_shifter_rs1_pre[15],
                                        alu_shifter_rs1_pre[16], alu_shifter_rs1_pre[17],
                                        alu_shifter_rs1_pre[18], alu_shifter_rs1_pre[19],
                                        alu_shifter_rs1_pre[20], alu_shifter_rs1_pre[21],
                                        alu_shifter_rs1_pre[22], alu_shifter_rs1_pre[23],
                                        alu_shifter_rs1_pre[24], alu_shifter_rs1_pre[25],
                                        alu_shifter_rs1_pre[26], alu_shifter_rs1_pre[27],
                                        alu_shifter_rs1_pre[28], alu_shifter_rs1_pre[29],
                                        alu_shifter_rs1_pre[30], alu_shifter_rs1_pre[31]
                                        };

assign alu_shifter_rs1[31:0] = alu_shifter_shift_dr ? alu_shifter_rs1_pre[31:0]
                                                    : alu_shifter_rs1_reverse[31:0];

//==========================================================
// Prepare Shift In Bits
//==========================================================
//when left shift, the shift in bit is zer0
assign alu_shifter_right_in = alu_shifter_shift_in & alu_shifter_rs1_pre[31];
assign alu_shifter_right_in_mask[31:0] = {32{alu_shifter_right_in}};

//==========================================================
// Implement of Right Shifter
//==========================================================
// &CombBeg; @252
always @( alu_shifter_right_in_mask[30:0]
       or alu_shifter_rs2[4:0]
       or alu_shifter_rs1[31:0])
begin
  case(alu_shifter_rs2[4:0])
  5'b00000:
     alu_shifter_right_rst[31:0] = alu_shifter_rs1[31:0];
  5'b00001:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[0], alu_shifter_rs1[31:1]};
  5'b00010:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[1:0], alu_shifter_rs1[31:2]};
  5'b00011:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[2:0], alu_shifter_rs1[31:3]};
  5'b00100:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[3:0], alu_shifter_rs1[31:4]};
  5'b00101:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[4:0], alu_shifter_rs1[31:5]};
  5'b00110:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[5:0], alu_shifter_rs1[31:6]};
  5'b00111:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[6:0], alu_shifter_rs1[31:7]};
  5'b01000:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[7:0], alu_shifter_rs1[31:8]};
  5'b01001:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[8:0], alu_shifter_rs1[31:9]};
  5'b01010:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[9:0], alu_shifter_rs1[31:10]};
  5'b01011:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[10:0], alu_shifter_rs1[31:11]};
  5'b01100:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[11:0], alu_shifter_rs1[31:12]};
  5'b01101:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[12:0], alu_shifter_rs1[31:13]};
  5'b01110:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[13:0], alu_shifter_rs1[31:14]};
  5'b01111:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[14:0], alu_shifter_rs1[31:15]};
  5'b10000:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[15:0], alu_shifter_rs1[31:16]};
  5'b10001:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[16:0], alu_shifter_rs1[31:17]};
  5'b10010:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[17:0], alu_shifter_rs1[31:18]};
  5'b10011:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[18:0], alu_shifter_rs1[31:19]};
  5'b10100:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[19:0], alu_shifter_rs1[31:20]};
  5'b10101:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[20:0], alu_shifter_rs1[31:21]};
  5'b10110:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[21:0], alu_shifter_rs1[31:22]};
  5'b10111:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[22:0], alu_shifter_rs1[31:23]};
  5'b11000:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[23:0], alu_shifter_rs1[31:24]};
  5'b11001:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[24:0], alu_shifter_rs1[31:25]};
  5'b11010:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[25:0], alu_shifter_rs1[31:26]};
  5'b11011:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[26:0], alu_shifter_rs1[31:27]};
  5'b11100:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[27:0], alu_shifter_rs1[31:28]};
  5'b11101:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[28:0], alu_shifter_rs1[31:29]};
  5'b11110:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[29:0], alu_shifter_rs1[31:30]};
  5'b11111:
     alu_shifter_right_rst[31:0]
                      = {alu_shifter_right_in_mask[30:0], alu_shifter_rs1[31]};
  default:
     alu_shifter_right_rst[31:0]
                      = 32'bx;
  endcase
// &CombEnd; @353
end

//==========================================================
// Right Shifter result to c
//==========================================================
assign alu_shifter_rst_right_out[31:0] = alu_shifter_right_rst[31:0];

assign alu_shifter_rst_left_out[31:0] =
                                {alu_shifter_rst_right_out[0], alu_shifter_rst_right_out[1],
                                 alu_shifter_rst_right_out[2], alu_shifter_rst_right_out[3],
                                 alu_shifter_rst_right_out[4], alu_shifter_rst_right_out[5],
                                 alu_shifter_rst_right_out[6], alu_shifter_rst_right_out[7],
                                 alu_shifter_rst_right_out[8], alu_shifter_rst_right_out[9],
                                 alu_shifter_rst_right_out[10],alu_shifter_rst_right_out[11],
                                 alu_shifter_rst_right_out[12],alu_shifter_rst_right_out[13],
                                 alu_shifter_rst_right_out[14],alu_shifter_rst_right_out[15],
                                 alu_shifter_rst_right_out[16],alu_shifter_rst_right_out[17],
                                 alu_shifter_rst_right_out[18],alu_shifter_rst_right_out[19],
                                 alu_shifter_rst_right_out[20],alu_shifter_rst_right_out[21],
                                 alu_shifter_rst_right_out[22],alu_shifter_rst_right_out[23],
                                 alu_shifter_rst_right_out[24],alu_shifter_rst_right_out[25],
                                 alu_shifter_rst_right_out[26],alu_shifter_rst_right_out[27],
                                 alu_shifter_rst_right_out[28],alu_shifter_rst_right_out[29],
                                 alu_shifter_rst_right_out[30],alu_shifter_rst_right_out[31]
                                };

//==========================================================
// Shifter result request
//==========================================================
assign alu_shifter_rst_out[31:0] = alu_shifter_shift_dr
                                 ? alu_shifter_rst_right_out[31:0]
                                 : alu_shifter_rst_left_out[31:0];

//==============================================================================
// Share the Adder data path with MAD summation
//==============================================================================
assign alu_adder_shared_rst_out[31:0] = mad_alu_rst_vld ? mad_alu_rst[31:0]
                                      : (alu_sub_func[2] || alu_sub_func[1]) 
                                      ? {31'b0, alu_adder_rst_cout}
                                      : alu_adder_rst_out[31:0];

//==============================================================================
// ALU to MAD
assign alu_mad_adder_rst[31:0]    = alu_shared_adder_rst[31:0];
assign alu_mad_rst_cout           = alu_adder_rst_cout;
// overflow infor for mult high
assign alu_mad_adder_of           = alu_shared_adder_cout;

//==============================================================================
// ALU to branch
assign alu_branch_rst_sign   = alu_adder_rst_cmp_signed_lt;
assign alu_branch_rst_unsign = alu_adder_rst_cmp_unsigned_lt;
assign alu_branch_xor_rst[31:0] = alu_logic_rst_out_xor[31:0];
assign alu_branch_adder_rst[31:0] = {alu_adder_rst_out[31:1], 1'b0};

assign iu_lsu_adder_rst[31:0] = alu_shared_adder_rst[31:0];

//==============================================================================
// ALU result request
//==============================================================================
//result bus request
assign alu_rbus_req = alu_sel;
//data valid
assign alu_rbus_data_vld = (ctrl_mad_ex_data_sel)
                           ? mad_alu_data_vld
                           : alu_dst_vld;
//data
// &Force("nonport", "alu_shifter_rst_sel"); @431
assign alu_rbus_data[31:0] = {32{alu_adder_sel}}   & alu_adder_shared_rst_out[31:0]
                           | {32{alu_logic_sel}}   & alu_logic_rst_out[31:0]
                           | {32{alu_shifter_rst_sel}} & alu_shifter_rst_out[31:0];

// &ModuleEnd; @441
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @25
module cr_iu_branch(
  alu_branch_adder_rst,
  alu_branch_rst_sign,
  alu_branch_rst_unsign,
  alu_branch_xor_rst,
  branch_alu_adder_cmp,
  branch_alu_adder_sel,
  branch_alu_logic_nz,
  branch_alu_logic_sel,
  branch_alu_pc_sel,
  branch_ctrl_stall,
  branch_pcgen_add_pc,
  branch_pcgen_br_chgflw_vld,
  branch_pcgen_br_chgflw_vld_for_data,
  branch_pcgen_br_pc_chgflw_vld,
  branch_pcgen_branch_chgflw_vld_for_data,
  branch_pcgen_jmp_chgflw_vld_for_data,
  branch_pcgen_reg_pc,
  branch_rbus_data,
  branch_rbus_data_vld,
  branch_rbus_req,
  branch_wb_cmp,
  branch_wb_jmp_reg,
  ctrl_branch_ex_data_sel,
  ctrl_branch_ex_sel,
  decd_branch_auipc,
  decd_branch_beq,
  decd_branch_bge,
  decd_branch_bgeu,
  decd_branch_blt,
  decd_branch_bltu,
  decd_branch_bne,
  decd_branch_cbeqz,
  decd_branch_cbnez,
  decd_branch_cj,
  decd_branch_cjal,
  decd_branch_cjalr,
  decd_branch_cjr,
  decd_branch_jal,
  decd_branch_jalr,
  decd_xx_inst_32bit,
  iu_had_chgflw_dst_pc,
  iu_had_chgflw_vld,
  oper_branch_rs1_reg,
  oper_branch_rs2_imm,
  oper_branch_rs2_reg,
  pcgen_xx_cur_pc,
  pcgen_xx_ibus_idle,
  retire_branch_stall,
  wb_branch_dep_ld,
  wb_ctrl_stall_without_hready
);

// &Ports; @26
input   [31:0]  alu_branch_adder_rst;                   
input           alu_branch_rst_sign;                    
input           alu_branch_rst_unsign;                  
input   [31:0]  alu_branch_xor_rst;                     
input           ctrl_branch_ex_data_sel;                
input           ctrl_branch_ex_sel;                     
input           decd_branch_auipc;                      
input           decd_branch_beq;                        
input           decd_branch_bge;                        
input           decd_branch_bgeu;                       
input           decd_branch_blt;                        
input           decd_branch_bltu;                       
input           decd_branch_bne;                        
input           decd_branch_cbeqz;                      
input           decd_branch_cbnez;                      
input           decd_branch_cj;                         
input           decd_branch_cjal;                       
input           decd_branch_cjalr;                      
input           decd_branch_cjr;                        
input           decd_branch_jal;                        
input           decd_branch_jalr;                       
input           decd_xx_inst_32bit;                     
input   [31:0]  oper_branch_rs1_reg;                    
input   [31:0]  oper_branch_rs2_imm;                    
input   [31:0]  oper_branch_rs2_reg;                    
input   [30:0]  pcgen_xx_cur_pc;                        
input           pcgen_xx_ibus_idle;                     
input           retire_branch_stall;                    
input           wb_branch_dep_ld;                       
input           wb_ctrl_stall_without_hready;           
output          branch_alu_adder_cmp;                   
output          branch_alu_adder_sel;                   
output          branch_alu_logic_nz;                    
output          branch_alu_logic_sel;                   
output          branch_alu_pc_sel;                      
output          branch_ctrl_stall;                      
output  [30:0]  branch_pcgen_add_pc;                    
output          branch_pcgen_br_chgflw_vld;             
output          branch_pcgen_br_chgflw_vld_for_data;    
output          branch_pcgen_br_pc_chgflw_vld;          
output          branch_pcgen_branch_chgflw_vld_for_data; 
output          branch_pcgen_jmp_chgflw_vld_for_data;   
output  [30:0]  branch_pcgen_reg_pc;                    
output  [31:0]  branch_rbus_data;                       
output          branch_rbus_data_vld;                   
output          branch_rbus_req;                        
output          branch_wb_cmp;                          
output          branch_wb_jmp_reg;                      
output  [31:0]  iu_had_chgflw_dst_pc;                   
output          iu_had_chgflw_vld;                      

// &Regs; @27

// &Wires; @28
wire    [31:0]  adder_pc;                               
wire    [31:0]  adder_src0;                             
wire    [31:0]  adder_src1;                             
wire    [31:0]  alu_branch_adder_rst;                   
wire            alu_branch_rst_sign;                    
wire            alu_branch_rst_unsign;                  
wire    [31:0]  alu_branch_xor_rst;                     
wire            branch_alu_adder_cmp;                   
wire            branch_alu_adder_sel;                   
wire            branch_alu_logic_nz;                    
wire            branch_alu_logic_sel;                   
wire            branch_alu_pc_sel;                      
wire            branch_br;                              
wire            branch_br_chgflw;                       
wire            branch_br_cmp;                          
wire            branch_br_cmpu;                         
wire            branch_br_eql;                          
wire            branch_br_xor;                          
wire            branch_cmp_result;                      
wire            branch_ctrl_stall;                      
wire            branch_eql_result;                      
wire    [31:0]  branch_imm;                             
wire            branch_jmp;                             
wire            branch_jmp_pc;                          
wire            branch_jmp_reg;                         
wire            branch_link;                            
wire    [30:0]  branch_pcgen_add_pc;                    
wire            branch_pcgen_br_chgflw_vld;             
wire            branch_pcgen_br_chgflw_vld_for_data;    
wire            branch_pcgen_br_pc_chgflw_vld;          
wire            branch_pcgen_branch_chgflw_vld_for_data; 
wire            branch_pcgen_jmp_chgflw_vld_for_data;   
wire    [30:0]  branch_pcgen_reg_pc;                    
wire    [31:0]  branch_rbus_data;                       
wire            branch_rbus_data_vld;                   
wire            branch_rbus_req;                        
wire    [31:0]  branch_rs1;                             
wire            branch_stall;                           
wire            branch_taken;                           
wire            branch_wb_cmp;                          
wire            branch_wb_jmp_reg;                      
wire            ctrl_branch_ex_data_sel;                
wire            ctrl_branch_ex_sel;                     
wire            decd_branch_auipc;                      
wire            decd_branch_beq;                        
wire            decd_branch_bge;                        
wire            decd_branch_bgeu;                       
wire            decd_branch_blt;                        
wire            decd_branch_bltu;                       
wire            decd_branch_bne;                        
wire            decd_branch_cbeqz;                      
wire            decd_branch_cbnez;                      
wire            decd_branch_cj;                         
wire            decd_branch_cjal;                       
wire            decd_branch_cjalr;                      
wire            decd_branch_cjr;                        
wire            decd_branch_jal;                        
wire            decd_branch_jalr;                       
wire            decd_xx_inst_32bit;                     
wire    [31:0]  inc_offset;                             
wire            inst_auipc;                             
wire            inst_beq;                               
wire            inst_bge;                               
wire            inst_bgeu;                              
wire            inst_blt;                               
wire            inst_bltu;                              
wire            inst_bne;                               
wire            inst_cbeqz;                             
wire            inst_cbnez;                             
wire            inst_cj;                                
wire            inst_cjal;                              
wire            inst_cjalr;                             
wire            inst_cjr;                               
wire            inst_jal;                               
wire            inst_jalr;                              
wire    [31:0]  iu_had_chgflw_dst_pc;                   
wire            iu_had_chgflw_vld;                      
wire    [31:0]  oper_branch_rs1_reg;                    
wire    [31:0]  oper_branch_rs2_imm;                    
wire    [30:0]  pcgen_xx_cur_pc;                        
wire            pcgen_xx_ibus_idle;                     
wire            retire_branch_stall;                    
wire    [31:0]  target_pc;                              
wire            wb_branch_dep_ld;                       
wire            wb_ctrl_stall_without_hready;           


//==============================================================================
//                      Operands and Operation Prepare
//==============================================================================

//-----------------------------------------------------
// Rename Input Signals
//-----------------------------------------------------
assign inst_cj    = decd_branch_cj;
assign inst_cjal  = decd_branch_cjal;
assign inst_cjr   = decd_branch_cjr;
assign inst_cjalr = decd_branch_cjalr;
assign inst_cbeqz = decd_branch_cbeqz;
assign inst_cbnez = decd_branch_cbnez;
assign inst_auipc = decd_branch_auipc;
assign inst_jal   = decd_branch_jal;
assign inst_jalr  = decd_branch_jalr;
assign inst_beq   = decd_branch_beq;
assign inst_bne   = decd_branch_bne;
assign inst_blt   = decd_branch_blt;
assign inst_bge   = decd_branch_bge;
assign inst_bltu  = decd_branch_bltu;
assign inst_bgeu  = decd_branch_bgeu;

//-----------------------------------------------------
// Function Prepare
//-----------------------------------------------------
assign branch_jmp_pc  = inst_cj   || inst_cjal  || inst_jal;
assign branch_jmp_reg = inst_cjr  || inst_cjalr || inst_jalr;
assign branch_br_cmp  = inst_blt  || inst_bge;
assign branch_br_cmpu = inst_bltu || inst_bgeu;
assign branch_br_xor  = inst_beq  || inst_bne;

assign branch_jmp     = branch_jmp_pc || inst_jalr;
assign branch_link    = inst_cjal || inst_cjalr || inst_jal || inst_jalr;

//-----------------------------------------------------
// Operands Prepare
//-----------------------------------------------------
assign branch_rs1[31:0] = {32{ctrl_branch_ex_data_sel}} & oper_branch_rs1_reg[31:0];
//assign branch_rs1[31:0] = {32{branch_jmp_reg}} & oper_branch_rs1_reg[31:0];
assign branch_imm[31:0] = oper_branch_rs2_imm[31:0];
//-----------------------------------------------------
// Compute
//-----------------------------------------------------
// adder
assign adder_src0[31:0] = {pcgen_xx_cur_pc[30:0], 1'b0};
assign adder_src1[31:0] = (ctrl_branch_ex_data_sel && branch_taken) ? 
                           branch_imm[31:0] : inc_offset[31:0];
assign inc_offset[31:0] = {29'b0, decd_xx_inst_32bit, !decd_xx_inst_32bit, 1'b0};
assign adder_pc[31:0]   = adder_src0[31:0] + adder_src1[31:0];

assign branch_taken = (inst_beq || inst_cbeqz) && !branch_eql_result
                   || (inst_bne || inst_cbnez) &&  branch_eql_result
                   || (inst_bge || inst_bgeu)  && !branch_cmp_result
                   || (inst_blt || inst_bltu)  &&  branch_cmp_result;

//take direct branchs updata pc valid signal
//br, bsr, jmp, jsr, and taken br, bf
assign branch_br_chgflw  = (branch_taken || branch_jmp_pc || branch_jmp_reg)
                                  && !(wb_branch_dep_ld && branch_link);

//when branch disable, the branch dbg_disable info is depend
//on the target addr
assign branch_stall      = retire_branch_stall //for dbg disable
                        || wb_branch_dep_ld && branch_link
                        || (branch_br_chgflw && !pcgen_xx_ibus_idle);
assign branch_ctrl_stall = ctrl_branch_ex_data_sel && branch_stall;

//-----------------------------------------------------
// result bus request
//-----------------------------------------------------
// branch complete when receiving direct branches, and
// indirect branches complete when mpu access dent or
// transcmplt
assign branch_rbus_req = ctrl_branch_ex_sel && !branch_stall;// && aranch_br

//-----------------------------------------------------
// result bus request data and data valid
//-----------------------------------------------------
//lrw and subroutine call need write back
assign branch_rbus_data_vld   = branch_link;// || inst_auipc;
//assign branch_rbus_data[31:0] = {32{branch_link}} & alu_branch_adder_rst[31:0]
assign branch_rbus_data[31:0] = {32{branch_link}} & {adder_pc[31:1], 1'b0}
                              ;//| {32{inst_auipc}} & target_pc[31:0];

assign branch_br_eql     = inst_beq  || inst_bne || inst_cbeqz || inst_cbnez;
assign branch_br         = branch_br_cmp || branch_br_cmpu || branch_br_eql;
assign branch_wb_cmp     = ctrl_branch_ex_data_sel && branch_br;
assign branch_wb_jmp_reg = ctrl_branch_ex_data_sel && branch_jmp_reg;
//-----------------------------------------------------
// Indicate jump register to set stall signal
//-----------------------------------------------------
// &Force("input","oper_branch_rs2_reg"); @157
// &Force("bus","oper_branch_rs2_reg",31,0); @158
assign branch_alu_adder_sel = ctrl_branch_ex_data_sel && (branch_br_cmp ||
                                                          branch_br_cmpu ||
                                                          branch_jmp_reg ||
                                                          branch_jmp_pc);
assign branch_alu_adder_cmp = ctrl_branch_ex_data_sel && (branch_br_cmp ||
                                                          branch_br_cmpu);
assign branch_alu_logic_sel = inst_beq || inst_bne || inst_cbeqz || inst_cbnez;
assign branch_alu_logic_nz = branch_br_xor;

assign branch_alu_pc_sel = inst_auipc || branch_jmp_pc;

assign branch_eql_result = |alu_branch_xor_rst[31:0];
assign branch_cmp_result = branch_br_cmp ? alu_branch_rst_sign
                                         : alu_branch_rst_unsign;

assign target_pc[31:0]  = (branch_jmp_pc || branch_jmp_reg) ? alu_branch_adder_rst[31:0]
                         : {adder_pc[31:1], 1'b0};

//==========================================================
//          Interface with ibus and IFU change flow
//==========================================================
//-----------------------------------------------------
// direct branch change flow
//-----------------------------------------------------
//branch unit request when receiving jsr and jmp except jmp r15
// &Force("output","branch_pcgen_br_pc_chgflw_vld"); @185
assign branch_pcgen_br_chgflw_vld             = ctrl_branch_ex_data_sel && branch_br_chgflw
                                             && !wb_ctrl_stall_without_hready
                                             && pcgen_xx_ibus_idle;
assign branch_pcgen_br_chgflw_vld_for_data    = ctrl_branch_ex_data_sel && branch_br_chgflw
                                             && pcgen_xx_ibus_idle;
//all direct branch should update pc
assign branch_pcgen_br_pc_chgflw_vld          = ctrl_branch_ex_sel && branch_br_chgflw
                                             && !branch_stall;
assign branch_pcgen_branch_chgflw_vld_for_data = ctrl_branch_ex_data_sel
                                              && (branch_taken || branch_jmp);
assign branch_pcgen_jmp_chgflw_vld_for_data    = ctrl_branch_ex_data_sel
                                              && (inst_cjr || inst_cjalr); 

//-----------------------------------------------------
// direct branch change flow
//-----------------------------------------------------
//the change flow address is from register or offset summation
// &Force("output","branch_pcgen_reg_pc"); @203
// &Force("output","branch_pcgen_add_pc"); @204
// &Force("bus","lsu_iu_branch_rst", 31, 0); @205
assign branch_pcgen_reg_pc[30:0] = branch_rs1[31:1];
assign branch_pcgen_add_pc[30:0] = target_pc[31:1];

assign iu_had_chgflw_vld = branch_pcgen_br_pc_chgflw_vld;
assign iu_had_chgflw_dst_pc[31:0] = branch_jmp_reg ? {branch_pcgen_reg_pc[30:0], 1'b0}
                                                   : {branch_pcgen_add_pc[30:0], 1'b0};
// &ModuleEnd; @214
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @25
module cr_iu_ctrl(
  branch_ctrl_stall,
  cp0_iu_stall,
  cp0_iu_stall_noinput,
  cp0_yy_priv_mode,
  ctrl_alu_ex_data_sel,
  ctrl_alu_ex_sel,
  ctrl_alu_mad_oper_mux_en,
  ctrl_alu_oper_mux_en,
  ctrl_branch_ex_data_sel,
  ctrl_branch_ex_sel,
  ctrl_cp0_ex_data_sel,
  ctrl_lsu_ex_data_sel,
  ctrl_mad_ex_data_sel,
  ctrl_mad_ex_sel,
  ctrl_mad_oper_mux_en,
  ctrl_oper_lsu_data_sel,
  ctrl_retire_ni_vld,
  ctrl_special_ex_data_sel,
  ctrl_special_ex_sel,
  ctrl_special_expt_vec,
  ctrl_special_expt_vld,
  ctrl_xx_sp_adjust,
  decd_ctrl_alu_sel,
  decd_ctrl_branch_sel,
  decd_ctrl_cp0_sel,
  decd_ctrl_expt_bkpt,
  decd_ctrl_expt_ecall,
  decd_ctrl_expt_inv,
  decd_ctrl_expt_wsc,
  decd_ctrl_lsu_sel,
  decd_ctrl_mad_sel,
  decd_xx_unit_special_sel,
  hs_split_iu_ctrl_inst_vld,
  ifu_iu_ex_expt_vld,
  ifu_iu_ex_inst_vld,
  ifu_iu_ex_ni,
  ifu_iu_ex_prvlg_expt_vld,
  ifu_iu_ex_rand_vld,
  iu_cp0_ecall,
  iu_cp0_ex_data_sel,
  iu_cp0_ex_sel,
  iu_cp0_oper_mux_en,
  iu_hs_split_ex_stall,
  iu_ifu_ex_stall,
  iu_ifu_ex_stall_noinput,
  iu_ifu_ex_vld,
  iu_ifu_wb_stall,
  iu_lsu_ex_data_sel,
  iu_lsu_ex_sel,
  iu_lsu_oper_mux_en,
  lsu_iu_stall,
  lsu_iu_stall_noinput,
  mad_ctrl_stall,
  mad_ctrl_stall_noinput,
  pcgen_ctrl_stall,
  special_ctrl_stall,
  special_ctrl_stall_noinput,
  vector_ctrl_stall,
  wb_ctrl_stall
);

// &Ports; @26
input          branch_ctrl_stall;          
input          cp0_iu_stall;               
input          cp0_iu_stall_noinput;       
input   [1:0]  cp0_yy_priv_mode;           
input          decd_ctrl_alu_sel;          
input          decd_ctrl_branch_sel;       
input          decd_ctrl_cp0_sel;          
input          decd_ctrl_expt_bkpt;        
input          decd_ctrl_expt_ecall;       
input          decd_ctrl_expt_inv;         
input          decd_ctrl_expt_wsc;         
input          decd_ctrl_lsu_sel;          
input          decd_ctrl_mad_sel;          
input          decd_xx_unit_special_sel;   
input          hs_split_iu_ctrl_inst_vld;  
input          ifu_iu_ex_expt_vld;         
input          ifu_iu_ex_inst_vld;         
input          ifu_iu_ex_ni;               
input          ifu_iu_ex_prvlg_expt_vld;   
input          ifu_iu_ex_rand_vld;         
input          lsu_iu_stall;               
input          lsu_iu_stall_noinput;       
input          mad_ctrl_stall;             
input          mad_ctrl_stall_noinput;     
input          pcgen_ctrl_stall;           
input          special_ctrl_stall;         
input          special_ctrl_stall_noinput; 
input          vector_ctrl_stall;          
input          wb_ctrl_stall;              
output         ctrl_alu_ex_data_sel;       
output         ctrl_alu_ex_sel;            
output         ctrl_alu_mad_oper_mux_en;   
output         ctrl_alu_oper_mux_en;       
output         ctrl_branch_ex_data_sel;    
output         ctrl_branch_ex_sel;         
output         ctrl_cp0_ex_data_sel;       
output         ctrl_lsu_ex_data_sel;       
output         ctrl_mad_ex_data_sel;       
output         ctrl_mad_ex_sel;            
output         ctrl_mad_oper_mux_en;       
output         ctrl_oper_lsu_data_sel;     
output         ctrl_retire_ni_vld;         
output         ctrl_special_ex_data_sel;   
output         ctrl_special_ex_sel;        
output  [4:0]  ctrl_special_expt_vec;      
output         ctrl_special_expt_vld;      
output         ctrl_xx_sp_adjust;          
output         iu_cp0_ecall;               
output         iu_cp0_ex_data_sel;         
output         iu_cp0_ex_sel;              
output         iu_cp0_oper_mux_en;         
output         iu_hs_split_ex_stall;       
output         iu_ifu_ex_stall;            
output         iu_ifu_ex_stall_noinput;    
output         iu_ifu_ex_vld;              
output         iu_ifu_wb_stall;            
output         iu_lsu_ex_data_sel;         
output         iu_lsu_ex_sel;              
output         iu_lsu_oper_mux_en;         

// &Regs; @27
reg     [4:0]  ctrl_special_expt_vec;      

// &Wires; @28
wire           bctm_ctrl_stall;            
wire           branch_ctrl_stall;          
wire           cp0_iu_stall;               
wire           cp0_iu_stall_noinput;       
wire    [1:0]  cp0_yy_priv_mode;           
wire           ctrl_alu_ex_data_sel;       
wire           ctrl_alu_ex_sel;            
wire           ctrl_alu_mad_oper_mux_en;   
wire           ctrl_alu_oper_mux_en;       
wire           ctrl_branch_ex_data_sel;    
wire           ctrl_branch_ex_sel;         
wire           ctrl_cp0_ex_data_sel;       
wire           ctrl_ex_inst_vld;           
wire           ctrl_internal_stall;        
wire           ctrl_lsu_ex_data_sel;       
wire           ctrl_mad_ex_data_sel;       
wire           ctrl_mad_ex_sel;            
wire           ctrl_mad_oper_mux_en;       
wire           ctrl_oper_lsu_data_sel;     
wire           ctrl_retire_ni_vld;         
wire           ctrl_special_ex_data_sel;   
wire           ctrl_special_ex_sel;        
wire           ctrl_special_expt_vld;      
wire           ctrl_xx_sp_adjust;          
wire           decd_ctrl_alu_sel;          
wire           decd_ctrl_branch_sel;       
wire           decd_ctrl_cp0_sel;          
wire           decd_ctrl_expt_bkpt;        
wire           decd_ctrl_expt_ecall;       
wire           decd_ctrl_expt_inv;         
wire           decd_ctrl_expt_wsc;         
wire           decd_ctrl_lsu_sel;          
wire           decd_ctrl_mad_sel;          
wire           decd_xx_unit_special_sel;   
wire           hs_split_iu_ctrl_inst_vld;  
wire           ifu_iu_ex_expt_vld;         
wire           ifu_iu_ex_hs_split_expt_vld; 
wire           ifu_iu_ex_hs_split_inst_vld; 
wire           ifu_iu_ex_inst_vld;         
wire           ifu_iu_ex_ni;               
wire           ifu_iu_ex_prvlg_expt_vld;   
wire           ifu_iu_ex_rand_vld;         
wire           iu_cp0_ecall;               
wire           iu_cp0_ex_data_sel;         
wire           iu_cp0_ex_sel;              
wire           iu_cp0_oper_mux_en;         
wire           iu_hs_split_ex_stall;       
wire           iu_ifu_ex_stall;            
wire           iu_ifu_ex_stall_noinput;    
wire           iu_ifu_ex_vld;              
wire           iu_ifu_wb_stall;            
wire           iu_lsu_ex_data_sel;         
wire           iu_lsu_ex_sel;              
wire           iu_lsu_oper_mux_en;         
wire           lsu_iu_stall;               
wire           lsu_iu_stall_noinput;       
wire           mad_ctrl_stall;             
wire           mad_ctrl_stall_noinput;     
wire           pcgen_ctrl_stall;           
wire           predec_lsu_sel;             
wire           sec_ctrl_stall;             
wire           special_ctrl_stall;         
wire           special_ctrl_stall_noinput; 
wire           vector_ctrl_stall;          
wire           wb_ctrl_stall;              


//==========================================================
//                  IU internal stall
//==========================================================
//1.write buffer will stall when load/store not complete
//2.jump register source cannot forward from load value
//  set stall in this condition
assign ifu_iu_ex_hs_split_inst_vld = ifu_iu_ex_inst_vld || hs_split_iu_ctrl_inst_vld;
assign ctrl_internal_stall  = ifu_iu_ex_hs_split_inst_vld
                              && wb_ctrl_stall;
assign iu_ifu_wb_stall = ctrl_internal_stall;

//==========================================================
//                  Generate stall signal
//==========================================================
assign bctm_ctrl_stall = 1'b0;
assign sec_ctrl_stall = 1'b0;
//the stall signal does not contain ex_inst_vld here, each
//execution unit will signal stall when it is valid
assign iu_ifu_ex_stall = ctrl_internal_stall
                         || branch_ctrl_stall
                         || pcgen_ctrl_stall
                         || vector_ctrl_stall
                         || cp0_iu_stall
                         || lsu_iu_stall
                         || mad_ctrl_stall
                         || special_ctrl_stall
                         || bctm_ctrl_stall
                         || sec_ctrl_stall;
assign iu_hs_split_ex_stall = ctrl_internal_stall || lsu_iu_stall;
// &Force("output","iu_ifu_ex_stall"); @65
assign iu_ifu_ex_vld  = ifu_iu_ex_hs_split_inst_vld;
assign iu_ifu_ex_stall_noinput = 
                            branch_ctrl_stall
                         || pcgen_ctrl_stall
                         || vector_ctrl_stall
                         || cp0_iu_stall_noinput
                         || lsu_iu_stall_noinput
                         || mad_ctrl_stall_noinput
                         || special_ctrl_stall_noinput
                         || bctm_ctrl_stall
                         || sec_ctrl_stall;

//==========================================================
//                Random Isntruction Valid
//==========================================================
//1.write buffer stall will make ex pipeline not valid
//2.random instruction does not generate control
//  path selection but turns on data path selection
assign ctrl_ex_inst_vld      = ifu_iu_ex_hs_split_inst_vld
                               && !ifu_iu_ex_rand_vld
                               && !ctrl_internal_stall;

//==========================================================
//             Execution Unit selection signal
//==========================================================
assign predec_lsu_sel    = decd_ctrl_lsu_sel;

// &Force("bus","decd_xx_unit_sel",6,0); @93
assign ctrl_alu_ex_sel       = ctrl_ex_inst_vld && !decd_xx_unit_special_sel && decd_ctrl_alu_sel;
assign ctrl_mad_ex_sel       = ctrl_ex_inst_vld && !decd_xx_unit_special_sel && decd_ctrl_mad_sel;
assign iu_lsu_ex_sel         = ctrl_ex_inst_vld && !decd_xx_unit_special_sel && predec_lsu_sel;
assign ctrl_special_ex_sel   = ctrl_ex_inst_vld &&  decd_xx_unit_special_sel;
assign iu_cp0_ex_sel         = ctrl_ex_inst_vld && !decd_xx_unit_special_sel && decd_ctrl_cp0_sel;
//branch unit is decd precisely, need't to see decd_xx_unit_special_sel
assign ctrl_branch_ex_sel    = ctrl_ex_inst_vld && decd_ctrl_branch_sel;
assign ctrl_alu_oper_mux_en     = decd_ctrl_alu_sel || ifu_iu_ex_rand_vld;
assign ctrl_mad_oper_mux_en     = decd_ctrl_mad_sel;
assign ctrl_alu_mad_oper_mux_en = decd_ctrl_mad_sel;
//assign iu_cp0_oper_mux_en       = (seu_xx_oper_mux_en[4] || decd_ctrl_cp0_sel);
assign iu_cp0_oper_mux_en       = decd_ctrl_cp0_sel;
assign iu_cp0_ecall             = decd_ctrl_expt_ecall;

assign iu_lsu_oper_mux_en       = predec_lsu_sel;

//the data path selection signal is only from decode information,
assign ctrl_alu_ex_data_sel     = ifu_iu_ex_hs_split_inst_vld && !ifu_iu_ex_rand_vld && decd_ctrl_alu_sel;
assign ctrl_mad_ex_data_sel     = ifu_iu_ex_hs_split_inst_vld && !ifu_iu_ex_rand_vld && decd_ctrl_mad_sel;
assign ctrl_lsu_ex_data_sel     = ifu_iu_ex_hs_split_inst_vld && !ifu_iu_ex_rand_vld && predec_lsu_sel;
assign ctrl_special_ex_data_sel = ifu_iu_ex_hs_split_inst_vld && !ifu_iu_ex_rand_vld && decd_xx_unit_special_sel;
assign ctrl_cp0_ex_data_sel     = ifu_iu_ex_hs_split_inst_vld && !ifu_iu_ex_rand_vld && decd_ctrl_cp0_sel;
assign ctrl_branch_ex_data_sel  = ifu_iu_ex_hs_split_inst_vld && !ifu_iu_ex_rand_vld && decd_ctrl_branch_sel;
assign ctrl_oper_lsu_data_sel   = ifu_iu_ex_hs_split_inst_vld && !ifu_iu_ex_rand_vld && predec_lsu_sel;

//when illeagle inst, lsu req cannot be asserted
assign iu_lsu_ex_data_sel       = ifu_iu_ex_hs_split_inst_vld && !ifu_iu_ex_rand_vld && predec_lsu_sel
                                  && !decd_xx_unit_special_sel;
assign iu_cp0_ex_data_sel       = ifu_iu_ex_hs_split_inst_vld && !ifu_iu_ex_rand_vld && decd_ctrl_cp0_sel;



//==========================================================
//                 Other Control signals
//==========================================================
//ignore internal stall signal to avoid memory transcmplt 
//path to get in
//EX stage instruction write back valid
//pay attention that bctm writes back r15 at the next
//cycle of check fail, but at that time there is no inst_vld
//in EX pipeline, so any write back/forward signal with
//following ex_inst_vld signals should be carefully designed.
//for examples, please refer to iu_wb

//when the sub_sp of nie, ee ie in PSR need to be asserted
// &Force("output","iu_cp0_nest_int_en"); @150
//assign ctrl_wb_nie_nir_vld = ifu_iu_ex_cr_oper;
assign ctrl_xx_sp_adjust = 1'b0;



//==========================================================
//               Non Interruptable Instruction
//==========================================================
assign ctrl_retire_ni_vld       = ifu_iu_ex_hs_split_inst_vld && ifu_iu_ex_ni;

//==========================================================
//                    Handle Exceptions
//==========================================================
assign ifu_iu_ex_hs_split_expt_vld   = ifu_iu_ex_expt_vld && !hs_split_iu_ctrl_inst_vld;
assign ctrl_special_expt_vld = ifu_iu_ex_hs_split_expt_vld
                            || ifu_iu_ex_prvlg_expt_vld
                            || decd_ctrl_expt_inv
                            || decd_ctrl_expt_bkpt
                            || decd_ctrl_expt_ecall
                            || decd_ctrl_expt_wsc;
// &CombBeg; @181
always @( cp0_yy_priv_mode[1:0]
       or decd_ctrl_expt_inv
       or decd_ctrl_expt_bkpt
       or ifu_iu_ex_hs_split_expt_vld
       or decd_ctrl_expt_ecall)
begin
  if(ifu_iu_ex_hs_split_expt_vld)       // Instruction access fault
  begin
    ctrl_special_expt_vec[4:0] = 5'b1;
  end
  else if(decd_ctrl_expt_inv )  // Illegal Instruction
  begin
    ctrl_special_expt_vec[4:0] = 5'b10;
  end
  else if(decd_ctrl_expt_bkpt) // Breakpoint
  begin
    ctrl_special_expt_vec[4:0] = 5'b11;
  end
  else if(decd_ctrl_expt_ecall) // Ecall from M-mode/U-mode
  begin
    ctrl_special_expt_vec[4:0] = {5{(cp0_yy_priv_mode[1:0] == 2'b11)}} & 5'b1011 |
                                 {5{(cp0_yy_priv_mode[1:0] == 2'b00)}} & 5'b1000 |
                                 {5{(cp0_yy_priv_mode[1:0] == 2'b01)}} & 5'b1001;
  end
  else  // no exception in before execution units, use reserved value
  begin
    ctrl_special_expt_vec[4:0] = 5'b01010;
  end
// &CombEnd; @204
end

// &ModuleEnd; @206
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @26
module cr_iu_decd(
  branch_pcgen_add_pc,
  cp0_iu_cskyisaee,
  cp0_yy_priv_mode,
  decd_alu_dst_vld,
  decd_alu_func,
  decd_alu_rs2_imm_vld,
  decd_alu_sub_func,
  decd_branch_auipc,
  decd_branch_beq,
  decd_branch_bge,
  decd_branch_bgeu,
  decd_branch_blt,
  decd_branch_bltu,
  decd_branch_bne,
  decd_branch_cbeqz,
  decd_branch_cbnez,
  decd_branch_cj,
  decd_branch_cjal,
  decd_branch_cjalr,
  decd_branch_cjr,
  decd_branch_jal,
  decd_branch_jalr,
  decd_ctrl_alu_sel,
  decd_ctrl_branch_sel,
  decd_ctrl_cp0_sel,
  decd_ctrl_expt_bkpt,
  decd_ctrl_expt_ecall,
  decd_ctrl_expt_inv,
  decd_ctrl_expt_wsc,
  decd_ctrl_lsu_sel,
  decd_ctrl_mad_sel,
  decd_mad_inst_div,
  decd_mad_inst_divu,
  decd_mad_inst_mul,
  decd_mad_inst_mulh,
  decd_mad_inst_mulhsu,
  decd_mad_inst_mulhu,
  decd_mad_inst_rem,
  decd_mad_inst_remu,
  decd_oper_alu_imm,
  decd_oper_branch_imm,
  decd_oper_cp0_imm,
  decd_oper_lsu_imm,
  decd_retire_cp0_inst,
  decd_retire_inst_mret,
  decd_special_fencei,
  decd_special_icall,
  decd_special_icpa,
  decd_wb_tval,
  decd_xx_inst_32bit,
  decd_xx_unit_special_sel,
  hs_split_iu_ctrl_inst_vld,
  hs_split_iu_dp_inst_op,
  ifu_had_chg_flw_inst,
  ifu_had_match_pc,
  ifu_iu_ex_expt_cur,
  ifu_iu_ex_expt_vld,
  ifu_iu_ex_inst,
  ifu_iu_ex_inst_bkpt,
  ifu_iu_ex_prvlg_expt_vld,
  ifu_iu_ex_rd_reg,
  ifu_iu_ex_rs1_reg,
  ifu_iu_ex_rs2_reg,
  iu_cp0_ex_csrrc,
  iu_cp0_ex_csrrci,
  iu_cp0_ex_csrrs,
  iu_cp0_ex_csrrsi,
  iu_cp0_ex_csrrw,
  iu_cp0_ex_csrrwi,
  iu_cp0_ex_func3,
  iu_cp0_ex_mret,
  iu_cp0_ex_rd_reg,
  iu_cp0_ex_rs1_reg,
  iu_cp0_ex_wfi,
  iu_ifu_lsu_inst,
  iu_lsu_ex_byte,
  iu_lsu_ex_half,
  iu_lsu_ex_store,
  iu_lsu_ex_uns,
  lsu_iu_wfd,
  pcgen_xx_cur_pc
);

// &Ports; @27
input   [30:0]  branch_pcgen_add_pc;        
input           cp0_iu_cskyisaee;           
input   [1 :0]  cp0_yy_priv_mode;           
input           hs_split_iu_ctrl_inst_vld;  
input   [31:0]  hs_split_iu_dp_inst_op;     
input           ifu_iu_ex_expt_cur;         
input           ifu_iu_ex_expt_vld;         
input   [31:0]  ifu_iu_ex_inst;             
input           ifu_iu_ex_inst_bkpt;        
input           ifu_iu_ex_prvlg_expt_vld;   
input           lsu_iu_wfd;                 
input   [30:0]  pcgen_xx_cur_pc;            
output          decd_alu_dst_vld;           
output  [2 :0]  decd_alu_func;              
output          decd_alu_rs2_imm_vld;       
output  [3 :0]  decd_alu_sub_func;          
output          decd_branch_auipc;          
output          decd_branch_beq;            
output          decd_branch_bge;            
output          decd_branch_bgeu;           
output          decd_branch_blt;            
output          decd_branch_bltu;           
output          decd_branch_bne;            
output          decd_branch_cbeqz;          
output          decd_branch_cbnez;          
output          decd_branch_cj;             
output          decd_branch_cjal;           
output          decd_branch_cjalr;          
output          decd_branch_cjr;            
output          decd_branch_jal;            
output          decd_branch_jalr;           
output          decd_ctrl_alu_sel;          
output          decd_ctrl_branch_sel;       
output          decd_ctrl_cp0_sel;          
output          decd_ctrl_expt_bkpt;        
output          decd_ctrl_expt_ecall;       
output          decd_ctrl_expt_inv;         
output          decd_ctrl_expt_wsc;         
output          decd_ctrl_lsu_sel;          
output          decd_ctrl_mad_sel;          
output          decd_mad_inst_div;          
output          decd_mad_inst_divu;         
output          decd_mad_inst_mul;          
output          decd_mad_inst_mulh;         
output          decd_mad_inst_mulhsu;       
output          decd_mad_inst_mulhu;        
output          decd_mad_inst_rem;          
output          decd_mad_inst_remu;         
output  [31:0]  decd_oper_alu_imm;          
output  [31:0]  decd_oper_branch_imm;       
output  [11:0]  decd_oper_cp0_imm;          
output  [31:0]  decd_oper_lsu_imm;          
output          decd_retire_cp0_inst;       
output          decd_retire_inst_mret;      
output          decd_special_fencei;        
output          decd_special_icall;         
output          decd_special_icpa;          
output  [31:0]  decd_wb_tval;               
output          decd_xx_inst_32bit;         
output          decd_xx_unit_special_sel;   
output          ifu_had_chg_flw_inst;       
output  [31:0]  ifu_had_match_pc;           
output  [4 :0]  ifu_iu_ex_rd_reg;           
output  [4 :0]  ifu_iu_ex_rs1_reg;          
output  [4 :0]  ifu_iu_ex_rs2_reg;          
output          iu_cp0_ex_csrrc;            
output          iu_cp0_ex_csrrci;           
output          iu_cp0_ex_csrrs;            
output          iu_cp0_ex_csrrsi;           
output          iu_cp0_ex_csrrw;            
output          iu_cp0_ex_csrrwi;           
output  [2 :0]  iu_cp0_ex_func3;            
output          iu_cp0_ex_mret;             
output  [4 :0]  iu_cp0_ex_rd_reg;           
output  [4 :0]  iu_cp0_ex_rs1_reg;          
output          iu_cp0_ex_wfi;              
output          iu_ifu_lsu_inst;            
output          iu_lsu_ex_byte;             
output          iu_lsu_ex_half;             
output          iu_lsu_ex_store;            
output          iu_lsu_ex_uns;              

// &Regs; @28
reg             decd_dst_vld;               
reg     [2 :0]  decd_func;                  
reg             decd_ill_expt16;            
reg             decd_ill_expt32;            
reg             decd_rs2_imm_vld;           
reg     [3 :0]  decd_sub_func;              
reg     [4 :0]  rd_16;                      
reg     [4 :0]  rs1_16;                     
reg     [4 :0]  rs2_16;                     

// &Wires; @29
wire    [31:0]  alu_imm;                    
wire            auipc_imm_vld;              
wire    [31:0]  branch_imm;                 
wire    [30:0]  branch_pcgen_add_pc;        
wire    [31:0]  btype_imm;                  
wire            btype_imm_vld;              
wire    [31:0]  cbtype_imm;                 
wire            cbtype_imm_vld;             
wire    [31:0]  ciatype_imm;                
wire            ciatype_imm_vld;            
wire    [31:0]  ciltype_imm;                
wire            ciltype_imm_vld;            
wire    [31:0]  cistype_imm;                
wire            cistype_imm_vld;            
wire    [31:0]  citype_imm;                 
wire            citype_imm_vld;             
wire    [31:0]  ciwtype_imm;                
wire            ciwtype_imm_vld;            
wire    [31:0]  cjtype_imm;                 
wire            cjtype_imm_vld;             
wire    [31:0]  cltype_imm;                 
wire            cltype_imm_vld;             
wire            cp0_iu_cskyisaee;           
wire    [1 :0]  cp0_yy_priv_mode;           
wire    [31:0]  csstype_imm;                
wire            csstype_imm_vld;            
wire            decd_alu_dst_vld;           
wire    [2 :0]  decd_alu_func;              
wire            decd_alu_rs2_imm_vld;       
wire            decd_alu_sel;               
wire    [3 :0]  decd_alu_sub_func;          
wire            decd_branch_auipc;          
wire            decd_branch_beq;            
wire            decd_branch_bge;            
wire            decd_branch_bgeu;           
wire            decd_branch_blt;            
wire            decd_branch_bltu;           
wire            decd_branch_bne;            
wire            decd_branch_cbeqz;          
wire            decd_branch_cbnez;          
wire            decd_branch_cj;             
wire            decd_branch_cjal;           
wire            decd_branch_cjalr;          
wire            decd_branch_cjr;            
wire            decd_branch_inst;           
wire            decd_branch_jal;            
wire            decd_branch_jalr;           
wire            decd_branch_sel;            
wire            decd_ctrl_alu_sel;          
wire            decd_ctrl_branch_sel;       
wire            decd_ctrl_cp0_sel;          
wire            decd_ctrl_expt_bkpt;        
wire            decd_ctrl_expt_ecall;       
wire            decd_ctrl_expt_inv;         
wire            decd_ctrl_expt_wsc;         
wire            decd_ctrl_lsu_sel;          
wire            decd_ctrl_mad_sel;          
wire    [2 :0]  decd_func3;                 
wire    [1 :0]  decd_func7;                 
wire            decd_ill_expt;              
wire            decd_ill_reg_32;            
wire    [31:0]  decd_imm;                   
wire    [31:0]  decd_inst;                  
wire            decd_inst_32bit;            
wire            decd_inst_auipc;            
wire            decd_inst_beq;              
wire            decd_inst_bge;              
wire            decd_inst_bgeu;             
wire            decd_inst_bkpt;             
wire            decd_inst_blt;              
wire            decd_inst_bltu;             
wire            decd_inst_bne;              
wire            decd_inst_cbeqz;            
wire            decd_inst_cbnez;            
wire            decd_inst_cj;               
wire            decd_inst_cjal;             
wire            decd_inst_cjalr;            
wire            decd_inst_cjr;              
wire            decd_inst_clw;              
wire            decd_inst_clwsp;            
wire            decd_inst_csrrc;            
wire            decd_inst_csrrci;           
wire            decd_inst_csrrs;            
wire            decd_inst_csrrsi;           
wire            decd_inst_csrrw;            
wire            decd_inst_csrrwi;           
wire            decd_inst_csw;              
wire            decd_inst_cswsp;            
wire            decd_inst_ecall;            
wire            decd_inst_expt;             
wire            decd_inst_fence;            
wire            decd_inst_fencei;           
wire            decd_inst_icall;            
wire            decd_inst_icpa;             
wire            decd_inst_jal;              
wire            decd_inst_jalr;             
wire            decd_inst_lb;               
wire            decd_inst_lbu;              
wire            decd_inst_lh;               
wire            decd_inst_lhu;              
wire            decd_inst_lw;               
wire            decd_inst_mret;             
wire            decd_inst_mret_nor;         
wire            decd_inst_nop;              
wire            decd_inst_sb;               
wire            decd_inst_sh;               
wire            decd_inst_sw;               
wire            decd_inst_wfi;              
wire            decd_lsu_byte;              
wire            decd_lsu_half;              
wire            decd_lsu_sel;               
wire            decd_lsu_store;             
wire            decd_lsu_uns;               
wire            decd_mad_inst_div;          
wire            decd_mad_inst_divu;         
wire            decd_mad_inst_mul;          
wire            decd_mad_inst_mulh;         
wire            decd_mad_inst_mulhsu;       
wire            decd_mad_inst_mulhu;        
wire            decd_mad_inst_rem;          
wire            decd_mad_inst_remu;         
wire            decd_mad_sel;               
wire    [6 :0]  decd_op;                    
wire    [31:0]  decd_oper_alu_imm;          
wire    [31:0]  decd_oper_branch_imm;       
wire    [11:0]  decd_oper_cp0_imm;          
wire    [31:0]  decd_oper_lsu_imm;          
wire    [4 :0]  decd_rd;                    
wire            decd_retire_cp0_inst;       
wire            decd_retire_inst_mret;      
wire    [4 :0]  decd_rs1;                   
wire    [4 :0]  decd_rs2;                   
wire            decd_special_fencei;        
wire            decd_special_icall;         
wire            decd_special_icpa;          
wire            decd_special_sel;           
wire            decd_sys;                   
wire    [31:0]  decd_wb_tval;               
wire            decd_xx_inst_32bit;         
wire            decd_xx_unit_special_sel;   
wire            hs_split_iu_ctrl_inst_vld;  
wire    [31:0]  hs_split_iu_dp_inst_op;     
wire            ifu_had_chg_flw_inst;       
wire    [31:0]  ifu_had_match_pc;           
wire            ifu_iu_ex_expt_cur;         
wire            ifu_iu_ex_expt_vld;         
wire            ifu_iu_ex_hs_split_expt_vld; 
wire    [31:0]  ifu_iu_ex_inst;             
wire            ifu_iu_ex_inst_bkpt;        
wire            ifu_iu_ex_prvlg_expt_vld;   
wire    [4 :0]  ifu_iu_ex_rd_reg;           
wire    [4 :0]  ifu_iu_ex_rs1_reg;          
wire    [4 :0]  ifu_iu_ex_rs2_reg;          
wire    [31:0]  itype_imm;                  
wire            itype_imm_vld;              
wire            iu_cp0_ex_csrrc;            
wire            iu_cp0_ex_csrrci;           
wire            iu_cp0_ex_csrrs;            
wire            iu_cp0_ex_csrrsi;           
wire            iu_cp0_ex_csrrw;            
wire            iu_cp0_ex_csrrwi;           
wire    [2 :0]  iu_cp0_ex_func3;            
wire            iu_cp0_ex_mret;             
wire    [4 :0]  iu_cp0_ex_rd_reg;           
wire    [4 :0]  iu_cp0_ex_rs1_reg;          
wire            iu_cp0_ex_wfi;              
wire            iu_ifu_lsu_inst;            
wire            iu_lsu_ex_byte;             
wire            iu_lsu_ex_half;             
wire            iu_lsu_ex_store;            
wire            iu_lsu_ex_uns;              
wire            jalr_imm_vld;               
wire    [31:0]  jtype_imm;                  
wire            jtype_imm_vld;              
wire            load_imm_vld;               
wire    [31:0]  lsu_imm;                    
wire            lsu_iu_wfd;                 
wire    [30:0]  pcgen_xx_cur_pc;            
wire            rd_update_32;               
wire            rs1_update_32;              
wire            rs2_update_32;              
wire    [31:0]  stype_imm;                  
wire            stype_imm_vld;              
wire    [31:0]  tval_pc;                    
wire            tval_sel_pc;                
wire    [31:0]  utype_imm;                  
wire            utype_imm_vld;              


//==========================================================
//                Define the operand type
//==========================================================

//--------------------parameter width define---------------
//following defines data width of decoded information
parameter FUNC_WIDTH            = 3;
parameter SUB_FUNC_WIDTH        = 4;

//--------------------ALU FUNC define---------------
//value definition of decd_func in ALU
parameter ADDER                  = 3'b001;
parameter LOGIC                  = 3'b010;
parameter SHIFT                  = 3'b100;
//--------------------ADDER SUB_FUNC define---------------
parameter ADD                    = 4'b0001;
parameter LTU                    = 4'b0010;
parameter SLT                    = 4'b0100;
parameter SUB                    = 4'b1000;
//--------------------LOGIC SUB_FUNC define---------------
parameter MOV                    = 4'b0001;
parameter AND                    = 4'b0010;
parameter OR                     = 4'b0100;
parameter XOR                    = 4'b1000;
//--------------------SHIFT SUB_FUNC define---------------
parameter SRA                    = 4'b0001;
parameter SLL                    = 4'b0010;
parameter SRL                    = 4'b0100;
//==========================================================
//                      Decoder Input
//==========================================================
assign decd_inst[31:0] = hs_split_iu_ctrl_inst_vld ? hs_split_iu_dp_inst_op[31:0] 
                                                   : ifu_iu_ex_inst[31:0];
assign decd_inst_32bit = decd_inst[1] && decd_inst[0];
assign decd_op[6:0]    = {decd_inst[6:5], decd_inst_32bit ? decd_inst[4:2] : decd_inst[15:13], decd_inst[1:0]};
assign decd_func3[2:0] = decd_inst_32bit ? decd_inst[14:12] : decd_inst[12:10];
assign decd_func7[1:0] = {decd_inst[30], decd_inst[25]};

// &CombBeg; @70
always @( decd_inst[15:13]
       or decd_inst[1:0]
       or decd_inst[11:7])
begin
  casez({decd_inst[15:13], decd_inst[1:0]})
  //casez({decd_op[4:0]})
    5'b01101, // C.ADDI16SP; note: C.LUI included
    5'b00000, // C.ADDI4SPN
    5'b?1010: // C.LWSP C.SWSP
      rs1_16[4:0] = 5'b00010;
    5'b?1000, // C.LW C.SW
    5'b11?01, // C.BEQZ C.BNEZ
    5'b10001: // C.SRLI C.SRAI C.ANDI C.AND C.OR C.XOR C.SUB
      rs1_16[4:0] = {2'b01, decd_inst[9:7]};
    5'b00001, // C.ADDI 
    5'b?0010: // C.JR C.JALR C.SLLI C.ADD; C.MOV included
      rs1_16[4:0] = decd_inst[11:7];
    default: 
    begin
      rs1_16[4:0] = {1'b0, decd_inst[10:7]};
    end
  endcase
// &CombEnd; @89
end

// &CombBeg; @91
always @( decd_inst[15:13]
       or decd_inst[6:0])
begin
  casez({decd_inst[15:13], decd_inst[1:0]})
  //casez({decd_op[4:0]})
    5'b11010, // C.SWSP
    5'b10010: // C.MV C.ADD; note: C.JR and C.JALR included 
      rs2_16[4:0] = decd_inst[6:2];
    5'b11000: // C.SW
      rs2_16[4:0] = {2'b01, decd_inst[4:2]};
    5'b10001: // C.AND C.OR C.XOR C.SUB C.SRLI C.SRAI C.ANDI
      rs2_16[4:0] = {2'b01, decd_inst[4:2]};
    default: 
      rs2_16[4:0] = {2'b01, decd_inst[4:2]};
    endcase
// &CombEnd; @104
end

// &CombBeg; @106
always @( decd_inst[15:13]
       or decd_inst[11:0])
begin
  casez({decd_inst[15:13], decd_inst[1:0]})
  //casez({decd_op[4:0]})
    5'b01010, // C.LWSP
    5'b01001, // C.LI
    5'b01101, // C.LUI C.ADDI16SP
    5'b00001, // C.ADDI
    5'b00010: // C.SLLI
      rd_16[4:0] = decd_inst[11:7];
    5'b10010: // C.MV C.ADD; C.JALR; note: C.JR included 
      rd_16[4:0] = decd_inst[6:2] == 5'b0 ? 5'b1 : decd_inst[11:7];
    5'b00101: // C.JAL
      rd_16[4:0] = 5'b1;
    5'b10001: // C.AND C.OR C.XOR C.SUB C.SRLI C.SRAI C.ANDI
      rd_16[4:0] = {2'b01, decd_inst[9:7]};
    5'b01000, // C.LW
    5'b00000: // C.ADDI4SPN
      rd_16[4:0] = {2'b01, decd_inst[4:2]};
    default : 
      rd_16[4:0] = {2'b01, decd_inst[9:7]};
  endcase
// &CombEnd; @127
end

assign decd_rs1[4:0] = decd_inst_32bit ? decd_inst[19:15] : rs1_16[4:0];
assign decd_rs2[4:0] = decd_inst_32bit ? decd_inst[24:20] : rs2_16[4:0];
assign decd_rd[4:0]  = decd_inst_32bit ? decd_inst[11:7]  : rd_16[4:0];

//==========================================================
//               IMM
//==========================================================
// I-Type: Load Arth-Imm CSR JALR
assign load_imm_vld    = decd_inst[6:0] == 7'b0000011;
assign itype_imm_vld   = decd_inst[6:0] == 7'b0010011 ||
                         decd_inst[6:0] == 7'b1110011;
assign jalr_imm_vld    = decd_inst[6:0] == 7'b1100111;
assign itype_imm[31:0] = {{21{decd_inst[31]}}, decd_inst[30:20]};
// S-Type: Store
assign stype_imm_vld   = decd_inst[6:0] == 7'b0100011; 
assign stype_imm[31:0] = {{21{decd_inst[31]}}, decd_inst[30:25], decd_inst[11:7]}; 
// B-Type: BEQ BNE BLT BGE BLTU BGEU
// only branch forward need update imm
assign btype_imm_vld   = decd_inst[6:0] == 7'b1100011;
assign btype_imm[31:0] = {{20{decd_inst[31]}}, decd_inst[7], decd_inst[30:25], decd_inst[11:8], 1'b0};
// U-Type: LUI AUIPC
assign utype_imm_vld   = decd_inst[6:0] == 7'b0110111;
assign auipc_imm_vld   = decd_inst[6:0] == 7'b0010111;
assign utype_imm[31:0] = {decd_inst[31:12], 12'b0};
// J-Type: JAL
assign jtype_imm_vld   = decd_inst[6:0] == 7'b1101111;
assign jtype_imm[31:0] = {{12{decd_inst[31]}}, decd_inst[19:12], decd_inst[20], decd_inst[30:21], 1'b0};

// imm for 16-bit insts
// CI-Type: C.LI C.ADDI C.SLLI C.SRAI C.SRLI C.ANDI
assign citype_imm_vld   = {decd_inst[15:13], decd_inst[1:0]} == 5'b01001 ||
                          {decd_inst[15:13], decd_inst[1:0]} == 5'b00001 ||
                          {decd_inst[15:13], decd_inst[1:0]} == 5'b00010 ||
                          {decd_inst[15:13], decd_inst[1:0]} == 5'b10001 && decd_inst[11:10] != 2'b11;
assign citype_imm[31:0] = {{27{decd_inst[12]}}, decd_inst[6:2]};
// CIS-Type: C.LWSP
assign cistype_imm_vld   = {decd_inst[15:13], decd_inst[1:0]} == 5'b01010;
assign cistype_imm[31:0] = {24'b0, decd_inst[3:2], decd_inst[12], decd_inst[6:4], 2'b0};
// CIL-Type: C.LUI
assign ciltype_imm_vld   = {decd_inst[15:13], decd_inst[1:0]} == 5'b01101 &&
                            decd_inst[10:7] != 4'b10;
assign ciltype_imm[31:0] = {{15{decd_inst[12]}}, decd_inst[6:2], 12'b0};
// CIA-Type: C.ADDI16SP
assign ciatype_imm_vld   = {decd_inst[15:13], decd_inst[1:0]} == 5'b01101 &&
                            decd_inst[10:7] == 4'b10;
assign ciatype_imm[31:0] = {{23{decd_inst[12]}}, decd_inst[4:3], decd_inst[5], decd_inst[2], decd_inst[6], 4'b0};
// CIW-Type: C.ADDI4SPN
assign ciwtype_imm_vld   = !decd_inst_32bit && {decd_inst[15:13], decd_inst[1:0]} == 5'b00000;
assign ciwtype_imm[31:0] = {22'b0, decd_inst[10:7], decd_inst[12:11], decd_inst[5], decd_inst[6], 2'b0};

// CL-Type: C.LW C.SW
assign cltype_imm_vld   = {decd_inst[15:13], decd_inst[1:0]} == 5'b01000 ||
                          {decd_inst[15:13], decd_inst[1:0]} == 5'b11000;
assign cltype_imm[31:0] = {25'b0, decd_inst[5], decd_inst[12:10], decd_inst[6], 2'b0};

// CSS-Type: C.SWSP
assign csstype_imm_vld   = {decd_inst[15:13], decd_inst[1:0]} == 5'b11010;
assign csstype_imm[31:0] = {24'b0, decd_inst[8:7], decd_inst[12:9], 2'b0};

// CB-Type: C.BEQZ C.BNEZ
assign cbtype_imm_vld   = {decd_inst[15:13], decd_inst[1:0]} == 5'b11001 ||
                          {decd_inst[15:13], decd_inst[1:0]} == 5'b11101;
assign cbtype_imm[31:0] = {{24{decd_inst[12]}}, decd_inst[6:5], decd_inst[2], decd_inst[11:10], decd_inst[4:3], 1'b0}; 
// CJ-Type: C.J C.JAL
assign cjtype_imm_vld   = {decd_inst[14:13], decd_inst[1:0]} == 4'b0101;
assign cjtype_imm[31:0] = {{21{decd_inst[12]}}, decd_inst[8], decd_inst[10:9], decd_inst[6], decd_inst[7], decd_inst[2], decd_inst[11], decd_inst[5:3], 1'b0};

// distribute imm
assign decd_imm[31:0]   = citype_imm[31:0];
assign alu_imm[31:0]    = {32{  itype_imm_vld}} &   itype_imm[31:0] |
                          {32{  utype_imm_vld}} &   utype_imm[31:0] |
                          {32{  auipc_imm_vld}} &   utype_imm[31:0] |
                          {32{ citype_imm_vld}} &  citype_imm[31:0] |
                          {32{ciltype_imm_vld}} & ciltype_imm[31:0] |
                          {32{ciatype_imm_vld}} & ciatype_imm[31:0] |
                          {32{ciwtype_imm_vld}} & ciwtype_imm[31:0];

assign branch_imm[31:0] = //{32{   jalr_imm_vld}} &   itype_imm[31:0] |
                          {32{  btype_imm_vld}} &   btype_imm[31:0] |
//                          {32{  jtype_imm_vld}} &   jtype_imm[31:0] |
//                          {32{  auipc_imm_vld}} &   utype_imm[31:0] |
//                          {32{ cjtype_imm_vld}} &  cjtype_imm[31:0] |
                          {32{ cbtype_imm_vld}} &  cbtype_imm[31:0];

assign lsu_imm[31:0]    = {32{  load_imm_vld}}  &   itype_imm[31:0] |
                          {32{   jalr_imm_vld}} &   itype_imm[31:0] |
                          {32{  jtype_imm_vld}} &   jtype_imm[31:0] |
                          {32{ cjtype_imm_vld}} &  cjtype_imm[31:0] |
                          {32{ stype_imm_vld}}  &   stype_imm[31:0] |
                          {32{cistype_imm_vld}} & cistype_imm[31:0] |
                          {32{ cltype_imm_vld}} &  cltype_imm[31:0] |
                          {32{csstype_imm_vld}} & csstype_imm[31:0];

assign decd_oper_alu_imm[31:0] = alu_imm[31:0] | lsu_imm[31:0];
assign decd_oper_lsu_imm[31:0] = 32'b0;
assign decd_oper_cp0_imm[11:0] = itype_imm[11:0];
assign decd_oper_branch_imm[31:0] = branch_imm[31:0];

assign ifu_iu_ex_rs1_reg[4:0] = {1'b0,decd_rs1[3:0]};
assign ifu_iu_ex_rs2_reg[4:0] = {1'b0,decd_rs2[3:0]};
assign ifu_iu_ex_rd_reg[4:0]  = {1'b0, decd_rd[3:0]};

assign iu_ifu_lsu_inst = (decd_inst_clwsp || decd_inst_cswsp 
                      || decd_inst_clw   || decd_inst_csw
                      || decd_op[6:0] == 7'b0000011
                      || decd_op[6:0] == 7'b0100011) && !lsu_iu_wfd;
assign decd_xx_inst_32bit = decd_inst_32bit;

//==========================================================
//               ILLEGAL INST
//==========================================================
// the illegal inst
// RV32C Insts
// &CombBeg; @252
always @( citype_imm[5:0]
       or rs2_16[4]
       or ciatype_imm[9:4]
       or decd_inst[6]
       or decd_op[4:0]
       or decd_inst[11]
       or decd_func3[2:0]
       or ciwtype_imm[9:2]
       or rd_16[4:0]
       or ciltype_imm[17:12])
begin
  casez({decd_func3[2:0], decd_op[4:0]})
    // 8-bits instructions decode logic
    8'b???01001:  // C.LI 
    begin
      decd_ill_expt16 = rd_16[4:0] == 5'b0   // for some insts, rd  can not be 0
                     || rd_16[4];
    end
    8'b???00001:  // C.ADDI C.NOP
      decd_ill_expt16 = rd_16[4:0] != 5'b0 &&  citype_imm[5:0] == 6'b0  // for some insts, imm can not be 0
                     || rd_16[4:0] == 5'b0 &&  citype_imm[5:0] != 6'b0
                     || rd_16[4];
    8'b?0?10001:  // C.SRLI C.SRAI
    begin
      decd_ill_expt16 = citype_imm[5:0] == 6'b0; // for some insts, imm can not be 0
    end
    8'b???00000:  // C.ADDI4SPN
    begin
      decd_ill_expt16 = ciwtype_imm[9:2] == 8'b0; // for some insts, imm can not be 0
    end
    8'b???01010,  // C.LWSP
    8'b???00010:  // C.SLLI
    begin
      decd_ill_expt16 = rd_16[4:0] == 5'b0 && citype_imm[5:0] == 6'b0
                     || rd_16[4]; 
    end
    8'b???01101:  // C.LUI C.ADDI16SP 
    begin
      decd_ill_expt16 = rd_16[4:0] == 5'b0 
                     || rd_16[4:0] != 5'b10 && ciltype_imm[17:12] == 6'b0 
                     || rd_16[4:0] == 5'b10 && ciatype_imm[9:4] == 6'b0
                     || rd_16[4]; 
    end
    8'b???11010:  // C.SWSP
      decd_ill_expt16 = rs2_16[4];
    8'b???10010:  // C.JR C.JALR C.MV C.ADD C.EBREAK
      decd_ill_expt16 = decd_inst[11] || decd_inst[6];
    8'b???01000,  // C.LW
    8'b???11000,  // C.SW
    8'b???10101,  // C.J
    8'b???00101,  // C.JAL
    8'b???11001,  // C.BEQZ
    8'b???11101,  // C.BNEZ
    8'b?1010001,  // C.ANDI
    8'b?1110001:  // C.AND C.OR C.XOR C.SUB
    begin  
      decd_ill_expt16 = 1'b0;      //initial invalid instruction exception
    end
    default:begin                //invalid instruction
      decd_ill_expt16 = 1'b1;      //invalid instruction exception
    end
  endcase
// &CombEnd; @304
end

// RV32EM Insts
// &CombBeg; @307
always @( decd_inst[31:20]
       or decd_op[6:2]
       or decd_inst[11:7]
       or cp0_iu_cskyisaee
       or cp0_yy_priv_mode[1:0]
       or decd_func3[2:0])
begin
  casez({decd_inst[31:25], decd_func3[2:0], decd_op[6:2]})
    // 15-bits instructions decode logic
    15'b010000000001100,  // SUB 
    15'b010000010101100,  // SRA
    15'b000000????01100,  // R-Type

    15'b????????0?00000,  // 
    15'b???????01000000,  // I-Type Load

    15'b000000000100100,  // SLLI
    15'b0?0000010100100,  // SRLI SRAI
    15'b????????1100100,  // I-Type 
    15'b?????????000100,  // I-Type 

    15'b???????00011001,  // JALR

    15'b?????????111100,  // 
    15'b????????1011100,  // CSR Type

    15'b???????00?01000,  // 
    15'b???????01001000,  // S-Type 

    15'b???????00?11000,  // 
    15'b???????1??11000,  // B-Type 

    15'b??????????01101,  // LUI

    15'b??????????00101,  // AUIPC

    15'b??????????11011,  // J-Type

    15'b???????00?00011:  // FENCE FENCE.I
    begin  
      decd_ill_expt32 = 1'b0; // initial invalid instruction exception
    end
    15'b???????00000010:  // Cache Ops
    begin
      decd_ill_expt32 = !(decd_inst[11:7] == 5'b0 && decd_inst[31:26] == 6'b0
                       && cp0_iu_cskyisaee); // initial invalid instruction exception
    end
    15'b000000000011100:  // ECALL EBREAK
    begin  
      decd_ill_expt32 = decd_inst[24:21] != 4'b0; 
    end
    15'b001100000011100:  // MRET
    begin  
      decd_ill_expt32 = decd_inst[24:20] != 5'b00010 || !(cp0_yy_priv_mode[1:0] == 2'b11); 
    end
    15'b000100000011100:  // WFI
    begin  
      decd_ill_expt32 = decd_inst[24:20] != 5'b00101 || !(cp0_yy_priv_mode[1:0] == 2'b11); 
    end
    default:
    begin               
      decd_ill_expt32 = 1'b1; // all other insts are illegal
    end
  endcase
// &CombEnd; @365
end

//assign csr_imm_type = decd_inst[6:2] == 5'b11100 && decd_inst[14];
assign rs1_update_32 = decd_inst_32bit &&
                     !(decd_op[6:2] == 5'b11100 && decd_func3[2]) && // CSRW Imm inst
                       decd_op[6:2] != 5'b01101 && // LUI 
                       decd_op[6:2] != 5'b00101 && // AUIPC
                       decd_op[6:2] != 5'b11011;   // JAL
                       
assign rs2_update_32 = decd_inst_32bit && (
                       decd_op[6:2] == 5'b01100 || // R-Type
                       decd_op[6:2] == 5'b01000 || // S-Type
                       decd_op[6:2] == 5'b11000 || // B-Type
                       decd_op[6:2] == 5'b11100 && decd_func3[2:0] == 3'b0);
assign rd_update_32  = decd_inst_32bit &&
                       decd_op[6:2] != 5'b01000 && // S-Type
                       decd_op[6:2] != 5'b11000;   // B-Type
assign decd_ill_reg_32 = rs1_update_32 && decd_rs1[4]
                    || rs2_update_32 && decd_rs2[4] && !hs_split_iu_ctrl_inst_vld
                    || rd_update_32 && decd_rd[4] && !hs_split_iu_ctrl_inst_vld;
assign decd_ill_expt = decd_inst_32bit ? decd_ill_expt32 || decd_ill_reg_32
                                       : decd_ill_expt16;

//when nie nir, the inst is always 16-bit, to maintain the correct PC
//==========================================================
//                      Main  Decoder
//==========================================================
//main decoder produces operation information, operand 
//information and ALU/ALU oper prepare information,
//all values are defined by parameter.
//details defintions of operation plz refer to 902_IU_spec
//details defintions of operands plz refer to parameter define
//decode info for program signature

// decoder for ALU
// &CombBeg; @411
always @( decd_op[6:0]
       or decd_rd[4:0]
       or decd_func3[2:0]
       or decd_func7[1:0])
begin
  //initialize decoded information value
  //operation information: execution unit selection, main function
  //and sub functions
  //decd_func[FUNC_WIDTH-1:0]         = {FUNC_WIDTH{1'b0}};
  //decd_sub_func[SUB_FUNC_WIDTH-1:0] = {SUB_FUNC_WIDTH{1'b0}};
  //decd_rs2_imm_vld                  = 1'b0;
  //decd_dst_vld                      = 1'b0;
  decd_func[FUNC_WIDTH-1:0]         = ADDER;
  decd_sub_func[SUB_FUNC_WIDTH-1:0] = ADD;
  decd_rs2_imm_vld                  = 1'b0;
  decd_dst_vld                      = 1'b1;
  casez({decd_func7[1:0], decd_func3[2:0], decd_op[6:0]})
    //---------------------------------------------------
    // ADDER 5 RV32C insts 11 RV32E insts
    12'b???????00001: // C.ADDI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = ADD;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b???????01101: // C.ADDI16SP C.LUI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = decd_rd[4:0] == 5'h2 ? ADDER : LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = ADD;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b???????00000: // C.ADDI4SPN; ALU Unit selected only rd = x2
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = ADD;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b??1????10010: // C.ADD     ; ALU Unit selected only rs2 != x0
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = ADD;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b??0110010001: // C.SUB
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SUB;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b??0000010011: // ADDI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = ADD;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b??0100010011: // SLTI 
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SLT;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b??0110010011: // SLTIU 
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = LTU;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b000000110011: // ADD
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = ADD;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b010??0110011: // MULT
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = ADD;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b0;
    end
    12'b011??0110011: // DIV
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = LTU;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b0;
    end
    12'b1?0000110011: // SUB
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SUB;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b?00100110011: // SLT
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SLT;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b?00110110011: // SLTU
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = LTU;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b??10?1100011: // BLT BGE
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SLT;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b0;
    end
    12'b??11?1100011: // BLTU BGEU
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = LTU;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b0;
    end
    12'b?????0010111: // AUIPC
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = ADD;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b?????1100111: // JALR
    begin  
      decd_func[FUNC_WIDTH-1:0]         = ADDER;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = ADD;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b0;
    end
    //---------------------------------------------------
    // LOGIC 6 RV32C insts 7 RV32E insts
    12'b???????01001: // C.LI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = MOV;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b??0????10010: // C.MV; ALU Unit selected only rs2 != x0
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = MOV;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b???10??10001: // C.ANDI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = AND;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b???111110001: // C.AND 
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = AND;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b???111010001: // C.OR
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = OR;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b???110110001: // C.XOR
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = XOR;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b?????0110111: // LUI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = MOV;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b??1110010011: // ANDI 
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = AND;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b??1100010011: // ORI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = OR;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b??1000010011: // XORI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = XOR;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b?01110110011: // AND 
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = AND;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b?01100110011: // OR
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = OR;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b?01000110011: // XOR
    begin  
      decd_func[FUNC_WIDTH-1:0]         = LOGIC;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = XOR;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    //---------------------------------------------------
    // SHIFT 3 RV32C insts 6 RV32E insts
    12'b???????00010: // C.SLLI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = SHIFT;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SLL;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b???00??10001: // C.SRLI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = SHIFT;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SRL;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b???01??10001: // C.SRAI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = SHIFT;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SRA;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b??0010010011: // SLLI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = SHIFT;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SLL;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b0?1010010011: // SRLI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = SHIFT;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SRL;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b1?1010010011: // SRAI
    begin  
      decd_func[FUNC_WIDTH-1:0]         = SHIFT;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SRA;
      decd_rs2_imm_vld                  = 1'b1;
      decd_dst_vld                      = 1'b1;
    end
    12'b?00010110011: // SLL
    begin  
      decd_func[FUNC_WIDTH-1:0]         = SHIFT;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SLL;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b001010110011: // SRL
    begin  
      decd_func[FUNC_WIDTH-1:0]         = SHIFT;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SRL;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    12'b1?1010110011: // SRA
    begin  
      decd_func[FUNC_WIDTH-1:0]         = SHIFT;
      decd_sub_func[SUB_FUNC_WIDTH-1:0] = SRA;
      decd_rs2_imm_vld                  = 1'b0;
      decd_dst_vld                      = 1'b1;
    end
    //---------------------------------------------------
  endcase
// &CombEnd; @714
end

// decoder for MAD
assign decd_mad_sel         = decd_op[6:0] == 7'b0110011 && decd_func7[0] &&
                              !decd_inst_expt;
assign decd_mad_inst_mul    = decd_mad_sel && decd_func3[2:0] == 3'b000; 
assign decd_mad_inst_mulh   = decd_mad_sel && decd_func3[2:0] == 3'b001; 
assign decd_mad_inst_mulhsu = decd_mad_sel && decd_func3[2:0] == 3'b010; 
assign decd_mad_inst_mulhu  = decd_mad_sel && decd_func3[2:0] == 3'b011; 
assign decd_mad_inst_div    = decd_mad_sel && decd_func3[2:0] == 3'b100; 
assign decd_mad_inst_divu   = decd_mad_sel && decd_func3[2:0] == 3'b101; 
assign decd_mad_inst_rem    = decd_mad_sel && decd_func3[2:0] == 3'b110; 
assign decd_mad_inst_remu   = decd_mad_sel && decd_func3[2:0] == 3'b111; 

// decoder for LSU
assign decd_lsu_sel   = (decd_inst_clwsp || decd_inst_cswsp || decd_inst_clw   
                      || decd_inst_csw   || decd_inst_lb    || decd_inst_lh
                      || decd_inst_lbu   || decd_inst_lhu   || decd_inst_lw
                      || decd_inst_sb    || decd_inst_sh    || decd_inst_sw)
                      && !decd_inst_expt;

assign decd_inst_clwsp = decd_op[4:0] == 5'b01010;
assign decd_inst_cswsp = decd_op[4:0] == 5'b11010;
assign decd_inst_clw   = decd_op[4:0] == 5'b01000;
assign decd_inst_csw   = decd_op[4:0] == 5'b11000;

assign decd_inst_lb    = decd_op[6:0] == 7'b0000011 && decd_func3[2:0] == 3'b000; 
assign decd_inst_lh    = decd_op[6:0] == 7'b0000011 && decd_func3[2:0] == 3'b001; 
assign decd_inst_lw    = decd_op[6:0] == 7'b0000011 && decd_func3[2:0] == 3'b010; 
assign decd_inst_lbu   = decd_op[6:0] == 7'b0000011 && decd_func3[2:0] == 3'b100; 
assign decd_inst_lhu   = decd_op[6:0] == 7'b0000011 && decd_func3[2:0] == 3'b101; 

assign decd_inst_sb    = decd_op[6:0] == 7'b0100011 && decd_func3[2:0] == 3'b000; 
assign decd_inst_sh    = decd_op[6:0] == 7'b0100011 && decd_func3[2:0] == 3'b001; 
assign decd_inst_sw    = decd_op[6:0] == 7'b0100011 && decd_func3[2:0] == 3'b010; 

assign decd_lsu_store  = decd_inst_cswsp || decd_inst_csw || decd_inst_sb
                      || decd_inst_sh    || decd_inst_sw;
assign decd_lsu_byte   = decd_inst_lb    || decd_inst_lbu || decd_inst_sb;
assign decd_lsu_half   = decd_inst_lh    || decd_inst_lhu || decd_inst_sh;
assign decd_lsu_uns    = decd_inst_lbu   || decd_inst_lhu;

assign decd_inst_fence  = decd_op[6:0] == 7'b0001111 && !decd_func3[0];
assign decd_inst_fencei = decd_op[6:0] == 7'b0001111 &&  decd_func3[0];

// decoder for CP0
assign decd_sys         = decd_op[6:0] == 7'b1110011 
                      && !decd_inst_expt;
assign decd_inst_ecall  = decd_sys && decd_func3[2:0] == 3'b000 && decd_rs2[1:0] == 2'b0;
assign decd_inst_mret   = decd_sys && decd_func3[2:0] == 3'b000 && decd_rs2[1];
assign decd_inst_mret_nor= decd_inst_mret && (cp0_yy_priv_mode[1:0] == 2'b11);
assign decd_inst_wfi    = decd_sys && decd_func3[2:0] == 3'b000 && decd_rs2[2];
assign decd_inst_csrrw  = decd_sys && decd_func3[2:0] == 3'b001;
assign decd_inst_csrrs  = decd_sys && decd_func3[2:0] == 3'b010;
assign decd_inst_csrrc  = decd_sys && decd_func3[2:0] == 3'b011;
assign decd_inst_csrrwi = decd_sys && decd_func3[2:0] == 3'b101;
assign decd_inst_csrrsi = decd_sys && decd_func3[2:0] == 3'b110;
assign decd_inst_csrrci = decd_sys && decd_func3[2:0] == 3'b111;
assign decd_retire_inst_mret =   1'b0;
assign decd_ctrl_expt_wsc       = 1'b0;
//assign decd_ctrl_mret_expt = decd_inst_mret && (cp0_yy_priv_mode[1:0] != 2'b11);
// &Force("output","decd_ctrl_expt_wsc"); @781
// //&Force("output","decd_ctrl_mret_expt"); @782
// decoder for BRANCH
assign decd_branch_inst = decd_inst_cj    || decd_inst_cjal  || decd_inst_cjr 
                      || decd_inst_cjalr || decd_inst_cbeqz || decd_inst_cbnez
//                      || decd_inst_auipc || decd_inst_jal   || decd_inst_jalr
                      || decd_inst_jal   || decd_inst_jalr
                      || decd_inst_beq   || decd_inst_bne   || decd_inst_blt
                      || decd_inst_bge   || decd_inst_bltu  || decd_inst_bgeu;
assign decd_branch_sel = decd_branch_inst && !decd_inst_expt;

assign decd_inst_cj    = decd_op[4:0] == 5'b10101;
assign decd_inst_cjal  = decd_op[4:0] == 5'b00101;
assign decd_inst_cjr   = decd_op[4:0] == 5'b10010 && !decd_func3[2] && decd_rs2[4:0] == 5'b0;
assign decd_inst_cjalr = decd_op[4:0] == 5'b10010 &&  decd_func3[2] && decd_rs2[4:0] == 5'b0;

assign decd_inst_cbeqz = decd_op[4:0] == 5'b11001;
assign decd_inst_cbnez = decd_op[4:0] == 5'b11101;

assign decd_inst_auipc = decd_op[6:0] == 7'b0010111;
assign decd_inst_jal   = decd_op[6:0] == 7'b1101111;
assign decd_inst_jalr  = decd_op[6:0] == 7'b1100111;

assign decd_inst_beq   = decd_op[6:0] == 7'b1100011 && decd_func3[2:0] == 3'b000; 
assign decd_inst_bne   = decd_op[6:0] == 7'b1100011 && decd_func3[2:0] == 3'b001; 
assign decd_inst_blt   = decd_op[6:0] == 7'b1100011 && decd_func3[2:0] == 3'b100; 
assign decd_inst_bge   = decd_op[6:0] == 7'b1100011 && decd_func3[2:0] == 3'b101; 
assign decd_inst_bltu  = decd_op[6:0] == 7'b1100011 && decd_func3[2:0] == 3'b110; 
assign decd_inst_bgeu  = decd_op[6:0] == 7'b1100011 && decd_func3[2:0] == 3'b111; 

// decoder for SPECIAL
// //&Force("bus", "ifu_iu_ex_imm", 31, 0); @812
assign decd_inst_icall = 1'b0;
assign decd_inst_icpa  = 1'b0;
assign decd_inst_nop   = decd_op[4:0] == 5'b1 && decd_rd[4:0] == 5'b0 &&
                         decd_imm[5:0] == 6'b0;
assign decd_inst_bkpt  = decd_inst[15:0] == 16'h9002      // C.EBREAK 
                      || decd_inst[31:0] == 32'h0010_0073 // EBREAK
                      || (ifu_iu_ex_inst_bkpt && !hs_split_iu_ctrl_inst_vld);
assign decd_inst_expt  = decd_ill_expt || decd_inst_bkpt;
assign ifu_iu_ex_hs_split_expt_vld = ifu_iu_ex_expt_vld && !hs_split_iu_ctrl_inst_vld || decd_inst_bkpt;
assign decd_special_sel = decd_ill_expt || ifu_iu_ex_hs_split_expt_vld
                       || ifu_iu_ex_prvlg_expt_vld
                       || decd_inst_ecall    || decd_inst_nop
                       || decd_inst_fence    || decd_inst_fencei
                       || decd_inst_icall    || decd_inst_icpa
                       || decd_ctrl_expt_wsc;
assign decd_special_fencei = decd_inst_fencei;
assign decd_special_icall = decd_inst_icall;
assign decd_special_icpa  = decd_inst_icpa;

assign tval_sel_pc = (ifu_iu_ex_inst_bkpt || ifu_iu_ex_expt_vld) 
                  && !hs_split_iu_ctrl_inst_vld;
// &Force("bus", "branch_pcgen_add_pc", 30, 0); @839
assign tval_pc[31:0] = ifu_iu_ex_expt_cur ?  {pcgen_xx_cur_pc[30:0], 1'b0}: {branch_pcgen_add_pc[30:1], 2'b0};
assign decd_wb_tval[31:0] = {32{tval_sel_pc}} & tval_pc[31:0] |
                            {32{decd_ill_expt}} & decd_inst[31:0] & {{16{decd_inst_32bit}},16'hffff};

//==========================================================
//                decoder post process
//==========================================================
assign decd_retire_cp0_inst                  = decd_sys;

//==========================================================
//     Rename output decoded information for IU modules
//==========================================================
// alu
assign decd_alu_sel     = !(decd_mad_sel || decd_lsu_sel || decd_sys 
                         || decd_branch_sel || decd_special_sel);
assign decd_alu_func[FUNC_WIDTH-1:0]         = decd_func[FUNC_WIDTH-1:0];
assign decd_alu_sub_func[SUB_FUNC_WIDTH-1:0] = decd_sub_func[SUB_FUNC_WIDTH-1:0];
assign decd_alu_dst_vld                      = decd_dst_vld;
assign decd_alu_rs2_imm_vld                  = decd_rs2_imm_vld;

// branch
assign decd_branch_cj    = decd_inst_cj;
assign decd_branch_cjal  = decd_inst_cjal;
assign decd_branch_cjr   = decd_inst_cjr;
assign decd_branch_cjalr = decd_inst_cjalr;
assign decd_branch_cbeqz = decd_inst_cbeqz;
assign decd_branch_cbnez = decd_inst_cbnez;
assign decd_branch_auipc = decd_inst_auipc;
assign decd_branch_jal   = decd_inst_jal;
assign decd_branch_jalr  = decd_inst_jalr;
assign decd_branch_beq   = decd_inst_beq;
assign decd_branch_bne   = decd_inst_bne;
assign decd_branch_blt   = decd_inst_blt;
assign decd_branch_bge   = decd_inst_bge;
assign decd_branch_bltu  = decd_inst_bltu;
assign decd_branch_bgeu  = decd_inst_bgeu;

// special
assign decd_xx_unit_special_sel = decd_special_sel;

// ctrl
assign decd_ctrl_alu_sel        = decd_alu_sel;
assign decd_ctrl_branch_sel     = decd_branch_sel;
assign decd_ctrl_mad_sel        = decd_mad_sel;
assign decd_ctrl_lsu_sel        = decd_lsu_sel;
assign decd_ctrl_cp0_sel        = decd_sys;
assign decd_ctrl_expt_inv       = decd_ill_expt;
assign decd_ctrl_expt_bkpt      = decd_inst_bkpt;
assign decd_ctrl_expt_ecall     = decd_inst_ecall;

//==========================================================
//     Rename output decoded information for LSU
//==========================================================
assign iu_lsu_ex_store  = decd_lsu_store;
assign iu_lsu_ex_byte   = decd_lsu_byte;
assign iu_lsu_ex_half   = decd_lsu_half;
assign iu_lsu_ex_uns    = decd_lsu_uns;

//==========================================================
//     Rename output decoded information for CP0
//==========================================================
assign iu_cp0_ex_mret   = decd_inst_mret_nor;   
assign iu_cp0_ex_wfi    = decd_inst_wfi;  
assign iu_cp0_ex_csrrw  = decd_inst_csrrw;
assign iu_cp0_ex_csrrs  = decd_inst_csrrs;
assign iu_cp0_ex_csrrc  = decd_inst_csrrc;
assign iu_cp0_ex_csrrwi = decd_inst_csrrwi;
assign iu_cp0_ex_csrrsi = decd_inst_csrrsi;
assign iu_cp0_ex_csrrci = decd_inst_csrrci;
assign iu_cp0_ex_rs1_reg[4:0] = decd_rs1[4:0];
assign iu_cp0_ex_rd_reg[4:0]  = decd_rd[4:0];
assign iu_cp0_ex_func3[2:0]  = decd_func3[2:0];

assign ifu_had_chg_flw_inst = decd_branch_inst;
assign ifu_had_match_pc[31:0] = {pcgen_xx_cur_pc[30:0], 1'b0};
// &ModuleEnd; @917
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_iu_gated_clk_reg(
  cp0_yy_clk_en,
  forever_cpuclk,
  pad_yy_gate_clk_en_b,
  write_data,
  x_randclk_reg_mod_en_w32,
  x_reg_dout,
  x_write_en
);

// &Ports; @24
input           cp0_yy_clk_en;           
input           forever_cpuclk;          
input           pad_yy_gate_clk_en_b;    
input   [31:0]  write_data;              
input           x_randclk_reg_mod_en_w32; 
input           x_write_en;              
output  [31:0]  x_reg_dout;              

// &Regs; @25
reg     [31:0]  x_reg_dout;              

// &Wires; @26
wire            cp0_yy_clk_en;           
wire            forever_cpuclk;          
wire            pad_yy_gate_clk_en_b;    
wire            reg_clk_en;              
wire            reg_cpuclk;              
wire    [31:0]  write_data;              
wire    [31:0]  write_in_data;           
wire            write_in_en;             
wire            x_randclk_reg_mod_en_w32; 
wire            x_write_en;              


//==============================================================================
//                      register with only 1 write port
//==============================================================================
assign reg_clk_en = write_in_en;
// &Instance("gated_clk_cell", "x_reg_gated_clk"); @32
gated_clk_cell  x_reg_gated_clk (
  .clk_in                   (forever_cpuclk          ),
  .clk_out                  (reg_cpuclk              ),
  .external_en              (1'b0                    ),
  .global_en                (cp0_yy_clk_en           ),
  .local_en                 (reg_clk_en              ),
  .module_en                (x_randclk_reg_mod_en_w32),
  .pad_yy_gate_clk_en_b     (pad_yy_gate_clk_en_b    )
);

// &Connect(.clk_in      (forever_cpuclk), @33
//          .external_en (1'b0), @34
//          .global_en   (cp0_yy_clk_en), @35
//          .module_en   (x_randclk_reg_mod_en_w32), @36
//          .local_en    (reg_clk_en), @37
//          .i_tst_en    (i_tst_en), @38
//          .clk_out     (reg_cpuclk)); @39

//==========================================================
//                    Write Port
//==========================================================
assign write_in_en = x_write_en;
assign write_in_data[31:0] = write_data[31:0];

// &Force("output", "x_reg_dout"); @54

always @(posedge reg_cpuclk)
begin
  if(write_in_en)
    x_reg_dout[31:0] <= write_in_data[31:0];
  else
    x_reg_dout[31:0] <= x_reg_dout[31:0];
end

// &Force("output", "x_reg_verify"); @66

// &Force("output", "x_reg_dout_pol"); @79

// &ModuleEnd; @90
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_iu_gated_clk_reg_timing(
  cp0_yy_clk_en,
  forever_cpuclk,
  pad_yy_gate_clk_en_b,
  write_data,
  x_randclk_reg_mod_en_w32,
  x_reg_dout,
  x_write_en
);

// &Ports; @24
input           cp0_yy_clk_en;           
input           forever_cpuclk;          
input           pad_yy_gate_clk_en_b;    
input   [31:0]  write_data;              
input           x_randclk_reg_mod_en_w32; 
input           x_write_en;              
output  [31:0]  x_reg_dout;              

// &Regs; @25
reg     [31:0]  x_reg_dout;              

// &Wires; @26
wire            cp0_yy_clk_en;           
wire            forever_cpuclk;          
wire            pad_yy_gate_clk_en_b;    
wire            reg_clk_en;              
wire            reg_cpuclk;              
wire    [31:0]  write_data;              
wire    [31:0]  write_in_data;           
wire            write_in_en;             
wire            x_randclk_reg_mod_en_w32; 
wire            x_write_en;              


//==============================================================================
//                      register with only 1 write port
//==============================================================================
assign reg_clk_en = write_in_en;
// &Instance("gated_clk_cell", "x_reg_gated_clk"); @32
gated_clk_cell  x_reg_gated_clk (
  .clk_in                   (forever_cpuclk          ),
  .clk_out                  (reg_cpuclk              ),
  .external_en              (1'b0                    ),
  .global_en                (cp0_yy_clk_en           ),
  .local_en                 (reg_clk_en              ),
  .module_en                (x_randclk_reg_mod_en_w32),
  .pad_yy_gate_clk_en_b     (pad_yy_gate_clk_en_b    )
);

// &Connect(.clk_in      (forever_cpuclk), @33
//          .external_en (1'b0), @34
//          .global_en   (cp0_yy_clk_en), @35
//          .module_en   (x_randclk_reg_mod_en_w32), @36
//          .local_en    (reg_clk_en), @37
//          .i_tst_en    (i_tst_en), @38
//          .clk_out     (reg_cpuclk)); @39

//==========================================================
//                    Write Port
//==========================================================
assign write_in_en = x_write_en;
assign write_in_data[31:0] = write_data[31:0];

// &Force("output", "x_reg_dout"); @54

always @(posedge reg_cpuclk)
begin
  if(write_in_en)
    x_reg_dout[31:0] <= write_in_data[31:0];
  else
    x_reg_dout[31:0] <= x_reg_dout[31:0];
end

// &Force("output", "x_reg_verify"); @66

// &Force("output", "x_reg_dout_pol"); @79

// &ModuleEnd; @90
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @22
module cr_iu_hs_split(
  hs_split_iu_ctrl_inst_vld,
  hs_split_iu_dp_inst_op,
  hs_split_iu_hs_retire_mask,
  hs_split_iu_hs_switch_se,
  hs_split_iu_nsinst_gpr_rst_b,
  hs_split_iu_unstack_chgflw,
  iu_hs_split_ex_stall,
  iu_ifu_spcu_int_en,
  split_ifctrl_hs_stall,
  split_ifctrl_hs_stall_part
);

// &Ports; @23
input           iu_hs_split_ex_stall;        
input           iu_ifu_spcu_int_en;          
output          hs_split_iu_ctrl_inst_vld;   
output  [31:0]  hs_split_iu_dp_inst_op;      
output          hs_split_iu_hs_retire_mask;  
output          hs_split_iu_hs_switch_se;    
output          hs_split_iu_nsinst_gpr_rst_b; 
output          hs_split_iu_unstack_chgflw;  
output          split_ifctrl_hs_stall;       
output          split_ifctrl_hs_stall_part;  

// &Regs; @24

// &Wires; @25
wire            hs_split_iu_ctrl_inst_vld;   
wire    [31:0]  hs_split_iu_dp_inst_op;      
wire            hs_split_iu_hs_retire_mask;  
wire            hs_split_iu_hs_switch_se;    
wire            hs_split_iu_nsinst_gpr_rst_b; 
wire            hs_split_iu_unstack_chgflw;  
wire            split_ifctrl_hs_stall;       
wire            split_ifctrl_hs_stall_part;  


//==============================================================================
//                      input value when no configuration
//==============================================================================
// &Force("output","split_ifctrl_hs_stall"); @30
// &Force("input","iu_ifu_spcu_int_en"); @31
// &Instance("gated_clk_cell", "x_split_cnt_upd_clkhdr"); @36
// &Connect(.clk_in(forever_cpuclk), @37
//          .external_en(1'b0), @38
//          .global_en(cp0_yy_clk_en), @39
//          .module_en(1'b0), @40
//          .local_en(split_cnt_upd_en), @41
//          .clk_out(split_cnt_upd_clk) @42
//         ); @43
// &Instance("gated_clk_cell", "x_sm_upd_clkhdr"); @46
// &Connect(.clk_in(forever_cpuclk), @47
//          .external_en(1'b0), @48
//          .global_en(cp0_yy_clk_en), @49
//          .module_en(1'b0), @50
//          .local_en(sm_upd_en), @51
//          .clk_out(sm_upd_clk) @52
//         ); @53
// &CombBeg; @156
// &CombEnd; @263
// &CombBeg; @363
// &CombEnd; @371
assign hs_split_iu_nsinst_gpr_rst_b = 1'b1; 
assign hs_split_iu_hs_retire_mask   = 1'b0; 
assign hs_split_iu_unstack_chgflw   = 1'b0;
assign hs_split_iu_hs_switch_se     = 1'b0;
assign split_ifctrl_hs_stall_part   = 1'b0;
assign split_ifctrl_hs_stall        = 1'b0;
assign hs_split_iu_ctrl_inst_vld    = 1'b0;
//assign hs_split_iu_ex_cr_oper       = 1'b0;
//assign hs_split_iu_hs_retire_mask   = 1'b0;
assign hs_split_iu_dp_inst_op[31:0] = 32'b0;
// &Force("input","iu_hs_split_ex_stall"); @417
// 1. check fail, stall ibuf
// 2. speculation fail, stall ibuf
//assign split_ifctrl_int_acc_stall = int_spcu_check_fail 
//                                 || iu_ifu_spcu_error_without_misalign 
//                                    && int_spcu_sm_not_idle; 

//==========================================================
//               Interface to IF Data Path
//==========================================================
//the data path signal
// &ModuleEnd; @429
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_iu_lockup(
  cache_iu_lockup_ack,
  cp0_iu_in_expt,
  cp0_iu_in_nmi,
  cp0_iu_mret,
  cpurst_b,
  ifu_iu_lockup_ack,
  iu_cache_lockup_req,
  iu_cp0_lockup_clr,
  iu_cp0_lockup_vld,
  iu_ifu_lockup_mask,
  iu_ifu_lockup_on,
  iu_ifu_lockup_req,
  iu_sysio_lockup_on,
  lockup_retire_dbg_vld,
  lockup_retire_mask,
  lockup_retire_nmi_vld,
  misc_clk,
  retire_lockup_dbg_on,
  retire_lockup_dbg_vld,
  retire_lockup_expt_vld,
  retire_lockup_inst_retire,
  retire_lockup_nmi_vld,
  retire_lockup_retire_pc
);

// &Ports; @24
input           cache_iu_lockup_ack;      
input           cp0_iu_in_expt;           
input           cp0_iu_in_nmi;            
input           cp0_iu_mret;              
input           cpurst_b;                 
input           ifu_iu_lockup_ack;        
input           misc_clk;                 
input           retire_lockup_dbg_on;     
input           retire_lockup_dbg_vld;    
input           retire_lockup_expt_vld;   
input           retire_lockup_inst_retire; 
input           retire_lockup_nmi_vld;    
input   [31:0]  retire_lockup_retire_pc;  
output          iu_cache_lockup_req;      
output          iu_cp0_lockup_clr;        
output          iu_cp0_lockup_vld;        
output          iu_ifu_lockup_mask;       
output          iu_ifu_lockup_on;         
output          iu_ifu_lockup_req;        
output          iu_sysio_lockup_on;       
output          lockup_retire_dbg_vld;    
output          lockup_retire_mask;       
output          lockup_retire_nmi_vld;    

// &Regs; @25
reg     [2 :0]  lockup_cur_st;            
reg     [2 :0]  lockup_nxt_st;            

// &Wires; @26
wire            cache_iu_lockup_ack;      
wire            cp0_iu_in_expt;           
wire            cp0_iu_in_nmi;            
wire            cp0_iu_mret;              
wire            cpurst_b;                 
wire            ifu_iu_lockup_ack;        
wire            iu_cache_lockup_req;      
wire            iu_cp0_lockup_clr;        
wire            iu_cp0_lockup_vld;        
wire            iu_ifu_lockup_mask;       
wire            iu_ifu_lockup_on;         
wire            iu_ifu_lockup_req;        
wire            iu_sysio_lockup_on;       
wire            lock_up_ack;              
wire            lock_up_vld;              
wire            lockup_retire_dbg_vld;    
wire            lockup_retire_mask;       
wire            lockup_retire_nmi_vld;    
wire            misc_clk;                 
wire            retire_lockup_dbg_on;     
wire            retire_lockup_dbg_vld;    
wire            retire_lockup_expt_vld;   
wire            retire_lockup_inst_retire; 
wire            retire_lockup_nmi_vld;    
wire    [31:0]  retire_lockup_retire_pc;  


// lock up module
// 1. Lock up valid when expt vld in a expt handler, ecall and ebreak excluded
// 2. Lock up will wait IFU empty and mask IFU fetch
// 3. Lock up can react debug and nmi

assign lock_up_vld = (cp0_iu_in_expt || cp0_iu_in_nmi) && retire_lockup_expt_vld;
// Lock up state machine
parameter IDLE  = 3'b000;
parameter WFLU  = 3'b001;
parameter LKUP  = 3'b010;
parameter LKNMI = 3'b011;
parameter LKDBG = 3'b111;

always @ (posedge misc_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    lockup_cur_st[2:0] <= IDLE;
  else
    lockup_cur_st[2:0] <= lockup_nxt_st[2:0];
end

// &CombBeg; @49
always @( retire_lockup_dbg_vld
       or lock_up_vld
       or lock_up_ack
       or retire_lockup_retire_pc[31:0]
       or retire_lockup_dbg_on
       or retire_lockup_nmi_vld
       or cp0_iu_in_nmi
       or lockup_cur_st[2:0]
       or cp0_iu_mret
       or retire_lockup_inst_retire)
begin
case(lockup_cur_st[2:0])
  IDLE:
  begin
    if(lock_up_vld)
      lockup_nxt_st[2:0] = WFLU;
    else
      lockup_nxt_st[2:0] = IDLE;
  end
  WFLU:
  begin
    if(lock_up_ack)
      lockup_nxt_st[2:0] = LKUP;
    else
      lockup_nxt_st[2:0] = WFLU;
  end
  LKUP:
  begin
    if(retire_lockup_dbg_vld)
      lockup_nxt_st[2:0] = LKDBG;
    else if(retire_lockup_nmi_vld && !cp0_iu_in_nmi)
      lockup_nxt_st[2:0] = LKNMI;
    else
      lockup_nxt_st[2:0] = LKUP;
  end
  LKNMI:
  begin
    if(cp0_iu_mret || lock_up_vld)
      lockup_nxt_st[2:0] = WFLU;
    else
      lockup_nxt_st[2:0] = LKNMI;
  end
  LKDBG:
  begin
    if(retire_lockup_inst_retire && !retire_lockup_dbg_on)
      if(retire_lockup_retire_pc[31:0] == 32'hEFFFFFFC)
        lockup_nxt_st[2:0] = WFLU;
      else
        lockup_nxt_st[2:0] = IDLE;
    else
      lockup_nxt_st[2:0] = LKDBG;
  end
  default:
  begin
    lockup_nxt_st[2:0] = IDLE;
  end
endcase
// &CombEnd; @96
end

assign lock_up_ack         = ifu_iu_lockup_ack && cache_iu_lockup_ack;
assign iu_ifu_lockup_req   = lockup_cur_st[2:0] == WFLU;
assign iu_cache_lockup_req = lockup_cur_st[2:0] == WFLU;
assign iu_ifu_lockup_on    = lockup_cur_st[2:0] == LKUP;
assign iu_sysio_lockup_on  = lockup_cur_st[2:0] == LKUP;

assign lockup_retire_mask    = lock_up_vld;
assign lockup_retire_nmi_vld = lockup_cur_st[2:0] == LKUP && retire_lockup_nmi_vld;
assign lockup_retire_dbg_vld = lockup_cur_st[2:0] == LKUP && retire_lockup_dbg_vld;

assign iu_cp0_lockup_vld     = lockup_cur_st[2:0] == WFLU && lock_up_ack;
assign iu_cp0_lockup_clr     = retire_lockup_inst_retire && !retire_lockup_dbg_on
                            && retire_lockup_retire_pc[31:0] != 32'hEFFFFFFC
                            && lockup_cur_st[2:0] == LKDBG;

assign iu_ifu_lockup_mask   = lockup_cur_st[2:0] == WFLU || lockup_cur_st[2:0] == LKUP;

// &ModuleEnd; @115
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @25
module cr_iu_mad(
  alu_mad_adder_of,
  alu_mad_adder_rst,
  alu_mad_rst_cout,
  cp0_yy_clk_en,
  cpurst_b,
  ctrl_mad_ex_data_sel,
  ctrl_mad_ex_sel,
  ctrl_mad_oper_mux_en,
  decd_mad_inst_div,
  decd_mad_inst_divu,
  decd_mad_inst_mul,
  decd_mad_inst_mulh,
  decd_mad_inst_mulhsu,
  decd_mad_inst_mulhu,
  decd_mad_inst_rem,
  decd_mad_inst_remu,
  forever_cpuclk,
  ifu_iu_ex_cnt,
  ifu_iu_ex_split_on,
  iu_lsu_imm_data,
  iu_lsu_imm_write_en,
  iu_yy_xx_flush,
  lsu_iu_mad_buf,
  mad_alu_data_vld,
  mad_alu_div_rs2,
  mad_alu_div_shift,
  mad_alu_fst_add,
  mad_alu_imm_vld,
  mad_alu_rs1,
  mad_alu_rs1_cst_0,
  mad_alu_rs1_vld,
  mad_alu_rs2_cst_0,
  mad_alu_rst,
  mad_alu_rst_vld,
  mad_ctrl_stall,
  mad_ctrl_stall_noinput,
  mad_rbus_req,
  oper_mad_rs1,
  oper_mad_rs2,
  pad_yy_gate_clk_en_b,
  randclk_mad_mod_en_w2,
  retire_mad_ex_cancel,
  wb_ctrl_stall
);

// &Ports; @26
input            alu_mad_adder_of;      
input   [31:0 ]  alu_mad_adder_rst;     
input            alu_mad_rst_cout;      
input            cp0_yy_clk_en;         
input            cpurst_b;              
input            ctrl_mad_ex_data_sel;  
input            ctrl_mad_ex_sel;       
input            ctrl_mad_oper_mux_en;  
input            decd_mad_inst_div;     
input            decd_mad_inst_divu;    
input            decd_mad_inst_mul;     
input            decd_mad_inst_mulh;    
input            decd_mad_inst_mulhsu;  
input            decd_mad_inst_mulhu;   
input            decd_mad_inst_rem;     
input            decd_mad_inst_remu;    
input            forever_cpuclk;        
input            iu_yy_xx_flush;        
input   [31:0 ]  lsu_iu_mad_buf;        
input   [31:0 ]  oper_mad_rs1;          
input   [31:0 ]  oper_mad_rs2;          
input            pad_yy_gate_clk_en_b;  
input            randclk_mad_mod_en_w2; 
input            retire_mad_ex_cancel;  
input            wb_ctrl_stall;         
output  [4 :0 ]  ifu_iu_ex_cnt;         
output           ifu_iu_ex_split_on;    
output  [31:0 ]  iu_lsu_imm_data;       
output           iu_lsu_imm_write_en;   
output           mad_alu_data_vld;      
output  [31:0 ]  mad_alu_div_rs2;       
output           mad_alu_div_shift;     
output           mad_alu_fst_add;       
output           mad_alu_imm_vld;       
output  [31:0 ]  mad_alu_rs1;           
output           mad_alu_rs1_cst_0;     
output           mad_alu_rs1_vld;       
output           mad_alu_rs2_cst_0;     
output  [31:0 ]  mad_alu_rst;           
output           mad_alu_rst_vld;       
output           mad_ctrl_stall;        
output           mad_ctrl_stall_noinput; 
output           mad_rbus_req;          

// &Regs; @27
reg     [2 :0 ]  cur_st;                
reg     [31:0 ]  mad_internal;          
reg              mad_neg;               
reg              mad_rs1_cst_0;         
reg     [2 :0 ]  nxt_st;                
reg     [4 :0 ]  rst_ff1;               
reg     [4 :0 ]  split_cnt;             

// &Wires; @28
wire             alu_mad_adder_of;      
wire    [31:0 ]  alu_mad_adder_rst;     
wire             alu_mad_rst_cout;      
wire             cnt_en;                
wire             cp0_yy_clk_en;         
wire             cpurst_b;              
wire             ctrl_mad_ex_data_sel;  
wire             ctrl_mad_ex_sel;       
wire             ctrl_mad_oper_mux_en;  
wire             decd_mad_inst_div;     
wire             decd_mad_inst_divu;    
wire             decd_mad_inst_mul;     
wire             decd_mad_inst_mulh;    
wire             decd_mad_inst_mulhsu;  
wire             decd_mad_inst_mulhu;   
wire             decd_mad_inst_rem;     
wire             decd_mad_inst_remu;    
wire    [4 :0 ]  div_cnt;               
wire    [31:0 ]  div_ifu_imm;           
wire    [31:0 ]  div_ifu_imm_pre;       
wire             div_neg;               
wire    [31:0 ]  div_quotient;          
wire    [31:0 ]  div_remainder;         
wire             div_rs2_shift;         
wire    [31:0 ]  div_rst;               
wire             div_rst_neg;           
wire    [31:0 ]  div_rst_rev;           
wire    [31:0 ]  div_rst_sel;           
wire             div_single_quotient;   
wire             div_unsigned;          
wire             div_vld;               
wire             div_zero;              
wire    [4 :0 ]  ff1_disp;              
wire             forever_cpuclk;        
wire    [4 :0 ]  ifu_iu_ex_cnt;         
wire             ifu_iu_ex_split_on;    
wire             ifu_iu_mad_idle;       
wire             ifu_iu_mad_pair;       
wire             ifu_iu_mad_split;      
wire             ifu_iu_mad_wfi2;       
wire             ifu_iu_mult_sign;      
wire    [4 :0 ]  iu_ifu_cnt;            
wire             iu_ifu_cnt_write_en;   
wire             iu_ifu_ex_stall;       
wire             iu_ifu_mad_cmplt;      
wire    [31:0 ]  iu_lsu_imm_data;       
wire             iu_lsu_imm_write_en;   
wire             iu_yy_xx_flush;        
wire    [31:0 ]  lsu_iu_mad_buf;        
wire             mad_alu_data_vld;      
wire    [31:0 ]  mad_alu_div_rs2;       
wire             mad_alu_div_shift;     
wire             mad_alu_fst_add;       
wire             mad_alu_imm_vld;       
wire    [31:0 ]  mad_alu_rs1;           
wire             mad_alu_rs1_cst_0;     
wire             mad_alu_rs1_vld;       
wire             mad_alu_rs2_cst_0;     
wire    [31:0 ]  mad_alu_rst;           
wire             mad_alu_rst_vld;       
wire             mad_clk;               
wire             mad_clk_en;            
wire             mad_cmplt;             
wire    [4 :0 ]  mad_cnt;               
wire             mad_ctrl_stall;        
wire             mad_ctrl_stall_noinput; 
wire    [31:0 ]  mad_ff1_src;           
wire             mad_pair;              
wire             mad_pair_mult_sign;    
wire             mad_pair_vld;          
wire             mad_rbus_req;          
wire    [31:0 ]  mad_rs1;               
wire    [31:0 ]  mad_rs1_abs;           
wire             mad_rs1_abs_sel;       
wire    [31:0 ]  mad_rs1_fin;           
wire    [31:0 ]  mad_rs2;               
wire    [31:0 ]  mad_rs2_abs;           
wire             mad_rs2_abs_sel;       
wire    [31:00]  mad_rs2_fin;           
wire             mad_vld_no_cancel;     
wire             mad_vld_no_input;      
wire             mls_cmplt;             
wire             mls_vld_no_cancel;     
wire             mulh_vld;              
wire             mult_add_one;          
wire             mult_fst_vld;          
wire    [31:0 ]  mult_high_data;        
wire    [31:0 ]  mult_high_rst;         
wire    [31:0 ]  mult_ifu_imm;          
wire    [31:0 ]  mult_low_rst;          
wire             mult_neg;              
wire    [31:0 ]  mult_reverse;          
wire    [31:0 ]  mult_rst;              
wire    [31:0 ]  mult_rst_fin;          
wire    [31:0 ]  mult_rst_pre;          
wire             mult_vld;              
wire             mult_zero;             
wire    [31:0 ]  oper_mad_rs1;          
wire    [31:0 ]  oper_mad_rs2;          
wire             pad_yy_gate_clk_en_b;  
wire             quot_zero;             
wire             randclk_mad_mod_en_w2; 
wire             rem_vld;               
wire             retire_mad_ex_cancel;  
wire             rs1_eqlz;              
wire    [4 :0 ]  rs1_ff1_rst;           
wire             rs2_eqlz;              
wire    [4 :0 ]  rs2_ff1_rst;           
wire             sm_upd_clk;            
wire             sm_upd_en;             
wire    [4 :0 ]  split_cnt_dec;         
wire             split_cnt_en;          
wire    [4 :0 ]  split_cnt_inc;         
wire             split_cnt_offset;      
wire             split_cnt_rst;         
wire             split_cnt_upd_clk;     
wire             split_cnt_upd_en;      
wire             split_cnt_write_en;    
wire             split_last;            
wire             split_last_noinput;    
wire             split_mad_cmplt;       
wire             split_on;              
wire             split_xx_stall;        
wire             wb_ctrl_stall;         



// &Force("input","ctrl_mad_ex_data_sel"); @41
// &Force("nonport","mad_rs1"); @45
// &Force("nonport","mad_rs2"); @46
// &Force("nonport","mult_result"); @47
// &Force("nonport","mult_sign"); @48
// &Force("bus","mult_result",63,0); @70

//==============================================================================
//                         SMALL Configuration MAD
//==============================================================================
//SMALL configuration implements no multiplier
//MAD use a add-shift algorithm, completely take ALU adder's data path

assign mad_rs1_abs_sel   = !(decd_mad_inst_mulhu || div_unsigned) && mad_rs1[31]; 

//==========================================================
//               Adder Operand Selection
//==========================================================
//1.the source 0 may be masked as 0, indicating by
//   mad_alu_rs1_cst_0, and done in ALU operand prepare logic
//2.the other adder source is always from 32bit immediate
//   data path
assign mad_cnt[4:0] = {5{ctrl_mad_oper_mux_en}} & split_cnt[4:0];
// &CombBeg; @105
always @( mad_rs2_fin[01:00]
       or mad_cnt[4:0]
       or mad_rs2_fin[21:17]
       or mad_rs2_fin[12:00]
       or mad_rs2_fin[16:09]
       or mad_rs2_fin[31:22])
begin
  case(mad_cnt[4:0])
    5'd31 : mad_rs1_cst_0 = mad_rs2_fin[31];
    5'd30 : mad_rs1_cst_0 = mad_rs2_fin[30];
    5'd29 : mad_rs1_cst_0 = mad_rs2_fin[29];
    5'd28 : mad_rs1_cst_0 = mad_rs2_fin[28];
    5'd27 : mad_rs1_cst_0 = mad_rs2_fin[27];
    5'd26 : mad_rs1_cst_0 = mad_rs2_fin[26];
    5'd25 : mad_rs1_cst_0 = mad_rs2_fin[25];
    5'd24 : mad_rs1_cst_0 = mad_rs2_fin[24];
    5'd23 : mad_rs1_cst_0 = mad_rs2_fin[23];
    5'd22 : mad_rs1_cst_0 = mad_rs2_fin[22];
    5'd21 : mad_rs1_cst_0 = mad_rs2_fin[21];
    5'd20 : mad_rs1_cst_0 = mad_rs2_fin[20];
    5'd19 : mad_rs1_cst_0 = mad_rs2_fin[19];
    5'd18 : mad_rs1_cst_0 = mad_rs2_fin[18];
    5'd17 : mad_rs1_cst_0 = mad_rs2_fin[17];
    5'd16 : mad_rs1_cst_0 = mad_rs2_fin[16];
    5'd15 : mad_rs1_cst_0 = mad_rs2_fin[15];
    5'd14 : mad_rs1_cst_0 = mad_rs2_fin[14];
    5'd13 : mad_rs1_cst_0 = mad_rs2_fin[13];
    5'd12 : mad_rs1_cst_0 = mad_rs2_fin[12];
    5'd11 : mad_rs1_cst_0 = mad_rs2_fin[11];
    5'd10 : mad_rs1_cst_0 = mad_rs2_fin[10];
    5'd9  : mad_rs1_cst_0 = mad_rs2_fin[09];
    5'd8  : mad_rs1_cst_0 = mad_rs2_fin[08];
    5'd7  : mad_rs1_cst_0 = mad_rs2_fin[07];
    5'd6  : mad_rs1_cst_0 = mad_rs2_fin[06];
    5'd5  : mad_rs1_cst_0 = mad_rs2_fin[05];
    5'd4  : mad_rs1_cst_0 = mad_rs2_fin[04];
    5'd3  : mad_rs1_cst_0 = mad_rs2_fin[03];
    5'd2  : mad_rs1_cst_0 = mad_rs2_fin[02];
    5'd1  : mad_rs1_cst_0 = mad_rs2_fin[01];
    5'd0  : mad_rs1_cst_0 = mad_rs2_fin[00];
    default:mad_rs1_cst_0 = 1'bx;
endcase
// &CombEnd; @141
end
 
//if ifu signal fix mult is set, the mult will execute 32 cycles
assign mult_fst_vld = ifu_iu_mad_wfi2;
assign mad_alu_rs2_cst_0  = ctrl_mad_ex_data_sel && mult_fst_vld && mult_vld;

//the source 0 and source 1 immediate does not effect the ff1 operands
assign mad_alu_rs1_cst_0 = ctrl_mad_ex_data_sel && mult_vld 
                        && (!mad_rs1_cst_0 || mult_fst_vld);
assign mad_alu_imm_vld   = ctrl_mad_ex_data_sel && mult_vld && !mult_fst_vld;

//==============================================================================
//                         Implementation of MULH
//==============================================================================
assign mult_low_rst[31:0]   = mad_pair ? lsu_iu_mad_buf[31:0] :
                              (mult_vld && rst_ff1[4:0] == 5'b0) ? mad_rs1_fin[31:0]
                              : alu_mad_adder_rst[31:0];

assign mult_high_rst[31:0]  = rst_ff1[4:0] == 5'b0 ? {31'b0, mult_neg && mult_low_rst[31]} : (mad_internal[31:0] + {31'b0, alu_mad_adder_of});
assign mult_high_data[31:0] = {mult_high_rst[30:0], alu_mad_adder_rst[31]};
//assign mult_ifu_imm[31:0] = {alu_mad_adder_rst[30:0], 1'b0};
assign mult_ifu_imm[31:0] = (mult_fst_vld && mult_vld && rst_ff1[4:0] == 5'b0) 
                           ? mad_rs1_fin[31:0] : split_on ? 
                            {alu_mad_adder_rst[30:0], 1'b0}
                           : alu_mad_adder_rst[31:0];

// the result of mul low is naturally in alu
assign mult_zero = rs1_eqlz || rs2_eqlz;
assign mult_neg = mad_pair ? mad_neg : 
                 (decd_mad_inst_mulh || decd_mad_inst_mul)
                  && (mad_rs1[31] ^ mad_rs2[31])
               || decd_mad_inst_mulhsu && mad_rs1[31];

// reverse and add 1 if neg
assign mult_rst_pre[31:0] = mulh_vld ? mult_high_rst[31:0] : mult_low_rst[31:0];
assign mult_reverse[31:0] = {32{mult_neg}} ^ mult_rst_pre[31:0];
assign mult_add_one       = mulh_vld ? mult_neg && alu_mad_adder_rst[31:0] == 32'b0 : mult_neg;
assign mult_rst_fin[31:0] = mult_reverse[31:0] + {31'b0, mult_add_one}; 
assign mult_rst[31:0] = {32{!mult_zero}} & mult_rst_fin[31:0];

assign iu_lsu_imm_write_en   = ctrl_mad_ex_sel && (split_on || mulh_vld) && !ifu_iu_mad_pair;

//==========================================================
//                 Instance of Gated Cell  
//==========================================================
assign mad_clk_en = ctrl_mad_ex_sel;
// &Instance("gated_clk_cell", "x_mad_gated_clk"); @190
gated_clk_cell  x_mad_gated_clk (
  .clk_in                (forever_cpuclk       ),
  .clk_out               (mad_clk              ),
  .external_en           (1'b0                 ),
  .global_en             (cp0_yy_clk_en        ),
  .local_en              (mad_clk_en           ),
  .module_en             (randclk_mad_mod_en_w2),
  .pad_yy_gate_clk_en_b  (pad_yy_gate_clk_en_b )
);

// &Connect(.clk_in      (forever_cpuclk), @191
//          .external_en (1'b0), @192
//          .global_en   (cp0_yy_clk_en), @193
//          .module_en   (randclk_mad_mod_en_w2), @194
//          .local_en    (mad_clk_en), @195
//          .clk_out     (mad_clk)); @196

//==========================================================
//               Parameter Definition
//==========================================================
parameter IDLE  = 3'b000,
          WFI1  = 3'b001,
          SPLIT = 3'b010,
          WFI2  = 3'b011,
          PAIR  = 3'b110,
          PAIRS = 3'b111;

//==========================================================
//                       Operand Mux
//==========================================================
assign mad_rs1[31:0] = {32{ctrl_mad_oper_mux_en}} & oper_mad_rs1[31:0];
assign mad_rs2[31:0] = {32{ctrl_mad_oper_mux_en}} & oper_mad_rs2[31:0];
assign mult_vld = decd_mad_inst_mul  || decd_mad_inst_mulhu 
               || decd_mad_inst_mulh || decd_mad_inst_mulhsu;
assign div_vld  = decd_mad_inst_div  || decd_mad_inst_divu 
               || decd_mad_inst_rem  || decd_mad_inst_remu;
assign div_unsigned = decd_mad_inst_divu || decd_mad_inst_remu;
assign rem_vld  = decd_mad_inst_rem  || decd_mad_inst_remu;

assign mulh_vld = decd_mad_inst_mulhu || decd_mad_inst_mulh 
                || decd_mad_inst_mulhsu;

assign mad_rs1_abs[31:0] = ~mad_rs1[31:0] + 1'b1;
assign mad_rs2_abs[31:0] = ~mad_rs2[31:0] + 1'b1;

assign mad_rs1_fin[31:0] = mad_rs1_abs_sel ? mad_rs1_abs[31:0] : mad_rs1[31:0];

assign mad_rs2_abs_sel   = !(decd_mad_inst_mulhu || decd_mad_inst_mulhsu || div_unsigned) && mad_rs2[31]; 
assign mad_rs2_fin[31:0] = mad_rs2_abs_sel ? mad_rs2_abs[31:0] : mad_rs2[31:0];

assign rs1_eqlz = mad_rs1[31:0] == 32'b0;
assign rs2_eqlz = mad_rs2[31:0] == 32'b0;

assign iu_ifu_cnt_write_en = ctrl_mad_ex_sel && (div_vld ? ifu_iu_mad_wfi2
                           : ifu_iu_mad_wfi2);
assign iu_ifu_cnt[4:0]     = mult_vld ? rst_ff1[4:0] : div_cnt[4:0];
//================================================
// FF1 logic
//================================================
assign mad_ff1_src[31:0] = ifu_iu_mad_idle && div_vld ? mad_rs1_fin[31:0] : mad_rs2_fin[31:0];
// &CombBeg; @241
always @( mad_ff1_src[31:0])
begin
  rst_ff1[4:0] = 5'd0;
  casez(mad_ff1_src[31:0])
  32'b1???????????????????????????????: rst_ff1[4:0] = 5'd31;
  32'b01??????????????????????????????: rst_ff1[4:0] = 5'd30;
  32'b001?????????????????????????????: rst_ff1[4:0] = 5'd29;
  32'b0001????????????????????????????: rst_ff1[4:0] = 5'd28;
  32'b00001???????????????????????????: rst_ff1[4:0] = 5'd27;
  32'b000001??????????????????????????: rst_ff1[4:0] = 5'd26;
  32'b0000001?????????????????????????: rst_ff1[4:0] = 5'd25;
  32'b00000001????????????????????????: rst_ff1[4:0] = 5'd24;
  32'b000000001???????????????????????: rst_ff1[4:0] = 5'd23;
  32'b0000000001??????????????????????: rst_ff1[4:0] = 5'd22;
  32'b00000000001?????????????????????: rst_ff1[4:0] = 5'd21;
  32'b000000000001????????????????????: rst_ff1[4:0] = 5'd20;
  32'b0000000000001???????????????????: rst_ff1[4:0] = 5'd19;
  32'b00000000000001??????????????????: rst_ff1[4:0] = 5'd18;
  32'b000000000000001?????????????????: rst_ff1[4:0] = 5'd17;
  32'b0000000000000001????????????????: rst_ff1[4:0] = 5'd16;
  32'b00000000000000001???????????????: rst_ff1[4:0] = 5'd15;
  32'b000000000000000001??????????????: rst_ff1[4:0] = 5'd14;
  32'b0000000000000000001?????????????: rst_ff1[4:0] = 5'd13;
  32'b00000000000000000001????????????: rst_ff1[4:0] = 5'd12;
  32'b000000000000000000001???????????: rst_ff1[4:0] = 5'd11;
  32'b0000000000000000000001??????????: rst_ff1[4:0] = 5'd10;
  32'b00000000000000000000001?????????: rst_ff1[4:0] = 5'd9;
  32'b000000000000000000000001????????: rst_ff1[4:0] = 5'd8;
  32'b0000000000000000000000001???????: rst_ff1[4:0] = 5'd7;
  32'b00000000000000000000000001??????: rst_ff1[4:0] = 5'd6;
  32'b000000000000000000000000001?????: rst_ff1[4:0] = 5'd5;
  32'b0000000000000000000000000001????: rst_ff1[4:0] = 5'd4;
  32'b00000000000000000000000000001???: rst_ff1[4:0] = 5'd3;
  32'b000000000000000000000000000001??: rst_ff1[4:0] = 5'd2;
  32'b0000000000000000000000000000001?: rst_ff1[4:0] = 5'd1;
  32'b00000000000000000000000000000001: rst_ff1[4:0] = 5'd0;
  endcase
// &CombEnd; @277
end

//the intermediate summation is written back to
//EX piepline immediate registers
//note that in ff1 cycle, the adder of alu is not selected,
//so the adder result is 0, could be write into imm
// &Force("bus","alu_mad_adder_rst",31,0); @283
always @ (posedge mad_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    mad_internal[31:0] <= 32'b0;
  else if (ctrl_mad_ex_sel && mulh_vld && ifu_iu_mad_wfi2)
    mad_internal[31:0] <= 32'b0;
  else if (ctrl_mad_ex_sel && mulh_vld)
    mad_internal[31:0] <= mult_high_data[31:0];
  else if (ctrl_mad_ex_sel && div_vld && ifu_iu_mad_idle && (quot_zero || div_zero))
    mad_internal[31:0] <= mad_rs1_fin[31:0];
  else if (ctrl_mad_ex_sel && div_vld && ifu_iu_mad_idle)
    mad_internal[31:0] <= {27'b0, rst_ff1[4:0]};
  else if (ctrl_mad_ex_sel && div_vld && ifu_iu_mad_wfi2)
    mad_internal[31:0] <= mad_rs1_fin[31:0];
  else if (ctrl_mad_ex_sel && div_vld && split_on && div_single_quotient && !ifu_iu_mad_pair)
    mad_internal[31:0] <= alu_mad_adder_rst[31:0];
  else
    mad_internal[31:0] <= mad_internal[31:0];
end

assign mad_pair = 1'b0;

always @ (posedge mad_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    mad_neg <= 1'b0;
  else if(ifu_iu_mult_sign)
    mad_neg <= 1'b1;
  else if(!split_on)
    mad_neg <= 1'b0;
  else
    mad_neg <= mad_neg;
end

//==============================================================================
//                         Implementation of DIV
//==============================================================================
// 1. judge if there is a negtive value in rs1 and rs2
assign div_neg    = !div_unsigned && (mad_rs1[31] ^ mad_rs2[31]) 
                 && !rs1_eqlz;

// 2. judge if the dividend is less than divisor or is zero
assign quot_zero = ifu_iu_mad_idle && alu_mad_rst_cout && !rs2_eqlz && alu_mad_adder_rst[31:0] != 32'b0;
assign div_zero = rs2_eqlz;

// 3. ff1 for rs1
assign rs1_ff1_rst[4:0] = {5{ifu_iu_mad_wfi2}} & mad_internal[4:0];

// 4. ff1 for rs2
assign rs2_ff1_rst[4:0] = rst_ff1[4:0];

// 5. disp for ff1 rsts
assign ff1_disp[4:0] = rs1_ff1_rst[4:0] - rs2_ff1_rst[4:0];
assign div_cnt[4:0] = ff1_disp[4:0];

// 6. iteration sub
assign div_rs2_shift = div_vld && ifu_iu_mad_split;

// 7. cal quotient and remainder
// &Force("bus", "lsu_iu_mad_buf", 31, 0); @345
assign div_single_quotient = !alu_mad_rst_cout;
assign div_ifu_imm_pre[31:0] = {32{!ifu_iu_mad_wfi2}} & {lsu_iu_mad_buf[30:0], div_single_quotient};
assign div_ifu_imm[31:0] = {32{!quot_zero}} & div_ifu_imm_pre[31:0] | {32{div_zero}};

assign div_quotient[31:0]  = div_ifu_imm[31:0];
assign div_remainder[31:0] = (quot_zero || div_zero) ? mad_rs1[31:0] : div_single_quotient ? alu_mad_adder_rst[31:0] : mad_internal[31:0];

assign div_rst_sel[31:0] = rem_vld ? div_remainder[31:0] : div_quotient[31:0];
assign div_rst_neg       = rem_vld ? !div_unsigned && mad_rs1[31] && !(quot_zero || div_zero) : div_neg && !rs2_eqlz;

assign div_rst_rev[31:0]  = {32{div_rst_neg}} ^ div_rst_sel[31:0];
assign div_rst[31:0]      = div_rst_rev[31:0] + {31'b0, div_rst_neg};

// send to alu
assign mad_alu_rs1_vld       = div_vld || mult_vld;
assign mad_alu_rs1[31:0]     = div_rs2_shift ? mad_internal[31:0] : mad_rs1_fin[31:0];
assign mad_alu_div_shift     = div_rs2_shift;
assign mad_alu_fst_add       = ifu_iu_mad_idle && mad_rs2_abs_sel;
assign mad_alu_div_rs2[31:0] = mad_rs2_fin[31:0];

//assign mad_split_full_cnt    = rs1_ff1_rst[4:0] == 5'h1f;

// divide complete when dividend is less than divisor (abs)
assign iu_ifu_mad_cmplt      = //(mult_vld && ifu_iu_mad_wfi2 && rst_ff1[4:0] == 5'b0 || 
                               div_vld && ifu_iu_mad_idle && (quot_zero || div_zero)//) 
                               && ctrl_mad_ex_sel;

assign iu_lsu_imm_data[31:0] = div_vld ? div_ifu_imm[31:0] : mult_ifu_imm[31:0];

//==========================================================
//                  Request result bus
//==========================================================
//result bus request
//each of mult instruction should retire for interrupt
assign mad_rbus_req   = ctrl_mad_ex_sel && split_mad_cmplt;
//data valid
assign mad_alu_data_vld = split_mad_cmplt;

assign mad_alu_rst_vld   = mult_vld || div_vld;
assign mad_alu_rst[31:0] = div_vld ? div_rst[31:0] : mult_rst[31:0];

// &Force("input", "ctrl_mad_ex_sel"); @392
// &Force("input", "ctrl_mad_oper_mux_en"); @393
// &Force("input", "decd_mad_inst_div"); @395
// &Force("input", "decd_mad_inst_divu"): @396
// &Force("input", "decd_mad_inst_mul"); @397
// &Force("input", "decd_mad_inst_mulh"); @398
// &Force("input", "decd_mad_inst_mulhsu"); @399
// &Force("input", "decd_mad_inst_mulhu"); @400
// &Force("input", "decd_mad_inst_rem"); @401
// &Force("input", "decd_mad_inst_remu"); @402
// &Force("input", "alu_mad_adder_of"); @404
// &Force("input", "alu_mad_adder_rst"); @405
// &Force("bus", "alu_mad_adder_rst", 31, 0); @406
// &Force("input", "alu_mad_rst_cout"); @407
// &Force("input", "decd_mad_inst_divu"); @408
// &Force("input", "randclk_mad_mod_en_w2"); @409
// &Force("input", "retire_mad_ex_cancel"); @411
// &Force("input", "oper_mad_rs1"); @421
// &Force("bus", "oper_mad_rs1", 31, 0); @422
// &Force("input", "oper_mad_rs2"); @423
// &Force("bus", "oper_mad_rs2", 31, 0); @424
assign iu_ifu_ex_stall = wb_ctrl_stall;

assign ifu_iu_ex_split_on = split_on;
assign mad_ctrl_stall   = split_xx_stall;
assign mad_ctrl_stall_noinput = ((cur_st != IDLE) || mad_vld_no_input) && !split_last_noinput;
assign split_last_noinput = (cur_st == SPLIT) && mad_vld_no_input && mad_cmplt
                          || cur_st[2];

//==============================================================================
//                      input value when no configuration
//==============================================================================
// &Force("bus","ifdp_split_inst",31,0); @471
//==============================================================================
//                            Gated Clock
//==============================================================================
// &Instance("gated_clk_cell", "x_split_cnt_upd_clkhdr"); @475
gated_clk_cell  x_split_cnt_upd_clkhdr (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (split_cnt_upd_clk   ),
  .external_en          (1'b0                ),
  .global_en            (cp0_yy_clk_en       ),
  .local_en             (split_cnt_upd_en    ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in(forever_cpuclk), @476
//          .external_en(1'b0), @477
//          .global_en(cp0_yy_clk_en), @478
//          .module_en(1'b0), @479
//          .local_en(split_cnt_upd_en), @480
//          .clk_out(split_cnt_upd_clk) @481
//         ); @482
assign split_cnt_upd_en = split_cnt_rst  || split_cnt_en       || split_cnt_write_en; 

// &Instance("gated_clk_cell", "x_sm_upd_clkhdr"); @485
gated_clk_cell  x_sm_upd_clkhdr (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (sm_upd_clk          ),
  .external_en          (1'b0                ),
  .global_en            (cp0_yy_clk_en       ),
  .local_en             (sm_upd_en           ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in(forever_cpuclk), @486
//          .external_en(1'b0), @487
//          .global_en(cp0_yy_clk_en), @488
//          .module_en(1'b0), @489
//          .local_en(sm_upd_en), @490
//          .clk_out(sm_upd_clk) @491
//         ); @492
assign sm_upd_en = retire_mad_ex_cancel  ||
                   mad_vld_no_cancel  ||
                   iu_ifu_cnt_write_en;

////////////////////////////////////////////////////////////////////////////////
//                              Data Path                                     //
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
//                      The Split Counter
//==============================================================================
assign split_cnt_write_en = iu_ifu_cnt_write_en;

//the split counter is used to record the state of the split SM
always @(posedge split_cnt_upd_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    split_cnt[4:0] <= 5'b0;
  else if(split_cnt_rst)
    split_cnt[4:0] <= 5'b0;
  else if(split_cnt_write_en)
    split_cnt[4:0] <= iu_ifu_cnt[4:0];
  else if(split_cnt_en)
    split_cnt[4:0] <= cnt_en ? split_cnt_dec[4:0]: split_cnt_inc[4:0];
end

assign split_cnt_inc[4:0] = split_cnt[4:0] + {4'b0, split_cnt_offset};
assign split_cnt_dec[4:0] = split_cnt[4:0] - {4'b0, split_cnt_offset};
assign split_cnt_offset = 1'b1; 
assign ifu_iu_ex_cnt[4:0] = split_cnt[4:0];

////////////////////////////////////////////////////////////////////////////////
//                              Control Logic                                 //
////////////////////////////////////////////////////////////////////////////////
//==============================================================================
//               Predecode of the Split Inst
//==============================================================================
//==========================================================
//               MLS Related
//==========================================================
assign mls_vld_no_cancel = 1'b0;
assign mls_cmplt = 1'b0;

//==========================================================
//               MAD Related
//==========================================================
assign mad_vld_no_cancel = ctrl_mad_ex_sel;
assign mad_vld_no_input  = ctrl_mad_ex_data_sel;
assign split_mad_cmplt    = split_last;

assign mad_pair_vld = 1'b0;
assign mad_pair_mult_sign = 1'b0;
//assign mad_cmplt = (split_cnt_dec[4:0] == 5'b0) || iu_ifu_cnt_write_en &&
//                       iu_ifu_cnt[4:0] == 5'b0;
assign mad_cmplt = split_cnt[4:0] == 5'b0;

//==============================================================================
//               The SPLIT State Machine
//==============================================================================
//==========================================================
//               Main State Machine 
//==========================================================
always @(posedge sm_upd_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    cur_st[2:0] <= IDLE;
  else if(retire_mad_ex_cancel)
    cur_st[2:0] <= IDLE;
  else
    cur_st[2:0] <= nxt_st[2:0];
end

// &CombBeg; @572
always @( iu_ifu_mad_cmplt
       or mad_cmplt
       or mls_cmplt
       or mls_vld_no_cancel
       or iu_ifu_cnt_write_en
       or mad_pair_mult_sign
       or mad_vld_no_cancel
       or iu_ifu_ex_stall
       or mad_pair_vld
       or cur_st)
begin
case(cur_st)
IDLE:
begin
  nxt_st = IDLE;
  if(iu_ifu_ex_stall)
    nxt_st = IDLE;
  else
  begin      
    case({mls_vld_no_cancel, mad_vld_no_cancel})
      2'b10:
      begin
        if(!mls_cmplt)
           nxt_st = SPLIT;
      end
      2'b01:
      begin
        if(mad_pair_vld)
          if(mad_pair_mult_sign)
            nxt_st = PAIRS;
          else
            nxt_st = PAIR;
        //else if(div_vld)
        //  nxt_st = WFI1;
        else if(iu_ifu_mad_cmplt)
          nxt_st = IDLE;
        else
          nxt_st = WFI2;
      end
      default:
        nxt_st = IDLE;
    endcase
  end
end
WFI1:
begin
  nxt_st = WFI1;
  if(iu_ifu_mad_cmplt)
    nxt_st = IDLE;
  else if(!iu_ifu_ex_stall)
    nxt_st = WFI2;
end
WFI2:
begin
  nxt_st = WFI2;
  if(iu_ifu_mad_cmplt)
    nxt_st = IDLE;
  else if(iu_ifu_cnt_write_en)
  begin
    nxt_st = SPLIT;
  end
end
SPLIT:
begin
  nxt_st = SPLIT;
  case({mls_vld_no_cancel, mad_vld_no_cancel})
    2'b10:
    begin
      if(mls_cmplt)
        nxt_st = IDLE;
    end
    2'b01:
    begin
      if(mad_cmplt)
        nxt_st = IDLE;
    end
    default:
      nxt_st = SPLIT;
  endcase
end
PAIR:
begin
  nxt_st = IDLE;
end
PAIRS:
begin
  nxt_st = IDLE;
end
default:
  nxt_st = IDLE;
endcase
// &CombEnd; @653
end

//inform split is on
assign split_on = (cur_st != IDLE)
                  || mls_vld_no_cancel || mad_vld_no_cancel;

//plus the split counter
assign cnt_en = (cur_st == IDLE)
                    && !iu_ifu_ex_stall
                    && ((mls_vld_no_cancel && !mls_cmplt) || mad_vld_no_cancel)
             || (cur_st == SPLIT)
                    && !iu_ifu_ex_stall
                    && ((mls_vld_no_cancel  && !mls_cmplt) ||
                        (mad_vld_no_cancel && !mad_cmplt)
                       );

//inform the last cycle if split
assign split_last = (cur_st == IDLE)
                        && !iu_ifu_ex_stall
                        && (mls_vld_no_cancel && mls_cmplt ||
                            mad_vld_no_cancel && iu_ifu_mad_cmplt)
                 || (cur_st == SPLIT)
                        && !iu_ifu_ex_stall
                        && ((mls_vld_no_cancel  && mls_cmplt) ||
                            (mad_vld_no_cancel && mad_cmplt)
                           )
                 || cur_st[2]
                 || (cur_st == WFI1) && iu_ifu_mad_cmplt
                 || (cur_st == WFI2) && iu_ifu_mad_cmplt;

assign ifu_iu_mad_idle  = (cur_st == IDLE);
//assign ifu_iu_mad_wfi1  = (cur_st == WFI1);
assign ifu_iu_mad_wfi2  = (cur_st == WFI2);
assign ifu_iu_mad_split = (cur_st == SPLIT);
assign ifu_iu_mad_pair  = 1'b0;
assign ifu_iu_mult_sign = 1'b0;

//==============================================================================
//                 Control Signal from the SMs
//==============================================================================
//1.when the last cycle of the split, the split counter should be reseted
//2.when if cancel happens, reset the counter
assign split_cnt_rst = split_last       ||
                       iu_yy_xx_flush;

assign split_cnt_en = cnt_en;

////////////////////////////////////////////////////////////////////////////////
//                              Interface                                     //
////////////////////////////////////////////////////////////////////////////////
//==========================================================
//               Globle Signal
//==========================================================
assign split_xx_stall = (split_on       && !split_last) ;

// &ModuleEnd; @709
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_iu_oper(
  cp0_yy_clk_en,
  ctrl_oper_lsu_data_sel,
  decd_oper_alu_imm,
  decd_oper_branch_imm,
  decd_oper_cp0_imm,
  decd_oper_lsu_imm,
  forever_cpuclk,
  had_idu_wbbr_data,
  had_idu_wbbr_vld,
  hs_split_iu_nsinst_gpr_rst_b,
  ifu_iu_ex_rs1_reg,
  ifu_iu_ex_rs2_reg,
  iu_cp0_imm,
  iu_cp0_rs1,
  iu_lsu_base,
  iu_lsu_data,
  iu_lsu_offset,
  iu_lsu_rs2,
  iu_yy_xx_reg_rst_b,
  oper_alu_rs1_reg,
  oper_alu_rs2_imm,
  oper_alu_rs2_reg,
  oper_branch_rs1_reg,
  oper_branch_rs2_imm,
  oper_branch_rs2_reg,
  oper_mad_rs1,
  oper_mad_rs2,
  oper_wb_rs1_equal_to_dst,
  oper_wb_rs2_equal_to_dst,
  pad_yy_gate_clk_en_b,
  randclk_oper_gpr_mod_en_w32,
  wb_oper_fwd_data_no_load,
  wb_oper_fwd_en,
  wb_oper_write_data,
  wb_oper_write_en,
  wb_oper_write_idx,
  wb_oper_write_idx_for_dep
);

// &Ports; @26
input           cp0_yy_clk_en;                  
input           ctrl_oper_lsu_data_sel;         
input   [31:0]  decd_oper_alu_imm;              
input   [31:0]  decd_oper_branch_imm;           
input   [11:0]  decd_oper_cp0_imm;              
input   [31:0]  decd_oper_lsu_imm;              
input           forever_cpuclk;                 
input   [31:0]  had_idu_wbbr_data;              
input           had_idu_wbbr_vld;               
input           hs_split_iu_nsinst_gpr_rst_b;   
input   [4 :0]  ifu_iu_ex_rs1_reg;              
input   [4 :0]  ifu_iu_ex_rs2_reg;              
input           iu_yy_xx_reg_rst_b;             
input           pad_yy_gate_clk_en_b;           
input   [20:0]  randclk_oper_gpr_mod_en_w32;    
input   [31:0]  wb_oper_fwd_data_no_load;       
input           wb_oper_fwd_en;                 
input   [31:0]  wb_oper_write_data;             
input           wb_oper_write_en;               
input   [4 :0]  wb_oper_write_idx;              
input   [4 :0]  wb_oper_write_idx_for_dep;      
output  [11:0]  iu_cp0_imm;                     
output  [31:0]  iu_cp0_rs1;                     
output  [31:0]  iu_lsu_base;                    
output  [31:0]  iu_lsu_data;                    
output  [31:0]  iu_lsu_offset;                  
output  [31:0]  iu_lsu_rs2;                     
output  [31:0]  oper_alu_rs1_reg;               
output  [31:0]  oper_alu_rs2_imm;               
output  [31:0]  oper_alu_rs2_reg;               
output  [31:0]  oper_branch_rs1_reg;            
output  [31:0]  oper_branch_rs2_imm;            
output  [31:0]  oper_branch_rs2_reg;            
output  [31:0]  oper_mad_rs1;                   
output  [31:0]  oper_mad_rs2;                   
output          oper_wb_rs1_equal_to_dst;       
output          oper_wb_rs2_equal_to_dst;       

// &Regs; @27

// &Wires; @28
wire            cp0_yy_clk_en;                  
wire            ctrl_oper_lsu_data_sel;         
wire    [31:0]  decd_oper_alu_imm;              
wire    [31:0]  decd_oper_branch_imm;           
wire    [11:0]  decd_oper_cp0_imm;              
wire    [31:0]  decd_oper_lsu_imm;              
wire            forever_cpuclk;                 
wire    [31:0]  had_idu_wbbr_data;              
wire            had_idu_wbbr_vld;               
wire            hs_split_iu_nsinst_gpr_rst_b;   
wire    [4 :0]  ifu_iu_ex_rs1_reg;              
wire    [4 :0]  ifu_iu_ex_rs2_reg;              
wire    [11:0]  iu_cp0_imm;                     
wire    [31:0]  iu_cp0_rs1;                     
wire    [31:0]  iu_lsu_base;                    
wire    [31:0]  iu_lsu_data;                    
wire    [31:0]  iu_lsu_offset;                  
wire    [31:0]  iu_lsu_rs2;                     
wire            iu_yy_xx_reg_rst_b;             
wire    [31:0]  oper_alu_rs1_reg;               
wire    [31:0]  oper_alu_rs2_imm;               
wire    [31:0]  oper_alu_rs2_reg;               
wire    [31:0]  oper_branch_rs1_reg;            
wire    [31:0]  oper_branch_rs2_imm;            
wire    [31:0]  oper_branch_rs2_reg;            
wire    [31:0]  oper_imm_for_alu;               
wire    [31:0]  oper_imm_for_branch;            
wire    [11:0]  oper_imm_for_cp0;               
wire    [31:0]  oper_imm_for_lsu;               
wire    [31:0]  oper_mad_rs1;                   
wire    [31:0]  oper_mad_rs2;                   
wire            oper_rs1_bsp_dep_vld;           
wire            oper_rs1_dep_vld;               
wire            oper_rs1_dep_vld_aft_bsp;       
wire            oper_rs1_equal_to_dst;          
wire    [31:0]  oper_rs1_gpr_data;              
wire    [31:0]  oper_rs1_gpr_reg;               
wire    [31:0]  oper_rs1_reg_no_load;           
wire    [31:0]  oper_rs1_reg_no_load_before_pol; 
wire            oper_rs2_dep_vld;               
wire            oper_rs2_equal_to_dst;          
wire    [31:0]  oper_rs2_gpr_data;              
wire    [31:0]  oper_rs2_gpr_reg;               
wire    [31:0]  oper_rs2_reg_before_pol;        
wire    [31:0]  oper_rs2_reg_no_load;           
wire    [31:0]  oper_rs2_reg_no_load_before_pol; 
wire            oper_wb_rs1_equal_to_dst;       
wire            oper_wb_rs2_equal_to_dst;       
wire            pad_yy_gate_clk_en_b;           
wire    [20:0]  randclk_oper_gpr_mod_en_w32;    
wire    [31:0]  wb_data_no_load_aft_bsp_fwd;    
wire    [31:0]  wb_oper_fwd_data_no_load;       
wire            wb_oper_fwd_en;                 
wire    [31:0]  wb_oper_write_data;             
wire            wb_oper_write_en;               
wire    [4 :0]  wb_oper_write_idx;              
wire    [4 :0]  wb_oper_write_idx_for_dep;      


//==============================================================================
//             General Purpose Register (GPR)
//==============================================================================
// &Force("input", "cp0_iu_af"); @34
// &Instance("cr_iu_oper_gpr", "x_cr_iu_oper_gpr"); @36
cr_iu_oper_gpr  x_cr_iu_oper_gpr (
  .cp0_yy_clk_en                     (cp0_yy_clk_en                    ),
  .forever_cpuclk                    (forever_cpuclk                   ),
  .hs_split_iu_nsinst_gpr_rst_b      (hs_split_iu_nsinst_gpr_rst_b     ),
  .inst_read_data0                   (oper_rs1_gpr_data[31:0]          ),
  .inst_read_data1                   (oper_rs2_gpr_data[31:0]          ),
  .inst_read_index0                  (ifu_iu_ex_rs1_reg[4:0]           ),
  .inst_read_index1                  (ifu_iu_ex_rs2_reg[4:0]           ),
  .inst_wen                          (wb_oper_write_en                 ),
  .inst_write_data                   (wb_oper_write_data[31:0]         ),
  .inst_write_index                  (wb_oper_write_idx[4:0]           ),
  .iu_yy_xx_reg_rst_b                (iu_yy_xx_reg_rst_b               ),
  .pad_yy_gate_clk_en_b              (pad_yy_gate_clk_en_b             ),
  .randclk_oper_gpr_mod_en_w32       (randclk_oper_gpr_mod_en_w32      )
);

// &Connect(.inst_wen(wb_oper_write_en), @37
//          .inst_write_index(wb_oper_write_idx[4:0]), @38
//          .inst_write_data(wb_oper_write_data[31:0]), @39
//          .inst_write_data_pol(wb_oper_write_data_pol), @40
// //         .inst_write_data_byte_wen(wb_oper_write_byte_wen[3:0]), @41
//          .inst_read_index0(ifu_iu_ex_rs1_reg[4:0]), @42
//          .inst_read_index1(ifu_iu_ex_rs2_reg[4:0]), @43
//          .inst_read_data0(oper_rs1_gpr_data[31:0]), @44
//          .inst_read_data0_pol(oper_rs1_gpr_data_pol), @45
//          .inst_read_data1(oper_rs2_gpr_data[31:0]), @46
//          .inst_read_data1_pol(oper_rs2_gpr_data_pol), @47
//          .inst_read_check_fail0(oper_rs1_gpr_check_fail), @48
//          .inst_read_check_fail1(oper_rs2_gpr_check_fail), @49
//          .inst_read_check_fail_fix(oper_src_fix_gpr_check_fail), @50
//          .supv_mode(cp0_yy_supv_mode), @51
//          .wb_supv_mode(wb_oper_supv_mode), @52
// //         .cp0_reg_write_data(cp0_write_data[31:0]), @53
// //         .cp0_reg_write_data_pol(cp0_write_data_pol), @54
// //         .user_2_reg_dout(oper_user_reg2_dout[31:0]), @55
// //         .user_reg_2_dout_pol(oper_user_reg_2_dout_pol), @56
// //         .user_reg_1_dout(oper_wb_x1[31:0]), @57
//  //        .user_reg_15_dout_pol(oper_wb_r15_pol), @58
//          .user_reg_22_dout(oper_bkup_lr_reg[31:0]), @59
//          .user_reg_22_dout_pol(oper_bkup_lr_reg_pol), @60
//          .user_reg_23_dout(oper_bstack_fp_reg[31:0]), @61
//          .user_reg_23_dout_pol(oper_bstack_fp_reg_pol), @62
//          .user_reg_24_dout(oper_bstack_top_reg[31:0]), @63
//          .user_reg_24_dout_pol(oper_bstack_top_reg_pol), @64
//          .user_reg_25_we(lsu_iu_bsp_we), @65
//          .user_reg_25_write_data(oper_user_reg_25_write_data[31:0]), @66
//          .user_reg_25_write_data_pol(oper_user_reg_25_write_data_pol), @67
//          .user_reg_25_dout(oper_bstack_pointer[31:0]), @68
//          .user_reg_25_dout_pol(oper_bstack_pointer_pol), @69
//          .user_reg_30_dout(oper_user_reg_30_dout[31:0]), @70
//          .user_reg_30_dout_pol(oper_user_reg_30_dout_pol), @71
// //         .machine_reg_2_dout_pol(oper_machine_reg_2_dout_pol), @72
// //         .susp_reg_dout(oper_susp_reg_2_dout), @73
// //         .intsp_reg_14_dout(oper_intsp_reg14_dout[31:0]), @74
// //         .susp_reg_14_dout_pol(oper_susp_reg_14_dout_pol), @75
//          .reg_cpuclk(cpuclk) @76
//         ); @77
// &Connect(.user_2_reg_dout(oper_user_reg2_dout[31:0]), @79
//          .machine_2_reg_dout(oper_machine_reg_2_dout) @80
//         ); @81

// &Connect(.susp_reg_dout(oper_susp_reg_2_dout));  @85

// &Connect(.alter_mode(cp0_iu_af)); @89
// &Connect(.secu_mode(cp0_yy_secu_mode)); @92
// &Connect(.wb_secu_mode(wb_oper_secu_mode)); @93


//==========================================================
//             Input and Output of user SP(r14)
//==========================================================


//read data to CP0


//==========================================================
//             Output of Backup Link Reg(r22)
//==========================================================

//==========================================================
//          Input and Output of Btack Pointer(r25)
//==========================================================


//==========================================================
//               Operand read from GPR 
//==========================================================
//WBBR Operand Replacement of rs1
assign oper_rs1_gpr_reg[31:0] = (had_idu_wbbr_vld && !ctrl_oper_lsu_data_sel) ? 
                                                      had_idu_wbbr_data[31:0]
                                                    : oper_rs1_gpr_data[31:0];
assign oper_rs2_gpr_reg[31:0] = had_idu_wbbr_vld ? had_idu_wbbr_data[31:0]
                                                 : oper_rs2_gpr_data[31:0];


//==========================================================
//              GPR Check Fail
//==========================================================


//=============================================================================
//         Operand Prepare including Dependency Check and Forwarding
//=============================================================================
//Operand Prepare when LOAD_FAST_RETIRE
//==========================================================
//        The Dependency Valid Signal
//==========================================================
assign oper_rs1_equal_to_dst = (ifu_iu_ex_rs1_reg[4:0] == wb_oper_write_idx_for_dep[4:0])
                              && ifu_iu_ex_rs1_reg[4:0] != 5'b0;
assign oper_rs2_equal_to_dst = (ifu_iu_ex_rs2_reg[4:0] == wb_oper_write_idx_for_dep[4:0]) 
                              && ifu_iu_ex_rs2_reg[4:0] != 5'b0;
//output to write back stage
assign oper_wb_rs1_equal_to_dst = oper_rs1_equal_to_dst;
assign oper_wb_rs2_equal_to_dst = oper_rs2_equal_to_dst;

//the dependency ignores source valid, which is not decoded for cost reason
assign oper_rs1_dep_vld = wb_oper_fwd_en && oper_rs1_equal_to_dst;
assign oper_rs2_dep_vld = wb_oper_fwd_en && oper_rs2_equal_to_dst;

//when BCTM, r25 is wrriten invisiblely, the dependency needs to be checked
assign oper_rs1_bsp_dep_vld = 1'b0;


//==========================================================
//        Operand Forwarding
//==========================================================

//the SRC0 without LOAD data from WB
//1.when lrw, the rs1 is PC
//2.when normal inst, the rs1 is the write data from WB
// &Force("bus","pcgen_xx_cur_pc",30,0); @247
assign wb_data_no_load_aft_bsp_fwd[31:0] = //oper_lrw_ex_vld 
                                             //? {pcgen_xx_cur_pc[30:1],2'b0}
                                             //: wb_oper_fwd_data_no_load[31:0];
                                               wb_oper_fwd_data_no_load[31:0];



//==========================================================
//           Forwarding for ALU and MAD
//==========================================================
//note that move WBBR replacement before forward mux, to when
//WBBR replacing, need to select non forward path

assign oper_rs2_reg_before_pol[31:0] = (oper_rs2_dep_vld)
                                        ? wb_oper_write_data[31:0]
                                        : oper_rs2_gpr_reg[31:0];


//==========================================================
//        Forwarding for LSU/BR/CP0 and DUP ALU
//==========================================================
assign oper_rs1_dep_vld_aft_bsp = oper_rs1_dep_vld || oper_rs1_bsp_dep_vld;

assign oper_rs1_reg_no_load_before_pol[31:0] = 
                                        (oper_rs1_dep_vld_aft_bsp && !had_idu_wbbr_vld)
                                        ? wb_data_no_load_aft_bsp_fwd[31:0]
                                        : oper_rs1_gpr_reg[31:0];



assign oper_rs2_reg_no_load_before_pol[31:0] = 
                                        oper_rs2_dep_vld
                                        ? wb_oper_fwd_data_no_load[31:0]
                                        : oper_rs2_gpr_reg[31:0];





//==========================================================
//         Processing Data Path Polarity
//==========================================================
//no data path polarity

assign oper_rs1_reg_no_load[31:0] = oper_rs1_reg_no_load_before_pol[31:0];
assign oper_rs2_reg_no_load[31:0] = oper_rs2_reg_no_load_before_pol[31:0];



//==========================================================
//              Immediate Prepare              
//==========================================================
assign oper_imm_for_alu[31:0] = decd_oper_alu_imm[31:0];
assign oper_imm_for_lsu[31:0] = decd_oper_lsu_imm[31:0];
assign oper_imm_for_cp0[11:0] = decd_oper_cp0_imm[11:0];
assign oper_imm_for_branch[31:0] = decd_oper_branch_imm[31:0];

//=============================================================================
//                    Operands to all the Excution Units
//=============================================================================
//==========================================================
//                    Operands for ALU
//==========================================================
assign oper_alu_rs1_reg[31:0]     = oper_rs1_reg_no_load[31:0];
assign oper_alu_rs2_reg[31:0]     = oper_rs2_reg_no_load[31:0];
assign oper_alu_rs2_imm[31:0]     = oper_imm_for_alu[31:0];

// &Force("nonport","oper_rs2_reg_no_load"); @429


//==========================================================
//                    Operands for MAD
//==========================================================

assign oper_mad_rs1[31:0]         = oper_rs1_reg_no_load[31:0];
assign oper_mad_rs2[31:0]         = oper_rs2_reg_no_load[31:0];



//==========================================================
//                    Operands for BRANCH
//==========================================================
//register does not forward from load
assign oper_branch_rs1_reg[31:0]  = oper_rs1_reg_no_load[31:0];
assign oper_branch_rs2_reg[31:0]  = oper_rs2_reg_no_load[31:0];
assign oper_branch_rs2_imm[31:0]  = oper_imm_for_branch[31:0];


//==========================================================
//                    Operands for LSU
//==========================================================
//register does not forward from load
assign iu_lsu_offset[31:0]         = oper_imm_for_lsu[31:0];
assign iu_lsu_data[31:0]           = oper_rs2_reg_before_pol[31:0];
assign iu_lsu_base[31:0]           = oper_rs1_reg_no_load[31:0];
assign iu_lsu_rs2[31:0]            = oper_rs2_reg_no_load[31:0];



//==========================================================
//                    Operands for CP0
//==========================================================
assign iu_cp0_rs1[31:0]           = oper_rs1_reg_no_load[31:0];
assign iu_cp0_imm[11:0]           = oper_imm_for_cp0[11:0];

// &ModuleEnd; @505
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_iu_oper_gpr(
  cp0_yy_clk_en,
  forever_cpuclk,
  hs_split_iu_nsinst_gpr_rst_b,
  inst_read_data0,
  inst_read_data1,
  inst_read_index0,
  inst_read_index1,
  inst_wen,
  inst_write_data,
  inst_write_index,
  iu_yy_xx_reg_rst_b,
  pad_yy_gate_clk_en_b,
  randclk_oper_gpr_mod_en_w32
);

// &Ports; @24
input           cp0_yy_clk_en;                   
input           forever_cpuclk;                  
input           hs_split_iu_nsinst_gpr_rst_b;    
input   [4 :0]  inst_read_index0;                
input   [4 :0]  inst_read_index1;                
input           inst_wen;                        
input   [31:0]  inst_write_data;                 
input   [4 :0]  inst_write_index;                
input           iu_yy_xx_reg_rst_b;              
input           pad_yy_gate_clk_en_b;            
input   [20:0]  randclk_oper_gpr_mod_en_w32;     
output  [31:0]  inst_read_data0;                 
output  [31:0]  inst_read_data1;                 

// &Regs; @25
reg     [31:0]  gpr_read_data0;                  
reg     [31:0]  gpr_read_data1;                  
reg     [31:0]  reg_sel;                         
reg     [31:0]  sp_read_data0;                   
reg     [31:0]  sp_read_data1;                   

// &Wires; @26
wire    [31:0]  alter_0_reg_dout;                
wire    [31:0]  alter_10_reg_dout;               
wire    [31:0]  alter_11_reg_dout;               
wire    [31:0]  alter_12_reg_dout;               
wire    [31:0]  alter_13_reg_dout;               
wire    [31:0]  alter_14_reg_dout;               
wire    [31:0]  alter_15_reg_dout;               
wire    [31:0]  alter_1_reg_dout;                
wire    [31:0]  alter_2_reg_dout;                
wire    [31:0]  alter_3_reg_dout;                
wire    [31:0]  alter_4_reg_dout;                
wire    [31:0]  alter_5_reg_dout;                
wire    [31:0]  alter_6_reg_dout;                
wire    [31:0]  alter_7_reg_dout;                
wire    [31:0]  alter_8_reg_dout;                
wire    [31:0]  alter_9_reg_dout;                
wire            alter_mode;                      
wire            cp0_yy_clk_en;                   
wire            forever_cpuclk;                  
wire            gpr_sync_rst_b;                  
wire            gpr_sync_rst_for_sp_b;           
wire            hs_split_iu_nsinst_gpr_rst_b;    
wire    [31:0]  inst_read_data0;                 
wire    [31:0]  inst_read_data1;                 
wire    [4 :0]  inst_read_index0;                
wire    [4 :0]  inst_read_index1;                
wire            inst_wen;                        
wire    [31:0]  inst_write_data;                 
wire    [4 :0]  inst_write_index;                
wire            iu_yy_xx_reg_rst_b;              
wire            machine_2_randclk_reg_mod_en_w32; 
wire    [31:0]  machine_2_reg_dout;              
wire            machine_2_write_en;              
wire            machine_write_en_2;              
wire            pad_cpu_gpr_rst_b;               
wire            pad_yy_gate_clk_en_b;            
wire    [20:0]  randclk_oper_gpr_mod_en_w32;     
wire            user_10_randclk_reg_mod_en_w32;  
wire    [31:0]  user_10_reg_dout;                
wire            user_10_write_en;                
wire            user_11_randclk_reg_mod_en_w32;  
wire    [31:0]  user_11_reg_dout;                
wire            user_11_write_en;                
wire            user_12_randclk_reg_mod_en_w32;  
wire    [31:0]  user_12_reg_dout;                
wire            user_12_write_en;                
wire            user_13_randclk_reg_mod_en_w32;  
wire    [31:0]  user_13_reg_dout;                
wire            user_13_write_en;                
wire            user_14_randclk_reg_mod_en_w32;  
wire    [31:0]  user_14_reg_dout;                
wire            user_14_write_en;                
wire            user_15_randclk_reg_mod_en_w32;  
wire    [31:0]  user_15_reg_dout;                
wire            user_15_write_en;                
wire            user_1_randclk_reg_mod_en_w32;   
wire    [31:0]  user_1_reg_dout;                 
wire            user_1_write_en;                 
wire            user_3_randclk_reg_mod_en_w32;   
wire    [31:0]  user_3_reg_dout;                 
wire            user_3_write_en;                 
wire            user_4_randclk_reg_mod_en_w32;   
wire    [31:0]  user_4_reg_dout;                 
wire            user_4_write_en;                 
wire            user_5_randclk_reg_mod_en_w32;   
wire    [31:0]  user_5_reg_dout;                 
wire            user_5_write_en;                 
wire            user_6_randclk_reg_mod_en_w32;   
wire    [31:0]  user_6_reg_dout;                 
wire            user_6_write_en;                 
wire            user_7_randclk_reg_mod_en_w32;   
wire    [31:0]  user_7_reg_dout;                 
wire            user_7_write_en;                 
wire            user_8_randclk_reg_mod_en_w32;   
wire    [31:0]  user_8_reg_dout;                 
wire            user_8_write_en;                 
wire            user_9_randclk_reg_mod_en_w32;   
wire    [31:0]  user_9_reg_dout;                 
wire            user_9_write_en;                 
wire    [31:0]  user_write_en;                   
wire            ussp_explicit_we;                
wire    [31:0]  write_data;                      
wire    [31:0]  write_data_for_sp;               
wire    [31:0]  write_port_data;                 


//==============================================================================
// Instance 16 registers for register file
//==============================================================================
// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_1"); @31
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_1 (
  .cp0_yy_clk_en                 (cp0_yy_clk_en                ),
  .forever_cpuclk                (forever_cpuclk               ),
  .pad_yy_gate_clk_en_b          (pad_yy_gate_clk_en_b         ),
  .write_data                    (write_data                   ),
  .x_randclk_reg_mod_en_w32      (user_1_randclk_reg_mod_en_w32),
  .x_reg_dout                    (user_1_reg_dout              ),
  .x_write_en                    (user_1_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_1_randclk_reg_mod_en_w32), @32
//          .x_write_en              (user_1_write_en), @33
//          .x_reg_dout              (user_1_reg_dout) @34
//         ); @35
// &Connect(.x_reg_verify            (user_1_reg_verify)); @37
// &Connect(.x_reg_dout_pol          (user_1_reg_dout_pol)); @40

// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_2"); @44
// &Connect(.x_randclk_reg_mod_en_w32(user_2_randclk_reg_mod_en_w32), @45
//          .write_data              (write_data_for_sp[31:0]), @46
//          .x_write_en              (user_2_write_en), @47
//          .x_reg_dout              (user_2_reg_dout) @48
//         ); @49
// &Connect(.x_reg_verify            (user_2_reg_verify)); @51
// &Connect(.x_reg_dout_pol          (user_2_reg_dout_pol)); @54

// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_3"); @58
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_3 (
  .cp0_yy_clk_en                 (cp0_yy_clk_en                ),
  .forever_cpuclk                (forever_cpuclk               ),
  .pad_yy_gate_clk_en_b          (pad_yy_gate_clk_en_b         ),
  .write_data                    (write_data                   ),
  .x_randclk_reg_mod_en_w32      (user_3_randclk_reg_mod_en_w32),
  .x_reg_dout                    (user_3_reg_dout              ),
  .x_write_en                    (user_3_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_3_randclk_reg_mod_en_w32), @59
//          .x_write_en              (user_3_write_en), @60
//          .x_reg_dout              (user_3_reg_dout) @61
//         ); @62
// &Connect(.x_reg_verify            (user_3_reg_verify)); @64
// &Connect(.x_reg_dout_pol          (user_3_reg_dout_pol)); @67


// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_4"); @71
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_4 (
  .cp0_yy_clk_en                 (cp0_yy_clk_en                ),
  .forever_cpuclk                (forever_cpuclk               ),
  .pad_yy_gate_clk_en_b          (pad_yy_gate_clk_en_b         ),
  .write_data                    (write_data                   ),
  .x_randclk_reg_mod_en_w32      (user_4_randclk_reg_mod_en_w32),
  .x_reg_dout                    (user_4_reg_dout              ),
  .x_write_en                    (user_4_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_4_randclk_reg_mod_en_w32), @72
//          .x_write_en              (user_4_write_en), @73
//          .x_reg_dout              (user_4_reg_dout) @74
//         ); @75
// &Connect(.x_reg_verify            (user_4_reg_verify)); @77
// &Connect(.x_reg_dout_pol          (user_4_reg_dout_pol)); @80


// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_5"); @84
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_5 (
  .cp0_yy_clk_en                 (cp0_yy_clk_en                ),
  .forever_cpuclk                (forever_cpuclk               ),
  .pad_yy_gate_clk_en_b          (pad_yy_gate_clk_en_b         ),
  .write_data                    (write_data                   ),
  .x_randclk_reg_mod_en_w32      (user_5_randclk_reg_mod_en_w32),
  .x_reg_dout                    (user_5_reg_dout              ),
  .x_write_en                    (user_5_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_5_randclk_reg_mod_en_w32), @85
//          .x_write_en              (user_5_write_en), @86
//          .x_reg_dout              (user_5_reg_dout) @87
//         ); @88
// &Connect(.x_reg_verify            (user_5_reg_verify)); @90
// &Connect(.x_reg_dout_pol          (user_5_reg_dout_pol)); @93


// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_6"); @97
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_6 (
  .cp0_yy_clk_en                 (cp0_yy_clk_en                ),
  .forever_cpuclk                (forever_cpuclk               ),
  .pad_yy_gate_clk_en_b          (pad_yy_gate_clk_en_b         ),
  .write_data                    (write_data                   ),
  .x_randclk_reg_mod_en_w32      (user_6_randclk_reg_mod_en_w32),
  .x_reg_dout                    (user_6_reg_dout              ),
  .x_write_en                    (user_6_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_6_randclk_reg_mod_en_w32), @98
//          .x_write_en              (user_6_write_en), @99
//          .x_reg_dout              (user_6_reg_dout) @100
//         ); @101
// &Connect(.x_reg_verify            (user_6_reg_verify)); @103
// &Connect(.x_reg_dout_pol          (user_6_reg_dout_pol)); @106


// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_7"); @110
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_7 (
  .cp0_yy_clk_en                 (cp0_yy_clk_en                ),
  .forever_cpuclk                (forever_cpuclk               ),
  .pad_yy_gate_clk_en_b          (pad_yy_gate_clk_en_b         ),
  .write_data                    (write_data                   ),
  .x_randclk_reg_mod_en_w32      (user_7_randclk_reg_mod_en_w32),
  .x_reg_dout                    (user_7_reg_dout              ),
  .x_write_en                    (user_7_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_7_randclk_reg_mod_en_w32), @111
//          .x_write_en              (user_7_write_en), @112
//          .x_reg_dout              (user_7_reg_dout) @113
//         ); @114
// &Connect(.x_reg_verify            (user_7_reg_verify)); @116
// &Connect(.x_reg_dout_pol          (user_7_reg_dout_pol)); @119


// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_8"); @123
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_8 (
  .cp0_yy_clk_en                 (cp0_yy_clk_en                ),
  .forever_cpuclk                (forever_cpuclk               ),
  .pad_yy_gate_clk_en_b          (pad_yy_gate_clk_en_b         ),
  .write_data                    (write_data                   ),
  .x_randclk_reg_mod_en_w32      (user_8_randclk_reg_mod_en_w32),
  .x_reg_dout                    (user_8_reg_dout              ),
  .x_write_en                    (user_8_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_8_randclk_reg_mod_en_w32), @124
//          .x_write_en              (user_8_write_en), @125
//          .x_reg_dout              (user_8_reg_dout) @126
//         ); @127
// &Connect(.x_reg_verify            (user_8_reg_verify)); @129
// &Connect(.x_reg_dout_pol          (user_8_reg_dout_pol)); @132


// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_9"); @137
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_9 (
  .cp0_yy_clk_en                 (cp0_yy_clk_en                ),
  .forever_cpuclk                (forever_cpuclk               ),
  .pad_yy_gate_clk_en_b          (pad_yy_gate_clk_en_b         ),
  .write_data                    (write_data                   ),
  .x_randclk_reg_mod_en_w32      (user_9_randclk_reg_mod_en_w32),
  .x_reg_dout                    (user_9_reg_dout              ),
  .x_write_en                    (user_9_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_9_randclk_reg_mod_en_w32), @138
//          .x_write_en              (user_9_write_en), @139
//          .x_reg_dout              (user_9_reg_dout) @140
//         ); @141
// &Connect(.x_reg_verify            (user_9_reg_verify)); @143
// &Connect(.x_reg_dout_pol          (user_9_reg_dout_pol)); @146


// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_10"); @150
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_10 (
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          ),
  .write_data                     (write_data                    ),
  .x_randclk_reg_mod_en_w32       (user_10_randclk_reg_mod_en_w32),
  .x_reg_dout                     (user_10_reg_dout              ),
  .x_write_en                     (user_10_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_10_randclk_reg_mod_en_w32), @151
//          .x_write_en              (user_10_write_en), @152
//          .x_reg_dout              (user_10_reg_dout) @153
//         ); @154
// &Connect(.x_reg_verify            (user_10_reg_verify)); @156
// &Connect(.x_reg_dout_pol          (user_10_reg_dout_pol)); @159


// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_11"); @163
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_11 (
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          ),
  .write_data                     (write_data                    ),
  .x_randclk_reg_mod_en_w32       (user_11_randclk_reg_mod_en_w32),
  .x_reg_dout                     (user_11_reg_dout              ),
  .x_write_en                     (user_11_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_11_randclk_reg_mod_en_w32), @164
//          .x_write_en              (user_11_write_en), @165
//          .x_reg_dout              (user_11_reg_dout) @166
//         ); @167
// &Connect(.x_reg_verify            (user_11_reg_verify)); @169
// &Connect(.x_reg_dout_pol          (user_11_reg_dout_pol)); @172


// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_12"); @176
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_12 (
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          ),
  .write_data                     (write_data                    ),
  .x_randclk_reg_mod_en_w32       (user_12_randclk_reg_mod_en_w32),
  .x_reg_dout                     (user_12_reg_dout              ),
  .x_write_en                     (user_12_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_12_randclk_reg_mod_en_w32), @177
//          .x_write_en              (user_12_write_en), @178
//          .x_reg_dout              (user_12_reg_dout) @179
//         ); @180
// &Connect(.x_reg_verify            (user_12_reg_verify)); @182
// &Connect(.x_reg_dout_pol          (user_12_reg_dout_pol)); @185


// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_13"); @189
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_13 (
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          ),
  .write_data                     (write_data                    ),
  .x_randclk_reg_mod_en_w32       (user_13_randclk_reg_mod_en_w32),
  .x_reg_dout                     (user_13_reg_dout              ),
  .x_write_en                     (user_13_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_13_randclk_reg_mod_en_w32), @190
//          .x_write_en              (user_13_write_en), @191
//          .x_reg_dout              (user_13_reg_dout) @192
//         ); @193
// &Connect(.x_reg_verify            (user_13_reg_verify)); @195
// &Connect(.x_reg_dout_pol          (user_13_reg_dout_pol)); @198


// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_14"); @203
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_14 (
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          ),
  .write_data                     (write_data                    ),
  .x_randclk_reg_mod_en_w32       (user_14_randclk_reg_mod_en_w32),
  .x_reg_dout                     (user_14_reg_dout              ),
  .x_write_en                     (user_14_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_14_randclk_reg_mod_en_w32), @204
//          .x_write_en              (user_14_write_en), @205
//          .x_reg_dout              (user_14_reg_dout) @206
//         ); @207
// &Connect(.x_reg_verify            (user_14_reg_verify)); @209
// &Connect(.x_reg_dout_pol          (user_14_reg_dout_pol)); @212

// &Instance("cr_iu_gated_clk_reg", "x_cr_iu_gated_clk_reg_user_15"); @215
cr_iu_gated_clk_reg  x_cr_iu_gated_clk_reg_user_15 (
  .cp0_yy_clk_en                  (cp0_yy_clk_en                 ),
  .forever_cpuclk                 (forever_cpuclk                ),
  .pad_yy_gate_clk_en_b           (pad_yy_gate_clk_en_b          ),
  .write_data                     (write_data                    ),
  .x_randclk_reg_mod_en_w32       (user_15_randclk_reg_mod_en_w32),
  .x_reg_dout                     (user_15_reg_dout              ),
  .x_write_en                     (user_15_write_en              )
);

// &Connect(.x_randclk_reg_mod_en_w32(user_15_randclk_reg_mod_en_w32), @216
//          .x_write_en              (user_15_write_en), @217
//          .x_reg_dout              (user_15_reg_dout) @218
//         ); @219
// &Connect(.x_reg_verify            (user_15_reg_verify)); @221
// &Connect(.x_reg_dout_pol          (user_15_reg_dout_pol)); @224

//==============================================================================
// Instance  registers for Privilege Mode register file
//==============================================================================
// &Instance("cr_iu_gated_clk_reg_timing", "x_cr_iu_gated_clk_reg_machine_2"); @230
cr_iu_gated_clk_reg_timing  x_cr_iu_gated_clk_reg_machine_2 (
  .cp0_yy_clk_en                    (cp0_yy_clk_en                   ),
  .forever_cpuclk                   (forever_cpuclk                  ),
  .pad_yy_gate_clk_en_b             (pad_yy_gate_clk_en_b            ),
  .write_data                       (write_data_for_sp[31:0]         ),
  .x_randclk_reg_mod_en_w32         (machine_2_randclk_reg_mod_en_w32),
  .x_reg_dout                       (machine_2_reg_dout              ),
  .x_write_en                       (machine_2_write_en              )
);

// &Connect(.write_data              (write_data_for_sp[31:0]), @231
//          .write_data_verify       (write_data_verify_for_sp[3:0]), @232
//          .write_data_pol          (write_data_pol_for_sp) @233
//         ); @234
// &Connect(.x_randclk_reg_mod_en_w32(machine_2_randclk_reg_mod_en_w32), @235
//          .x_write_en              (machine_2_write_en), @236
//          .x_reg_dout              (machine_2_reg_dout) @237
//         ); @238
// &Connect(.x_reg_verify            (machine_2_reg_verify)); @240
// &Connect(.x_reg_dout_pol          (machine_2_reg_dout_pol)); @244

//==============================================================================
// Instance  registers for Secure Privilege and User stack register file
//==============================================================================
// &Instance("cr_iu_gated_clk_reg_timing", "x_cr_iu_gated_clk_reg_sec_user_2"); @251
// &Connect(.write_data              (write_data_for_sp[31:0]), @252
//          .write_data_verify       (write_data_verify_for_sp[3:0]), @253
//          .write_data_pol          (write_data_pol_for_sp) @254
//         ); @255
// &Connect(.x_randclk_reg_mod_en_w32(susp_randclk_reg_mod_en_w32), @256
//          .x_write_en              (susp_write_en), @257
//          .x_reg_dout              (susp_reg_dout) @258
//         ); @259
// &Connect(.x_reg_verify            (susp_reg_verify)); @261
// &Connect(.x_reg_dout_pol          (susp_reg_dout_pol)); @265
// &Instance("cr_iu_gated_clk_reg_timing", "x_cr_iu_gated_clk_reg_sec_machine_2"); @268
// &Connect(.write_data              (write_data_for_sp[31:0]), @269
//          .write_data_verify       (write_data_verify_for_sp[3:0]), @270
//          .write_data_pol          (write_data_pol_for_sp) @271
//         ); @272
// &Connect(.x_randclk_reg_mod_en_w32(sssp_randclk_reg_mod_en_w32), @274
//          .x_write_en              (sssp_write_en), @275
//          .x_reg_dout              (sssp_reg_dout) @276
//         ); @277
// &Connect(.x_reg_verify            (sssp_reg_verify)); @279
// &Connect(.x_reg_dout_pol          (sssp_reg_dout_pol)); @283

//==============================================================================
// rename random clock module enable signal
//==============================================================================
// &Force("bus","randclk_oper_gpr_mod_en_w32",20,0); @291
//assign user_0_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[0];
assign user_1_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[1];
assign user_3_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[3];
assign user_4_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[4];
assign user_5_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[5];
assign user_6_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[6];
assign user_7_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[7];
assign user_8_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[8];
assign user_9_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[9];
assign user_10_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[10];
assign user_11_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[11];
assign user_12_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[12];
assign user_13_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[13];
assign user_14_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[14];
assign user_15_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[15];

assign machine_2_randclk_reg_mod_en_w32 = randclk_oper_gpr_mod_en_w32[16];
//==============================================================================
// implement of 1 write port GPR
//==============================================================================
//if not define, set rst_b 1
assign pad_cpu_gpr_rst_b = 1'b1;

assign gpr_sync_rst_b = pad_cpu_gpr_rst_b && iu_yy_xx_reg_rst_b
                        && hs_split_iu_nsinst_gpr_rst_b;
assign gpr_sync_rst_for_sp_b = pad_cpu_gpr_rst_b && iu_yy_xx_reg_rst_b;

//the general write port
assign write_port_data[31:0] = {32{gpr_sync_rst_b}}
                             & inst_write_data[31:0];
assign write_data[31:0] = write_port_data[31:0];

//==============================================================================
// implement of 1 write port GPR
//==============================================================================
//write port for gpr with general write buffer wen and CP0 wen
//1.user x2 when MACHINE_SP
//2.machine x2 when CSKY_TEE
//3.susp when CSKY_TEE

assign  write_data_for_sp[31:0] =  write_port_data[31:0];

//==========================================================
// implement of write port: write data and write enable
//==========================================================

// &CombBeg; @376
always @( inst_write_index[4:0])
begin
  reg_sel[31:0] = 32'b0;
  case(inst_write_index[4:0])
  5'h0 :  reg_sel[0]  = 1'b1;
  5'h1 :  reg_sel[1]  = 1'b1;
  5'h2 :  reg_sel[2]  = 1'b1;
  5'h3 :  reg_sel[3]  = 1'b1;
  5'h4 :  reg_sel[4]  = 1'b1;
  5'h5 :  reg_sel[5]  = 1'b1;
  5'h6 :  reg_sel[6]  = 1'b1;
  5'h7 :  reg_sel[7]  = 1'b1;
  5'h8 :  reg_sel[8]  = 1'b1;
  5'h9 :  reg_sel[9]  = 1'b1;
  5'ha :  reg_sel[10] = 1'b1;
  5'hb :  reg_sel[11] = 1'b1;
  5'hc :  reg_sel[12] = 1'b1;
  5'hd :  reg_sel[13] = 1'b1;
  5'he :  reg_sel[14] = 1'b1;
  5'hf :  reg_sel[15] = 1'b1;
  endcase
// &CombEnd; @398
end

//r31~r0, normal
assign user_write_en[31:3] = reg_sel[31:3] & {29{inst_wen}};
assign user_write_en[1:0]  = reg_sel[1:0] & {2{inst_wen}}; 

// &Force ("bus","cp0_iu_vec",7,0); @404

assign user_write_en[2] = 1'b0;

assign ussp_explicit_we   = reg_sel[2] && inst_wen
                         || !gpr_sync_rst_for_sp_b;
assign machine_write_en_2 = ussp_explicit_we;


assign user_1_write_en   = !gpr_sync_rst_b | user_write_en[1];
assign user_3_write_en   = !gpr_sync_rst_b | user_write_en[3];
assign user_4_write_en   = !gpr_sync_rst_b | user_write_en[4];
assign user_5_write_en   = !gpr_sync_rst_b | user_write_en[5];
assign user_6_write_en   = !gpr_sync_rst_b | user_write_en[6];
assign user_7_write_en   = !gpr_sync_rst_b | user_write_en[7];
assign user_8_write_en   = !gpr_sync_rst_b | user_write_en[8];
assign user_9_write_en   = !gpr_sync_rst_b | user_write_en[9];
assign user_10_write_en  = !gpr_sync_rst_b | user_write_en[10];
assign user_11_write_en  = !gpr_sync_rst_b | user_write_en[11];
assign user_12_write_en  = !gpr_sync_rst_b | user_write_en[12];
assign user_13_write_en  = !gpr_sync_rst_b | user_write_en[13];
assign user_14_write_en  = !gpr_sync_rst_b | user_write_en[14];
assign user_15_write_en  = !gpr_sync_rst_b | user_write_en[15];
assign machine_2_write_en = machine_write_en_2;



//==============================================================================
// As GPR has 2 read ports, the logic is responsible for generating 2 read ports
//==============================================================================
//read port of x1 for IFU forwarding
// //&Force("output","user_reg_1_dout"); @475
//assign user_reg_1_dout[31:0] = alter_mode ? alter_1_reg_dout[31:0]
//                                          : user_1_reg_dout[31:0];

//==============================================================================
//for code sytye of GPR read
//==============================================================================
// //&Force ("output","alter_mode"); @482

assign alter_mode = 1'b0;
assign alter_0_reg_dout[31:0] = 32'b0;
assign alter_1_reg_dout[31:0] = 32'b0;
assign alter_2_reg_dout[31:0] = 32'b0;
assign alter_3_reg_dout[31:0] = 32'b0;
assign alter_4_reg_dout[31:0] = 32'b0;
assign alter_5_reg_dout[31:0] = 32'b0;
assign alter_6_reg_dout[31:0] = 32'b0;
assign alter_7_reg_dout[31:0] = 32'b0;
assign alter_8_reg_dout[31:0] = 32'b0;
assign alter_9_reg_dout[31:0]  = 32'b0;
assign alter_10_reg_dout[31:0] = 32'b0;
assign alter_11_reg_dout[31:0] = 32'b0;
assign alter_12_reg_dout[31:0] = 32'b0;
assign alter_13_reg_dout[31:0] = 32'b0;
assign alter_14_reg_dout[31:0] = 32'b0;
assign alter_15_reg_dout[31:0] = 32'b0;

//==============================================================================
// Read Port 0
//==============================================================================
// &CombBeg; @509
always @( user_8_reg_dout[31:0]
       or alter_3_reg_dout[31:0]
       or alter_7_reg_dout[31:0]
       or alter_13_reg_dout[31:0]
       or inst_read_index0[4:0]
       or user_11_reg_dout[31:0]
       or user_10_reg_dout[31:0]
       or user_3_reg_dout[31:0]
       or user_9_reg_dout[31:0]
       or alter_15_reg_dout[31:0]
       or alter_1_reg_dout[31:0]
       or alter_6_reg_dout[31:0]
       or user_1_reg_dout[31:0]
       or sp_read_data0[31:0]
       or alter_5_reg_dout[31:0]
       or user_13_reg_dout[31:0]
       or alter_4_reg_dout[31:0]
       or alter_mode
       or user_4_reg_dout[31:0]
       or user_5_reg_dout[31:0]
       or user_15_reg_dout[31:0]
       or user_6_reg_dout[31:0]
       or alter_12_reg_dout[31:0]
       or alter_10_reg_dout[31:0]
       or alter_9_reg_dout[31:0]
       or alter_11_reg_dout[31:0]
       or user_14_reg_dout[31:0]
       or alter_0_reg_dout[31:0]
       or user_12_reg_dout[31:0]
       or user_7_reg_dout[31:0]
       or alter_8_reg_dout[31:0]
       or alter_14_reg_dout[31:0])
begin
  case(inst_read_index0[4:0])
  5'h0:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_0_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = 32'b0;
  5'h1:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_1_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_1_reg_dout[31:0];
  5'h2:
    gpr_read_data0[31:0] = sp_read_data0[31:0];
  5'h3:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_3_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_3_reg_dout[31:0];
  5'h4:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_4_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_4_reg_dout[31:0];
  5'h5:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_5_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_5_reg_dout[31:0];
  5'h6:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_6_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_6_reg_dout[31:0];
  5'h7:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_7_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_7_reg_dout[31:0];
  5'h8:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_8_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_8_reg_dout[31:0];
  5'h9:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_9_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_9_reg_dout[31:0];
  5'ha:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_10_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_10_reg_dout[31:0];
  5'hb:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_11_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_11_reg_dout[31:0];
  5'hc:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_12_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_12_reg_dout[31:0];
  5'hd:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_13_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_13_reg_dout[31:0];
  5'he:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_14_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_14_reg_dout[31:0];
  5'hf:
  if(alter_mode)
    gpr_read_data0[31:0] = alter_15_reg_dout[31:0];
  else
    gpr_read_data0[31:0] = user_15_reg_dout[31:0];
  default: gpr_read_data0[31:0] = 32'b0;
  endcase
// &CombEnd; @592
end

// &CombBeg; @594
always @( alter_2_reg_dout[31:0]
       or alter_mode
       or machine_2_reg_dout[31:0])
begin
  if(alter_mode)
    sp_read_data0[31:0] = alter_2_reg_dout[31:0];
  else
    sp_read_data0[31:0] = machine_2_reg_dout[31:0];

// &CombEnd; @627
end

assign inst_read_data0[31:0] = gpr_read_data0[31:0];

//==============================================================================
// Read Port 1
//==============================================================================
// &CombBeg; @634
always @( user_8_reg_dout[31:0]
       or alter_3_reg_dout[31:0]
       or sp_read_data1[31:0]
       or alter_7_reg_dout[31:0]
       or alter_13_reg_dout[31:0]
       or user_11_reg_dout[31:0]
       or user_10_reg_dout[31:0]
       or user_3_reg_dout[31:0]
       or user_9_reg_dout[31:0]
       or alter_15_reg_dout[31:0]
       or inst_read_index1[4:0]
       or alter_1_reg_dout[31:0]
       or alter_6_reg_dout[31:0]
       or user_1_reg_dout[31:0]
       or user_13_reg_dout[31:0]
       or alter_5_reg_dout[31:0]
       or alter_4_reg_dout[31:0]
       or alter_mode
       or user_4_reg_dout[31:0]
       or user_5_reg_dout[31:0]
       or user_15_reg_dout[31:0]
       or user_6_reg_dout[31:0]
       or alter_10_reg_dout[31:0]
       or alter_12_reg_dout[31:0]
       or alter_9_reg_dout[31:0]
       or alter_11_reg_dout[31:0]
       or alter_0_reg_dout[31:0]
       or user_14_reg_dout[31:0]
       or user_12_reg_dout[31:0]
       or user_7_reg_dout[31:0]
       or alter_8_reg_dout[31:0]
       or alter_14_reg_dout[31:0])
begin
  case(inst_read_index1[4:0])
  5'h0:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_0_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = 32'b0;
  5'h1:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_1_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_1_reg_dout[31:0];
  5'h2:
    gpr_read_data1[31:0] = sp_read_data1[31:0];
  5'h3:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_3_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_3_reg_dout[31:0];
  5'h4:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_4_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_4_reg_dout[31:0];
  5'h5:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_5_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_5_reg_dout[31:0];
  5'h6:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_6_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_6_reg_dout[31:0];
  5'h7:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_7_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_7_reg_dout[31:0];
  5'h8:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_8_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_8_reg_dout[31:0];
  5'h9:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_9_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_9_reg_dout[31:0];
  5'ha:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_10_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_10_reg_dout[31:0];
  5'hb:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_11_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_11_reg_dout[31:0];
  5'hc:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_12_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_12_reg_dout[31:0];
  5'hd:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_13_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_13_reg_dout[31:0];
  5'he:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_14_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_14_reg_dout[31:0];
  5'hf:
  if(alter_mode)
    gpr_read_data1[31:0] = alter_15_reg_dout[31:0];
  else
    gpr_read_data1[31:0] = user_15_reg_dout[31:0];
  default: gpr_read_data1[31:0] = 32'b0;
  endcase
// &CombEnd; @736
end
// &CombBeg; @740
always @( alter_2_reg_dout[31:0]
       or alter_mode
       or machine_2_reg_dout[31:0])
begin
  if(alter_mode)
    sp_read_data1[31:0] = alter_2_reg_dout[31:0];
  else
    sp_read_data1[31:0] = machine_2_reg_dout[31:0];
// &CombEnd; @772
end
// &Force("output","user_2_reg_dout"); @774
// &Force("output","machine_2_reg_dout"); @777
// &Force("output","susp_reg_dout"); @778

assign inst_read_data1[31:0] = gpr_read_data1[31:0];

// &ModuleEnd; @783
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @26
module cr_iu_pcgen(
  branch_pcgen_add_pc,
  branch_pcgen_br_chgflw_vld,
  branch_pcgen_br_chgflw_vld_for_data,
  branch_pcgen_br_pc_chgflw_vld,
  branch_pcgen_branch_chgflw_vld_for_data,
  branch_pcgen_jmp_chgflw_vld_for_data,
  branch_pcgen_reg_pc,
  cp0_iu_epc_for_chgflw,
  cp0_iu_flush_chgflw_vld,
  cp0_iu_rte_chgflw_vld,
  cp0_iu_rte_chgflw_vld_for_data,
  cp0_yy_clk_en,
  cpurst_b,
  forever_cpuclk,
  had_iu_pc,
  had_iu_rte_pc_sel,
  had_yy_xx_exit_dbg,
  hs_split_iu_unstack_chgflw,
  ifu_iu_ibus_idle,
  ifu_iu_spcu_retire_mask,
  ifu_iu_xx_ibus_data,
  iu_ifu_addr,
  iu_ifu_data_fetch,
  iu_ifu_data_fetch_for_data,
  iu_ifu_inst_fetch,
  iu_ifu_inst_fetch_for_data,
  iu_ifu_inst_fetch_without_dbg_disable,
  iu_yy_xx_flush,
  iu_yy_xx_retire,
  misc_clk,
  nie_flush_chgflw,
  pad_yy_gate_clk_en_b,
  pcgen_ctrl_stall,
  pcgen_retire_updt_pc,
  pcgen_top_abort_clk_en,
  pcgen_vector_expt_taken,
  pcgen_xx_cur_pc,
  pcgen_xx_ibus_idle,
  randclk_pcgen_mod_en_w32,
  retire_branch_stall,
  retire_pcgen_curpc_update,
  retire_xx_normal_retire,
  special_pcgen_chgflw_vld,
  sysio_iu_rst_addr,
  vector_pcgen_buf_vbr,
  vector_pcgen_chgflw_vld,
  vector_pcgen_cur_pc_vld,
  vector_pcgen_enter_addr,
  vector_pcgen_ibus_req,
  vector_pcgen_reset_vld,
  wb_pcgen_ldst_stall,
  wb_pcgen_pc_updt_val,
  wb_pcgen_switch_ld_pc,
  wb_retire_fast_retire_load_pc
);

// &Ports; @27
input   [30:0]  branch_pcgen_add_pc;                    
input           branch_pcgen_br_chgflw_vld;             
input           branch_pcgen_br_chgflw_vld_for_data;    
input           branch_pcgen_br_pc_chgflw_vld;          
input           branch_pcgen_branch_chgflw_vld_for_data; 
input           branch_pcgen_jmp_chgflw_vld_for_data;   
input   [30:0]  branch_pcgen_reg_pc;                    
input   [30:0]  cp0_iu_epc_for_chgflw;                  
input           cp0_iu_flush_chgflw_vld;                
input           cp0_iu_rte_chgflw_vld;                  
input           cp0_iu_rte_chgflw_vld_for_data;         
input           cp0_yy_clk_en;                          
input           cpurst_b;                               
input           forever_cpuclk;                         
input   [30:0]  had_iu_pc;                              
input           had_iu_rte_pc_sel;                      
input           had_yy_xx_exit_dbg;                     
input           hs_split_iu_unstack_chgflw;             
input           ifu_iu_ibus_idle;                       
input           ifu_iu_spcu_retire_mask;                
input   [31:0]  ifu_iu_xx_ibus_data;                    
input           iu_yy_xx_flush;                         
input           iu_yy_xx_retire;                        
input           misc_clk;                               
input           nie_flush_chgflw;                       
input           pad_yy_gate_clk_en_b;                   
input           randclk_pcgen_mod_en_w32;               
input           retire_branch_stall;                    
input           retire_pcgen_curpc_update;              
input           retire_xx_normal_retire;                
input           special_pcgen_chgflw_vld;               
input   [31:0]  sysio_iu_rst_addr;                      
input           vector_pcgen_buf_vbr;                   
input           vector_pcgen_chgflw_vld;                
input           vector_pcgen_cur_pc_vld;                
input   [30:0]  vector_pcgen_enter_addr;                
input           vector_pcgen_ibus_req;                  
input           vector_pcgen_reset_vld;                 
input           wb_pcgen_ldst_stall;                    
input   [30:0]  wb_pcgen_pc_updt_val;                   
input           wb_pcgen_switch_ld_pc;                  
input   [30:0]  wb_retire_fast_retire_load_pc;          
output  [30:0]  iu_ifu_addr;                            
output          iu_ifu_data_fetch;                      
output          iu_ifu_data_fetch_for_data;             
output          iu_ifu_inst_fetch;                      
output          iu_ifu_inst_fetch_for_data;             
output          iu_ifu_inst_fetch_without_dbg_disable;  
output          pcgen_ctrl_stall;                       
output  [30:0]  pcgen_retire_updt_pc;                   
output          pcgen_top_abort_clk_en;                 
output          pcgen_vector_expt_taken;                
output  [30:0]  pcgen_xx_cur_pc;                        
output          pcgen_xx_ibus_idle;                     

// &Regs; @28
reg             cur_state;                              
reg             fetch_cur_state;                        
reg             fetch_next_state;                       
reg             next_state;                             
reg     [30:0]  pcgen_cur_pc;                           

// &Wires; @29
wire    [30:0]  bctm_pcgen_chgflw_pc;                   
wire            bctm_pcgen_chk_chgflw_vld;              
wire            bctm_pcgen_chk_fail_pc_vld;             
wire            bctm_pcgen_jmp_chgflw_vld;              
wire            bctm_pcgen_jmp_chgflw_vld_for_data;     
wire    [30:0]  branch_pcgen_add_pc;                    
wire            branch_pcgen_br_chgflw_vld;             
wire            branch_pcgen_br_chgflw_vld_for_data;    
wire            branch_pcgen_br_pc_chgflw_vld;          
wire            branch_pcgen_branch_chgflw_vld_for_data; 
wire            branch_pcgen_jmp_chgflw_vld_for_data;   
wire    [30:0]  branch_pcgen_reg_pc;                    
wire    [30:0]  cp0_iu_epc_for_chgflw;                  
wire            cp0_iu_flush_chgflw_vld;                
wire            cp0_iu_rte_chgflw_vld;                  
wire            cp0_iu_rte_chgflw_vld_for_data;         
wire            cp0_yy_clk_en;                          
wire            cpurst_b;                               
wire            curpc_10_0_clk;                         
wire            curpc_10_0_clk_en;                      
wire            curpc_30_11_clk;                        
wire            curpc_30_11_clk_en;                     
wire            curpc_sel_from_wb;                      
wire            curpc_sel_not_hs;                       
wire            forever_cpuclk;                         
wire    [30:0]  had_iu_pc;                              
wire            had_iu_rte_pc_sel;                      
wire            had_yy_xx_exit_dbg;                     
wire            hs_split_iu_unstack_chgflw;             
wire            ifu_iu_ibus_idle;                       
wire            ifu_iu_spcu_retire_mask;                
wire    [31:0]  ifu_iu_xx_ibus_data;                    
wire            inst_fetch_mask;                        
wire    [30:0]  iu_ifu_addr;                            
wire            iu_ifu_data_fetch;                      
wire            iu_ifu_data_fetch_for_data;             
wire            iu_ifu_inst_fetch;                      
wire            iu_ifu_inst_fetch_for_data;             
wire            iu_ifu_inst_fetch_without_dbg_disable;  
wire            iu_yy_xx_flush;                         
wire            iu_yy_xx_retire;                        
wire            misc_clk;                               
wire            nie_flush_chgflw;                       
wire            pad_yy_gate_clk_en_b;                   
wire            pcgen_abort_chgflw_vld;                 
wire            pcgen_abort_chgflw_vld_for_data;        
wire    [30:0]  pcgen_addr_after_bctm;                  
wire    [30:0]  pcgen_addr_chgflw_asap;                 
wire    [30:0]  pcgen_addr_chgflw_delay;                
wire    [30:0]  pcgen_addr_except_chgflw_delay;         
wire            pcgen_address_add;                      
wire            pcgen_address_cur;                      
wire            pcgen_address_epc;                      
wire            pcgen_address_had;                      
wire            pcgen_address_ibus;                     
wire            pcgen_address_inc;                      
wire            pcgen_address_reg;                      
wire            pcgen_address_svbr;                     
wire            pcgen_address_vec;                      
wire            pcgen_chfglw_asap_vld_for_data;         
wire            pcgen_chgflw_asap_vld;                  
wire            pcgen_chgflw_delay_sel;                 
wire            pcgen_ctrl_stall;                       
wire    [30:0]  pcgen_cur_pc_next_val;                  
wire    [30:0]  pcgen_cur_pc_next_val_before_hs;        
wire            pcgen_cur_pc_updt_vld;                  
wire            pcgen_cur_pc_updt_vld_by_inst;          
wire            pcgen_cur_pc_updt_vld_chgflw;           
wire            pcgen_cur_pc_updt_vld_normal;           
wire            pcgen_cur_pc_updt_vld_not_by_inst;      
wire            pcgen_fetch_mask_trig;                  
wire            pcgen_idle_chgflw_vld;                  
wire            pcgen_idle_chgflw_vld_for_data;         
wire    [30:0]  pcgen_increase_pc;                      
wire            pcgen_inst_fetch;                       
wire    [30:0]  pcgen_retire_updt_pc;                   
wire            pcgen_top_abort_clk_en;                 
wire            pcgen_vector_expt_taken;                
wire            pcgen_wait_idle_trig;                   
wire    [30:0]  pcgen_xx_cur_pc;                        
wire            pcgen_xx_ibus_idle;                     
wire            randclk_pcgen_mod_en_w32;               
wire            retire_branch_stall;                    
wire            retire_pcgen_curpc_update;              
wire            retire_xx_normal_retire;                
wire            special_pcgen_chgflw_vld;               
wire    [31:0]  sysio_iu_rst_addr;                      
wire            vector_pcgen_buf_vbr;                   
wire            vector_pcgen_chgflw_vld;                
wire            vector_pcgen_cur_pc_vld;                
wire    [30:0]  vector_pcgen_enter_addr;                
wire            vector_pcgen_ibus_req;                  
wire            vector_pcgen_reset_vld;                 
wire            wb_pcgen_ldst_stall;                    
wire    [30:0]  wb_pcgen_pc_updt_val;                   
wire            wb_pcgen_switch_ld_pc;                  
wire    [30:0]  wb_retire_fast_retire_load_pc;          


parameter IDLE       = 1'b0;
parameter WAIT_IDLE  = 1'b1;
parameter FETCH_IDLE = 1'b0;
parameter FETCH_MASK = 1'b1;
parameter EMMU_IDLE       = 1'b0;
parameter EMMU_WAIT_IDLE  = 1'b1;

//==========================================================
//                 Instance of Gated Cell  
//==========================================================
assign pcgen_top_abort_clk_en = pcgen_wait_idle_trig
                             || pcgen_fetch_mask_trig
                             || (cur_state != IDLE)
                             || (fetch_cur_state != FETCH_IDLE);

//Depending on principle of locality ,the program will execute in certain pc range,
//so the changing frequency of high bit of cur_pc[30:0] will be rather small. As
//a result ,we separate cur_pc[30:0] into two part to reduce power
assign curpc_10_0_clk_en = pcgen_cur_pc_updt_vld || vector_pcgen_reset_vld;
// &Instance("gated_clk_cell", "x_curpc_gated_clk"); @50
gated_clk_cell  x_curpc_gated_clk (
  .clk_in                   (forever_cpuclk          ),
  .clk_out                  (curpc_10_0_clk          ),
  .external_en              (1'b0                    ),
  .global_en                (cp0_yy_clk_en           ),
  .local_en                 (curpc_10_0_clk_en       ),
  .module_en                (randclk_pcgen_mod_en_w32),
  .pad_yy_gate_clk_en_b     (pad_yy_gate_clk_en_b    )
);

// &Connect(.clk_in      (forever_cpuclk), @51
//          .external_en (1'b0), @52
//          .global_en   (cp0_yy_clk_en), @53
//          .module_en   (randclk_pcgen_mod_en_w32), @54
//          .local_en    (curpc_10_0_clk_en), @55
//          .clk_out     (curpc_10_0_clk)); @56

assign curpc_30_11_clk_en = pcgen_cur_pc_updt_vld_chgflw
                         || vector_pcgen_reset_vld
                         || pcgen_cur_pc_updt_vld_normal
                            && (pcgen_cur_pc[11] ^ pcgen_cur_pc_next_val[11]);
// &Instance("gated_clk_cell", "x_curpc_30_11_gated_clk"); @64
gated_clk_cell  x_curpc_30_11_gated_clk (
  .clk_in                   (forever_cpuclk          ),
  .clk_out                  (curpc_30_11_clk         ),
  .external_en              (1'b0                    ),
  .global_en                (cp0_yy_clk_en           ),
  .local_en                 (curpc_30_11_clk_en      ),
  .module_en                (randclk_pcgen_mod_en_w32),
  .pad_yy_gate_clk_en_b     (pad_yy_gate_clk_en_b    )
);

// &Connect(.clk_in      (forever_cpuclk), @65
//          .external_en (1'b0), @66
//          .global_en   (cp0_yy_clk_en), @67
//          .module_en   (randclk_pcgen_mod_en_w32), @68
//          .local_en    (curpc_30_11_clk_en), @69
//          .clk_out     (curpc_30_11_clk)); @70
//==========================================================
//          The Original Instruction Fetch Sources
//==========================================================
//the original change flow (instruction fetch) sources are:
// 1.exit of debug mode
// 2.direct branch without exception (interrupt)
// 3.return from exception (rte) exception (interrupt, cp0
//   will not change flow when privilege violation)
// 4.cp0 flush without exception (interrupt) will change
//   flow (not include rte change flow)
// 5.change flow to exception service routine from vector
//   machine
// 6.jmpix without exception (interrupt) (ifdef BCTM)
// 7.check fail change flow
assign bctm_pcgen_jmp_chgflw_vld          = 1'b0;
assign bctm_pcgen_jmp_chgflw_vld_for_data = 1'b0;
assign bctm_pcgen_chgflw_pc[30:0] = 31'b0;
assign bctm_pcgen_chk_fail_pc_vld = 1'b0;
assign bctm_pcgen_chk_chgflw_vld = 1'b0;

assign pcgen_inst_fetch = branch_pcgen_br_chgflw_vld
                       || cp0_iu_rte_chgflw_vld
                       || cp0_iu_flush_chgflw_vld 
                       || had_yy_xx_exit_dbg
                       || vector_pcgen_chgflw_vld 
                       || special_pcgen_chgflw_vld 
                       || bctm_pcgen_jmp_chgflw_vld
                       || bctm_pcgen_chk_chgflw_vld
                       || hs_split_iu_unstack_chgflw 
                       || nie_flush_chgflw;

//==========================================================
//            The Abort State Machine implement  
//==========================================================
//-----------------------------------------------------
// Once IFU had requested the ibus, the address cannot
// change, so instruction fetch have to wait IFU finish
// the previous transfer (idle)
//-----------------------------------------------------
//------------------FSM of abort logic-----------------
// State Description:
// IDLE       : no instruction fetch or ibus idle
// WAIT_IDLE  : wait idle of ibus
//-----------------------------------------------------
//the pcgen state machine does not affect by flush
always @(posedge misc_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    cur_state <= IDLE;
  else
    cur_state <= next_state;
end

//-----------------------------------------------------
// State change signals
//-----------------------------------------------------
assign pcgen_chgflw_asap_vld          = branch_pcgen_br_chgflw_vld;
assign pcgen_chfglw_asap_vld_for_data = branch_pcgen_br_chgflw_vld_for_data; 

assign pcgen_wait_idle_trig = pcgen_inst_fetch && !pcgen_chgflw_asap_vld;
// &CombBeg; @135
always @( cur_state
       or pcgen_wait_idle_trig
       or ifu_iu_ibus_idle)
begin
  case(cur_state)
  IDLE      : if(pcgen_wait_idle_trig)
                next_state = WAIT_IDLE;
              else
                next_state = IDLE;
  WAIT_IDLE : if(ifu_iu_ibus_idle)
                next_state = IDLE;
              else
                next_state = WAIT_IDLE;
  default   :   next_state = IDLE;
  endcase
// &CombEnd; @147
end

always @(posedge misc_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    fetch_cur_state <= FETCH_IDLE;
  else if(iu_yy_xx_flush)
    fetch_cur_state <= FETCH_IDLE;
  else
    fetch_cur_state <= fetch_next_state;
end

assign pcgen_fetch_mask_trig = pcgen_chgflw_asap_vld && !iu_yy_xx_retire;
// &CombBeg; @160
always @( pcgen_fetch_mask_trig
       or iu_yy_xx_retire
       or fetch_cur_state)
begin
  case(fetch_cur_state)
  FETCH_IDLE : if(pcgen_fetch_mask_trig)
                 fetch_next_state = FETCH_MASK;
               else
                 fetch_next_state = FETCH_IDLE;
  FETCH_MASK : if(iu_yy_xx_retire)
                 fetch_next_state = FETCH_IDLE;
               else
                 fetch_next_state = FETCH_MASK;
  default    :   fetch_next_state = FETCH_IDLE;
  endcase
// &CombEnd; @172
end

assign inst_fetch_mask = (fetch_cur_state == FETCH_MASK);
assign pcgen_xx_ibus_idle = ifu_iu_ibus_idle || inst_fetch_mask;

//==========================================================
//                  Instruction Fetch
//==========================================================
//if ibus is idle, the directly request instruction fetch
//otherwise wait until ibus idle
assign pcgen_idle_chgflw_vld  = pcgen_chgflw_asap_vld 
                                && !inst_fetch_mask;
assign pcgen_abort_chgflw_vld = (cur_state == WAIT_IDLE)
                                && ifu_iu_ibus_idle;
// &Force("output","iu_ifu_inst_fetch"); @186
assign iu_ifu_inst_fetch  = pcgen_abort_chgflw_vld || pcgen_idle_chgflw_vld;

assign pcgen_idle_chgflw_vld_for_data  = pcgen_chfglw_asap_vld_for_data
                                         && !inst_fetch_mask;
assign pcgen_abort_chgflw_vld_for_data = (cur_state == WAIT_IDLE)
                                         && ifu_iu_ibus_idle; 
assign iu_ifu_inst_fetch_for_data = pcgen_abort_chgflw_vld_for_data ||
                                    pcgen_idle_chgflw_vld_for_data;

assign iu_ifu_inst_fetch_without_dbg_disable = iu_ifu_inst_fetch && !retire_branch_stall
                                               && !wb_pcgen_ldst_stall;

//==============================================================================
//                                 Data Fetch 
//==============================================================================

//-----------------------------------------------------
// the data fetch from ibus includes lrw and vector
// intermediate value fetch, which will wait ibus idle
// so data fetch needs no abort
//-----------------------------------------------------
assign iu_ifu_data_fetch = vector_pcgen_ibus_req;
assign iu_ifu_data_fetch_for_data = vector_pcgen_ibus_req;
//==========================================================
//                     Abort stall
//==========================================================
//IU should prevent wrong after change flow instruction
//pipedown after change flow flush, these wrong instructions
//will be stop by abort stall and abort instruction fetch 
//request will get right instruction
//IDLE state does not need stall since change flow flush
assign pcgen_ctrl_stall   = (cur_state == WAIT_IDLE)
                         && !ifu_iu_spcu_retire_mask;// && !ifu_iu_ibus_idle;

//==============================================================================
//                  Address Mux of inst fetch and data fetch
//==============================================================================
//the reqeust address of inst fetch and data fetch are
//1.from had pc when exit debug mode
assign pcgen_address_had  = had_yy_xx_exit_dbg
                         || cp0_iu_rte_chgflw_vld_for_data && had_iu_rte_pc_sel;
                    
//2.from vbr and vec when vector intermediate value
assign pcgen_address_vec  = vector_pcgen_buf_vbr;
assign pcgen_address_ibus = vector_pcgen_cur_pc_vld;
//3.from epc after rte flush
assign pcgen_address_epc  = cp0_iu_rte_chgflw_vld_for_data && !had_iu_rte_pc_sel
                            && !pcgen_address_svbr;

//4-5.from register or offset summation when direct branch
//    when brach mispred as not-taken, chgflw pc is from offset
assign pcgen_address_add  = branch_pcgen_branch_chgflw_vld_for_data
                            && !pcgen_address_svbr;
assign pcgen_address_reg  = branch_pcgen_jmp_chgflw_vld_for_data
                            && !pcgen_address_svbr;
//6.from svbr with offset when jmpix or check fail change flow
assign pcgen_address_svbr = bctm_pcgen_jmp_chgflw_vld_for_data
                         || bctm_pcgen_chk_fail_pc_vld;
//7.from increase pc after mtcr flush and normal retire
assign pcgen_address_inc  = !(pcgen_address_add
                             || pcgen_address_reg
                             || pcgen_address_svbr
                             || pcgen_address_cur);
//8.from current pc when inst fetch abort
//  when expt, the vector table addr and expt enter addr are from curpc
//  when exit dbg mode, the pc is from curpc
//  when rte, the pc is flop to curpc and then chflgw from curpc
assign pcgen_address_cur  = (cur_state == WAIT_IDLE) || vector_pcgen_ibus_req;

//-----------------------------------------------------
// request address mux
//-----------------------------------------------------
//the address mux does not include current pc, the result
//is reuse with current pc update value
assign pcgen_addr_chgflw_delay[30:0] = 
             {31{pcgen_address_had}}  & had_iu_pc[30:0]
           | {31{pcgen_address_vec}}  & vector_pcgen_enter_addr[30:0]
           | {31{pcgen_address_ibus}} & ifu_iu_xx_ibus_data[31:1]
           | {31{pcgen_address_epc}}  & cp0_iu_epc_for_chgflw[30:0];

//the asap pc is for ifu inst fetch
assign pcgen_addr_chgflw_asap[30:0] =
             {31{pcgen_address_add}}  & branch_pcgen_add_pc[30:0]
           | {31{pcgen_address_reg}}  & branch_pcgen_reg_pc[30:0]
           | {31{pcgen_address_inc}}  & pcgen_increase_pc[30:0]
           | {31{pcgen_address_cur}}  & pcgen_cur_pc[30:0];
// &Force("bus","ifu_iu_xx_ibus_data",31,0); @273
assign pcgen_addr_after_bctm[30:0] = 
             {31{pcgen_address_svbr}}  & bctm_pcgen_chgflw_pc[30:0]
           | {31{!pcgen_address_svbr}} & pcgen_addr_chgflw_asap[30:0];

assign pcgen_addr_except_chgflw_delay[30:0] = pcgen_cur_pc_updt_vld
                                      ? pcgen_addr_after_bctm[30:0]
                                      : pcgen_cur_pc[30:0];

//the PC to updata EPC or HAD PC when:
//1.expt happens -> EPC
//2.acc err after int -> EPC
//3.acc err after dbg -> HAD PC
//4.bstack chk fail after int -> EPC
//5.bstack chk fail after dbg -> HAD PC
assign pcgen_retire_updt_pc[30:0] = pcgen_addr_except_chgflw_delay[30:0]; 

//-----------------------------------------------------
//     Value to Updata CurPC  
//-----------------------------------------------------
assign pcgen_chgflw_delay_sel = pcgen_cur_pc_updt_vld
                             && (pcgen_address_had
                                 || pcgen_address_vec
                                 || pcgen_address_ibus
                                 || pcgen_address_epc);

assign pcgen_cur_pc_next_val_before_hs[30:0] = pcgen_chgflw_delay_sel
                                      ? pcgen_addr_chgflw_delay[30:0]
                                      : pcgen_addr_except_chgflw_delay[30:0];

assign curpc_sel_from_wb = retire_pcgen_curpc_update
                        && !bctm_pcgen_chk_fail_pc_vld;
assign curpc_sel_not_hs = !curpc_sel_from_wb
                       && !wb_pcgen_switch_ld_pc;
assign pcgen_cur_pc_next_val[30:0] = 
        {31{curpc_sel_from_wb}}     & wb_retire_fast_retire_load_pc[30:0]
      | {31{wb_pcgen_switch_ld_pc}} & wb_pcgen_pc_updt_val[30:0]
      | {31{curpc_sel_not_hs}}      & pcgen_cur_pc_next_val_before_hs[30:0];

//==========================================================
//   The addr to IFU (including data fetch and inst fetch)   
//==========================================================
assign iu_ifu_addr[30:0] = pcgen_addr_chgflw_asap[30:0]; 


//==============================================================================
//                            Current PC maintain
//==============================================================================
//current pc update valid signal
//1.exit debug mode
//2.direct branch change flow
//3.the vbr will be buffered in curPC first, then sent to IFU
//4.vector change flow
//5.return from exception
assign pcgen_cur_pc_updt_vld_not_by_inst = had_yy_xx_exit_dbg
                                        || vector_pcgen_cur_pc_vld
                                        || vector_pcgen_buf_vbr
                                        || bctm_pcgen_chk_fail_pc_vld
                                        || retire_pcgen_curpc_update
                                        || wb_pcgen_switch_ld_pc;

//6.jmpix and check fail change flow
assign pcgen_cur_pc_updt_vld_by_inst = branch_pcgen_br_pc_chgflw_vld
                                    || cp0_iu_rte_chgflw_vld
                                    || bctm_pcgen_jmp_chgflw_vld;

//7.cp0 flush and normal retire
//when EMMU and BCTM, when BCTM check fail, the cur pc cannot be updt in order
//to maintain the check fail chgflw for EMMU check
assign pcgen_cur_pc_updt_vld_normal = retire_xx_normal_retire;

assign pcgen_cur_pc_updt_vld_chgflw = pcgen_cur_pc_updt_vld_not_by_inst 
                                   || pcgen_cur_pc_updt_vld_by_inst;

assign pcgen_cur_pc_updt_vld = pcgen_cur_pc_updt_vld_not_by_inst
                            || pcgen_cur_pc_updt_vld_normal;

//-----------------------------------------------------
//            implement of current pc flop
//-----------------------------------------------------
//  &Force("bus", "sysio_iu_rst_addr", 31, 0); @358
always @(posedge curpc_10_0_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    pcgen_cur_pc[10:0] <= 11'b0;
  else if(vector_pcgen_reset_vld)
    pcgen_cur_pc[10:0] <= sysio_iu_rst_addr[11:1];
  else
    pcgen_cur_pc[10:0] <= pcgen_cur_pc_next_val[10:0];
end

always @(posedge curpc_30_11_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    pcgen_cur_pc[30:11] <= 20'b0;
  else if(vector_pcgen_reset_vld)
    pcgen_cur_pc[30:11] <= sysio_iu_rst_addr[31:12];
  else
    pcgen_cur_pc[30:11] <= pcgen_cur_pc_next_val[30:11];
end

//output for branch source
assign pcgen_xx_cur_pc[30:0] = pcgen_cur_pc[30:0];

//-----------------------------------------------------
//                    Increase PC
//-----------------------------------------------------
//assign pcgen_increase_pc[30:0] = pcgen_cur_pc[30:0] + pcgen_inc_offset[1:0];
assign pcgen_increase_pc[30:0] = branch_pcgen_add_pc[30:0];
//                                 + {decd_xx_inst_32bit, !decd_xx_inst_32bit};
//when bctm check fail, the curpc is not updated, and in next cycle,
//the curpc+1 need to be written to R15
//assign pcgen_inc_offset[1] = decd_xx_inst_32bit;
//assign pcgen_inc_offset[0] = !decd_xx_inst_32bit;

//output for branch_source 
//assign pcgen_branch_inc_pc[30:0] = pcgen_increase_pc[30:0];

assign pcgen_vector_expt_taken = (cur_state==IDLE);
//-----------------------------------------------------
//            PC Check of Security Extension
//-----------------------------------------------------
// &ModuleEnd; @425
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module cr_iu_randclk(
  randclk_mad_mod_en_w2,
  randclk_oper_gpr_mod_en_w32,
  randclk_pcgen_mod_en_w32,
  randclk_retire_mod_en_w2,
  randclk_wb_buf_mod_en_w32,
  randclk_wb_ctrl_mod_en_w2,
  randclk_wb_idx_mod_en_w5
);

// &Ports; @25
output          randclk_mad_mod_en_w2;      
output  [20:0]  randclk_oper_gpr_mod_en_w32; 
output          randclk_pcgen_mod_en_w32;   
output          randclk_retire_mod_en_w2;   
output          randclk_wb_buf_mod_en_w32;  
output          randclk_wb_ctrl_mod_en_w2;  
output          randclk_wb_idx_mod_en_w5;   

// &Regs; @26

// &Wires; @27
wire            randclk_mad_mod_en_w2;      
wire    [20:0]  randclk_oper_gpr_mod_en_w32; 
wire            randclk_pcgen_mod_en_w32;   
wire            randclk_retire_mod_en_w2;   
wire            randclk_wb_buf_mod_en_w32;  
wire            randclk_wb_ctrl_mod_en_w2;  
wire            randclk_wb_idx_mod_en_w5;   


// &Force("bus","seu_iu_randclk_mod_en",31,0); @31

//assign randclk_branch_mod_en_w2          = 1'b0;
assign randclk_mad_mod_en_w2             = 1'b0;
assign randclk_oper_gpr_mod_en_w32[20:0] = 21'b0;
assign randclk_pcgen_mod_en_w32          = 1'b0;
assign randclk_retire_mod_en_w2          = 1'b0;
//assign randclk_vector_mod_en_w3          = 1'b0;
assign randclk_wb_buf_mod_en_w32         = 1'b0;
assign randclk_wb_ctrl_mod_en_w2         = 1'b0;
assign randclk_wb_idx_mod_en_w5          = 1'b0;
//assign randclk_wb_pc_mod_en_w31          = 1'b0;


// &ModuleEnd; @82
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @27
module cr_iu_rbus(
  alu_rbus_data,
  alu_rbus_data_vld,
  alu_rbus_req,
  branch_rbus_data,
  branch_rbus_data_vld,
  branch_rbus_req,
  cp0_iu_data,
  cp0_iu_data_vld,
  cp0_iu_expt_vec,
  cp0_iu_expt_vld,
  cp0_iu_flush,
  cp0_iu_req,
  ctrl_alu_ex_data_sel,
  ctrl_branch_ex_data_sel,
  ctrl_cp0_ex_data_sel,
  ctrl_lsu_ex_data_sel,
  ctrl_mad_ex_data_sel,
  ctrl_special_ex_data_sel,
  ctrl_xx_sp_adjust,
  decd_xx_unit_special_sel,
  hs_split_iu_hs_retire_mask,
  ifu_iu_ex_int_spcu_mask,
  ifu_iu_ex_rd_reg,
  lsu_iu_data,
  lsu_iu_data_vld,
  lsu_iu_expt_vec,
  lsu_iu_expt_vld,
  lsu_iu_fast_retire,
  lsu_iu_req,
  lsu_iu_store,
  mad_alu_data_vld,
  mad_ctrl_stall,
  mad_rbus_req,
  rbus_retire_cmplt,
  rbus_retire_expt_vec,
  rbus_retire_expt_vld,
  rbus_retire_flush,
  rbus_retire_split_inst,
  rbus_wb_cmplt,
  rbus_wb_data,
  rbus_wb_dst_reg,
  rbus_wb_inst_cmplt,
  rbus_wb_load,
  rbus_wb_store,
  special_rbus_expt_vec,
  special_rbus_expt_vld,
  special_rbus_flush,
  special_rbus_req,
  wb_rbus_lsu_vec,
  wb_rbus_st_aft_load,
  wb_xx_acc_err_after_retire
);

// &Ports; @28
input   [31:0]  alu_rbus_data;                   
input           alu_rbus_data_vld;               
input           alu_rbus_req;                    
input   [31:0]  branch_rbus_data;                
input           branch_rbus_data_vld;            
input           branch_rbus_req;                 
input   [31:0]  cp0_iu_data;                     
input           cp0_iu_data_vld;                 
input   [4 :0]  cp0_iu_expt_vec;                 
input           cp0_iu_expt_vld;                 
input           cp0_iu_flush;                    
input           cp0_iu_req;                      
input           ctrl_alu_ex_data_sel;            
input           ctrl_branch_ex_data_sel;         
input           ctrl_cp0_ex_data_sel;            
input           ctrl_lsu_ex_data_sel;            
input           ctrl_mad_ex_data_sel;            
input           ctrl_special_ex_data_sel;        
input           ctrl_xx_sp_adjust;               
input           decd_xx_unit_special_sel;        
input           hs_split_iu_hs_retire_mask;      
input           ifu_iu_ex_int_spcu_mask;         
input   [4 :0]  ifu_iu_ex_rd_reg;                
input   [31:0]  lsu_iu_data;                     
input           lsu_iu_data_vld;                 
input   [4 :0]  lsu_iu_expt_vec;                 
input           lsu_iu_expt_vld;                 
input           lsu_iu_fast_retire;              
input           lsu_iu_req;                      
input           lsu_iu_store;                    
input           mad_alu_data_vld;                
input           mad_ctrl_stall;                  
input           mad_rbus_req;                    
input   [4 :0]  special_rbus_expt_vec;           
input           special_rbus_expt_vld;           
input           special_rbus_flush;              
input           special_rbus_req;                
input   [4 :0]  wb_rbus_lsu_vec;                 
input           wb_rbus_st_aft_load;             
input           wb_xx_acc_err_after_retire;      
output          rbus_retire_cmplt;               
output  [4 :0]  rbus_retire_expt_vec;            
output          rbus_retire_expt_vld;            
output          rbus_retire_flush;               
output          rbus_retire_split_inst;          
output          rbus_wb_cmplt;                   
output  [31:0]  rbus_wb_data;                    
output  [4 :0]  rbus_wb_dst_reg;                 
output          rbus_wb_inst_cmplt;              
output          rbus_wb_load;                    
output          rbus_wb_store;                   

// &Regs; @29

// &Wires; @30
wire            alu_data_sel;                    
wire    [31:0]  alu_rbus_data;                   
wire            alu_rbus_data_vld;               
wire            alu_rbus_req;                    
wire            alu_sel;                         
wire            bctm_rbus_flush;                 
wire            bctm_rbus_req;                   
wire    [31:0]  bctm_rbus_wb_data;               
wire    [4 :0]  bctm_rbus_wb_reg;                
wire            bctm_rbus_wb_vld;                
wire    [31:0]  branch_rbus_data;                
wire            branch_rbus_data_vld;            
wire            branch_rbus_req;                 
wire            branch_sel;                      
wire    [31:0]  cp0_iu_data;                     
wire            cp0_iu_data_vld;                 
wire    [4 :0]  cp0_iu_expt_vec;                 
wire            cp0_iu_expt_vld;                 
wire            cp0_iu_flush;                    
wire            cp0_iu_req;                      
wire            cp0_sel;                         
wire            ctrl_alu_ex_data_sel;            
wire            ctrl_branch_ex_data_sel;         
wire            ctrl_cp0_ex_data_sel;            
wire            ctrl_lsu_ex_data_sel;            
wire            ctrl_mad_ex_data_sel;            
wire            ctrl_special_ex_data_sel;        
wire            ctrl_xx_sp_adjust;               
wire            decd_xx_unit_special_sel;        
wire            hs_split_iu_hs_retire_mask;      
wire            ifu_iu_ex_int_spcu_mask;         
wire    [4 :0]  ifu_iu_ex_rd_reg;                
wire    [31:0]  lsu_iu_data;                     
wire            lsu_iu_data_vld;                 
wire    [4 :0]  lsu_iu_expt_vec;                 
wire            lsu_iu_expt_vld;                 
wire            lsu_iu_fast_retire;              
wire            lsu_iu_flush;                    
wire            lsu_iu_req;                      
wire            lsu_iu_store;                    
wire            lsu_sel;                         
wire            mad_alu_data_vld;                
wire    [31:0]  mad_alu_rbus_data;               
wire            mad_ctrl_stall;                  
wire            mad_data_sel;                    
wire            mad_rbus_req;                    
wire            mad_sel;                         
wire            prgsign_rbus_req;                
wire            prgsign_rbus_secure_violation;   
wire            rbus_cmplt;                      
wire    [31:0]  rbus_data;                       
wire    [31:0]  rbus_data_expt_lsu;              
wire    [31:0]  rbus_data_expt_lsu_without_pol;  
wire            rbus_data_sel_alu;               
wire            rbus_data_sel_branch;            
wire            rbus_data_sel_cp0;               
wire            rbus_data_sel_lsu;               
wire            rbus_data_sel_mad;               
wire            rbus_retire_cmplt;               
wire            rbus_retire_data_vld;            
wire    [4 :0]  rbus_retire_expt_vec;            
wire    [4 :0]  rbus_retire_expt_vec_aft_prgsign; 
wire    [4 :0]  rbus_retire_expt_vec_pre;        
wire            rbus_retire_expt_vld;            
wire            rbus_retire_expt_vld_pre;        
wire            rbus_retire_flush;               
wire            rbus_retire_split_inst;          
wire            rbus_wb_cmplt;                   
wire    [31:0]  rbus_wb_data;                    
wire    [4 :0]  rbus_wb_dst_reg;                 
wire            rbus_wb_inst_cmplt;              
wire            rbus_wb_load;                    
wire            rbus_wb_store;                   
wire            rbus_write_back_cmplt;           
wire    [4 :0]  special_rbus_expt_vec;           
wire            special_rbus_expt_vld;           
wire            special_rbus_flush;              
wire            special_rbus_req;                
wire            special_sel;                     
wire    [4 :0]  wb_rbus_lsu_vec;                 
wire            wb_rbus_st_aft_load;             
wire            wb_xx_acc_err_after_retire;      


//==========================================================
//                   Complete Signals
//==========================================================
assign bctm_rbus_req           = 1'b0;
assign bctm_rbus_flush         = 1'b0;
assign bctm_rbus_wb_vld        = 1'b0;
assign bctm_rbus_wb_data[31:0] = 32'b0;
assign bctm_rbus_wb_reg[4:0]   = 5'b0;
assign lsu_iu_flush            = 1'b0;
assign branch_sel  = ctrl_branch_ex_data_sel;//  && !decd_xx_unit_special_sel;
assign cp0_sel     = ctrl_cp0_ex_data_sel     && !decd_xx_unit_special_sel;
assign special_sel = ctrl_special_ex_data_sel ||  decd_xx_unit_special_sel;
assign lsu_sel     = ctrl_lsu_ex_data_sel     && !decd_xx_unit_special_sel;
//when SMALL MULT, ALU and MAD share the same result bus data path in ALU
assign alu_sel     = (ctrl_alu_ex_data_sel || ctrl_mad_ex_data_sel) && !decd_xx_unit_special_sel;
assign alu_data_sel=  ctrl_alu_ex_data_sel || ctrl_mad_ex_data_sel;
assign mad_sel     = ctrl_mad_ex_data_sel;
assign mad_data_sel= 1'b0;
assign mad_alu_rbus_data[31:0] = 32'b0;

//assign req_bus[6:0] = {bctm_sel, branch_sel, cp0_sel, special_sel,
//                       lsu_sel,  mad_sel,    alu_sel}; 
assign prgsign_rbus_req = 1'b0;
assign prgsign_rbus_secure_violation = 1'b0;
assign rbus_cmplt = alu_rbus_req    || mad_rbus_req 
                 || lsu_iu_req      || special_rbus_req
                 || cp0_iu_req      || branch_rbus_req 
                 || bctm_rbus_req   || prgsign_rbus_req; 

assign rbus_retire_cmplt = rbus_cmplt && !hs_split_iu_hs_retire_mask
                                      && !ifu_iu_ex_int_spcu_mask;

//==========================================================
//                      Result Bus
//==========================================================
//-----------------------------------------------------
//                       Flush
//-----------------------------------------------------
assign rbus_retire_flush = //branch_rbus_req && branch_rbus_flush
                           cp0_iu_req      && cp0_iu_flush
                        || bctm_rbus_req   && bctm_rbus_flush
                        || special_rbus_req && special_rbus_flush
                        || lsu_iu_req      && lsu_iu_flush;


//-----------------------------------------------------
//                  Write back data
//-----------------------------------------------------
//the data sel signal need not to see !special sel
//bcz special unit doesn't have write data
assign rbus_data_sel_branch = ctrl_branch_ex_data_sel 
                           && branch_rbus_data_vld    && !bctm_rbus_wb_vld;
assign rbus_data_sel_cp0    = ctrl_cp0_ex_data_sel    && !bctm_rbus_wb_vld;
assign rbus_data_sel_mad    = mad_data_sel            && !bctm_rbus_wb_vld;
assign rbus_data_sel_alu    = alu_data_sel            && !bctm_rbus_wb_vld;

// &Force("nonport", "rbus_data_sel_branch"); @95
// &Force("nonport", "rbus_data_sel_cp0"); @96
// &Force("nonport", "rbus_data_sel_mad"); @97
// &Force("nonport", "rbus_data_sel_alu"); @98
// &Force("nonport", "rbus_data_sel_lsu"); @99
assign rbus_data_expt_lsu_without_pol[31:0] = 
                                  {32{bctm_rbus_wb_vld}}     & bctm_rbus_wb_data[31:0]
                                | {32{rbus_data_sel_branch}} & branch_rbus_data[31:0]
                                | {32{rbus_data_sel_cp0}}    & cp0_iu_data[31:0]
                                | {32{rbus_data_sel_mad}}    & mad_alu_rbus_data[31:0]
                                | {32{rbus_data_sel_alu}}    & alu_rbus_data[31:0];
assign rbus_data[31:0] = {32{!rbus_data_sel_lsu}} & rbus_data_expt_lsu[31:0]
                       | {32{rbus_data_sel_lsu}}  & lsu_iu_data[31:0];

assign rbus_data_expt_lsu[31:0] = rbus_data_expt_lsu_without_pol[31:0];

assign rbus_data_sel_lsu = (ctrl_lsu_ex_data_sel || wb_rbus_st_aft_load)
                           && !bctm_rbus_wb_vld && !ctrl_xx_sp_adjust;



//-----------------------------------------------------
//         Other write back signals and exception
//-----------------------------------------------------
//special and bctm have no data vld
assign rbus_retire_data_vld = alu_sel    && alu_rbus_data_vld
                           || mad_sel    && mad_alu_data_vld
                           || lsu_sel    && lsu_iu_data_vld
                           || cp0_sel    && cp0_iu_data_vld
                           || branch_sel && branch_rbus_data_vld;
                            
//alu mad branch bctm have no expt info
assign rbus_retire_expt_vld_pre = lsu_sel     && lsu_iu_expt_vld
                               || special_sel && special_rbus_expt_vld
                               || cp0_sel     && cp0_iu_expt_vld;

assign rbus_retire_expt_vec_pre[4:0] = {5{lsu_sel}}     & lsu_iu_expt_vec[4:0]
                                     | {5{special_sel}} & special_rbus_expt_vec[4:0]
                                     | {5{cp0_sel}}     & cp0_iu_expt_vec[4:0];

//when the fast retired ls st come back with acc_err
assign rbus_retire_expt_vld = rbus_retire_expt_vld_pre || wb_xx_acc_err_after_retire
                              || prgsign_rbus_secure_violation;
assign rbus_retire_expt_vec_aft_prgsign[4:0] = prgsign_rbus_secure_violation
                                                ? 5'b01000
                                                : rbus_retire_expt_vec_pre[4:0];
assign rbus_retire_expt_vec[4:0] = wb_xx_acc_err_after_retire
                                        ? wb_rbus_lsu_vec[4:0]
                                        : rbus_retire_expt_vec_aft_prgsign[4:0];

//-----------------------------------------------------
//        Destination register index and other
//-----------------------------------------------------
assign rbus_retire_split_inst   = mad_ctrl_stall;

//==========================================================
//            Complete and write back signals
//                 for Write back buffer
//==========================================================
//-----------------------------------------------------
//                Write back data and index
//-----------------------------------------------------
//the next cycle after retire of check failed instruction,
//bctm need to borrow write back data path to write next pc
//into link register
assign rbus_wb_dst_reg[4:0]        = (bctm_rbus_wb_vld)
                                     ? bctm_rbus_wb_reg[4:0]
                                     : ifu_iu_ex_rd_reg[4:0];

assign rbus_wb_data[31:0]          =  rbus_data[31:0];

//-----------------------------------------------------
//           Complete/Write back valid signals
//-----------------------------------------------------
//signal for write back buffer
//the complete write instructions include complete load and
//other instruction needs to write back to GPR
assign rbus_write_back_cmplt = rbus_cmplt && rbus_retire_data_vld;
                                         // && !lsu_iu_fast_retire;
//the uncomplete load and store
assign rbus_wb_load          = !lsu_iu_store
                                          && lsu_iu_fast_retire;
assign rbus_wb_store         = lsu_iu_store
                                          && lsu_iu_fast_retire;

//the next cycle after retire of check failed instruction,
//bctm need to borrow write back data path to write next pc
//into link register
assign rbus_wb_cmplt         = rbus_write_back_cmplt || bctm_rbus_wb_vld;
assign rbus_wb_inst_cmplt    = rbus_cmplt;

// &ModuleEnd; @225
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @30
module cr_iu_retire(
  clic_cpu_int_hv,
  clic_cpu_int_id,
  clic_cpu_int_il,
  clic_cpu_int_priv,
  clint_cpu_me_int,
  cp0_iu_dbg_disable_for_tee,
  cp0_iu_il,
  cp0_iu_in_nmi,
  cp0_iu_inst_mret,
  cp0_iu_meie,
  cp0_iu_mie_for_int,
  cp0_iu_vec_mode,
  cp0_iu_wfe_en,
  cp0_yy_clk_en,
  cp0_yy_priv_mode,
  cpurst_b,
  ctrl_branch_ex_sel,
  ctrl_retire_ni_vld,
  decd_retire_cp0_inst,
  decd_retire_inst_mret,
  forever_cpuclk,
  had_core_dbg_mode_req,
  had_iu_bkpt_trace_en,
  had_iu_dr_set_req,
  had_iu_force_dbg_en,
  had_iu_int_vld,
  had_iu_mbkpt_fsm_index_mbee,
  had_iu_mem_bkpt_exp_req,
  had_iu_mem_bkpt_mask,
  had_iu_mem_bkpt_req,
  had_iu_rte_pc_sel,
  had_iu_trace_req,
  had_iu_trace_req_for_dbg_disable,
  had_iu_xx_fdb,
  had_iu_xx_jdbreq,
  had_yy_xx_exit_dbg,
  hs_split_iu_hs_retire_mask,
  hs_split_iu_hs_switch_se,
  ifu_iu_ex_inst_dbg_disable,
  ifu_iu_ex_sp_oper,
  ifu_iu_ex_split_on,
  ifu_iu_ibus_idle,
  ifu_iu_inst_bkpt_dbg_occur_vld,
  ifu_iu_inst_bkpt_dbgexp_occur_vld,
  ifu_iu_inst_buf_inst_dbg_disable,
  ifu_iu_inst_buf_inst_vld,
  iu_cp0_epc,
  iu_cp0_epc_update,
  iu_cp0_expt_vld,
  iu_cp0_int_vld,
  iu_cp0_lp_wk_int,
  iu_cp0_mtval_updt_vld,
  iu_cp0_nmi_vld,
  iu_cp0_nt_int_pending_vld,
  iu_had_adr_dbg_ack,
  iu_had_data_bkpt_occur_vld,
  iu_had_dbg_disable_for_tee,
  iu_had_dr_dbg_ack,
  iu_had_expt_vld,
  iu_had_fast_retire_acc_err_pc_update,
  iu_had_fast_retire_acc_err_pc_val,
  iu_had_inst_bkpt_occur_vld,
  iu_had_int_ack,
  iu_had_retire_with_had_int,
  iu_had_trace_occur_vld,
  iu_had_xx_bkpt_inst,
  iu_had_xx_dbg_ack,
  iu_had_xx_mldst,
  iu_had_xx_retire,
  iu_had_xx_retire_normal,
  iu_had_xx_retire_pc,
  iu_ifu_kill_inst,
  iu_ifu_spcu_int_en,
  iu_pad_inst_retire,
  iu_pad_inst_split,
  iu_pad_retire_pc,
  iu_sys_lp_wk_int,
  iu_yy_xx_dbgon,
  iu_yy_xx_expt_vec,
  iu_yy_xx_flush,
  iu_yy_xx_int_hv,
  iu_yy_xx_int_il,
  iu_yy_xx_int_pending_hv,
  iu_yy_xx_int_pending_id,
  iu_yy_xx_int_pending_il,
  iu_yy_xx_int_pending_priv,
  iu_yy_xx_reg_rst_b,
  iu_yy_xx_retire,
  lockup_retire_dbg_vld,
  lockup_retire_mask,
  lockup_retire_nmi_vld,
  lsu_iu_wb_acc_err,
  lsu_iu_wb_cmplt,
  nie_flush_chgflw,
  pad_yy_gate_clk_en_b,
  pcgen_retire_updt_pc,
  pcgen_xx_cur_pc,
  randclk_retire_mod_en_w2,
  rbus_retire_cmplt,
  rbus_retire_expt_vec,
  rbus_retire_expt_vld,
  rbus_retire_flush,
  rbus_retire_split_inst,
  rbus_wb_load,
  rbus_wb_store,
  retire_branch_stall,
  retire_lockup_dbg_on,
  retire_lockup_dbg_vld,
  retire_lockup_expt_vld,
  retire_lockup_inst_retire,
  retire_lockup_nmi_vld,
  retire_lockup_retire_pc,
  retire_mad_ex_cancel,
  retire_pcgen_curpc_update,
  retire_vector_expt_int_hv,
  retire_vector_expt_vld,
  retire_wb_dbg_in_ack,
  retire_wb_hs_err_epc_sel,
  retire_wb_mem_bkpt_fast_retire,
  retire_xx_normal_retire,
  special_retire_inst_wsc,
  sysio_iu_nmi_int,
  sysio_iu_wk_event,
  wb_retire_fast_retire_load_pc,
  wb_xx_acc_err_after_retire,
  wb_xx_lsu_check_fail_after_retire
);

// &Ports; @31
input           clic_cpu_int_hv;                     
input   [11:0]  clic_cpu_int_id;                     
input   [7 :0]  clic_cpu_int_il;                     
input   [1 :0]  clic_cpu_int_priv;                   
input           clint_cpu_me_int;                    
input           cp0_iu_dbg_disable_for_tee;          
input   [7 :0]  cp0_iu_il;                           
input           cp0_iu_in_nmi;                       
input           cp0_iu_inst_mret;                    
input           cp0_iu_meie;                         
input           cp0_iu_mie_for_int;                  
input   [1 :0]  cp0_iu_vec_mode;                     
input           cp0_iu_wfe_en;                       
input           cp0_yy_clk_en;                       
input   [1 :0]  cp0_yy_priv_mode;                    
input           cpurst_b;                            
input           ctrl_branch_ex_sel;                  
input           ctrl_retire_ni_vld;                  
input           decd_retire_cp0_inst;                
input           decd_retire_inst_mret;               
input           forever_cpuclk;                      
input           had_core_dbg_mode_req;               
input           had_iu_bkpt_trace_en;                
input           had_iu_dr_set_req;                   
input           had_iu_force_dbg_en;                 
input           had_iu_int_vld;                      
input           had_iu_mbkpt_fsm_index_mbee;         
input           had_iu_mem_bkpt_exp_req;             
input           had_iu_mem_bkpt_mask;                
input           had_iu_mem_bkpt_req;                 
input           had_iu_rte_pc_sel;                   
input           had_iu_trace_req;                    
input           had_iu_trace_req_for_dbg_disable;    
input           had_iu_xx_fdb;                       
input           had_iu_xx_jdbreq;                    
input           had_yy_xx_exit_dbg;                  
input           hs_split_iu_hs_retire_mask;          
input           hs_split_iu_hs_switch_se;            
input           ifu_iu_ex_inst_dbg_disable;          
input           ifu_iu_ex_sp_oper;                   
input           ifu_iu_ex_split_on;                  
input           ifu_iu_ibus_idle;                    
input           ifu_iu_inst_bkpt_dbg_occur_vld;      
input           ifu_iu_inst_bkpt_dbgexp_occur_vld;   
input           ifu_iu_inst_buf_inst_dbg_disable;    
input           ifu_iu_inst_buf_inst_vld;            
input           iu_yy_xx_reg_rst_b;                  
input           lockup_retire_dbg_vld;               
input           lockup_retire_mask;                  
input           lockup_retire_nmi_vld;               
input           lsu_iu_wb_acc_err;                   
input           lsu_iu_wb_cmplt;                     
input           pad_yy_gate_clk_en_b;                
input   [30:0]  pcgen_retire_updt_pc;                
input   [30:0]  pcgen_xx_cur_pc;                     
input           randclk_retire_mod_en_w2;            
input           rbus_retire_cmplt;                   
input   [4 :0]  rbus_retire_expt_vec;                
input           rbus_retire_expt_vld;                
input           rbus_retire_flush;                   
input           rbus_retire_split_inst;              
input           rbus_wb_load;                        
input           rbus_wb_store;                       
input           special_retire_inst_wsc;             
input           sysio_iu_nmi_int;                    
input           sysio_iu_wk_event;                   
input   [30:0]  wb_retire_fast_retire_load_pc;       
input           wb_xx_acc_err_after_retire;          
input           wb_xx_lsu_check_fail_after_retire;   
output  [30:0]  iu_cp0_epc;                          
output          iu_cp0_epc_update;                   
output          iu_cp0_expt_vld;                     
output          iu_cp0_int_vld;                      
output          iu_cp0_lp_wk_int;                    
output          iu_cp0_mtval_updt_vld;               
output          iu_cp0_nmi_vld;                      
output          iu_cp0_nt_int_pending_vld;           
output          iu_had_adr_dbg_ack;                  
output          iu_had_data_bkpt_occur_vld;          
output          iu_had_dbg_disable_for_tee;          
output          iu_had_dr_dbg_ack;                   
output          iu_had_expt_vld;                     
output          iu_had_fast_retire_acc_err_pc_update; 
output  [30:0]  iu_had_fast_retire_acc_err_pc_val;   
output          iu_had_inst_bkpt_occur_vld;          
output          iu_had_int_ack;                      
output          iu_had_retire_with_had_int;          
output          iu_had_trace_occur_vld;              
output          iu_had_xx_bkpt_inst;                 
output          iu_had_xx_dbg_ack;                   
output          iu_had_xx_mldst;                     
output          iu_had_xx_retire;                    
output          iu_had_xx_retire_normal;             
output  [31:0]  iu_had_xx_retire_pc;                 
output          iu_ifu_kill_inst;                    
output          iu_ifu_spcu_int_en;                  
output          iu_pad_inst_retire;                  
output          iu_pad_inst_split;                   
output  [31:0]  iu_pad_retire_pc;                    
output          iu_sys_lp_wk_int;                    
output          iu_yy_xx_dbgon;                      
output  [9 :0]  iu_yy_xx_expt_vec;                   
output          iu_yy_xx_flush;                      
output          iu_yy_xx_int_hv;                     
output  [7 :0]  iu_yy_xx_int_il;                     
output          iu_yy_xx_int_pending_hv;             
output  [9 :0]  iu_yy_xx_int_pending_id;             
output  [7 :0]  iu_yy_xx_int_pending_il;             
output  [1 :0]  iu_yy_xx_int_pending_priv;           
output          iu_yy_xx_retire;                     
output          nie_flush_chgflw;                    
output          retire_branch_stall;                 
output          retire_lockup_dbg_on;                
output          retire_lockup_dbg_vld;               
output          retire_lockup_expt_vld;              
output          retire_lockup_inst_retire;           
output          retire_lockup_nmi_vld;               
output  [31:0]  retire_lockup_retire_pc;             
output          retire_mad_ex_cancel;                
output          retire_pcgen_curpc_update;           
output          retire_vector_expt_int_hv;           
output          retire_vector_expt_vld;              
output          retire_wb_dbg_in_ack;                
output          retire_wb_hs_err_epc_sel;            
output          retire_wb_mem_bkpt_fast_retire;      
output          retire_xx_normal_retire;             

// &Regs; @32
reg             bkpt_cur_state;                      
reg             bkpt_next_state;                     
reg     [1 :0]  br_cur_state;                        
reg     [1 :0]  br_next_state;                       
reg             cpu_nmi_int_f;                       
reg             cpu_wk_event_f1;                     
reg             cpu_wk_event_f2;                     
reg             dbg_mode_on;                         
reg             dbgreq_ack_ff;                       
reg     [9 :0]  expt_vec;                            
reg             retire_ack_expt;                     
reg             retire_ack_int;                      
reg             retire_nmi_int_req_raw;              
reg             retire_with_ack_dbg;                 
reg             retire_with_ack_int;                 
reg             trace_cur_state;                     
reg             trace_next_state;                    
reg             wb_split_inst;                       

// &Wires; @33
wire            bctm_retire_epc_updt_vld;            
wire            bctm_retire_had_pc_updt_vld;         
wire            bkpt_fsm_trigger;                    
wire            clic_cpu_int_hv;                     
wire    [11:0]  clic_cpu_int_id;                     
wire    [7 :0]  clic_cpu_int_il;                     
wire    [1 :0]  clic_cpu_int_priv;                   
wire            clic_int_pending_vld;                
wire            clic_lp_wk_int;                      
wire            clic_pending_int_need_ack;           
wire            clint_cpu_me_int;                    
wire            clint_lp_wk_int;                     
wire            cp0_iu_dbg_disable_for_tee;          
wire            cp0_iu_ee;                           
wire            cp0_iu_ic;                           
wire    [7 :0]  cp0_iu_il;                           
wire            cp0_iu_in_nmi;                       
wire            cp0_iu_inst_mret;                    
wire            cp0_iu_int_spcu_en;                  
wire            cp0_iu_meie;                         
wire            cp0_iu_mie_for_int;                  
wire    [1 :0]  cp0_iu_vec_mode;                     
wire            cp0_iu_wfe_en;                       
wire            cp0_yy_clk_en;                       
wire    [1 :0]  cp0_yy_priv_mode;                    
wire            cpu_ext_int;                         
wire            cpu_int_vld;                         
wire            cpurst_b;                            
wire            ctrl_branch_ex_sel;                  
wire            ctrl_retire_ni_vld;                  
wire            dbg_clk;                             
wire            dbg_clk_en;                          
wire            dbgreq_ack;                          
wire            dbgreq_ack_aft_force;                
wire            decd_retire_cp0_inst;                
wire            decd_retire_inst_mret;               
wire            epc_update_after_retire;             
wire            ex_inst_dbg_disable;                 
wire    [30:0]  fast_retire_acc_err_epc;             
wire            flop_cpuclk;                         
wire            flop_cpuclk_en;                      
wire            forever_cpuclk;                      
wire            had_core_dbg_mode_req;               
wire            had_iu_bkpt_trace_en;                
wire            had_iu_dr_set_req;                   
wire            had_iu_force_dbg_en;                 
wire            had_iu_int_vld;                      
wire            had_iu_mbkpt_fsm_index_mbee;         
wire            had_iu_mem_bkpt_exp_req;             
wire            had_iu_mem_bkpt_mask;                
wire            had_iu_mem_bkpt_req;                 
wire            had_iu_rte_pc_sel;                   
wire            had_iu_trace_req;                    
wire            had_iu_trace_req_for_dbg_disable;    
wire            had_iu_xx_fdb;                       
wire            had_iu_xx_jdbreq;                    
wire            had_yy_xx_exit_dbg;                  
wire            hadpc_update_after_retire;           
wire            hs_split_iu_hs_retire_mask;          
wire            hs_split_iu_hs_switch_se;            
wire            ifu_iu_ex_inst_dbg_disable;          
wire            ifu_iu_ex_sp_oper;                   
wire            ifu_iu_ex_split_on;                  
wire            ifu_iu_ibus_idle;                    
wire            ifu_iu_inst_bkpt_dbg_occur_vld;      
wire            ifu_iu_inst_bkpt_dbgexp_occur_vld;   
wire            ifu_iu_inst_buf_inst_dbg_disable;    
wire            ifu_iu_inst_buf_inst_vld;            
wire            inst_dbg_disable;                    
wire            int_enable_with_ee_ie;               
wire            int_ic_aft_sec_sel;                  
wire            intc_cpu_int_vld;                    
wire    [30:0]  iu_cp0_epc;                          
wire            iu_cp0_epc_update;                   
wire            iu_cp0_expt_vld;                     
wire            iu_cp0_int_vld;                      
wire            iu_cp0_lp_wk_int;                    
wire            iu_cp0_mtval_updt_vld;               
wire            iu_cp0_nmi_vld;                      
wire            iu_cp0_nt_int_pending_vld;           
wire            iu_had_adr_dbg_ack;                  
wire            iu_had_data_bkpt_occur_vld;          
wire            iu_had_dbg_disable_for_tee;          
wire            iu_had_dr_dbg_ack;                   
wire            iu_had_expt_vld;                     
wire            iu_had_fast_retire_acc_err_pc_update; 
wire    [30:0]  iu_had_fast_retire_acc_err_pc_val;   
wire            iu_had_inst_bkpt_occur_vld;          
wire            iu_had_int_ack;                      
wire            iu_had_retire_with_had_int;          
wire            iu_had_trace_occur_vld;              
wire            iu_had_xx_bkpt_inst;                 
wire            iu_had_xx_dbg_ack;                   
wire            iu_had_xx_mldst;                     
wire            iu_had_xx_retire;                    
wire            iu_had_xx_retire_normal;             
wire    [31:0]  iu_had_xx_retire_pc;                 
wire            iu_ifu_kill_inst;                    
wire            iu_ifu_spcu_int_en;                  
wire            iu_pad_inst_retire;                  
wire            iu_pad_inst_split;                   
wire    [31:0]  iu_pad_retire_pc;                    
wire            iu_sys_lp_wk_int;                    
wire            iu_yy_xx_dbgon;                      
wire    [9 :0]  iu_yy_xx_expt_vec;                   
wire            iu_yy_xx_flush;                      
wire            iu_yy_xx_int_hv;                     
wire    [7 :0]  iu_yy_xx_int_il;                     
wire            iu_yy_xx_int_pending_hv;             
wire    [9 :0]  iu_yy_xx_int_pending_id;             
wire    [7 :0]  iu_yy_xx_int_pending_il;             
wire    [1 :0]  iu_yy_xx_int_pending_priv;           
wire            iu_yy_xx_reg_rst_b;                  
wire            iu_yy_xx_retire;                     
wire            load_store_fast_retire;              
wire            lockup_retire_dbg_vld;               
wire            lockup_retire_mask;                  
wire            lockup_retire_nmi_vld;               
wire            lsu_iu_wb_acc_err;                   
wire            lsu_iu_wb_cmplt;                     
wire            nie_flush;                           
wire            nie_flush_chgflw;                    
wire            pad_yy_gate_clk_en_b;                
wire    [30:0]  pcgen_retire_updt_pc;                
wire    [30:0]  pcgen_xx_cur_pc;                     
wire            randclk_retire_mod_en_w2;            
wire            rbus_flush;                          
wire            rbus_retire_cmplt;                   
wire    [4 :0]  rbus_retire_expt_vec;                
wire            rbus_retire_expt_vld;                
wire            rbus_retire_flush;                   
wire            rbus_retire_split_inst;              
wire            rbus_wb_load;                        
wire            rbus_wb_store;                       
wire            retire_ack_bkpt;                     
wire            retire_ack_dr_set_req;               
wire            retire_ack_expt_vld;                 
wire            retire_ack_int_vld;                  
wire            retire_ack_jdbreq;                   
wire            retire_ack_mem_bkpt_fast_retire;     
wire            retire_ack_mem_bkpt_req;             
wire            retire_ack_mem_bkpt_vld;             
wire            retire_ack_mem_bkpt_vld_idle;        
wire            retire_ack_trace_fast_retire;        
wire            retire_ack_trace_req;                
wire            retire_ack_trace_vld;                
wire            retire_ack_trace_vld_idle;           
wire            retire_branch_dbg_idle;              
wire            retire_branch_stall;                 
wire            retire_dbg_disable;                  
wire            retire_dbg_disable_pre;              
wire            retire_dbg_expt;                     
wire            retire_dbg_mask;                     
wire    [30:0]  retire_epc_or_hadpc;                 
wire            retire_expt_int_vld;                 
wire            retire_expt_vld;                     
wire            retire_hs_acc_err;                   
wire            retire_hs_err_epc_sel;               
wire            retire_in_nmi;                       
wire            retire_inst_expt;                    
wire            retire_int;                          
wire            retire_int_mask_from_had;            
wire            retire_int_vld;                      
wire            retire_lockup_dbg_on;                
wire            retire_lockup_dbg_vld;               
wire            retire_lockup_expt_vld;              
wire            retire_lockup_inst_retire;           
wire            retire_lockup_nmi_vld;               
wire    [31:0]  retire_lockup_retire_pc;             
wire            retire_mad_ex_cancel;                
wire            retire_nmi_int_raw;                  
wire            retire_nmi_int_req;                  
wire            retire_nmi_int_vld;                  
wire            retire_pc_expt_vld;                  
wire            retire_pcgen_curpc_update;           
wire            retire_split_inst_no_dbg;            
wire            retire_split_inst_no_dbg_for_pad;    
wire            retire_split_inst_with_dbg_ack;      
wire            retire_vector_expt_int_hv;           
wire            retire_vector_expt_vld;              
wire            retire_wakeup_event_vld;             
wire            retire_wb_dbg_in_ack;                
wire            retire_wb_hs_err_epc_sel;            
wire            retire_wb_mem_bkpt_fast_retire;      
wire            retire_with_ack_had_int;             
wire            retire_with_ack_vic_int;             
wire            retire_xx_normal_retire;             
wire            sec_retire_flush;                    
wire            soft_reset_vld;                      
wire            special_retire_inst_wsc;             
wire            sysio_iu_nmi_int;                    
wire            sysio_iu_wk_event;                   
wire            wb_dbg_exp_after_retire;             
wire    [30:0]  wb_retire_fast_retire_load_pc;       
wire            wb_split_inst_clk_en;                
wire            wb_xx_acc_err_after_retire;          
wire            wb_xx_lsu_check_fail_after_retire;   


// for old csky wires
assign cp0_iu_ee = 1'b1;
assign cp0_iu_int_spcu_en = 1'b0;
//assign cp0_iu_intsp_we = 1'b0;

//==========================================================
//                 Instance of Gated Cell  
//==========================================================
assign dbg_clk_en = dbgreq_ack_aft_force || dbg_mode_on || dbgreq_ack_ff
                 || retire_int_vld
                 || retire_with_ack_int || retire_with_ack_dbg
                 || wb_split_inst_clk_en
                 || had_iu_mem_bkpt_req || had_iu_trace_req
                 || had_iu_trace_req_for_dbg_disable
                 || retire_wb_dbg_in_ack || had_iu_mem_bkpt_exp_req;
// &Instance("gated_clk_cell", "x_dbg_gated_clk"); @51
gated_clk_cell  x_dbg_gated_clk (
  .clk_in                   (forever_cpuclk          ),
  .clk_out                  (dbg_clk                 ),
  .external_en              (1'b0                    ),
  .global_en                (cp0_yy_clk_en           ),
  .local_en                 (dbg_clk_en              ),
  .module_en                (randclk_retire_mod_en_w2),
  .pad_yy_gate_clk_en_b     (pad_yy_gate_clk_en_b    )
);

// &Connect(.clk_in      (forever_cpuclk), @52
//          .external_en (1'b0), @53
//          .global_en   (cp0_yy_clk_en), @54
//          .module_en   (randclk_retire_mod_en_w2), @55
//          .local_en    (dbg_clk_en), @56
//          .clk_out     (dbg_clk)); @57
// &Instance("gated_clk_cell", "x_dbg_gated_clk"); @60
// &Connect(.clk_in      (forever_cpuclk), @61
//          .external_en (1'b0), @62
//          .global_en   (cp0_yy_clk_en), @63
//          .module_en   (randclk_retire_mod_en_w2), @64
//          .local_en    (dbg_clk_en), @65
//          .clk_out     (dbg_clk)); @66
// &Instance("gated_clk_cell", "x_dbg_gated_clk"); @69
// &Connect(.clk_in      (forever_cpuclk), @70
//          .external_en (1'b0), @71
//          .global_en   (cp0_yy_clk_en), @72
//          .module_en   (randclk_retire_mod_en_w2), @73
//          .local_en    (dbg_clk_en), @74
//          .clk_out     (dbg_clk)); @75
// &Force("nonport","dbg_clk_en"); @77
// &Force("input","randclk_retire_mod_en_w2"); @78


//==============================================================================
// Instruction retire and result write back
//==============================================================================
// &Force("output","iu_yy_xx_retire"); @87
assign iu_yy_xx_retire      = rbus_retire_cmplt;

//==============================================================================
// 1. Synchronous/asynchronous interrupt process
// 2. Exception Handle
//==============================================================================
// &Force("bus", "clic_cpu_int_id", 11, 0); @94
// &Force("nonport","iu_yy_xx_int_pending_hv"); @106
// &Force("nonport","iu_yy_xx_int_pending_id"); @107
// &Force("nonport","iu_yy_xx_int_pending_il"); @108
// &Force("nonport","iu_yy_xx_int_pending_priv"); @109
// &Force("nonport","iu_yy_xx_int_hv"); @110
// &Force("nonport","iu_yy_xx_int_il"); @111
//============================
// external interrput flop
//============================
assign cpu_ext_int = clint_cpu_me_int;


assign flop_cpuclk_en = cpu_nmi_int_f ^ sysio_iu_nmi_int
                     || cpu_wk_event_f1 ^ sysio_iu_wk_event
                     || cpu_wk_event_f2 ^ cpu_wk_event_f1
                     || retire_nmi_int_raw
                     || retire_nmi_int_vld;
// &Instance("gated_clk_cell", "x_flop_cpuclk"); @137
gated_clk_cell  x_flop_cpuclk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (flop_cpuclk         ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (flop_cpuclk_en      ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk), @138
//          .external_en (1'b0), @139
//          .global_en   (1'b1), @140
//          .module_en   (1'b0), @141
//          .local_en    (flop_cpuclk_en), @142
//          .clk_out     (flop_cpuclk)); @143

always @ (posedge flop_cpuclk or negedge cpurst_b)
begin
  if (!cpurst_b) begin
    cpu_nmi_int_f   <= 1'b0;
    cpu_wk_event_f1 <= 1'b0;
    cpu_wk_event_f2 <= 1'b0;
  end
  else begin
    cpu_nmi_int_f  <= sysio_iu_nmi_int;
    cpu_wk_event_f1 <= sysio_iu_wk_event;
    cpu_wk_event_f2 <= cpu_wk_event_f1;
  end
end
assign retire_nmi_int_raw = !cpu_nmi_int_f && sysio_iu_nmi_int;
assign retire_wakeup_event_vld = !cpu_wk_event_f2 && cpu_wk_event_f1;

always @ (posedge flop_cpuclk or negedge cpurst_b)
begin
  if (!cpurst_b)
    retire_nmi_int_req_raw <= 1'b0;
  else if (retire_nmi_int_raw)
    retire_nmi_int_req_raw <= retire_nmi_int_raw;
  else if (retire_nmi_int_vld)
    retire_nmi_int_req_raw <= 1'b0;
  else
    retire_nmi_int_req_raw <= retire_nmi_int_req_raw;
end

assign retire_in_nmi = cp0_iu_in_nmi && !cp0_iu_inst_mret;
assign retire_nmi_int_req = retire_nmi_int_req_raw && !retire_in_nmi;
assign retire_nmi_int_vld = retire_int_vld && retire_nmi_int_req;
assign retire_lockup_nmi_vld = retire_nmi_int_req;
assign retire_lockup_inst_retire = iu_yy_xx_retire;
assign retire_lockup_dbg_on = dbg_mode_on;
assign retire_lockup_retire_pc[31:0] = {pcgen_xx_cur_pc[30:0],1'b0};

assign cpu_int_vld = (cp0_iu_vec_mode[1] ? clic_pending_int_need_ack : intc_cpu_int_vld && (int_enable_with_ee_ie))
                  || retire_nmi_int_req;
assign clic_pending_int_need_ack = clic_int_pending_vld && 
                                   (
                                   (int_enable_with_ee_ie && 
                                   (clic_cpu_int_il[7:0] > cp0_iu_il[7:0])));
assign clic_int_pending_vld      = |clic_cpu_int_il[7:0];
assign clint_lp_wk_int                = cpu_ext_int && cp0_iu_meie;
assign iu_cp0_nt_int_pending_vld      = cpu_ext_int;

assign iu_yy_xx_int_pending_priv[1:0] = clic_cpu_int_priv[1:0];
assign iu_yy_xx_int_pending_hv        = clic_cpu_int_hv;
assign iu_yy_xx_int_pending_il[7:0]   = clic_cpu_int_il[7:0];
assign iu_yy_xx_int_pending_id[9:0]   = clic_cpu_int_id[9:0];
assign iu_yy_xx_int_il[7:0]           = clic_cpu_int_il[7:0];
assign iu_yy_xx_int_hv                = clic_cpu_int_hv;
assign iu_cp0_lp_wk_int               = (cp0_iu_vec_mode[1] ? clic_lp_wk_int : clint_lp_wk_int)
                                      || retire_nmi_int_req
                                      || cp0_iu_wfe_en && retire_wakeup_event_vld;
assign iu_sys_lp_wk_int               = iu_cp0_lp_wk_int;
// &Force("output","iu_cp0_lp_wk_int"); @216
assign clic_lp_wk_int                 = clic_int_pending_vld && 
                                   ((clic_cpu_int_priv[1:0] > cp0_yy_priv_mode[1:0]) || 
                                   (clic_cpu_int_il[7:0] > cp0_iu_il[7:0]) ||
                                   cp0_iu_wfe_en);


assign int_enable_with_ee_ie = cp0_iu_mie_for_int;
assign intc_cpu_int_vld      = cpu_ext_int && cp0_iu_meie;
assign int_ic_aft_sec_sel = cp0_iu_ic;
assign cp0_iu_ic = 1'b0;
assign retire_int = (cpu_int_vld && !had_iu_int_vld
                  || had_iu_int_vld
                       && !decd_retire_cp0_inst
                    )
                && !retire_in_nmi
                && !special_retire_inst_wsc
                && !decd_retire_inst_mret
                && !had_iu_rte_pc_sel
                && !(ctrl_retire_ni_vld || wb_xx_acc_err_after_retire)
                && (  !int_ic_aft_sec_sel && !rbus_retire_split_inst 
                    || int_ic_aft_sec_sel);
//the auto vector is always set to 1
//assign int_vec[7:0]  = had_iu_int_vld ? 8'b00001101 : ~intc_cpu_vec_b[7:0];

//assign retire_srst_misalign_expt =  cp0_iu_ee
//                                 && rbus_retire_expt_vld
//                                 && (rbus_retire_expt_vec[4:1] == 4'b0000);
//assign retire_srst_misalign_expt = 1'b0;
assign retire_inst_expt     =  rbus_retire_expt_vld;

// &Instance("gated_clk_cell", "x_dp_gated_clk"); @269
// &Connect(.clk_in      (forever_cpuclk), @270
//          .external_en (1'b0), @271
//          .global_en   (cp0_yy_clk_en), @272
//          .module_en   (1'b0), @273
//          .local_en    (dp_clk_en), @274
//          .clk_out     (dp_cpuclk)); @275
// &Force("output","iu_had_dp_mbkpt_index"); @373
assign retire_dbg_expt = 1'b0;
//assign retire_dbg_inst_expt = 1'b0;
assign iu_ifu_kill_inst = 1'b0;

// &CombBeg; @392
always @( rbus_retire_expt_vec[4:0]
       or retire_dbg_expt
       or retire_int
       or retire_inst_expt
       or had_iu_int_vld
       or cp0_iu_vec_mode[1]
       or clic_cpu_int_id[9:0])
begin
  expt_vec[9:0]   = 10'b0;
  retire_ack_expt = 1'b0;
  retire_ack_int  = 1'b0;
  if(retire_dbg_expt)
  begin
    retire_ack_expt = 1'b1;
    expt_vec[9:0] = {7'b0,3'b11};
  end
  else if(retire_int)
  begin
    retire_ack_int  = 1'b1;
    expt_vec[9:0]   =  had_iu_int_vld ? {6'b0,4'b1101} : cp0_iu_vec_mode[1] ? clic_cpu_int_id[9:0] : {6'b0,4'b1011};
  end
  else if(retire_inst_expt)
  begin
    retire_ack_expt = 1'b1;
    expt_vec[9:0] = {5'b0,rbus_retire_expt_vec[4:0]};
  end
// &CombEnd; @411
end

// &Force("output","iu_yy_xx_hs_acc_err"); @416
assign retire_hs_acc_err = 1'b0;

//the expt valid need to be asserted when acc_err happen after retire
assign retire_ack_expt_vld = (retire_ack_expt && iu_yy_xx_retire)
                          || (wb_xx_acc_err_after_retire
                              && !retire_with_ack_int)
                          || wb_dbg_exp_after_retire && cp0_iu_ee;

assign retire_ack_int_vld  = retire_ack_int && iu_yy_xx_retire
                          || lockup_retire_nmi_vld;

assign retire_expt_vld = retire_ack_expt_vld && (!dbg_mode_on || soft_reset_vld)
                      && !dbgreq_ack_aft_force;

//when mem bkpt or trace req, the dbg ack may be not with retire, so the int
//when retire need to be masked
assign retire_int_mask_from_had = had_iu_mem_bkpt_mask || had_iu_trace_req;
assign retire_int_vld  = retire_ack_int_vld  && !dbg_mode_on && !dbgreq_ack_aft_force
                         && !retire_int_mask_from_had;

assign iu_yy_xx_expt_vec[9:0] = retire_hs_acc_err ? {5'b0,rbus_retire_expt_vec[4:0]}: expt_vec[9:0];

assign retire_expt_int_vld = retire_expt_vld || retire_int_vld;

//assign retire_split_inst   = rbus_retire_split_inst && !retire_expt_int_vld;

assign retire_split_inst_no_dbg = rbus_retire_split_inst
                                  && !(iu_yy_xx_retire && retire_int);

//the split inst to pad need to be 0 when dbg ack, so the retite signal is
//valid
assign retire_split_inst_no_dbg_for_pad = rbus_retire_split_inst
                                          && !(retire_ack_expt_vld || retire_ack_int_vld);
assign retire_split_inst_with_dbg_ack = retire_split_inst_no_dbg_for_pad && !dbgreq_ack_aft_force;

//the exception and interrupt valid signal for pc update:
//when entering into debug mode, these logic should see exception valid
//if the instruction gets exception itself when interruption, the pc should
//update as exception way
assign retire_pc_expt_vld = retire_inst_expt && !dbg_mode_on;
//assign retire_pc_int_vld  = (retire_ack_int && !retire_inst_expt) && !dbg_mode_on;

//rename for output
// &Force("output","iu_cp0_expt_vld"); @462
assign iu_cp0_expt_vld             = retire_expt_int_vld;
assign iu_cp0_mtval_updt_vld       = retire_expt_int_vld && !special_retire_inst_wsc && !retire_nmi_int_vld
                                    || retire_hs_acc_err
                                    ||(iu_yy_xx_retire && ifu_iu_inst_bkpt_dbg_occur_vld)
                                    || retire_ack_mem_bkpt_req 
                                    || retire_ack_mem_bkpt_fast_retire;
assign retire_wb_mem_bkpt_fast_retire = retire_ack_mem_bkpt_fast_retire;
// &Force("output","iu_cp0_ntint_vld"); @471

assign iu_cp0_int_vld              = retire_int_vld && !retire_nmi_int_req;
assign iu_cp0_nmi_vld              = retire_nmi_int_vld;
//assign iu_cp0_int_num[7:0]         = int_vec[7:0];
assign iu_ifu_spcu_int_en          = retire_int_vld && !had_iu_bkpt_trace_en
                                     && cp0_iu_int_spcu_en;

//assign retire_pcgen_expt_vld       = retire_pc_expt_vld || retire_pc_int_vld;
//assign retire_pcgen_int_vld        = retire_pc_int_vld;
assign retire_vector_expt_vld      = retire_expt_int_vld && !lockup_retire_mask;
assign retire_vector_expt_int_hv   = retire_ack_int & !retire_nmi_int_vld ?
                                     cp0_iu_vec_mode[1] && clic_cpu_int_hv
                                     : 1'b0;
assign retire_lockup_expt_vld      = retire_expt_vld && expt_vec[3:0] != 4'd11 && expt_vec[3:0] != 4'd3;
assign retire_lockup_dbg_vld       = had_iu_dr_set_req || had_iu_xx_jdbreq;
//assign cpu_intc_int_ack            = retire_int_vld && !had_iu_int_vld;
//assign cpu_intc_ack_vec[7:0]       = ~intc_cpu_vec_b[7:0];

//assign retire_special_ack_expt_vld = retire_ack_expt_vld;
//assign retire_special_clear_cnt_with_ack_dbg = retire_with_ack_dbg 
//                                            && (wb_xx_acc_err_after_retire || wb_dbg_exp_after_retire && cp0_iu_ee);

assign soft_reset_vld              = 1'b0;


//==========================================================
//the retire info with interrupt and dbg ack
//==========================================================
//when LOAD_FAST_RETIRE or BCTM is defined, the retire info 
//needs to be recorded
//when both LOAD_FAST_RETIRE and BCTM are not defined, the
//retire info is set to ZERO
always @(posedge dbg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    retire_with_ack_int <= 1'b0;
  else if(retire_int_vld)
    retire_with_ack_int <= 1'b1;
  else if(iu_yy_xx_retire)
    retire_with_ack_int <= 1'b0;
end

always @(posedge dbg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    retire_with_ack_dbg <= 1'b0;
  else if(dbgreq_ack_aft_force)
    retire_with_ack_dbg <= 1'b1;
  else if(iu_yy_xx_retire)
    retire_with_ack_dbg <= 1'b0;
end

assign retire_with_ack_vic_int = retire_with_ack_int && !had_iu_rte_pc_sel;
assign retire_with_ack_had_int = retire_with_ack_int && had_iu_rte_pc_sel;


//the retire info to BCTM, according to which BCTM decide whether update EPC
//or HAD PC
assign bctm_retire_epc_updt_vld = 1'b0;
assign bctm_retire_had_pc_updt_vld = 1'b0;


//==========================================================
//the EPC updata to CP0
//==========================================================
//the update pc from pcgen is the value been updated into
//current pc, that is, for instruction with exception, it
//is current pc, for interrupt, it is next pc

//when fast acc_err happens, but the ldst which has been fast retired
//get into an interrupt, the expt_vld signal should not be asserted,
//the one thing need to do is updating the right PC into epc, so when
//exit from interrupt, the ldst inst can be fetch and excute again
assign fast_retire_acc_err_epc[30:0] = wb_retire_fast_retire_load_pc[30:0];
assign retire_hs_err_epc_sel         = retire_hs_acc_err && !retire_with_ack_int;
assign retire_wb_hs_err_epc_sel      = retire_hs_err_epc_sel;
assign retire_epc_or_hadpc[30:0] = (wb_xx_acc_err_after_retire 
                                     && !retire_hs_acc_err
                                   || retire_hs_err_epc_sel)
                                      ? fast_retire_acc_err_epc[30:0]
                                      : pcgen_retire_updt_pc[30:0];

assign iu_cp0_epc[30:0] = retire_epc_or_hadpc[30:0];
//when hw stacking, epc does not need to be updt
assign epc_update_after_retire = wb_xx_acc_err_after_retire && retire_with_ack_vic_int
                              || bctm_retire_epc_updt_vld;
assign iu_cp0_epc_update = epc_update_after_retire
                        && !hs_split_iu_hs_retire_mask;
//assign iu_cp0_cur_epc_update = 1'b0;


//when hw stacking, acc err aft retire will not updt curpc in pcgen
assign retire_pcgen_curpc_update = (epc_update_after_retire
                                      || hadpc_update_after_retire)
                                && hs_split_iu_hs_retire_mask && !retire_hs_acc_err;
//==============================================================================
// IU/HAD Interface
//==============================================================================
//when CSKY_TEE, rte and wsc cannot ack dr and trace dbg req
assign inst_dbg_disable    = 1'b0;

assign retire_ack_jdbreq  = had_iu_xx_jdbreq
                          && !hs_split_iu_hs_switch_se
                          && !inst_dbg_disable
                          && !retire_dbg_disable;

//when addsp or subsp in split, and it is not the last beat of split, cpu
//cannot ack dbg
assign retire_dbg_mask = ifu_iu_ex_sp_oper && ifu_iu_ex_split_on;
assign retire_ack_dr_set_req   = iu_yy_xx_retire && had_iu_dr_set_req
                                 && !retire_dbg_mask
                                 && !inst_dbg_disable
                                 && !had_iu_rte_pc_sel
                                 && !retire_dbg_disable;

assign retire_ack_bkpt    =  iu_yy_xx_retire && rbus_retire_expt_vld
                          && (rbus_retire_expt_vec[4:0] == 5'b00011)
                          && (had_iu_xx_fdb || had_core_dbg_mode_req
                          ||  ifu_iu_inst_bkpt_dbg_occur_vld)
                          && !dbg_mode_on
                          && !inst_dbg_disable
                          && !had_iu_rte_pc_sel
                          && !retire_dbg_disable
                          && !(ifu_iu_inst_bkpt_dbgexp_occur_vld
                          &&  !ifu_iu_inst_bkpt_dbg_occur_vld);

//the mem bkpt and trace dbg req ack_vld is asserted when fast retired ldst
//complete without exception
assign retire_ack_mem_bkpt_req         = retire_ack_mem_bkpt_vld_idle 
                                         && had_iu_mem_bkpt_req
                                         && !inst_dbg_disable
                                         && !had_iu_rte_pc_sel
                                         && !retire_dbg_disable;
assign retire_ack_mem_bkpt_fast_retire = retire_ack_mem_bkpt_vld
                                     && !had_iu_mbkpt_fsm_index_mbee;

assign retire_ack_trace_req            = retire_ack_trace_vld_idle    
                                         && had_iu_trace_req
                                         && !inst_dbg_disable
                                         && !had_iu_rte_pc_sel
                                         && !retire_dbg_disable;
assign retire_ack_trace_fast_retire    = retire_ack_trace_vld; 

assign dbgreq_ack = retire_ack_jdbreq     || retire_ack_bkpt
                 || retire_ack_dr_set_req || retire_ack_mem_bkpt_req
                 || retire_ack_trace_req
                 || retire_ack_mem_bkpt_fast_retire
                 || retire_ack_trace_fast_retire;

assign dbgreq_ack_aft_force = dbgreq_ack || had_iu_force_dbg_en || lockup_retire_dbg_vld;


always @(posedge dbg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    dbgreq_ack_ff <= 1'b0;
  else
    dbgreq_ack_ff <= dbgreq_ack_aft_force;
end

assign iu_had_xx_dbg_ack = dbgreq_ack_ff;

always @(posedge dbg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    dbg_mode_on <= 1'b0;
  else if(had_yy_xx_exit_dbg || !iu_yy_xx_reg_rst_b)
    dbg_mode_on <= 1'b0;
  else if(dbgreq_ack_aft_force)
    dbg_mode_on <= 1'b1;
  else
    dbg_mode_on <= dbg_mode_on;
end

// &Force("output","iu_yy_xx_dbgon"); @733
assign iu_yy_xx_dbgon            = dbg_mode_on;

assign iu_had_xx_retire          = iu_yy_xx_retire;

assign iu_had_xx_retire_pc[31:0] = {pcgen_xx_cur_pc[30:0],1'b0};

assign iu_had_xx_mldst           = retire_split_inst_no_dbg;

assign iu_had_xx_retire_normal   = !rbus_retire_expt_vld;

//assign iu_had_chg_flw_inst       = rbus_retire_chg_flw_inst;


//had int ack when DCC
assign iu_had_int_ack = retire_int_vld && had_iu_int_vld; 
assign iu_had_retire_with_had_int = retire_with_ack_had_int;

//dbg ack to HAD, to updt dbg info
assign iu_had_dbg_disable_for_tee = cp0_iu_dbg_disable_for_tee;
//for adr
assign iu_had_adr_dbg_ack = retire_ack_jdbreq;
//for dr
assign iu_had_dr_dbg_ack  = retire_ack_dr_set_req;
//for HW bkpt
assign iu_had_inst_bkpt_occur_vld = retire_ack_bkpt
                                 && ifu_iu_inst_bkpt_dbg_occur_vld;
assign iu_had_data_bkpt_occur_vld = retire_ack_mem_bkpt_req
                                 || retire_ack_mem_bkpt_fast_retire;
//for SW bkpt
assign iu_had_xx_bkpt_inst       = retire_ack_bkpt
                               && !ifu_iu_inst_bkpt_dbg_occur_vld
                               && !had_core_dbg_mode_req;
//for trace
assign iu_had_trace_occur_vld     = retire_ack_trace_req
                                 || retire_ack_trace_fast_retire;

////for inst bkpt counter dec
//assign iu_had_inst_bkpta_hit      = ifu_iu_inst_bkpta_hit; 
//assign iu_had_inst_bkptb_hit      = ifu_iu_inst_bkptb_hit;

//when expt, the counter of mem bkpt will be reset to zero
assign iu_had_expt_vld            = retire_expt_int_vld;

////the trace coutner need to be dec when expt during split when fast retire
//assign iu_had_expt_during_split   = wb_xx_acc_err_after_retire
//                                    && !retire_with_ack_int
//                                    && wb_split_inst;

assign wb_split_inst_clk_en = wb_split_inst ^ retire_split_inst_no_dbg;
always @(posedge dbg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    wb_split_inst <= 1'b0;
  else if(iu_yy_xx_retire)
    wb_split_inst <= retire_split_inst_no_dbg;
end


//when the fast retired ldst get into debug mode, and than the 
//acc_err come from dbus after cpu is in debug mode, the PC 
//in HAD is not corrcet and need to be updated with the PC of
//fast retired ldst
assign hadpc_update_after_retire = wb_xx_acc_err_after_retire
                                     && (retire_with_ack_dbg
                                      || retire_with_ack_had_int)
                                || bctm_retire_had_pc_updt_vld;
assign iu_had_fast_retire_acc_err_pc_update = hadpc_update_after_retire
                                           && !retire_hs_acc_err;
assign iu_had_fast_retire_acc_err_pc_val[30:0] = retire_epc_or_hadpc[30:0];


//======================================
//  the mem bkpt and trace ack signal
//======================================
//the fast retire ld st will not ack dbg req before complete
assign load_store_fast_retire = rbus_wb_load || rbus_wb_store;

//the mem bkpt ack SM
parameter BKPT_IDLE = 1'b0;
parameter BKPT_ACK  = 1'b1;

always @(posedge dbg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    bkpt_cur_state <= BKPT_IDLE;
  else
    bkpt_cur_state <= bkpt_next_state;
end

assign bkpt_fsm_trigger = (had_iu_mem_bkpt_req
                        || had_iu_mem_bkpt_exp_req)
                        && load_store_fast_retire
                        && !ex_inst_dbg_disable && !had_iu_rte_pc_sel;

// &CombBeg; @863
always @( bkpt_cur_state
       or bkpt_fsm_trigger
       or lsu_iu_wb_cmplt)
begin
  case(bkpt_cur_state)
  BKPT_IDLE : if(bkpt_fsm_trigger)
                bkpt_next_state = BKPT_ACK;
              else
                bkpt_next_state = BKPT_IDLE;
  BKPT_ACK  : if(lsu_iu_wb_cmplt)
                bkpt_next_state = BKPT_IDLE;
              else
                bkpt_next_state = BKPT_ACK;
  default   :   bkpt_next_state = BKPT_IDLE;
  endcase
// &CombEnd; @875
end


assign retire_ack_mem_bkpt_vld_idle = (bkpt_cur_state == BKPT_IDLE)
                                      && !load_store_fast_retire;
assign retire_ack_mem_bkpt_vld = (bkpt_cur_state == BKPT_ACK)
                                 && lsu_iu_wb_cmplt
                                 && !lsu_iu_wb_acc_err;
assign wb_dbg_exp_after_retire = (bkpt_cur_state == BKPT_ACK) 
                                 && lsu_iu_wb_cmplt
                                 && !lsu_iu_wb_acc_err
                                 && had_iu_mbkpt_fsm_index_mbee;

//the trace ack SM
parameter TRACE_IDLE = 1'b0;
parameter TRACE_ACK  = 1'b1;

always @(posedge dbg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    trace_cur_state <= TRACE_IDLE;
  else
    trace_cur_state <= trace_next_state;
end

// &CombBeg; @911
always @( trace_cur_state
       or ex_inst_dbg_disable
       or load_store_fast_retire
       or had_iu_rte_pc_sel
       or had_iu_trace_req
       or lsu_iu_wb_cmplt)
begin
  case(trace_cur_state)
  TRACE_IDLE : if(had_iu_trace_req && load_store_fast_retire
                  && !ex_inst_dbg_disable && !had_iu_rte_pc_sel)
                trace_next_state = TRACE_ACK;
              else
                trace_next_state = TRACE_IDLE;
  TRACE_ACK  : if(lsu_iu_wb_cmplt)
                trace_next_state = TRACE_IDLE;
              else
                trace_next_state = TRACE_ACK;
  default    :  trace_next_state = TRACE_IDLE;
  endcase
// &CombEnd; @924
end

assign retire_ack_trace_vld_idle = (trace_cur_state == TRACE_IDLE)
                                   && !load_store_fast_retire;
assign retire_ack_trace_vld = (trace_cur_state == TRACE_ACK)
                              && lsu_iu_wb_cmplt
                              && !lsu_iu_wb_acc_err;

//when dbg in ack, the internal stall in EX need to be asserted
// &Force("output","retire_wb_dbg_in_ack"); @933
assign retire_wb_dbg_in_ack = (bkpt_cur_state  == BKPT_ACK)
                           || (trace_cur_state == TRACE_ACK);


//==============================================================================
//                Branch Debug Disable Handle Logic
//==============================================================================
parameter BR_DBG_IDLE = 2'b00;
parameter BR_DBG_ACK  = 2'b10;

always @(posedge dbg_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    br_cur_state[1:0] <= BR_DBG_IDLE;
  else
    br_cur_state[1:0] <= br_next_state[1:0];
end

// &CombBeg; @960
always @( ctrl_branch_ex_sel
       or br_cur_state
       or ifu_iu_ibus_idle
       or had_iu_trace_req_for_dbg_disable
       or ifu_iu_inst_buf_inst_vld)
begin
  case(br_cur_state)
  BR_DBG_IDLE : if(ctrl_branch_ex_sel && ifu_iu_ibus_idle && had_iu_trace_req_for_dbg_disable)
                  br_next_state = BR_DBG_ACK;
                else
                  br_next_state = BR_DBG_IDLE;
  BR_DBG_ACK  : if(ifu_iu_inst_buf_inst_vld)
                  br_next_state = BR_DBG_IDLE;
                else
                  br_next_state = BR_DBG_ACK;
  default     :   br_next_state = BR_DBG_IDLE;
  endcase
// &CombEnd; @972
end

assign retire_branch_stall = (br_cur_state == BR_DBG_IDLE)
                                && had_iu_trace_req_for_dbg_disable
                          || (br_cur_state == BR_DBG_ACK)
                                && !ifu_iu_inst_buf_inst_vld;

assign retire_branch_dbg_idle = (br_cur_state == BR_DBG_IDLE);

//for peak power, when dbg disable, no peak power mask
//assign iu_ifu_not_wait_for_dbg_disable = retire_branch_dbg_idle;

assign retire_dbg_disable = retire_dbg_disable_pre || cp0_iu_dbg_disable_for_tee;

assign retire_dbg_disable_pre = retire_branch_dbg_idle
                                  ? ex_inst_dbg_disable
                                  : ifu_iu_inst_buf_inst_dbg_disable;

assign ex_inst_dbg_disable = ifu_iu_ex_inst_dbg_disable || cp0_iu_dbg_disable_for_tee;


//normal retire without exception, used for increase pc update
//the interrupt should update increase pc. so set when
//1.normal instruction retire without exception
//2.normal instruction retire with interruption
//3.last split instruction retire with interruption
assign retire_xx_normal_retire = iu_yy_xx_retire
                                    && !rbus_retire_split_inst
                                    && !(retire_pc_expt_vld && !special_retire_inst_wsc);


//==============================================================================
// Flush
//==============================================================================
assign sec_retire_flush = 1'b0;

assign rbus_flush      = iu_yy_xx_retire && rbus_retire_flush;

assign nie_flush = 1'b0;
assign nie_flush_chgflw = 1'b0;
assign retire_mad_ex_cancel = dbgreq_ack_aft_force;
assign iu_yy_xx_flush  = rbus_flush
                         || iu_cp0_expt_vld
                         || dbgreq_ack_aft_force
                         || wb_xx_lsu_check_fail_after_retire
                         || retire_hs_acc_err
                         || sec_retire_flush
                         || nie_flush;


//==============================================================================
// Retire corresponding signals for gate-level simulation
//==============================================================================
assign iu_pad_inst_retire     = iu_yy_xx_retire && !retire_split_inst_with_dbg_ack;

assign iu_pad_inst_split      = retire_split_inst_with_dbg_ack;

assign iu_pad_retire_pc[31:0] = {pcgen_xx_cur_pc[30:0],1'b0};

// &Force("bus", "cp0_iu_vec_mode", 1, 0); @1061
// &ModuleEnd; @1062
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @25
module cr_iu_special(
  cp0_iu_cache_inv_done,
  ctrl_special_ex_data_sel,
  ctrl_special_ex_sel,
  ctrl_special_expt_vec,
  ctrl_special_expt_vld,
  decd_special_fencei,
  decd_special_icall,
  decd_special_icpa,
  special_ctrl_stall,
  special_ctrl_stall_noinput,
  special_pcgen_chgflw_vld,
  special_rbus_expt_vec,
  special_rbus_expt_vld,
  special_rbus_flush,
  special_rbus_req,
  special_retire_inst_wsc,
  wb_special_st_uncmplt
);

// &Ports; @26
input          cp0_iu_cache_inv_done;     
input          ctrl_special_ex_data_sel;  
input          ctrl_special_ex_sel;       
input   [4:0]  ctrl_special_expt_vec;     
input          ctrl_special_expt_vld;     
input          decd_special_fencei;       
input          decd_special_icall;        
input          decd_special_icpa;         
input          wb_special_st_uncmplt;     
output         special_ctrl_stall;        
output         special_ctrl_stall_noinput; 
output         special_pcgen_chgflw_vld;  
output  [4:0]  special_rbus_expt_vec;     
output         special_rbus_expt_vld;     
output         special_rbus_flush;        
output         special_rbus_req;          
output         special_retire_inst_wsc;   

// &Regs; @27

// &Wires; @28
wire           cp0_iu_cache_inv_done;     
wire           ctrl_special_ex_data_sel;  
wire           ctrl_special_ex_sel;       
wire    [4:0]  ctrl_special_expt_vec;     
wire           ctrl_special_expt_vld;     
wire           decd_special_fencei;       
wire           decd_special_icall;        
wire           decd_special_icpa;         
wire           special_cmplt;             
wire           special_ctrl_stall;        
wire           special_ctrl_stall_noinput; 
wire           special_pcgen_chgflw_vld;  
wire    [4:0]  special_rbus_expt_vec;     
wire           special_rbus_expt_vld;     
wire           special_rbus_flush;        
wire           special_rbus_req;          
wire           special_retire_inst_wsc;   
wire           special_stall;             
wire           wb_special_st_uncmplt;     


//==============================================================================
// SEPCIAL result request
//==============================================================================
// fencei judge
assign special_stall = (decd_special_fencei || decd_special_icall
                    || decd_special_icpa)
                    && (wb_special_st_uncmplt || !cp0_iu_cache_inv_done);
assign special_cmplt  = (decd_special_fencei || decd_special_icall
                    || decd_special_icpa)
                    && !wb_special_st_uncmplt
                    && cp0_iu_cache_inv_done;

//result bus request
assign special_rbus_req         = ctrl_special_ex_sel && !special_stall;
assign special_rbus_flush       = ctrl_special_ex_sel && special_cmplt;
assign special_pcgen_chgflw_vld = ctrl_special_ex_sel && special_cmplt;
//data and data valid : special does not write back

//exception valid and vector
assign special_rbus_expt_vld      = ctrl_special_ex_sel && ctrl_special_expt_vld;
assign special_rbus_expt_vec[4:0] = ctrl_special_expt_vec[4:0];

assign special_ctrl_stall = ctrl_special_ex_data_sel && special_stall;
assign special_ctrl_stall_noinput = ctrl_special_ex_data_sel 
                         && (decd_special_fencei || decd_special_icall
                         || decd_special_icpa);

assign special_retire_inst_wsc = 1'b0;

// &ModuleEnd; @68
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_iu_top(
  bmu_xx_ibus_acc_err,
  bmu_xx_ibus_data_vld,
  bmu_xx_ibus_grnt,
  cache_iu_lockup_ack,
  clic_cpu_int_hv,
  clic_cpu_int_id,
  clic_cpu_int_il,
  clic_cpu_int_priv,
  clint_cpu_me_int,
  clk_en,
  cp0_iu_cache_inv_done,
  cp0_iu_cskyisaee,
  cp0_iu_data,
  cp0_iu_data_vld,
  cp0_iu_dbg_disable_for_tee,
  cp0_iu_epc_for_chgflw,
  cp0_iu_expt_vec,
  cp0_iu_expt_vld,
  cp0_iu_flush,
  cp0_iu_flush_chgflw_vld,
  cp0_iu_il,
  cp0_iu_in_expt,
  cp0_iu_in_nmi,
  cp0_iu_inst_mret,
  cp0_iu_meie,
  cp0_iu_mie_for_int,
  cp0_iu_mret,
  cp0_iu_req,
  cp0_iu_rte_chgflw_vld,
  cp0_iu_rte_chgflw_vld_for_data,
  cp0_iu_stall,
  cp0_iu_stall_noinput,
  cp0_iu_vbr,
  cp0_iu_vec_mode,
  cp0_iu_wfe_en,
  cp0_vector_vec_err_vbr,
  cp0_yy_clk_en,
  cp0_yy_priv_mode,
  cpurst_b,
  forever_cpuclk,
  had_core_dbg_mode_req,
  had_idu_wbbr_data,
  had_idu_wbbr_vld,
  had_iu_bkpt_trace_en,
  had_iu_dr_set_req,
  had_iu_force_dbg_en,
  had_iu_int_vld,
  had_iu_mbkpt_fsm_index_mbee,
  had_iu_mem_bkpt_exp_req,
  had_iu_mem_bkpt_mask,
  had_iu_mem_bkpt_req,
  had_iu_pc,
  had_iu_rte_pc_sel,
  had_iu_trace_req,
  had_iu_trace_req_for_dbg_disable,
  had_iu_xx_fdb,
  had_iu_xx_jdbreq,
  had_yy_xx_exit_dbg,
  ifu_had_chg_flw_inst,
  ifu_had_match_pc,
  ifu_iu_ex_expt_cur,
  ifu_iu_ex_expt_vld,
  ifu_iu_ex_inst,
  ifu_iu_ex_inst_bkpt,
  ifu_iu_ex_inst_dbg_disable,
  ifu_iu_ex_inst_vld,
  ifu_iu_ex_int_spcu_mask,
  ifu_iu_ex_int_spcu_vld,
  ifu_iu_ex_ni,
  ifu_iu_ex_prvlg_expt_vld,
  ifu_iu_ex_rand_vld,
  ifu_iu_ex_sp_oper,
  ifu_iu_ibus_idle,
  ifu_iu_inst_bkpt_dbg_occur_vld,
  ifu_iu_inst_bkpt_dbgexp_occur_vld,
  ifu_iu_inst_buf_inst_dbg_disable,
  ifu_iu_inst_buf_inst_vld,
  ifu_iu_lockup_ack,
  ifu_iu_spcu_retire_mask,
  ifu_iu_vector_ibus_in_idle,
  ifu_iu_xx_ibus_data,
  iu_bmu_vec_redirect,
  iu_cache_lockup_req,
  iu_cp0_ecall,
  iu_cp0_epc,
  iu_cp0_epc_update,
  iu_cp0_ex_csrrc,
  iu_cp0_ex_csrrci,
  iu_cp0_ex_csrrs,
  iu_cp0_ex_csrrsi,
  iu_cp0_ex_csrrw,
  iu_cp0_ex_csrrwi,
  iu_cp0_ex_data_sel,
  iu_cp0_ex_func3,
  iu_cp0_ex_mret,
  iu_cp0_ex_rd_reg,
  iu_cp0_ex_rs1_reg,
  iu_cp0_ex_sel,
  iu_cp0_ex_wfi,
  iu_cp0_expt_tval,
  iu_cp0_expt_vld,
  iu_cp0_imm,
  iu_cp0_int_vld,
  iu_cp0_lockup_clr,
  iu_cp0_lockup_vld,
  iu_cp0_lp_wk_int,
  iu_cp0_mtval_updt_vld,
  iu_cp0_nmi_vld,
  iu_cp0_nt_int_pending_vld,
  iu_cp0_oper_mux_en,
  iu_cp0_rs1,
  iu_cp0_syc_rst_b,
  iu_had_adr_dbg_ack,
  iu_had_chgflw_dst_pc,
  iu_had_chgflw_vld,
  iu_had_data_bkpt_occur_vld,
  iu_had_dbg_disable_for_tee,
  iu_had_dr_dbg_ack,
  iu_had_expt_vld,
  iu_had_fast_retire_acc_err_pc_update,
  iu_had_fast_retire_acc_err_pc_val,
  iu_had_flush,
  iu_had_inst_bkpt_occur_vld,
  iu_had_int_ack,
  iu_had_retire_with_had_int,
  iu_had_trace_occur_vld,
  iu_had_xx_bkpt_inst,
  iu_had_xx_data,
  iu_had_xx_data_vld,
  iu_had_xx_dbg_ack,
  iu_had_xx_mldst,
  iu_had_xx_retire,
  iu_had_xx_retire_normal,
  iu_had_xx_retire_pc,
  iu_ifu_addr,
  iu_ifu_data_fetch,
  iu_ifu_data_fetch_for_data,
  iu_ifu_ex_stall,
  iu_ifu_ex_stall_noinput,
  iu_ifu_ex_vld,
  iu_ifu_inst_fetch,
  iu_ifu_inst_fetch_for_data,
  iu_ifu_inst_fetch_mask,
  iu_ifu_inst_fetch_without_dbg_disable,
  iu_ifu_kill_inst,
  iu_ifu_lockup_mask,
  iu_ifu_lockup_on,
  iu_ifu_lockup_req,
  iu_ifu_lsu_inst,
  iu_ifu_reset_vld,
  iu_ifu_security_violation,
  iu_ifu_wb_ldst,
  iu_ifu_wb_stall,
  iu_lsu_adder_rst,
  iu_lsu_base,
  iu_lsu_data,
  iu_lsu_ex_byte,
  iu_lsu_ex_data_sel,
  iu_lsu_ex_half,
  iu_lsu_ex_sel,
  iu_lsu_ex_store,
  iu_lsu_ex_uns,
  iu_lsu_imm_data,
  iu_lsu_imm_write_en,
  iu_lsu_offset,
  iu_lsu_oper_mux_en,
  iu_lsu_rs2,
  iu_lsu_stall_without_hready,
  iu_lsu_wb_ldst,
  iu_lsu_wb_load,
  iu_lsu_wb_store,
  iu_pad_gpr_data,
  iu_pad_gpr_index,
  iu_pad_gpr_we,
  iu_pad_inst_retire,
  iu_pad_inst_split,
  iu_pad_retire_pc,
  iu_sys_lp_wk_int,
  iu_sysio_lockup_on,
  iu_yy_xx_dbgon,
  iu_yy_xx_expt_vec,
  iu_yy_xx_flush,
  iu_yy_xx_int_hv,
  iu_yy_xx_int_il,
  iu_yy_xx_int_pending_hv,
  iu_yy_xx_int_pending_id,
  iu_yy_xx_int_pending_il,
  iu_yy_xx_int_pending_priv,
  lsu_iu_addr,
  lsu_iu_addr_vld,
  lsu_iu_alu_sel,
  lsu_iu_data,
  lsu_iu_data_vld,
  lsu_iu_expt_vec,
  lsu_iu_expt_vld,
  lsu_iu_fast_retire,
  lsu_iu_mad_buf,
  lsu_iu_req,
  lsu_iu_stall,
  lsu_iu_stall_noinput,
  lsu_iu_store,
  lsu_iu_wb_acc_err,
  lsu_iu_wb_bstack_chk_fail,
  lsu_iu_wb_cmplt,
  lsu_iu_wb_data_vld,
  lsu_iu_wb_load_data,
  lsu_iu_wfd,
  pad_yy_gate_clk_en_b,
  split_ifctrl_hs_stall,
  split_ifctrl_hs_stall_part,
  sysio_iu_nmi_int,
  sysio_iu_rst_addr,
  sysio_iu_wk_event,
  vector_cp0_vec_err,
  vector_cp0_vec_err_epc,
  vector_cp0_vec_succeed
);

// &Ports; @24
input           bmu_xx_ibus_acc_err;                    
input           bmu_xx_ibus_data_vld;                   
input           bmu_xx_ibus_grnt;                       
input           cache_iu_lockup_ack;                    
input           clic_cpu_int_hv;                        
input   [11:0]  clic_cpu_int_id;                        
input   [7 :0]  clic_cpu_int_il;                        
input   [1 :0]  clic_cpu_int_priv;                      
input           clint_cpu_me_int;                       
input           clk_en;                                 
input           cp0_iu_cache_inv_done;                  
input           cp0_iu_cskyisaee;                       
input   [31:0]  cp0_iu_data;                            
input           cp0_iu_data_vld;                        
input           cp0_iu_dbg_disable_for_tee;             
input   [30:0]  cp0_iu_epc_for_chgflw;                  
input   [4 :0]  cp0_iu_expt_vec;                        
input           cp0_iu_expt_vld;                        
input           cp0_iu_flush;                           
input           cp0_iu_flush_chgflw_vld;                
input   [7 :0]  cp0_iu_il;                              
input           cp0_iu_in_expt;                         
input           cp0_iu_in_nmi;                          
input           cp0_iu_inst_mret;                       
input           cp0_iu_meie;                            
input           cp0_iu_mie_for_int;                     
input           cp0_iu_mret;                            
input           cp0_iu_req;                             
input           cp0_iu_rte_chgflw_vld;                  
input           cp0_iu_rte_chgflw_vld_for_data;         
input           cp0_iu_stall;                           
input           cp0_iu_stall_noinput;                   
input   [29:0]  cp0_iu_vbr;                             
input   [1 :0]  cp0_iu_vec_mode;                        
input           cp0_iu_wfe_en;                          
input   [29:0]  cp0_vector_vec_err_vbr;                 
input           cp0_yy_clk_en;                          
input   [1 :0]  cp0_yy_priv_mode;                       
input           cpurst_b;                               
input           forever_cpuclk;                         
input           had_core_dbg_mode_req;                  
input   [31:0]  had_idu_wbbr_data;                      
input           had_idu_wbbr_vld;                       
input           had_iu_bkpt_trace_en;                   
input           had_iu_dr_set_req;                      
input           had_iu_force_dbg_en;                    
input           had_iu_int_vld;                         
input           had_iu_mbkpt_fsm_index_mbee;            
input           had_iu_mem_bkpt_exp_req;                
input           had_iu_mem_bkpt_mask;                   
input           had_iu_mem_bkpt_req;                    
input   [30:0]  had_iu_pc;                              
input           had_iu_rte_pc_sel;                      
input           had_iu_trace_req;                       
input           had_iu_trace_req_for_dbg_disable;       
input           had_iu_xx_fdb;                          
input           had_iu_xx_jdbreq;                       
input           had_yy_xx_exit_dbg;                     
input           ifu_iu_ex_expt_cur;                     
input           ifu_iu_ex_expt_vld;                     
input   [31:0]  ifu_iu_ex_inst;                         
input           ifu_iu_ex_inst_bkpt;                    
input           ifu_iu_ex_inst_dbg_disable;             
input           ifu_iu_ex_inst_vld;                     
input           ifu_iu_ex_int_spcu_mask;                
input           ifu_iu_ex_int_spcu_vld;                 
input           ifu_iu_ex_ni;                           
input           ifu_iu_ex_prvlg_expt_vld;               
input           ifu_iu_ex_rand_vld;                     
input           ifu_iu_ex_sp_oper;                      
input           ifu_iu_ibus_idle;                       
input           ifu_iu_inst_bkpt_dbg_occur_vld;         
input           ifu_iu_inst_bkpt_dbgexp_occur_vld;      
input           ifu_iu_inst_buf_inst_dbg_disable;       
input           ifu_iu_inst_buf_inst_vld;               
input           ifu_iu_lockup_ack;                      
input           ifu_iu_spcu_retire_mask;                
input           ifu_iu_vector_ibus_in_idle;             
input   [31:0]  ifu_iu_xx_ibus_data;                    
input   [31:0]  lsu_iu_addr;                            
input           lsu_iu_addr_vld;                        
input           lsu_iu_alu_sel;                         
input   [31:0]  lsu_iu_data;                            
input           lsu_iu_data_vld;                        
input   [4 :0]  lsu_iu_expt_vec;                        
input           lsu_iu_expt_vld;                        
input           lsu_iu_fast_retire;                     
input   [31:0]  lsu_iu_mad_buf;                         
input           lsu_iu_req;                             
input           lsu_iu_stall;                           
input           lsu_iu_stall_noinput;                   
input           lsu_iu_store;                           
input           lsu_iu_wb_acc_err;                      
input           lsu_iu_wb_bstack_chk_fail;              
input           lsu_iu_wb_cmplt;                        
input           lsu_iu_wb_data_vld;                     
input   [31:0]  lsu_iu_wb_load_data;                    
input           lsu_iu_wfd;                             
input           pad_yy_gate_clk_en_b;                   
input           sysio_iu_nmi_int;                       
input   [31:0]  sysio_iu_rst_addr;                      
input           sysio_iu_wk_event;                      
output          ifu_had_chg_flw_inst;                   
output  [31:0]  ifu_had_match_pc;                       
output          iu_bmu_vec_redirect;                    
output          iu_cache_lockup_req;                    
output          iu_cp0_ecall;                           
output  [30:0]  iu_cp0_epc;                             
output          iu_cp0_epc_update;                      
output          iu_cp0_ex_csrrc;                        
output          iu_cp0_ex_csrrci;                       
output          iu_cp0_ex_csrrs;                        
output          iu_cp0_ex_csrrsi;                       
output          iu_cp0_ex_csrrw;                        
output          iu_cp0_ex_csrrwi;                       
output          iu_cp0_ex_data_sel;                     
output  [2 :0]  iu_cp0_ex_func3;                        
output          iu_cp0_ex_mret;                         
output  [4 :0]  iu_cp0_ex_rd_reg;                       
output  [4 :0]  iu_cp0_ex_rs1_reg;                      
output          iu_cp0_ex_sel;                          
output          iu_cp0_ex_wfi;                          
output  [31:0]  iu_cp0_expt_tval;                       
output          iu_cp0_expt_vld;                        
output  [11:0]  iu_cp0_imm;                             
output          iu_cp0_int_vld;                         
output          iu_cp0_lockup_clr;                      
output          iu_cp0_lockup_vld;                      
output          iu_cp0_lp_wk_int;                       
output          iu_cp0_mtval_updt_vld;                  
output          iu_cp0_nmi_vld;                         
output          iu_cp0_nt_int_pending_vld;              
output          iu_cp0_oper_mux_en;                     
output  [31:0]  iu_cp0_rs1;                             
output          iu_cp0_syc_rst_b;                       
output          iu_had_adr_dbg_ack;                     
output  [31:0]  iu_had_chgflw_dst_pc;                   
output          iu_had_chgflw_vld;                      
output          iu_had_data_bkpt_occur_vld;             
output          iu_had_dbg_disable_for_tee;             
output          iu_had_dr_dbg_ack;                      
output          iu_had_expt_vld;                        
output          iu_had_fast_retire_acc_err_pc_update;   
output  [30:0]  iu_had_fast_retire_acc_err_pc_val;      
output          iu_had_flush;                           
output          iu_had_inst_bkpt_occur_vld;             
output          iu_had_int_ack;                         
output          iu_had_retire_with_had_int;             
output          iu_had_trace_occur_vld;                 
output          iu_had_xx_bkpt_inst;                    
output  [31:0]  iu_had_xx_data;                         
output          iu_had_xx_data_vld;                     
output          iu_had_xx_dbg_ack;                      
output          iu_had_xx_mldst;                        
output          iu_had_xx_retire;                       
output          iu_had_xx_retire_normal;                
output  [31:0]  iu_had_xx_retire_pc;                    
output  [30:0]  iu_ifu_addr;                            
output          iu_ifu_data_fetch;                      
output          iu_ifu_data_fetch_for_data;             
output          iu_ifu_ex_stall;                        
output          iu_ifu_ex_stall_noinput;                
output          iu_ifu_ex_vld;                          
output          iu_ifu_inst_fetch;                      
output          iu_ifu_inst_fetch_for_data;             
output          iu_ifu_inst_fetch_mask;                 
output          iu_ifu_inst_fetch_without_dbg_disable;  
output          iu_ifu_kill_inst;                       
output          iu_ifu_lockup_mask;                     
output          iu_ifu_lockup_on;                       
output          iu_ifu_lockup_req;                      
output          iu_ifu_lsu_inst;                        
output          iu_ifu_reset_vld;                       
output          iu_ifu_security_violation;              
output          iu_ifu_wb_ldst;                         
output          iu_ifu_wb_stall;                        
output  [31:0]  iu_lsu_adder_rst;                       
output  [31:0]  iu_lsu_base;                            
output  [31:0]  iu_lsu_data;                            
output          iu_lsu_ex_byte;                         
output          iu_lsu_ex_data_sel;                     
output          iu_lsu_ex_half;                         
output          iu_lsu_ex_sel;                          
output          iu_lsu_ex_store;                        
output          iu_lsu_ex_uns;                          
output  [31:0]  iu_lsu_imm_data;                        
output          iu_lsu_imm_write_en;                    
output  [31:0]  iu_lsu_offset;                          
output          iu_lsu_oper_mux_en;                     
output  [31:0]  iu_lsu_rs2;                             
output          iu_lsu_stall_without_hready;            
output          iu_lsu_wb_ldst;                         
output          iu_lsu_wb_load;                         
output          iu_lsu_wb_store;                        
output  [31:0]  iu_pad_gpr_data;                        
output  [4 :0]  iu_pad_gpr_index;                       
output          iu_pad_gpr_we;                          
output          iu_pad_inst_retire;                     
output          iu_pad_inst_split;                      
output  [31:0]  iu_pad_retire_pc;                       
output          iu_sys_lp_wk_int;                       
output          iu_sysio_lockup_on;                     
output          iu_yy_xx_dbgon;                         
output  [9 :0]  iu_yy_xx_expt_vec;                      
output          iu_yy_xx_flush;                         
output          iu_yy_xx_int_hv;                        
output  [7 :0]  iu_yy_xx_int_il;                        
output          iu_yy_xx_int_pending_hv;                
output  [9 :0]  iu_yy_xx_int_pending_id;                
output  [7 :0]  iu_yy_xx_int_pending_il;                
output  [1 :0]  iu_yy_xx_int_pending_priv;              
output          split_ifctrl_hs_stall;                  
output          split_ifctrl_hs_stall_part;             
output          vector_cp0_vec_err;                     
output  [29:0]  vector_cp0_vec_err_epc;                 
output          vector_cp0_vec_succeed;                 

// &Regs; @25

// &Wires; @26
wire    [31:0]  alu_branch_adder_rst;                   
wire            alu_branch_rst_sign;                    
wire            alu_branch_rst_unsign;                  
wire    [31:0]  alu_branch_xor_rst;                     
wire            alu_mad_adder_of;                       
wire    [31:0]  alu_mad_adder_rst;                      
wire            alu_mad_rst_cout;                       
wire    [31:0]  alu_rbus_data;                          
wire            alu_rbus_data_vld;                      
wire            alu_rbus_req;                           
wire            bctm_top_clk_en;                        
wire            bmu_xx_ibus_acc_err;                    
wire            bmu_xx_ibus_data_vld;                   
wire            bmu_xx_ibus_grnt;                       
wire            branch_alu_adder_cmp;                   
wire            branch_alu_adder_sel;                   
wire            branch_alu_logic_nz;                    
wire            branch_alu_logic_sel;                   
wire            branch_alu_pc_sel;                      
wire            branch_ctrl_stall;                      
wire    [30:0]  branch_pcgen_add_pc;                    
wire            branch_pcgen_br_chgflw_vld;             
wire            branch_pcgen_br_chgflw_vld_for_data;    
wire            branch_pcgen_br_pc_chgflw_vld;          
wire            branch_pcgen_branch_chgflw_vld_for_data; 
wire            branch_pcgen_jmp_chgflw_vld_for_data;   
wire    [30:0]  branch_pcgen_reg_pc;                    
wire    [31:0]  branch_rbus_data;                       
wire            branch_rbus_data_vld;                   
wire            branch_rbus_req;                        
wire            branch_wb_cmp;                          
wire            branch_wb_jmp_reg;                      
wire            cache_iu_lockup_ack;                    
wire            clic_cpu_int_hv;                        
wire    [11:0]  clic_cpu_int_id;                        
wire    [7 :0]  clic_cpu_int_il;                        
wire    [1 :0]  clic_cpu_int_priv;                      
wire            clint_cpu_me_int;                       
wire            clk_en;                                 
wire            cp0_iu_cache_inv_done;                  
wire            cp0_iu_cskyisaee;                       
wire    [31:0]  cp0_iu_data;                            
wire            cp0_iu_data_vld;                        
wire            cp0_iu_dbg_disable_for_tee;             
wire    [30:0]  cp0_iu_epc_for_chgflw;                  
wire    [4 :0]  cp0_iu_expt_vec;                        
wire            cp0_iu_expt_vld;                        
wire            cp0_iu_flush;                           
wire            cp0_iu_flush_chgflw_vld;                
wire    [7 :0]  cp0_iu_il;                              
wire            cp0_iu_in_expt;                         
wire            cp0_iu_in_nmi;                          
wire            cp0_iu_inst_mret;                       
wire            cp0_iu_meie;                            
wire            cp0_iu_mie_for_int;                     
wire            cp0_iu_mret;                            
wire            cp0_iu_req;                             
wire            cp0_iu_rte_chgflw_vld;                  
wire            cp0_iu_rte_chgflw_vld_for_data;         
wire            cp0_iu_stall;                           
wire            cp0_iu_stall_noinput;                   
wire    [29:0]  cp0_iu_vbr;                             
wire    [1 :0]  cp0_iu_vec_mode;                        
wire            cp0_iu_wfe_en;                          
wire    [29:0]  cp0_vector_vec_err_vbr;                 
wire            cp0_yy_clk_en;                          
wire    [1 :0]  cp0_yy_priv_mode;                       
wire            cpurst_b;                               
wire            ctrl_alu_ex_data_sel;                   
wire            ctrl_alu_ex_sel;                        
wire            ctrl_alu_mad_oper_mux_en;               
wire            ctrl_alu_oper_mux_en;                   
wire            ctrl_branch_ex_data_sel;                
wire            ctrl_branch_ex_sel;                     
wire            ctrl_cp0_ex_data_sel;                   
wire            ctrl_lsu_ex_data_sel;                   
wire            ctrl_mad_ex_data_sel;                   
wire            ctrl_mad_ex_sel;                        
wire            ctrl_mad_oper_mux_en;                   
wire            ctrl_oper_lsu_data_sel;                 
wire            ctrl_retire_ni_vld;                     
wire            ctrl_special_ex_data_sel;               
wire            ctrl_special_ex_sel;                    
wire    [4 :0]  ctrl_special_expt_vec;                  
wire            ctrl_special_expt_vld;                  
wire            ctrl_xx_sp_adjust;                      
wire            decd_alu_dst_vld;                       
wire    [2 :0]  decd_alu_func;                          
wire            decd_alu_rs2_imm_vld;                   
wire    [3 :0]  decd_alu_sub_func;                      
wire            decd_branch_auipc;                      
wire            decd_branch_beq;                        
wire            decd_branch_bge;                        
wire            decd_branch_bgeu;                       
wire            decd_branch_blt;                        
wire            decd_branch_bltu;                       
wire            decd_branch_bne;                        
wire            decd_branch_cbeqz;                      
wire            decd_branch_cbnez;                      
wire            decd_branch_cj;                         
wire            decd_branch_cjal;                       
wire            decd_branch_cjalr;                      
wire            decd_branch_cjr;                        
wire            decd_branch_jal;                        
wire            decd_branch_jalr;                       
wire            decd_ctrl_alu_sel;                      
wire            decd_ctrl_branch_sel;                   
wire            decd_ctrl_cp0_sel;                      
wire            decd_ctrl_expt_bkpt;                    
wire            decd_ctrl_expt_ecall;                   
wire            decd_ctrl_expt_inv;                     
wire            decd_ctrl_expt_wsc;                     
wire            decd_ctrl_lsu_sel;                      
wire            decd_ctrl_mad_sel;                      
wire            decd_mad_inst_div;                      
wire            decd_mad_inst_divu;                     
wire            decd_mad_inst_mul;                      
wire            decd_mad_inst_mulh;                     
wire            decd_mad_inst_mulhsu;                   
wire            decd_mad_inst_mulhu;                    
wire            decd_mad_inst_rem;                      
wire            decd_mad_inst_remu;                     
wire    [31:0]  decd_oper_alu_imm;                      
wire    [31:0]  decd_oper_branch_imm;                   
wire    [11:0]  decd_oper_cp0_imm;                      
wire    [31:0]  decd_oper_lsu_imm;                      
wire            decd_retire_cp0_inst;                   
wire            decd_retire_inst_mret;                  
wire            decd_special_fencei;                    
wire            decd_special_icall;                     
wire            decd_special_icpa;                      
wire    [31:0]  decd_wb_tval;                           
wire            decd_xx_inst_32bit;                     
wire            decd_xx_unit_special_sel;               
wire            forever_cpuclk;                         
wire            had_core_dbg_mode_req;                  
wire    [31:0]  had_idu_wbbr_data;                      
wire            had_idu_wbbr_vld;                       
wire            had_iu_bkpt_trace_en;                   
wire            had_iu_dr_set_req;                      
wire            had_iu_force_dbg_en;                    
wire            had_iu_int_vld;                         
wire            had_iu_mbkpt_fsm_index_mbee;            
wire            had_iu_mem_bkpt_exp_req;                
wire            had_iu_mem_bkpt_mask;                   
wire            had_iu_mem_bkpt_req;                    
wire    [30:0]  had_iu_pc;                              
wire            had_iu_rte_pc_sel;                      
wire            had_iu_trace_req;                       
wire            had_iu_trace_req_for_dbg_disable;       
wire            had_iu_xx_fdb;                          
wire            had_iu_xx_jdbreq;                       
wire            had_yy_xx_exit_dbg;                     
wire            hs_split_iu_ctrl_inst_vld;              
wire    [31:0]  hs_split_iu_dp_inst_op;                 
wire            hs_split_iu_hs_retire_mask;             
wire            hs_split_iu_hs_switch_se;               
wire            hs_split_iu_nsinst_gpr_rst_b;           
wire            hs_split_iu_unstack_chgflw;             
wire            ifu_had_chg_flw_inst;                   
wire    [31:0]  ifu_had_match_pc;                       
wire    [4 :0]  ifu_iu_ex_cnt;                          
wire            ifu_iu_ex_expt_cur;                     
wire            ifu_iu_ex_expt_vld;                     
wire    [31:0]  ifu_iu_ex_inst;                         
wire            ifu_iu_ex_inst_bkpt;                    
wire            ifu_iu_ex_inst_dbg_disable;             
wire            ifu_iu_ex_inst_vld;                     
wire            ifu_iu_ex_int_spcu_mask;                
wire            ifu_iu_ex_int_spcu_vld;                 
wire            ifu_iu_ex_ni;                           
wire            ifu_iu_ex_prvlg_expt_vld;               
wire            ifu_iu_ex_rand_vld;                     
wire    [4 :0]  ifu_iu_ex_rd_reg;                       
wire    [4 :0]  ifu_iu_ex_rs1_reg;                      
wire    [4 :0]  ifu_iu_ex_rs2_reg;                      
wire            ifu_iu_ex_sp_oper;                      
wire            ifu_iu_ex_split_on;                     
wire            ifu_iu_ibus_idle;                       
wire            ifu_iu_inst_bkpt_dbg_occur_vld;         
wire            ifu_iu_inst_bkpt_dbgexp_occur_vld;      
wire            ifu_iu_inst_buf_inst_dbg_disable;       
wire            ifu_iu_inst_buf_inst_vld;               
wire            ifu_iu_lockup_ack;                      
wire            ifu_iu_spcu_retire_mask;                
wire            ifu_iu_vector_ibus_in_idle;             
wire    [31:0]  ifu_iu_xx_ibus_data;                    
wire            iu_bmu_vec_redirect;                    
wire            iu_cache_lockup_req;                    
wire            iu_cp0_ecall;                           
wire    [30:0]  iu_cp0_epc;                             
wire            iu_cp0_epc_update;                      
wire            iu_cp0_ex_csrrc;                        
wire            iu_cp0_ex_csrrci;                       
wire            iu_cp0_ex_csrrs;                        
wire            iu_cp0_ex_csrrsi;                       
wire            iu_cp0_ex_csrrw;                        
wire            iu_cp0_ex_csrrwi;                       
wire            iu_cp0_ex_data_sel;                     
wire    [2 :0]  iu_cp0_ex_func3;                        
wire            iu_cp0_ex_mret;                         
wire    [4 :0]  iu_cp0_ex_rd_reg;                       
wire    [4 :0]  iu_cp0_ex_rs1_reg;                      
wire            iu_cp0_ex_sel;                          
wire            iu_cp0_ex_wfi;                          
wire    [31:0]  iu_cp0_expt_tval;                       
wire            iu_cp0_expt_vld;                        
wire    [11:0]  iu_cp0_imm;                             
wire            iu_cp0_int_vld;                         
wire            iu_cp0_lockup_clr;                      
wire            iu_cp0_lockup_vld;                      
wire            iu_cp0_lp_wk_int;                       
wire            iu_cp0_mtval_updt_vld;                  
wire            iu_cp0_nmi_vld;                         
wire            iu_cp0_nt_int_pending_vld;              
wire            iu_cp0_oper_mux_en;                     
wire    [31:0]  iu_cp0_rs1;                             
wire            iu_cp0_syc_rst_b;                       
wire            iu_had_adr_dbg_ack;                     
wire    [31:0]  iu_had_chgflw_dst_pc;                   
wire            iu_had_chgflw_vld;                      
wire            iu_had_data_bkpt_occur_vld;             
wire            iu_had_dbg_disable_for_tee;             
wire            iu_had_dr_dbg_ack;                      
wire            iu_had_expt_vld;                        
wire            iu_had_fast_retire_acc_err_pc_update;   
wire    [30:0]  iu_had_fast_retire_acc_err_pc_val;      
wire            iu_had_flush;                           
wire            iu_had_inst_bkpt_occur_vld;             
wire            iu_had_int_ack;                         
wire            iu_had_retire_with_had_int;             
wire            iu_had_trace_occur_vld;                 
wire            iu_had_xx_bkpt_inst;                    
wire    [31:0]  iu_had_xx_data;                         
wire            iu_had_xx_data_vld;                     
wire            iu_had_xx_dbg_ack;                      
wire            iu_had_xx_mldst;                        
wire            iu_had_xx_retire;                       
wire            iu_had_xx_retire_normal;                
wire    [31:0]  iu_had_xx_retire_pc;                    
wire            iu_hs_split_ex_stall;                   
wire    [30:0]  iu_ifu_addr;                            
wire            iu_ifu_data_fetch;                      
wire            iu_ifu_data_fetch_for_data;             
wire            iu_ifu_ex_stall;                        
wire            iu_ifu_ex_stall_noinput;                
wire            iu_ifu_ex_vld;                          
wire            iu_ifu_inst_fetch;                      
wire            iu_ifu_inst_fetch_for_data;             
wire            iu_ifu_inst_fetch_mask;                 
wire            iu_ifu_inst_fetch_without_dbg_disable;  
wire            iu_ifu_kill_inst;                       
wire            iu_ifu_lockup_mask;                     
wire            iu_ifu_lockup_on;                       
wire            iu_ifu_lockup_req;                      
wire            iu_ifu_lsu_inst;                        
wire            iu_ifu_reset_vld;                       
wire            iu_ifu_security_violation;              
wire            iu_ifu_spcu_int_en;                     
wire            iu_ifu_wb_ldst;                         
wire            iu_ifu_wb_stall;                        
wire    [31:0]  iu_lsu_adder_rst;                       
wire    [31:0]  iu_lsu_base;                            
wire    [31:0]  iu_lsu_data;                            
wire            iu_lsu_ex_byte;                         
wire            iu_lsu_ex_data_sel;                     
wire            iu_lsu_ex_half;                         
wire            iu_lsu_ex_sel;                          
wire            iu_lsu_ex_store;                        
wire            iu_lsu_ex_uns;                          
wire    [31:0]  iu_lsu_imm_data;                        
wire            iu_lsu_imm_write_en;                    
wire    [31:0]  iu_lsu_offset;                          
wire            iu_lsu_oper_mux_en;                     
wire    [31:0]  iu_lsu_rs2;                             
wire            iu_lsu_stall_without_hready;            
wire            iu_lsu_wb_ldst;                         
wire            iu_lsu_wb_load;                         
wire            iu_lsu_wb_store;                        
wire    [31:0]  iu_pad_gpr_data;                        
wire    [4 :0]  iu_pad_gpr_index;                       
wire            iu_pad_gpr_we;                          
wire            iu_pad_inst_retire;                     
wire            iu_pad_inst_split;                      
wire    [31:0]  iu_pad_retire_pc;                       
wire            iu_sys_lp_wk_int;                       
wire            iu_sysio_lockup_on;                     
wire            iu_yy_xx_dbgon;                         
wire    [9 :0]  iu_yy_xx_expt_vec;                      
wire            iu_yy_xx_flush;                         
wire            iu_yy_xx_int_hv;                        
wire    [7 :0]  iu_yy_xx_int_il;                        
wire            iu_yy_xx_int_pending_hv;                
wire    [9 :0]  iu_yy_xx_int_pending_id;                
wire    [7 :0]  iu_yy_xx_int_pending_il;                
wire    [1 :0]  iu_yy_xx_int_pending_priv;              
wire            iu_yy_xx_reg_rst_b;                     
wire            iu_yy_xx_retire;                        
wire            lockup_retire_dbg_vld;                  
wire            lockup_retire_mask;                     
wire            lockup_retire_nmi_vld;                  
wire    [31:0]  lsu_iu_addr;                            
wire            lsu_iu_addr_vld;                        
wire            lsu_iu_alu_sel;                         
wire    [31:0]  lsu_iu_data;                            
wire            lsu_iu_data_vld;                        
wire    [4 :0]  lsu_iu_expt_vec;                        
wire            lsu_iu_expt_vld;                        
wire            lsu_iu_fast_retire;                     
wire    [31:0]  lsu_iu_mad_buf;                         
wire            lsu_iu_req;                             
wire            lsu_iu_stall;                           
wire            lsu_iu_stall_noinput;                   
wire            lsu_iu_store;                           
wire            lsu_iu_wb_acc_err;                      
wire            lsu_iu_wb_bstack_chk_fail;              
wire            lsu_iu_wb_cmplt;                        
wire            lsu_iu_wb_data_vld;                     
wire    [31:0]  lsu_iu_wb_load_data;                    
wire            lsu_iu_wfd;                             
wire            mad_alu_data_vld;                       
wire    [31:0]  mad_alu_div_rs2;                        
wire            mad_alu_div_shift;                      
wire            mad_alu_fst_add;                        
wire            mad_alu_imm_vld;                        
wire    [31:0]  mad_alu_rs1;                            
wire            mad_alu_rs1_cst_0;                      
wire            mad_alu_rs1_vld;                        
wire            mad_alu_rs2_cst_0;                      
wire    [31:0]  mad_alu_rst;                            
wire            mad_alu_rst_vld;                        
wire            mad_ctrl_stall;                         
wire            mad_ctrl_stall_noinput;                 
wire            mad_rbus_req;                           
wire            misc_clk;                               
wire            misc_clk_en;                            
wire            nie_flush_chgflw;                       
wire    [31:0]  oper_alu_rs1_reg;                       
wire    [31:0]  oper_alu_rs2_imm;                       
wire    [31:0]  oper_alu_rs2_reg;                       
wire    [31:0]  oper_branch_rs1_reg;                    
wire    [31:0]  oper_branch_rs2_imm;                    
wire    [31:0]  oper_branch_rs2_reg;                    
wire    [31:0]  oper_mad_rs1;                           
wire    [31:0]  oper_mad_rs2;                           
wire            oper_wb_rs1_equal_to_dst;               
wire            oper_wb_rs2_equal_to_dst;               
wire            pad_yy_gate_clk_en_b;                   
wire            pcgen_ctrl_stall;                       
wire    [30:0]  pcgen_retire_updt_pc;                   
wire            pcgen_top_abort_clk_en;                 
wire            pcgen_vector_expt_taken;                
wire    [30:0]  pcgen_xx_cur_pc;                        
wire            pcgen_xx_ibus_idle;                     
wire            randclk_mad_mod_en_w2;                  
wire    [20:0]  randclk_oper_gpr_mod_en_w32;            
wire            randclk_pcgen_mod_en_w32;               
wire            randclk_retire_mod_en_w2;               
wire            randclk_wb_buf_mod_en_w32;              
wire            randclk_wb_ctrl_mod_en_w2;              
wire            randclk_wb_idx_mod_en_w5;               
wire            rbus_retire_cmplt;                      
wire    [4 :0]  rbus_retire_expt_vec;                   
wire            rbus_retire_expt_vld;                   
wire            rbus_retire_flush;                      
wire            rbus_retire_split_inst;                 
wire            rbus_wb_cmplt;                          
wire    [31:0]  rbus_wb_data;                           
wire    [4 :0]  rbus_wb_dst_reg;                        
wire            rbus_wb_inst_cmplt;                     
wire            rbus_wb_load;                           
wire            rbus_wb_store;                          
wire            retire_branch_stall;                    
wire            retire_lockup_dbg_on;                   
wire            retire_lockup_dbg_vld;                  
wire            retire_lockup_expt_vld;                 
wire            retire_lockup_inst_retire;              
wire            retire_lockup_nmi_vld;                  
wire    [31:0]  retire_lockup_retire_pc;                
wire            retire_mad_ex_cancel;                   
wire            retire_pcgen_curpc_update;              
wire            retire_vector_expt_int_hv;              
wire            retire_vector_expt_vld;                 
wire            retire_wb_dbg_in_ack;                   
wire            retire_wb_hs_err_epc_sel;               
wire            retire_wb_mem_bkpt_fast_retire;         
wire            retire_xx_normal_retire;                
wire            sec_top_clk_en;                         
wire            special_ctrl_stall;                     
wire            special_ctrl_stall_noinput;             
wire            special_pcgen_chgflw_vld;               
wire    [4 :0]  special_rbus_expt_vec;                  
wire            special_rbus_expt_vld;                  
wire            special_rbus_flush;                     
wire            special_rbus_req;                       
wire            special_retire_inst_wsc;                
wire            split_ifctrl_hs_stall;                  
wire            split_ifctrl_hs_stall_part;             
wire            sysio_iu_nmi_int;                       
wire    [31:0]  sysio_iu_rst_addr;                      
wire            sysio_iu_wk_event;                      
wire            vec_top_clk_en;                         
wire            vector_cp0_vec_err;                     
wire    [29:0]  vector_cp0_vec_err_epc;                 
wire            vector_cp0_vec_succeed;                 
wire            vector_ctrl_stall;                      
wire            vector_pcgen_buf_vbr;                   
wire            vector_pcgen_chgflw_vld;                
wire            vector_pcgen_cur_pc_vld;                
wire    [30:0]  vector_pcgen_enter_addr;                
wire            vector_pcgen_ibus_req;                  
wire            vector_pcgen_reset_vld;                 
wire            wb_branch_dep_ld;                       
wire            wb_ctrl_stall;                          
wire            wb_ctrl_stall_without_hready;           
wire    [31:0]  wb_oper_fwd_data_no_load;               
wire            wb_oper_fwd_en;                         
wire    [31:0]  wb_oper_write_data;                     
wire            wb_oper_write_en;                       
wire    [4 :0]  wb_oper_write_idx;                      
wire    [4 :0]  wb_oper_write_idx_for_dep;              
wire            wb_pcgen_ldst_stall;                    
wire    [30:0]  wb_pcgen_pc_updt_val;                   
wire            wb_pcgen_switch_ld_pc;                  
wire    [4 :0]  wb_rbus_lsu_vec;                        
wire            wb_rbus_st_aft_load;                    
wire    [30:0]  wb_retire_fast_retire_load_pc;          
wire            wb_special_st_uncmplt;                  
wire            wb_top_machine_mode_clk_en;             
wire            wb_top_machine_sp_en_clk_en;            
wire            wb_top_secu_mode_clk_en;                
wire            wb_top_sp_adjust_clk_en;                
wire            wb_vector_ldst_wait_cmplt;              
wire            wb_xx_acc_err_after_retire;             
wire            wb_xx_lsu_check_fail_after_retire;      


//gate cell to misc flop
// &Instance("gated_clk_cell", "x_misc_gated_clk"); @29
gated_clk_cell  x_misc_gated_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (misc_clk            ),
  .external_en          (1'b0                ),
  .global_en            (cp0_yy_clk_en       ),
  .local_en             (misc_clk_en         ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk), @30
//          .external_en (1'b0), @31
//          .global_en   (cp0_yy_clk_en), @32
//          .module_en   (1'b0), @33
//          .local_en    (misc_clk_en), @34
//          .clk_out     (misc_clk)); @35

assign bctm_top_clk_en = 1'b0;
//fix signal for gate cell in CP0

assign sec_top_clk_en = 1'b0;

assign misc_clk_en = bctm_top_clk_en
                  || pcgen_top_abort_clk_en
                  || sec_top_clk_en
                  || wb_top_secu_mode_clk_en
                  || wb_top_machine_mode_clk_en
                  || wb_top_sp_adjust_clk_en
                  || vec_top_clk_en
                  || wb_top_machine_sp_en_clk_en;

// &Force("output","iu_yy_xx_flush"); @57
// &Force("output","iu_yy_xx_dbgon"); @58
// &Force("output","iu_yy_xx_hs_acc_err"); @60
// &Force("output","iu_pad_inst_retire"); @62

// &Instance("cr_iu_decd"); @64
cr_iu_decd  x_cr_iu_decd (
  .branch_pcgen_add_pc       (branch_pcgen_add_pc      ),
  .cp0_iu_cskyisaee          (cp0_iu_cskyisaee         ),
  .cp0_yy_priv_mode          (cp0_yy_priv_mode         ),
  .decd_alu_dst_vld          (decd_alu_dst_vld         ),
  .decd_alu_func             (decd_alu_func            ),
  .decd_alu_rs2_imm_vld      (decd_alu_rs2_imm_vld     ),
  .decd_alu_sub_func         (decd_alu_sub_func        ),
  .decd_branch_auipc         (decd_branch_auipc        ),
  .decd_branch_beq           (decd_branch_beq          ),
  .decd_branch_bge           (decd_branch_bge          ),
  .decd_branch_bgeu          (decd_branch_bgeu         ),
  .decd_branch_blt           (decd_branch_blt          ),
  .decd_branch_bltu          (decd_branch_bltu         ),
  .decd_branch_bne           (decd_branch_bne          ),
  .decd_branch_cbeqz         (decd_branch_cbeqz        ),
  .decd_branch_cbnez         (decd_branch_cbnez        ),
  .decd_branch_cj            (decd_branch_cj           ),
  .decd_branch_cjal          (decd_branch_cjal         ),
  .decd_branch_cjalr         (decd_branch_cjalr        ),
  .decd_branch_cjr           (decd_branch_cjr          ),
  .decd_branch_jal           (decd_branch_jal          ),
  .decd_branch_jalr          (decd_branch_jalr         ),
  .decd_ctrl_alu_sel         (decd_ctrl_alu_sel        ),
  .decd_ctrl_branch_sel      (decd_ctrl_branch_sel     ),
  .decd_ctrl_cp0_sel         (decd_ctrl_cp0_sel        ),
  .decd_ctrl_expt_bkpt       (decd_ctrl_expt_bkpt      ),
  .decd_ctrl_expt_ecall      (decd_ctrl_expt_ecall     ),
  .decd_ctrl_expt_inv        (decd_ctrl_expt_inv       ),
  .decd_ctrl_expt_wsc        (decd_ctrl_expt_wsc       ),
  .decd_ctrl_lsu_sel         (decd_ctrl_lsu_sel        ),
  .decd_ctrl_mad_sel         (decd_ctrl_mad_sel        ),
  .decd_mad_inst_div         (decd_mad_inst_div        ),
  .decd_mad_inst_divu        (decd_mad_inst_divu       ),
  .decd_mad_inst_mul         (decd_mad_inst_mul        ),
  .decd_mad_inst_mulh        (decd_mad_inst_mulh       ),
  .decd_mad_inst_mulhsu      (decd_mad_inst_mulhsu     ),
  .decd_mad_inst_mulhu       (decd_mad_inst_mulhu      ),
  .decd_mad_inst_rem         (decd_mad_inst_rem        ),
  .decd_mad_inst_remu        (decd_mad_inst_remu       ),
  .decd_oper_alu_imm         (decd_oper_alu_imm        ),
  .decd_oper_branch_imm      (decd_oper_branch_imm     ),
  .decd_oper_cp0_imm         (decd_oper_cp0_imm        ),
  .decd_oper_lsu_imm         (decd_oper_lsu_imm        ),
  .decd_retire_cp0_inst      (decd_retire_cp0_inst     ),
  .decd_retire_inst_mret     (decd_retire_inst_mret    ),
  .decd_special_fencei       (decd_special_fencei      ),
  .decd_special_icall        (decd_special_icall       ),
  .decd_special_icpa         (decd_special_icpa        ),
  .decd_wb_tval              (decd_wb_tval             ),
  .decd_xx_inst_32bit        (decd_xx_inst_32bit       ),
  .decd_xx_unit_special_sel  (decd_xx_unit_special_sel ),
  .hs_split_iu_ctrl_inst_vld (hs_split_iu_ctrl_inst_vld),
  .hs_split_iu_dp_inst_op    (hs_split_iu_dp_inst_op   ),
  .ifu_had_chg_flw_inst      (ifu_had_chg_flw_inst     ),
  .ifu_had_match_pc          (ifu_had_match_pc         ),
  .ifu_iu_ex_expt_cur        (ifu_iu_ex_expt_cur       ),
  .ifu_iu_ex_expt_vld        (ifu_iu_ex_expt_vld       ),
  .ifu_iu_ex_inst            (ifu_iu_ex_inst           ),
  .ifu_iu_ex_inst_bkpt       (ifu_iu_ex_inst_bkpt      ),
  .ifu_iu_ex_prvlg_expt_vld  (ifu_iu_ex_prvlg_expt_vld ),
  .ifu_iu_ex_rd_reg          (ifu_iu_ex_rd_reg         ),
  .ifu_iu_ex_rs1_reg         (ifu_iu_ex_rs1_reg        ),
  .ifu_iu_ex_rs2_reg         (ifu_iu_ex_rs2_reg        ),
  .iu_cp0_ex_csrrc           (iu_cp0_ex_csrrc          ),
  .iu_cp0_ex_csrrci          (iu_cp0_ex_csrrci         ),
  .iu_cp0_ex_csrrs           (iu_cp0_ex_csrrs          ),
  .iu_cp0_ex_csrrsi          (iu_cp0_ex_csrrsi         ),
  .iu_cp0_ex_csrrw           (iu_cp0_ex_csrrw          ),
  .iu_cp0_ex_csrrwi          (iu_cp0_ex_csrrwi         ),
  .iu_cp0_ex_func3           (iu_cp0_ex_func3          ),
  .iu_cp0_ex_mret            (iu_cp0_ex_mret           ),
  .iu_cp0_ex_rd_reg          (iu_cp0_ex_rd_reg         ),
  .iu_cp0_ex_rs1_reg         (iu_cp0_ex_rs1_reg        ),
  .iu_cp0_ex_wfi             (iu_cp0_ex_wfi            ),
  .iu_ifu_lsu_inst           (iu_ifu_lsu_inst          ),
  .iu_lsu_ex_byte            (iu_lsu_ex_byte           ),
  .iu_lsu_ex_half            (iu_lsu_ex_half           ),
  .iu_lsu_ex_store           (iu_lsu_ex_store          ),
  .iu_lsu_ex_uns             (iu_lsu_ex_uns            ),
  .lsu_iu_wfd                (lsu_iu_wfd               ),
  .pcgen_xx_cur_pc           (pcgen_xx_cur_pc          )
);


// &Instance("cr_iu_oper"); @66
cr_iu_oper  x_cr_iu_oper (
  .cp0_yy_clk_en                (cp0_yy_clk_en               ),
  .ctrl_oper_lsu_data_sel       (ctrl_oper_lsu_data_sel      ),
  .decd_oper_alu_imm            (decd_oper_alu_imm           ),
  .decd_oper_branch_imm         (decd_oper_branch_imm        ),
  .decd_oper_cp0_imm            (decd_oper_cp0_imm           ),
  .decd_oper_lsu_imm            (decd_oper_lsu_imm           ),
  .forever_cpuclk               (forever_cpuclk              ),
  .had_idu_wbbr_data            (had_idu_wbbr_data           ),
  .had_idu_wbbr_vld             (had_idu_wbbr_vld            ),
  .hs_split_iu_nsinst_gpr_rst_b (hs_split_iu_nsinst_gpr_rst_b),
  .ifu_iu_ex_rs1_reg            (ifu_iu_ex_rs1_reg           ),
  .ifu_iu_ex_rs2_reg            (ifu_iu_ex_rs2_reg           ),
  .iu_cp0_imm                   (iu_cp0_imm                  ),
  .iu_cp0_rs1                   (iu_cp0_rs1                  ),
  .iu_lsu_base                  (iu_lsu_base                 ),
  .iu_lsu_data                  (iu_lsu_data                 ),
  .iu_lsu_offset                (iu_lsu_offset               ),
  .iu_lsu_rs2                   (iu_lsu_rs2                  ),
  .iu_yy_xx_reg_rst_b           (iu_yy_xx_reg_rst_b          ),
  .oper_alu_rs1_reg             (oper_alu_rs1_reg            ),
  .oper_alu_rs2_imm             (oper_alu_rs2_imm            ),
  .oper_alu_rs2_reg             (oper_alu_rs2_reg            ),
  .oper_branch_rs1_reg          (oper_branch_rs1_reg         ),
  .oper_branch_rs2_imm          (oper_branch_rs2_imm         ),
  .oper_branch_rs2_reg          (oper_branch_rs2_reg         ),
  .oper_mad_rs1                 (oper_mad_rs1                ),
  .oper_mad_rs2                 (oper_mad_rs2                ),
  .oper_wb_rs1_equal_to_dst     (oper_wb_rs1_equal_to_dst    ),
  .oper_wb_rs2_equal_to_dst     (oper_wb_rs2_equal_to_dst    ),
  .pad_yy_gate_clk_en_b         (pad_yy_gate_clk_en_b        ),
  .randclk_oper_gpr_mod_en_w32  (randclk_oper_gpr_mod_en_w32 ),
  .wb_oper_fwd_data_no_load     (wb_oper_fwd_data_no_load    ),
  .wb_oper_fwd_en               (wb_oper_fwd_en              ),
  .wb_oper_write_data           (wb_oper_write_data          ),
  .wb_oper_write_en             (wb_oper_write_en            ),
  .wb_oper_write_idx            (wb_oper_write_idx           ),
  .wb_oper_write_idx_for_dep    (wb_oper_write_idx_for_dep   )
);


// &Instance("cr_iu_alu"); @68
cr_iu_alu  x_cr_iu_alu (
  .alu_branch_adder_rst     (alu_branch_adder_rst    ),
  .alu_branch_rst_sign      (alu_branch_rst_sign     ),
  .alu_branch_rst_unsign    (alu_branch_rst_unsign   ),
  .alu_branch_xor_rst       (alu_branch_xor_rst      ),
  .alu_mad_adder_of         (alu_mad_adder_of        ),
  .alu_mad_adder_rst        (alu_mad_adder_rst       ),
  .alu_mad_rst_cout         (alu_mad_rst_cout        ),
  .alu_rbus_data            (alu_rbus_data           ),
  .alu_rbus_data_vld        (alu_rbus_data_vld       ),
  .alu_rbus_req             (alu_rbus_req            ),
  .branch_alu_adder_cmp     (branch_alu_adder_cmp    ),
  .branch_alu_adder_sel     (branch_alu_adder_sel    ),
  .branch_alu_logic_nz      (branch_alu_logic_nz     ),
  .branch_alu_logic_sel     (branch_alu_logic_sel    ),
  .branch_alu_pc_sel        (branch_alu_pc_sel       ),
  .ctrl_alu_ex_sel          (ctrl_alu_ex_sel         ),
  .ctrl_alu_mad_oper_mux_en (ctrl_alu_mad_oper_mux_en),
  .ctrl_alu_oper_mux_en     (ctrl_alu_oper_mux_en    ),
  .ctrl_mad_ex_data_sel     (ctrl_mad_ex_data_sel    ),
  .decd_alu_dst_vld         (decd_alu_dst_vld        ),
  .decd_alu_func            (decd_alu_func           ),
  .decd_alu_rs2_imm_vld     (decd_alu_rs2_imm_vld    ),
  .decd_alu_sub_func        (decd_alu_sub_func       ),
  .ifu_iu_ex_cnt            (ifu_iu_ex_cnt           ),
  .iu_lsu_adder_rst         (iu_lsu_adder_rst        ),
  .lsu_iu_alu_sel           (lsu_iu_alu_sel          ),
  .lsu_iu_mad_buf           (lsu_iu_mad_buf          ),
  .mad_alu_data_vld         (mad_alu_data_vld        ),
  .mad_alu_div_rs2          (mad_alu_div_rs2         ),
  .mad_alu_div_shift        (mad_alu_div_shift       ),
  .mad_alu_fst_add          (mad_alu_fst_add         ),
  .mad_alu_imm_vld          (mad_alu_imm_vld         ),
  .mad_alu_rs1              (mad_alu_rs1             ),
  .mad_alu_rs1_cst_0        (mad_alu_rs1_cst_0       ),
  .mad_alu_rs1_vld          (mad_alu_rs1_vld         ),
  .mad_alu_rs2_cst_0        (mad_alu_rs2_cst_0       ),
  .mad_alu_rst              (mad_alu_rst             ),
  .mad_alu_rst_vld          (mad_alu_rst_vld         ),
  .oper_alu_rs1_reg         (oper_alu_rs1_reg        ),
  .oper_alu_rs2_imm         (oper_alu_rs2_imm        ),
  .oper_alu_rs2_reg         (oper_alu_rs2_reg        ),
  .pcgen_xx_cur_pc          (pcgen_xx_cur_pc         )
);


// &Instance("cr_iu_mad"); @70
cr_iu_mad  x_cr_iu_mad (
  .alu_mad_adder_of       (alu_mad_adder_of      ),
  .alu_mad_adder_rst      (alu_mad_adder_rst     ),
  .alu_mad_rst_cout       (alu_mad_rst_cout      ),
  .cp0_yy_clk_en          (cp0_yy_clk_en         ),
  .cpurst_b               (cpurst_b              ),
  .ctrl_mad_ex_data_sel   (ctrl_mad_ex_data_sel  ),
  .ctrl_mad_ex_sel        (ctrl_mad_ex_sel       ),
  .ctrl_mad_oper_mux_en   (ctrl_mad_oper_mux_en  ),
  .decd_mad_inst_div      (decd_mad_inst_div     ),
  .decd_mad_inst_divu     (decd_mad_inst_divu    ),
  .decd_mad_inst_mul      (decd_mad_inst_mul     ),
  .decd_mad_inst_mulh     (decd_mad_inst_mulh    ),
  .decd_mad_inst_mulhsu   (decd_mad_inst_mulhsu  ),
  .decd_mad_inst_mulhu    (decd_mad_inst_mulhu   ),
  .decd_mad_inst_rem      (decd_mad_inst_rem     ),
  .decd_mad_inst_remu     (decd_mad_inst_remu    ),
  .forever_cpuclk         (forever_cpuclk        ),
  .ifu_iu_ex_cnt          (ifu_iu_ex_cnt         ),
  .ifu_iu_ex_split_on     (ifu_iu_ex_split_on    ),
  .iu_lsu_imm_data        (iu_lsu_imm_data       ),
  .iu_lsu_imm_write_en    (iu_lsu_imm_write_en   ),
  .iu_yy_xx_flush         (iu_yy_xx_flush        ),
  .lsu_iu_mad_buf         (lsu_iu_mad_buf        ),
  .mad_alu_data_vld       (mad_alu_data_vld      ),
  .mad_alu_div_rs2        (mad_alu_div_rs2       ),
  .mad_alu_div_shift      (mad_alu_div_shift     ),
  .mad_alu_fst_add        (mad_alu_fst_add       ),
  .mad_alu_imm_vld        (mad_alu_imm_vld       ),
  .mad_alu_rs1            (mad_alu_rs1           ),
  .mad_alu_rs1_cst_0      (mad_alu_rs1_cst_0     ),
  .mad_alu_rs1_vld        (mad_alu_rs1_vld       ),
  .mad_alu_rs2_cst_0      (mad_alu_rs2_cst_0     ),
  .mad_alu_rst            (mad_alu_rst           ),
  .mad_alu_rst_vld        (mad_alu_rst_vld       ),
  .mad_ctrl_stall         (mad_ctrl_stall        ),
  .mad_ctrl_stall_noinput (mad_ctrl_stall_noinput),
  .mad_rbus_req           (mad_rbus_req          ),
  .oper_mad_rs1           (oper_mad_rs1          ),
  .oper_mad_rs2           (oper_mad_rs2          ),
  .pad_yy_gate_clk_en_b   (pad_yy_gate_clk_en_b  ),
  .randclk_mad_mod_en_w2  (randclk_mad_mod_en_w2 ),
  .retire_mad_ex_cancel   (retire_mad_ex_cancel  ),
  .wb_ctrl_stall          (wb_ctrl_stall         )
);


// &Instance("cr_iu_branch"); @72
cr_iu_branch  x_cr_iu_branch (
  .alu_branch_adder_rst                    (alu_branch_adder_rst                   ),
  .alu_branch_rst_sign                     (alu_branch_rst_sign                    ),
  .alu_branch_rst_unsign                   (alu_branch_rst_unsign                  ),
  .alu_branch_xor_rst                      (alu_branch_xor_rst                     ),
  .branch_alu_adder_cmp                    (branch_alu_adder_cmp                   ),
  .branch_alu_adder_sel                    (branch_alu_adder_sel                   ),
  .branch_alu_logic_nz                     (branch_alu_logic_nz                    ),
  .branch_alu_logic_sel                    (branch_alu_logic_sel                   ),
  .branch_alu_pc_sel                       (branch_alu_pc_sel                      ),
  .branch_ctrl_stall                       (branch_ctrl_stall                      ),
  .branch_pcgen_add_pc                     (branch_pcgen_add_pc                    ),
  .branch_pcgen_br_chgflw_vld              (branch_pcgen_br_chgflw_vld             ),
  .branch_pcgen_br_chgflw_vld_for_data     (branch_pcgen_br_chgflw_vld_for_data    ),
  .branch_pcgen_br_pc_chgflw_vld           (branch_pcgen_br_pc_chgflw_vld          ),
  .branch_pcgen_branch_chgflw_vld_for_data (branch_pcgen_branch_chgflw_vld_for_data),
  .branch_pcgen_jmp_chgflw_vld_for_data    (branch_pcgen_jmp_chgflw_vld_for_data   ),
  .branch_pcgen_reg_pc                     (branch_pcgen_reg_pc                    ),
  .branch_rbus_data                        (branch_rbus_data                       ),
  .branch_rbus_data_vld                    (branch_rbus_data_vld                   ),
  .branch_rbus_req                         (branch_rbus_req                        ),
  .branch_wb_cmp                           (branch_wb_cmp                          ),
  .branch_wb_jmp_reg                       (branch_wb_jmp_reg                      ),
  .ctrl_branch_ex_data_sel                 (ctrl_branch_ex_data_sel                ),
  .ctrl_branch_ex_sel                      (ctrl_branch_ex_sel                     ),
  .decd_branch_auipc                       (decd_branch_auipc                      ),
  .decd_branch_beq                         (decd_branch_beq                        ),
  .decd_branch_bge                         (decd_branch_bge                        ),
  .decd_branch_bgeu                        (decd_branch_bgeu                       ),
  .decd_branch_blt                         (decd_branch_blt                        ),
  .decd_branch_bltu                        (decd_branch_bltu                       ),
  .decd_branch_bne                         (decd_branch_bne                        ),
  .decd_branch_cbeqz                       (decd_branch_cbeqz                      ),
  .decd_branch_cbnez                       (decd_branch_cbnez                      ),
  .decd_branch_cj                          (decd_branch_cj                         ),
  .decd_branch_cjal                        (decd_branch_cjal                       ),
  .decd_branch_cjalr                       (decd_branch_cjalr                      ),
  .decd_branch_cjr                         (decd_branch_cjr                        ),
  .decd_branch_jal                         (decd_branch_jal                        ),
  .decd_branch_jalr                        (decd_branch_jalr                       ),
  .decd_xx_inst_32bit                      (decd_xx_inst_32bit                     ),
  .iu_had_chgflw_dst_pc                    (iu_had_chgflw_dst_pc                   ),
  .iu_had_chgflw_vld                       (iu_had_chgflw_vld                      ),
  .oper_branch_rs1_reg                     (oper_branch_rs1_reg                    ),
  .oper_branch_rs2_imm                     (oper_branch_rs2_imm                    ),
  .oper_branch_rs2_reg                     (oper_branch_rs2_reg                    ),
  .pcgen_xx_cur_pc                         (pcgen_xx_cur_pc                        ),
  .pcgen_xx_ibus_idle                      (pcgen_xx_ibus_idle                     ),
  .retire_branch_stall                     (retire_branch_stall                    ),
  .wb_branch_dep_ld                        (wb_branch_dep_ld                       ),
  .wb_ctrl_stall_without_hready            (wb_ctrl_stall_without_hready           )
);

// &Instance("cr_iu_bctm"); @74
// &Instance("cr_iu_special"); @76
cr_iu_special  x_cr_iu_special (
  .cp0_iu_cache_inv_done      (cp0_iu_cache_inv_done     ),
  .ctrl_special_ex_data_sel   (ctrl_special_ex_data_sel  ),
  .ctrl_special_ex_sel        (ctrl_special_ex_sel       ),
  .ctrl_special_expt_vec      (ctrl_special_expt_vec     ),
  .ctrl_special_expt_vld      (ctrl_special_expt_vld     ),
  .decd_special_fencei        (decd_special_fencei       ),
  .decd_special_icall         (decd_special_icall        ),
  .decd_special_icpa          (decd_special_icpa         ),
  .special_ctrl_stall         (special_ctrl_stall        ),
  .special_ctrl_stall_noinput (special_ctrl_stall_noinput),
  .special_pcgen_chgflw_vld   (special_pcgen_chgflw_vld  ),
  .special_rbus_expt_vec      (special_rbus_expt_vec     ),
  .special_rbus_expt_vld      (special_rbus_expt_vld     ),
  .special_rbus_flush         (special_rbus_flush        ),
  .special_rbus_req           (special_rbus_req          ),
  .special_retire_inst_wsc    (special_retire_inst_wsc   ),
  .wb_special_st_uncmplt      (wb_special_st_uncmplt     )
);


// &Instance("cr_iu_rbus"); @78
cr_iu_rbus  x_cr_iu_rbus (
  .alu_rbus_data              (alu_rbus_data             ),
  .alu_rbus_data_vld          (alu_rbus_data_vld         ),
  .alu_rbus_req               (alu_rbus_req              ),
  .branch_rbus_data           (branch_rbus_data          ),
  .branch_rbus_data_vld       (branch_rbus_data_vld      ),
  .branch_rbus_req            (branch_rbus_req           ),
  .cp0_iu_data                (cp0_iu_data               ),
  .cp0_iu_data_vld            (cp0_iu_data_vld           ),
  .cp0_iu_expt_vec            (cp0_iu_expt_vec           ),
  .cp0_iu_expt_vld            (cp0_iu_expt_vld           ),
  .cp0_iu_flush               (cp0_iu_flush              ),
  .cp0_iu_req                 (cp0_iu_req                ),
  .ctrl_alu_ex_data_sel       (ctrl_alu_ex_data_sel      ),
  .ctrl_branch_ex_data_sel    (ctrl_branch_ex_data_sel   ),
  .ctrl_cp0_ex_data_sel       (ctrl_cp0_ex_data_sel      ),
  .ctrl_lsu_ex_data_sel       (ctrl_lsu_ex_data_sel      ),
  .ctrl_mad_ex_data_sel       (ctrl_mad_ex_data_sel      ),
  .ctrl_special_ex_data_sel   (ctrl_special_ex_data_sel  ),
  .ctrl_xx_sp_adjust          (ctrl_xx_sp_adjust         ),
  .decd_xx_unit_special_sel   (decd_xx_unit_special_sel  ),
  .hs_split_iu_hs_retire_mask (hs_split_iu_hs_retire_mask),
  .ifu_iu_ex_int_spcu_mask    (ifu_iu_ex_int_spcu_mask   ),
  .ifu_iu_ex_rd_reg           (ifu_iu_ex_rd_reg          ),
  .lsu_iu_data                (lsu_iu_data               ),
  .lsu_iu_data_vld            (lsu_iu_data_vld           ),
  .lsu_iu_expt_vec            (lsu_iu_expt_vec           ),
  .lsu_iu_expt_vld            (lsu_iu_expt_vld           ),
  .lsu_iu_fast_retire         (lsu_iu_fast_retire        ),
  .lsu_iu_req                 (lsu_iu_req                ),
  .lsu_iu_store               (lsu_iu_store              ),
  .mad_alu_data_vld           (mad_alu_data_vld          ),
  .mad_ctrl_stall             (mad_ctrl_stall            ),
  .mad_rbus_req               (mad_rbus_req              ),
  .rbus_retire_cmplt          (rbus_retire_cmplt         ),
  .rbus_retire_expt_vec       (rbus_retire_expt_vec      ),
  .rbus_retire_expt_vld       (rbus_retire_expt_vld      ),
  .rbus_retire_flush          (rbus_retire_flush         ),
  .rbus_retire_split_inst     (rbus_retire_split_inst    ),
  .rbus_wb_cmplt              (rbus_wb_cmplt             ),
  .rbus_wb_data               (rbus_wb_data              ),
  .rbus_wb_dst_reg            (rbus_wb_dst_reg           ),
  .rbus_wb_inst_cmplt         (rbus_wb_inst_cmplt        ),
  .rbus_wb_load               (rbus_wb_load              ),
  .rbus_wb_store              (rbus_wb_store             ),
  .special_rbus_expt_vec      (special_rbus_expt_vec     ),
  .special_rbus_expt_vld      (special_rbus_expt_vld     ),
  .special_rbus_flush         (special_rbus_flush        ),
  .special_rbus_req           (special_rbus_req          ),
  .wb_rbus_lsu_vec            (wb_rbus_lsu_vec           ),
  .wb_rbus_st_aft_load        (wb_rbus_st_aft_load       ),
  .wb_xx_acc_err_after_retire (wb_xx_acc_err_after_retire)
);


// &Instance("cr_iu_retire"); @80
cr_iu_retire  x_cr_iu_retire (
  .clic_cpu_int_hv                      (clic_cpu_int_hv                     ),
  .clic_cpu_int_id                      (clic_cpu_int_id                     ),
  .clic_cpu_int_il                      (clic_cpu_int_il                     ),
  .clic_cpu_int_priv                    (clic_cpu_int_priv                   ),
  .clint_cpu_me_int                     (clint_cpu_me_int                    ),
  .cp0_iu_dbg_disable_for_tee           (cp0_iu_dbg_disable_for_tee          ),
  .cp0_iu_il                            (cp0_iu_il                           ),
  .cp0_iu_in_nmi                        (cp0_iu_in_nmi                       ),
  .cp0_iu_inst_mret                     (cp0_iu_inst_mret                    ),
  .cp0_iu_meie                          (cp0_iu_meie                         ),
  .cp0_iu_mie_for_int                   (cp0_iu_mie_for_int                  ),
  .cp0_iu_vec_mode                      (cp0_iu_vec_mode                     ),
  .cp0_iu_wfe_en                        (cp0_iu_wfe_en                       ),
  .cp0_yy_clk_en                        (cp0_yy_clk_en                       ),
  .cp0_yy_priv_mode                     (cp0_yy_priv_mode                    ),
  .cpurst_b                             (cpurst_b                            ),
  .ctrl_branch_ex_sel                   (ctrl_branch_ex_sel                  ),
  .ctrl_retire_ni_vld                   (ctrl_retire_ni_vld                  ),
  .decd_retire_cp0_inst                 (decd_retire_cp0_inst                ),
  .decd_retire_inst_mret                (decd_retire_inst_mret               ),
  .forever_cpuclk                       (forever_cpuclk                      ),
  .had_core_dbg_mode_req                (had_core_dbg_mode_req               ),
  .had_iu_bkpt_trace_en                 (had_iu_bkpt_trace_en                ),
  .had_iu_dr_set_req                    (had_iu_dr_set_req                   ),
  .had_iu_force_dbg_en                  (had_iu_force_dbg_en                 ),
  .had_iu_int_vld                       (had_iu_int_vld                      ),
  .had_iu_mbkpt_fsm_index_mbee          (had_iu_mbkpt_fsm_index_mbee         ),
  .had_iu_mem_bkpt_exp_req              (had_iu_mem_bkpt_exp_req             ),
  .had_iu_mem_bkpt_mask                 (had_iu_mem_bkpt_mask                ),
  .had_iu_mem_bkpt_req                  (had_iu_mem_bkpt_req                 ),
  .had_iu_rte_pc_sel                    (had_iu_rte_pc_sel                   ),
  .had_iu_trace_req                     (had_iu_trace_req                    ),
  .had_iu_trace_req_for_dbg_disable     (had_iu_trace_req_for_dbg_disable    ),
  .had_iu_xx_fdb                        (had_iu_xx_fdb                       ),
  .had_iu_xx_jdbreq                     (had_iu_xx_jdbreq                    ),
  .had_yy_xx_exit_dbg                   (had_yy_xx_exit_dbg                  ),
  .hs_split_iu_hs_retire_mask           (hs_split_iu_hs_retire_mask          ),
  .hs_split_iu_hs_switch_se             (hs_split_iu_hs_switch_se            ),
  .ifu_iu_ex_inst_dbg_disable           (ifu_iu_ex_inst_dbg_disable          ),
  .ifu_iu_ex_sp_oper                    (ifu_iu_ex_sp_oper                   ),
  .ifu_iu_ex_split_on                   (ifu_iu_ex_split_on                  ),
  .ifu_iu_ibus_idle                     (ifu_iu_ibus_idle                    ),
  .ifu_iu_inst_bkpt_dbg_occur_vld       (ifu_iu_inst_bkpt_dbg_occur_vld      ),
  .ifu_iu_inst_bkpt_dbgexp_occur_vld    (ifu_iu_inst_bkpt_dbgexp_occur_vld   ),
  .ifu_iu_inst_buf_inst_dbg_disable     (ifu_iu_inst_buf_inst_dbg_disable    ),
  .ifu_iu_inst_buf_inst_vld             (ifu_iu_inst_buf_inst_vld            ),
  .iu_cp0_epc                           (iu_cp0_epc                          ),
  .iu_cp0_epc_update                    (iu_cp0_epc_update                   ),
  .iu_cp0_expt_vld                      (iu_cp0_expt_vld                     ),
  .iu_cp0_int_vld                       (iu_cp0_int_vld                      ),
  .iu_cp0_lp_wk_int                     (iu_cp0_lp_wk_int                    ),
  .iu_cp0_mtval_updt_vld                (iu_cp0_mtval_updt_vld               ),
  .iu_cp0_nmi_vld                       (iu_cp0_nmi_vld                      ),
  .iu_cp0_nt_int_pending_vld            (iu_cp0_nt_int_pending_vld           ),
  .iu_had_adr_dbg_ack                   (iu_had_adr_dbg_ack                  ),
  .iu_had_data_bkpt_occur_vld           (iu_had_data_bkpt_occur_vld          ),
  .iu_had_dbg_disable_for_tee           (iu_had_dbg_disable_for_tee          ),
  .iu_had_dr_dbg_ack                    (iu_had_dr_dbg_ack                   ),
  .iu_had_expt_vld                      (iu_had_expt_vld                     ),
  .iu_had_fast_retire_acc_err_pc_update (iu_had_fast_retire_acc_err_pc_update),
  .iu_had_fast_retire_acc_err_pc_val    (iu_had_fast_retire_acc_err_pc_val   ),
  .iu_had_inst_bkpt_occur_vld           (iu_had_inst_bkpt_occur_vld          ),
  .iu_had_int_ack                       (iu_had_int_ack                      ),
  .iu_had_retire_with_had_int           (iu_had_retire_with_had_int          ),
  .iu_had_trace_occur_vld               (iu_had_trace_occur_vld              ),
  .iu_had_xx_bkpt_inst                  (iu_had_xx_bkpt_inst                 ),
  .iu_had_xx_dbg_ack                    (iu_had_xx_dbg_ack                   ),
  .iu_had_xx_mldst                      (iu_had_xx_mldst                     ),
  .iu_had_xx_retire                     (iu_had_xx_retire                    ),
  .iu_had_xx_retire_normal              (iu_had_xx_retire_normal             ),
  .iu_had_xx_retire_pc                  (iu_had_xx_retire_pc                 ),
  .iu_ifu_kill_inst                     (iu_ifu_kill_inst                    ),
  .iu_ifu_spcu_int_en                   (iu_ifu_spcu_int_en                  ),
  .iu_pad_inst_retire                   (iu_pad_inst_retire                  ),
  .iu_pad_inst_split                    (iu_pad_inst_split                   ),
  .iu_pad_retire_pc                     (iu_pad_retire_pc                    ),
  .iu_sys_lp_wk_int                     (iu_sys_lp_wk_int                    ),
  .iu_yy_xx_dbgon                       (iu_yy_xx_dbgon                      ),
  .iu_yy_xx_expt_vec                    (iu_yy_xx_expt_vec                   ),
  .iu_yy_xx_flush                       (iu_yy_xx_flush                      ),
  .iu_yy_xx_int_hv                      (iu_yy_xx_int_hv                     ),
  .iu_yy_xx_int_il                      (iu_yy_xx_int_il                     ),
  .iu_yy_xx_int_pending_hv              (iu_yy_xx_int_pending_hv             ),
  .iu_yy_xx_int_pending_id              (iu_yy_xx_int_pending_id             ),
  .iu_yy_xx_int_pending_il              (iu_yy_xx_int_pending_il             ),
  .iu_yy_xx_int_pending_priv            (iu_yy_xx_int_pending_priv           ),
  .iu_yy_xx_reg_rst_b                   (iu_yy_xx_reg_rst_b                  ),
  .iu_yy_xx_retire                      (iu_yy_xx_retire                     ),
  .lockup_retire_dbg_vld                (lockup_retire_dbg_vld               ),
  .lockup_retire_mask                   (lockup_retire_mask                  ),
  .lockup_retire_nmi_vld                (lockup_retire_nmi_vld               ),
  .lsu_iu_wb_acc_err                    (lsu_iu_wb_acc_err                   ),
  .lsu_iu_wb_cmplt                      (lsu_iu_wb_cmplt                     ),
  .nie_flush_chgflw                     (nie_flush_chgflw                    ),
  .pad_yy_gate_clk_en_b                 (pad_yy_gate_clk_en_b                ),
  .pcgen_retire_updt_pc                 (pcgen_retire_updt_pc                ),
  .pcgen_xx_cur_pc                      (pcgen_xx_cur_pc                     ),
  .randclk_retire_mod_en_w2             (randclk_retire_mod_en_w2            ),
  .rbus_retire_cmplt                    (rbus_retire_cmplt                   ),
  .rbus_retire_expt_vec                 (rbus_retire_expt_vec                ),
  .rbus_retire_expt_vld                 (rbus_retire_expt_vld                ),
  .rbus_retire_flush                    (rbus_retire_flush                   ),
  .rbus_retire_split_inst               (rbus_retire_split_inst              ),
  .rbus_wb_load                         (rbus_wb_load                        ),
  .rbus_wb_store                        (rbus_wb_store                       ),
  .retire_branch_stall                  (retire_branch_stall                 ),
  .retire_lockup_dbg_on                 (retire_lockup_dbg_on                ),
  .retire_lockup_dbg_vld                (retire_lockup_dbg_vld               ),
  .retire_lockup_expt_vld               (retire_lockup_expt_vld              ),
  .retire_lockup_inst_retire            (retire_lockup_inst_retire           ),
  .retire_lockup_nmi_vld                (retire_lockup_nmi_vld               ),
  .retire_lockup_retire_pc              (retire_lockup_retire_pc             ),
  .retire_mad_ex_cancel                 (retire_mad_ex_cancel                ),
  .retire_pcgen_curpc_update            (retire_pcgen_curpc_update           ),
  .retire_vector_expt_int_hv            (retire_vector_expt_int_hv           ),
  .retire_vector_expt_vld               (retire_vector_expt_vld              ),
  .retire_wb_dbg_in_ack                 (retire_wb_dbg_in_ack                ),
  .retire_wb_hs_err_epc_sel             (retire_wb_hs_err_epc_sel            ),
  .retire_wb_mem_bkpt_fast_retire       (retire_wb_mem_bkpt_fast_retire      ),
  .retire_xx_normal_retire              (retire_xx_normal_retire             ),
  .special_retire_inst_wsc              (special_retire_inst_wsc             ),
  .sysio_iu_nmi_int                     (sysio_iu_nmi_int                    ),
  .sysio_iu_wk_event                    (sysio_iu_wk_event                   ),
  .wb_retire_fast_retire_load_pc        (wb_retire_fast_retire_load_pc       ),
  .wb_xx_acc_err_after_retire           (wb_xx_acc_err_after_retire          ),
  .wb_xx_lsu_check_fail_after_retire    (wb_xx_lsu_check_fail_after_retire   )
);

// &Connect(.dbg_clk   (forever_cpuclk)); @87

// &Instance("cr_iu_wb"); @92
cr_iu_wb  x_cr_iu_wb (
  .branch_wb_cmp                     (branch_wb_cmp                    ),
  .branch_wb_jmp_reg                 (branch_wb_jmp_reg                ),
  .cp0_yy_clk_en                     (cp0_yy_clk_en                    ),
  .cp0_yy_priv_mode                  (cp0_yy_priv_mode                 ),
  .cpurst_b                          (cpurst_b                         ),
  .ctrl_alu_ex_data_sel              (ctrl_alu_ex_data_sel             ),
  .ctrl_mad_ex_data_sel              (ctrl_mad_ex_data_sel             ),
  .decd_wb_tval                      (decd_wb_tval                     ),
  .decd_xx_inst_32bit                (decd_xx_inst_32bit               ),
  .decd_xx_unit_special_sel          (decd_xx_unit_special_sel         ),
  .forever_cpuclk                    (forever_cpuclk                   ),
  .ifu_iu_ex_inst_vld                (ifu_iu_ex_inst_vld               ),
  .ifu_iu_ex_int_spcu_mask           (ifu_iu_ex_int_spcu_mask          ),
  .ifu_iu_ex_int_spcu_vld            (ifu_iu_ex_int_spcu_vld           ),
  .ifu_iu_ex_split_on                (ifu_iu_ex_split_on               ),
  .iu_cp0_expt_tval                  (iu_cp0_expt_tval                 ),
  .iu_had_flush                      (iu_had_flush                     ),
  .iu_had_xx_data                    (iu_had_xx_data                   ),
  .iu_had_xx_data_vld                (iu_had_xx_data_vld               ),
  .iu_ifu_wb_ldst                    (iu_ifu_wb_ldst                   ),
  .iu_lsu_stall_without_hready       (iu_lsu_stall_without_hready      ),
  .iu_lsu_wb_ldst                    (iu_lsu_wb_ldst                   ),
  .iu_lsu_wb_load                    (iu_lsu_wb_load                   ),
  .iu_lsu_wb_store                   (iu_lsu_wb_store                  ),
  .iu_pad_gpr_data                   (iu_pad_gpr_data                  ),
  .iu_pad_gpr_index                  (iu_pad_gpr_index                 ),
  .iu_pad_gpr_we                     (iu_pad_gpr_we                    ),
  .iu_yy_xx_dbgon                    (iu_yy_xx_dbgon                   ),
  .iu_yy_xx_flush                    (iu_yy_xx_flush                   ),
  .lsu_iu_addr                       (lsu_iu_addr                      ),
  .lsu_iu_addr_vld                   (lsu_iu_addr_vld                  ),
  .lsu_iu_fast_retire                (lsu_iu_fast_retire               ),
  .lsu_iu_wb_acc_err                 (lsu_iu_wb_acc_err                ),
  .lsu_iu_wb_bstack_chk_fail         (lsu_iu_wb_bstack_chk_fail        ),
  .lsu_iu_wb_cmplt                   (lsu_iu_wb_cmplt                  ),
  .lsu_iu_wb_data_vld                (lsu_iu_wb_data_vld               ),
  .lsu_iu_wb_load_data               (lsu_iu_wb_load_data              ),
  .misc_clk                          (misc_clk                         ),
  .oper_wb_rs1_equal_to_dst          (oper_wb_rs1_equal_to_dst         ),
  .oper_wb_rs2_equal_to_dst          (oper_wb_rs2_equal_to_dst         ),
  .pad_yy_gate_clk_en_b              (pad_yy_gate_clk_en_b             ),
  .pcgen_xx_cur_pc                   (pcgen_xx_cur_pc                  ),
  .randclk_wb_buf_mod_en_w32         (randclk_wb_buf_mod_en_w32        ),
  .randclk_wb_ctrl_mod_en_w2         (randclk_wb_ctrl_mod_en_w2        ),
  .randclk_wb_idx_mod_en_w5          (randclk_wb_idx_mod_en_w5         ),
  .rbus_wb_cmplt                     (rbus_wb_cmplt                    ),
  .rbus_wb_data                      (rbus_wb_data                     ),
  .rbus_wb_dst_reg                   (rbus_wb_dst_reg                  ),
  .rbus_wb_inst_cmplt                (rbus_wb_inst_cmplt               ),
  .rbus_wb_load                      (rbus_wb_load                     ),
  .rbus_wb_store                     (rbus_wb_store                    ),
  .retire_wb_dbg_in_ack              (retire_wb_dbg_in_ack             ),
  .retire_wb_hs_err_epc_sel          (retire_wb_hs_err_epc_sel         ),
  .retire_wb_mem_bkpt_fast_retire    (retire_wb_mem_bkpt_fast_retire   ),
  .wb_branch_dep_ld                  (wb_branch_dep_ld                 ),
  .wb_ctrl_stall                     (wb_ctrl_stall                    ),
  .wb_ctrl_stall_without_hready      (wb_ctrl_stall_without_hready     ),
  .wb_oper_fwd_data_no_load          (wb_oper_fwd_data_no_load         ),
  .wb_oper_fwd_en                    (wb_oper_fwd_en                   ),
  .wb_oper_write_data                (wb_oper_write_data               ),
  .wb_oper_write_en                  (wb_oper_write_en                 ),
  .wb_oper_write_idx                 (wb_oper_write_idx                ),
  .wb_oper_write_idx_for_dep         (wb_oper_write_idx_for_dep        ),
  .wb_pcgen_ldst_stall               (wb_pcgen_ldst_stall              ),
  .wb_pcgen_pc_updt_val              (wb_pcgen_pc_updt_val             ),
  .wb_pcgen_switch_ld_pc             (wb_pcgen_switch_ld_pc            ),
  .wb_rbus_lsu_vec                   (wb_rbus_lsu_vec                  ),
  .wb_rbus_st_aft_load               (wb_rbus_st_aft_load              ),
  .wb_retire_fast_retire_load_pc     (wb_retire_fast_retire_load_pc    ),
  .wb_special_st_uncmplt             (wb_special_st_uncmplt            ),
  .wb_top_machine_mode_clk_en        (wb_top_machine_mode_clk_en       ),
  .wb_top_machine_sp_en_clk_en       (wb_top_machine_sp_en_clk_en      ),
  .wb_top_secu_mode_clk_en           (wb_top_secu_mode_clk_en          ),
  .wb_top_sp_adjust_clk_en           (wb_top_sp_adjust_clk_en          ),
  .wb_vector_ldst_wait_cmplt         (wb_vector_ldst_wait_cmplt        ),
  .wb_xx_acc_err_after_retire        (wb_xx_acc_err_after_retire       ),
  .wb_xx_lsu_check_fail_after_retire (wb_xx_lsu_check_fail_after_retire)
);


// &Instance("cr_iu_pcgen"); @94
cr_iu_pcgen  x_cr_iu_pcgen (
  .branch_pcgen_add_pc                     (branch_pcgen_add_pc                    ),
  .branch_pcgen_br_chgflw_vld              (branch_pcgen_br_chgflw_vld             ),
  .branch_pcgen_br_chgflw_vld_for_data     (branch_pcgen_br_chgflw_vld_for_data    ),
  .branch_pcgen_br_pc_chgflw_vld           (branch_pcgen_br_pc_chgflw_vld          ),
  .branch_pcgen_branch_chgflw_vld_for_data (branch_pcgen_branch_chgflw_vld_for_data),
  .branch_pcgen_jmp_chgflw_vld_for_data    (branch_pcgen_jmp_chgflw_vld_for_data   ),
  .branch_pcgen_reg_pc                     (branch_pcgen_reg_pc                    ),
  .cp0_iu_epc_for_chgflw                   (cp0_iu_epc_for_chgflw                  ),
  .cp0_iu_flush_chgflw_vld                 (cp0_iu_flush_chgflw_vld                ),
  .cp0_iu_rte_chgflw_vld                   (cp0_iu_rte_chgflw_vld                  ),
  .cp0_iu_rte_chgflw_vld_for_data          (cp0_iu_rte_chgflw_vld_for_data         ),
  .cp0_yy_clk_en                           (cp0_yy_clk_en                          ),
  .cpurst_b                                (cpurst_b                               ),
  .forever_cpuclk                          (forever_cpuclk                         ),
  .had_iu_pc                               (had_iu_pc                              ),
  .had_iu_rte_pc_sel                       (had_iu_rte_pc_sel                      ),
  .had_yy_xx_exit_dbg                      (had_yy_xx_exit_dbg                     ),
  .hs_split_iu_unstack_chgflw              (hs_split_iu_unstack_chgflw             ),
  .ifu_iu_ibus_idle                        (ifu_iu_ibus_idle                       ),
  .ifu_iu_spcu_retire_mask                 (ifu_iu_spcu_retire_mask                ),
  .ifu_iu_xx_ibus_data                     (ifu_iu_xx_ibus_data                    ),
  .iu_ifu_addr                             (iu_ifu_addr                            ),
  .iu_ifu_data_fetch                       (iu_ifu_data_fetch                      ),
  .iu_ifu_data_fetch_for_data              (iu_ifu_data_fetch_for_data             ),
  .iu_ifu_inst_fetch                       (iu_ifu_inst_fetch                      ),
  .iu_ifu_inst_fetch_for_data              (iu_ifu_inst_fetch_for_data             ),
  .iu_ifu_inst_fetch_without_dbg_disable   (iu_ifu_inst_fetch_without_dbg_disable  ),
  .iu_yy_xx_flush                          (iu_yy_xx_flush                         ),
  .iu_yy_xx_retire                         (iu_yy_xx_retire                        ),
  .misc_clk                                (misc_clk                               ),
  .nie_flush_chgflw                        (nie_flush_chgflw                       ),
  .pad_yy_gate_clk_en_b                    (pad_yy_gate_clk_en_b                   ),
  .pcgen_ctrl_stall                        (pcgen_ctrl_stall                       ),
  .pcgen_retire_updt_pc                    (pcgen_retire_updt_pc                   ),
  .pcgen_top_abort_clk_en                  (pcgen_top_abort_clk_en                 ),
  .pcgen_vector_expt_taken                 (pcgen_vector_expt_taken                ),
  .pcgen_xx_cur_pc                         (pcgen_xx_cur_pc                        ),
  .pcgen_xx_ibus_idle                      (pcgen_xx_ibus_idle                     ),
  .randclk_pcgen_mod_en_w32                (randclk_pcgen_mod_en_w32               ),
  .retire_branch_stall                     (retire_branch_stall                    ),
  .retire_pcgen_curpc_update               (retire_pcgen_curpc_update              ),
  .retire_xx_normal_retire                 (retire_xx_normal_retire                ),
  .special_pcgen_chgflw_vld                (special_pcgen_chgflw_vld               ),
  .sysio_iu_rst_addr                       (sysio_iu_rst_addr                      ),
  .vector_pcgen_buf_vbr                    (vector_pcgen_buf_vbr                   ),
  .vector_pcgen_chgflw_vld                 (vector_pcgen_chgflw_vld                ),
  .vector_pcgen_cur_pc_vld                 (vector_pcgen_cur_pc_vld                ),
  .vector_pcgen_enter_addr                 (vector_pcgen_enter_addr                ),
  .vector_pcgen_ibus_req                   (vector_pcgen_ibus_req                  ),
  .vector_pcgen_reset_vld                  (vector_pcgen_reset_vld                 ),
  .wb_pcgen_ldst_stall                     (wb_pcgen_ldst_stall                    ),
  .wb_pcgen_pc_updt_val                    (wb_pcgen_pc_updt_val                   ),
  .wb_pcgen_switch_ld_pc                   (wb_pcgen_switch_ld_pc                  ),
  .wb_retire_fast_retire_load_pc           (wb_retire_fast_retire_load_pc          )
);


// &Instance("cr_iu_vector"); @96
cr_iu_vector  x_cr_iu_vector (
  .bmu_xx_ibus_acc_err        (bmu_xx_ibus_acc_err       ),
  .bmu_xx_ibus_data_vld       (bmu_xx_ibus_data_vld      ),
  .bmu_xx_ibus_grnt           (bmu_xx_ibus_grnt          ),
  .clk_en                     (clk_en                    ),
  .cp0_iu_vbr                 (cp0_iu_vbr                ),
  .cp0_vector_vec_err_vbr     (cp0_vector_vec_err_vbr    ),
  .cpurst_b                   (cpurst_b                  ),
  .ifu_iu_vector_ibus_in_idle (ifu_iu_vector_ibus_in_idle),
  .iu_bmu_vec_redirect        (iu_bmu_vec_redirect       ),
  .iu_cp0_syc_rst_b           (iu_cp0_syc_rst_b          ),
  .iu_ifu_inst_fetch_mask     (iu_ifu_inst_fetch_mask    ),
  .iu_ifu_reset_vld           (iu_ifu_reset_vld          ),
  .iu_yy_xx_reg_rst_b         (iu_yy_xx_reg_rst_b        ),
  .misc_clk                   (misc_clk                  ),
  .pcgen_vector_expt_taken    (pcgen_vector_expt_taken   ),
  .retire_vector_expt_int_hv  (retire_vector_expt_int_hv ),
  .retire_vector_expt_vld     (retire_vector_expt_vld    ),
  .vec_top_clk_en             (vec_top_clk_en            ),
  .vector_cp0_vec_err         (vector_cp0_vec_err        ),
  .vector_cp0_vec_err_epc     (vector_cp0_vec_err_epc    ),
  .vector_cp0_vec_succeed     (vector_cp0_vec_succeed    ),
  .vector_ctrl_stall          (vector_ctrl_stall         ),
  .vector_pcgen_buf_vbr       (vector_pcgen_buf_vbr      ),
  .vector_pcgen_chgflw_vld    (vector_pcgen_chgflw_vld   ),
  .vector_pcgen_cur_pc_vld    (vector_pcgen_cur_pc_vld   ),
  .vector_pcgen_enter_addr    (vector_pcgen_enter_addr   ),
  .vector_pcgen_ibus_req      (vector_pcgen_ibus_req     ),
  .vector_pcgen_reset_vld     (vector_pcgen_reset_vld    ),
  .wb_vector_ldst_wait_cmplt  (wb_vector_ldst_wait_cmplt )
);


// &Instance("cr_iu_ctrl"); @98
cr_iu_ctrl  x_cr_iu_ctrl (
  .branch_ctrl_stall          (branch_ctrl_stall         ),
  .cp0_iu_stall               (cp0_iu_stall              ),
  .cp0_iu_stall_noinput       (cp0_iu_stall_noinput      ),
  .cp0_yy_priv_mode           (cp0_yy_priv_mode          ),
  .ctrl_alu_ex_data_sel       (ctrl_alu_ex_data_sel      ),
  .ctrl_alu_ex_sel            (ctrl_alu_ex_sel           ),
  .ctrl_alu_mad_oper_mux_en   (ctrl_alu_mad_oper_mux_en  ),
  .ctrl_alu_oper_mux_en       (ctrl_alu_oper_mux_en      ),
  .ctrl_branch_ex_data_sel    (ctrl_branch_ex_data_sel   ),
  .ctrl_branch_ex_sel         (ctrl_branch_ex_sel        ),
  .ctrl_cp0_ex_data_sel       (ctrl_cp0_ex_data_sel      ),
  .ctrl_lsu_ex_data_sel       (ctrl_lsu_ex_data_sel      ),
  .ctrl_mad_ex_data_sel       (ctrl_mad_ex_data_sel      ),
  .ctrl_mad_ex_sel            (ctrl_mad_ex_sel           ),
  .ctrl_mad_oper_mux_en       (ctrl_mad_oper_mux_en      ),
  .ctrl_oper_lsu_data_sel     (ctrl_oper_lsu_data_sel    ),
  .ctrl_retire_ni_vld         (ctrl_retire_ni_vld        ),
  .ctrl_special_ex_data_sel   (ctrl_special_ex_data_sel  ),
  .ctrl_special_ex_sel        (ctrl_special_ex_sel       ),
  .ctrl_special_expt_vec      (ctrl_special_expt_vec     ),
  .ctrl_special_expt_vld      (ctrl_special_expt_vld     ),
  .ctrl_xx_sp_adjust          (ctrl_xx_sp_adjust         ),
  .decd_ctrl_alu_sel          (decd_ctrl_alu_sel         ),
  .decd_ctrl_branch_sel       (decd_ctrl_branch_sel      ),
  .decd_ctrl_cp0_sel          (decd_ctrl_cp0_sel         ),
  .decd_ctrl_expt_bkpt        (decd_ctrl_expt_bkpt       ),
  .decd_ctrl_expt_ecall       (decd_ctrl_expt_ecall      ),
  .decd_ctrl_expt_inv         (decd_ctrl_expt_inv        ),
  .decd_ctrl_expt_wsc         (decd_ctrl_expt_wsc        ),
  .decd_ctrl_lsu_sel          (decd_ctrl_lsu_sel         ),
  .decd_ctrl_mad_sel          (decd_ctrl_mad_sel         ),
  .decd_xx_unit_special_sel   (decd_xx_unit_special_sel  ),
  .hs_split_iu_ctrl_inst_vld  (hs_split_iu_ctrl_inst_vld ),
  .ifu_iu_ex_expt_vld         (ifu_iu_ex_expt_vld        ),
  .ifu_iu_ex_inst_vld         (ifu_iu_ex_inst_vld        ),
  .ifu_iu_ex_ni               (ifu_iu_ex_ni              ),
  .ifu_iu_ex_prvlg_expt_vld   (ifu_iu_ex_prvlg_expt_vld  ),
  .ifu_iu_ex_rand_vld         (ifu_iu_ex_rand_vld        ),
  .iu_cp0_ecall               (iu_cp0_ecall              ),
  .iu_cp0_ex_data_sel         (iu_cp0_ex_data_sel        ),
  .iu_cp0_ex_sel              (iu_cp0_ex_sel             ),
  .iu_cp0_oper_mux_en         (iu_cp0_oper_mux_en        ),
  .iu_hs_split_ex_stall       (iu_hs_split_ex_stall      ),
  .iu_ifu_ex_stall            (iu_ifu_ex_stall           ),
  .iu_ifu_ex_stall_noinput    (iu_ifu_ex_stall_noinput   ),
  .iu_ifu_ex_vld              (iu_ifu_ex_vld             ),
  .iu_ifu_wb_stall            (iu_ifu_wb_stall           ),
  .iu_lsu_ex_data_sel         (iu_lsu_ex_data_sel        ),
  .iu_lsu_ex_sel              (iu_lsu_ex_sel             ),
  .iu_lsu_oper_mux_en         (iu_lsu_oper_mux_en        ),
  .lsu_iu_stall               (lsu_iu_stall              ),
  .lsu_iu_stall_noinput       (lsu_iu_stall_noinput      ),
  .mad_ctrl_stall             (mad_ctrl_stall            ),
  .mad_ctrl_stall_noinput     (mad_ctrl_stall_noinput    ),
  .pcgen_ctrl_stall           (pcgen_ctrl_stall          ),
  .special_ctrl_stall         (special_ctrl_stall        ),
  .special_ctrl_stall_noinput (special_ctrl_stall_noinput),
  .vector_ctrl_stall          (vector_ctrl_stall         ),
  .wb_ctrl_stall              (wb_ctrl_stall             )
);


// &Instance("cr_iu_randclk"); @100
cr_iu_randclk  x_cr_iu_randclk (
  .randclk_mad_mod_en_w2       (randclk_mad_mod_en_w2      ),
  .randclk_oper_gpr_mod_en_w32 (randclk_oper_gpr_mod_en_w32),
  .randclk_pcgen_mod_en_w32    (randclk_pcgen_mod_en_w32   ),
  .randclk_retire_mod_en_w2    (randclk_retire_mod_en_w2   ),
  .randclk_wb_buf_mod_en_w32   (randclk_wb_buf_mod_en_w32  ),
  .randclk_wb_ctrl_mod_en_w2   (randclk_wb_ctrl_mod_en_w2  ),
  .randclk_wb_idx_mod_en_w5    (randclk_wb_idx_mod_en_w5   )
);


// &Instance("cr_iu_hs_split"); @102
cr_iu_hs_split  x_cr_iu_hs_split (
  .hs_split_iu_ctrl_inst_vld    (hs_split_iu_ctrl_inst_vld   ),
  .hs_split_iu_dp_inst_op       (hs_split_iu_dp_inst_op      ),
  .hs_split_iu_hs_retire_mask   (hs_split_iu_hs_retire_mask  ),
  .hs_split_iu_hs_switch_se     (hs_split_iu_hs_switch_se    ),
  .hs_split_iu_nsinst_gpr_rst_b (hs_split_iu_nsinst_gpr_rst_b),
  .hs_split_iu_unstack_chgflw   (hs_split_iu_unstack_chgflw  ),
  .iu_hs_split_ex_stall         (iu_hs_split_ex_stall        ),
  .iu_ifu_spcu_int_en           (iu_ifu_spcu_int_en          ),
  .split_ifctrl_hs_stall        (split_ifctrl_hs_stall       ),
  .split_ifctrl_hs_stall_part   (split_ifctrl_hs_stall_part  )
);


// &Instance("cr_iu_lockup"); @104
cr_iu_lockup  x_cr_iu_lockup (
  .cache_iu_lockup_ack       (cache_iu_lockup_ack      ),
  .cp0_iu_in_expt            (cp0_iu_in_expt           ),
  .cp0_iu_in_nmi             (cp0_iu_in_nmi            ),
  .cp0_iu_mret               (cp0_iu_mret              ),
  .cpurst_b                  (cpurst_b                 ),
  .ifu_iu_lockup_ack         (ifu_iu_lockup_ack        ),
  .iu_cache_lockup_req       (iu_cache_lockup_req      ),
  .iu_cp0_lockup_clr         (iu_cp0_lockup_clr        ),
  .iu_cp0_lockup_vld         (iu_cp0_lockup_vld        ),
  .iu_ifu_lockup_mask        (iu_ifu_lockup_mask       ),
  .iu_ifu_lockup_on          (iu_ifu_lockup_on         ),
  .iu_ifu_lockup_req         (iu_ifu_lockup_req        ),
  .iu_sysio_lockup_on        (iu_sysio_lockup_on       ),
  .lockup_retire_dbg_vld     (lockup_retire_dbg_vld    ),
  .lockup_retire_mask        (lockup_retire_mask       ),
  .lockup_retire_nmi_vld     (lockup_retire_nmi_vld    ),
  .misc_clk                  (misc_clk                 ),
  .retire_lockup_dbg_on      (retire_lockup_dbg_on     ),
  .retire_lockup_dbg_vld     (retire_lockup_dbg_vld    ),
  .retire_lockup_expt_vld    (retire_lockup_expt_vld   ),
  .retire_lockup_inst_retire (retire_lockup_inst_retire),
  .retire_lockup_nmi_vld     (retire_lockup_nmi_vld    ),
  .retire_lockup_retire_pc   (retire_lockup_retire_pc  )
);

// &Force("output","iu_yy_ssp_sel"); @106

// &Instance("cr_iu_security"); @110
assign iu_ifu_security_violation = 1'b0;

// &Force("output","iu_yy_xx_retire"); @116
// &Force("output","iu_cp0_expt_vld"); @117
// &Instance("cr_iu_prgsign"); @118
//fix signal for gate cell in CP0
//assign iu_cp0_prgsign_sign_vld = 1'b0;

// &ModuleEnd; @124
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_iu_vector(
  bmu_xx_ibus_acc_err,
  bmu_xx_ibus_data_vld,
  bmu_xx_ibus_grnt,
  clk_en,
  cp0_iu_vbr,
  cp0_vector_vec_err_vbr,
  cpurst_b,
  ifu_iu_vector_ibus_in_idle,
  iu_bmu_vec_redirect,
  iu_cp0_syc_rst_b,
  iu_ifu_inst_fetch_mask,
  iu_ifu_reset_vld,
  iu_yy_xx_reg_rst_b,
  misc_clk,
  pcgen_vector_expt_taken,
  retire_vector_expt_int_hv,
  retire_vector_expt_vld,
  vec_top_clk_en,
  vector_cp0_vec_err,
  vector_cp0_vec_err_epc,
  vector_cp0_vec_succeed,
  vector_ctrl_stall,
  vector_pcgen_buf_vbr,
  vector_pcgen_chgflw_vld,
  vector_pcgen_cur_pc_vld,
  vector_pcgen_enter_addr,
  vector_pcgen_ibus_req,
  vector_pcgen_reset_vld,
  wb_vector_ldst_wait_cmplt
);

// &Ports; @24
input           bmu_xx_ibus_acc_err;        
input           bmu_xx_ibus_data_vld;       
input           bmu_xx_ibus_grnt;           
input           clk_en;                     
input   [29:0]  cp0_iu_vbr;                 
input   [29:0]  cp0_vector_vec_err_vbr;     
input           cpurst_b;                   
input           ifu_iu_vector_ibus_in_idle; 
input           misc_clk;                   
input           pcgen_vector_expt_taken;    
input           retire_vector_expt_int_hv;  
input           retire_vector_expt_vld;     
input           wb_vector_ldst_wait_cmplt;  
output          iu_bmu_vec_redirect;        
output          iu_cp0_syc_rst_b;           
output          iu_ifu_inst_fetch_mask;     
output          iu_ifu_reset_vld;           
output          iu_yy_xx_reg_rst_b;         
output          vec_top_clk_en;             
output          vector_cp0_vec_err;         
output  [29:0]  vector_cp0_vec_err_epc;     
output          vector_cp0_vec_succeed;     
output          vector_ctrl_stall;          
output          vector_pcgen_buf_vbr;       
output          vector_pcgen_chgflw_vld;    
output          vector_pcgen_cur_pc_vld;    
output  [30:0]  vector_pcgen_enter_addr;    
output          vector_pcgen_ibus_req;      
output          vector_pcgen_reset_vld;     

// &Regs; @25
reg     [3 :0]  cur_state;                  
reg     [3 :0]  next_state;                 

// &Wires; @26
wire            bmu_xx_ibus_acc_err;        
wire            bmu_xx_ibus_data_vld;       
wire            bmu_xx_ibus_grnt;           
wire            clk_en;                     
wire    [29:0]  cp0_iu_vbr;                 
wire    [29:0]  cp0_vector_vec_err_vbr;     
wire            cpurst_b;                   
wire            expt_non_vec;               
wire            hs_split_iu_hs_stall_vector; 
wire            ifu_iu_vector_ibus_in_idle; 
wire            iu_bmu_vec_redirect;        
wire            iu_cp0_syc_rst_b;           
wire            iu_ifu_inst_fetch_mask;     
wire            iu_ifu_reset_vld;           
wire            iu_yy_xx_hs_acc_err;        
wire            iu_yy_xx_reg_rst_b;         
wire            misc_clk;                   
wire            pcgen_vector_expt_taken;    
wire            reg_rst_b;                  
wire            retire_vector_expt_int_hv;  
wire            retire_vector_expt_vld;     
wire            vec_top_clk_en;             
wire            vector_cp0_vec_err;         
wire    [29:0]  vector_cp0_vec_err_epc;     
wire            vector_cp0_vec_succeed;     
wire            vector_ctrl_stall;          
wire            vector_cur_pc_vld;          
wire            vector_pcgen_buf_vbr;       
wire            vector_pcgen_chgflw_vld;    
wire            vector_pcgen_cur_pc_vld;    
wire    [30:0]  vector_pcgen_enter_addr;    
wire            vector_pcgen_ibus_req;      
wire            vector_pcgen_reset_vld;     
wire            wb_vector_ldst_wait_cmplt;  

parameter IDLE        = 4'b0000;
parameter BUF_VBR     = 4'b0001;
parameter WAIT_IDLE   = 4'b0010;
parameter WAIT_GRANT  = 4'b0011;
parameter WAIT_DATA   = 4'b0100;
parameter NONVEC_WAIT = 4'b0101;
parameter NONVEC_WAIT_IDLE = 4'b0110;
parameter VEC_ERR     = 4'b0111;
parameter RESET       = 4'b1000;

//-----------------------------------------------------
// value for request address
//-----------------------------------------------------
assign vector_pcgen_enter_addr[30:1] = (cur_state == VEC_ERR) ? 
                                        cp0_vector_vec_err_vbr[29:0] 
                                        : cp0_iu_vbr[29:0];
assign vector_pcgen_enter_addr[0]    = 1'b0;

//-----------------------------------------------------
// exception service routine change flow
//-----------------------------------------------------
//the change flow pc will firstly update into current
//pc register, and than change flow from register,
//avoide memory to memory path
//==========================================================
//          Interface with ibus and IFU change flow
//==========================================================
assign iu_ifu_inst_fetch_mask = !(cur_state == IDLE);

assign vec_top_clk_en = (cur_state == IDLE)
                          && retire_vector_expt_vld
                     || (cur_state != IDLE)
                     || iu_yy_xx_hs_acc_err;

//the syc reset signal for registers
assign reg_rst_b =1'b1;

assign iu_yy_xx_reg_rst_b = reg_rst_b;
assign iu_cp0_syc_rst_b   = reg_rst_b;

//assign iu_sysyio_soft_rst = 1'b0;

assign iu_bmu_vec_redirect = 1'b0;
assign iu_yy_xx_hs_acc_err =1'b0;
assign hs_split_iu_hs_stall_vector = 1'b0;
// when in CLIC vector mode, the vector will start a statemachine
// to fetch the new vector entrence.
//-------------------FSM of vec logic-----------------
// State Description:
// IDLE       : no exception
// WAIT_IDLE  : wait ibus idle after exception
// WAIT_GRANT : hold request unitl ibus acknowledge grant
// WAIT_DATA  : wait transcmplt of ibus
// RESET      : reset state
//-----------------------------------------------------
always @(posedge misc_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    cur_state[3:0] <= RESET;
  else
    cur_state[3:0] <= next_state[3:0];
end
//-----------------------------------------------------
// State change signals
//-----------------------------------------------------
assign expt_non_vec  = !retire_vector_expt_int_hv ;
// &CombBeg; @117
always @( cur_state
       or iu_yy_xx_hs_acc_err
       or ifu_iu_vector_ibus_in_idle
       or bmu_xx_ibus_data_vld
       or pcgen_vector_expt_taken
       or bmu_xx_ibus_acc_err
       or expt_non_vec
       or hs_split_iu_hs_stall_vector
       or retire_vector_expt_vld
       or wb_vector_ldst_wait_cmplt
       or bmu_xx_ibus_grnt
       or clk_en)
begin
  case(cur_state)
  RESET       : if(clk_en)
                  next_state = IDLE;
                else
                  next_state = RESET;
  IDLE        : if((retire_vector_expt_vld))
                  next_state = expt_non_vec ? NONVEC_WAIT : BUF_VBR;
                else if(iu_yy_xx_hs_acc_err)
                  next_state = NONVEC_WAIT;
                else
                  next_state = IDLE;
  NONVEC_WAIT:  if(wb_vector_ldst_wait_cmplt)
                  next_state = NONVEC_WAIT;
                else if(iu_yy_xx_hs_acc_err)
                  next_state = NONVEC_WAIT;
                else if(hs_split_iu_hs_stall_vector)
                  next_state = NONVEC_WAIT;
                else 
                  next_state = NONVEC_WAIT_IDLE;
  NONVEC_WAIT_IDLE: if(pcgen_vector_expt_taken)
                  next_state = IDLE;
                    else
                  next_state = NONVEC_WAIT_IDLE;
  BUF_VBR     : if(wb_vector_ldst_wait_cmplt)
                  next_state = BUF_VBR;
                else if(iu_yy_xx_hs_acc_err)
                  next_state = NONVEC_WAIT;
                else if(hs_split_iu_hs_stall_vector)
                  next_state = BUF_VBR;
                else 
                  next_state = WAIT_IDLE;
  WAIT_IDLE   : if(ifu_iu_vector_ibus_in_idle && !bmu_xx_ibus_grnt)
                  next_state = WAIT_GRANT;
                else if(ifu_iu_vector_ibus_in_idle)
                  next_state = WAIT_DATA;
                else 
                  next_state = WAIT_IDLE;
  WAIT_GRANT  : if(bmu_xx_ibus_grnt)
                  next_state = WAIT_DATA;
                else
                  next_state = WAIT_GRANT;
  WAIT_DATA   : if(bmu_xx_ibus_data_vld)
                  next_state = IDLE;
                else if(bmu_xx_ibus_acc_err)
                  next_state = VEC_ERR;
                else
                  next_state = WAIT_DATA;
  VEC_ERR     : next_state   = IDLE;
  default     : next_state   = IDLE;
  endcase
// &CombEnd; @168
end

assign vector_pcgen_buf_vbr = ((cur_state == BUF_VBR)
                           && (next_state == WAIT_IDLE))
                           || ((cur_state == NONVEC_WAIT_IDLE)      //non vec vbr   
                               && (next_state == IDLE)) 
                           ||
                           (cur_state == VEC_ERR);            // vec error vbr
assign vector_pcgen_ibus_req = (cur_state == WAIT_IDLE)
                                && ifu_iu_vector_ibus_in_idle
                            || (cur_state == WAIT_GRANT);
//-----------------------------------------------------
// exception service routine change flow
//-----------------------------------------------------
//the change flow pc will firstly update into current
//pc register, and than change flow from register,
//avoide memory to memory path
assign vector_cur_pc_vld = (cur_state == VEC_ERR) ||    // the vec error
                           (cur_state == WAIT_DATA)
                           && bmu_xx_ibus_data_vld ||   // regular vec
                           ((cur_state == NONVEC_WAIT_IDLE)  // non vec mode
                           && (next_state == IDLE))
                           ;
assign vector_pcgen_cur_pc_vld = (cur_state == WAIT_DATA)
                                 && bmu_xx_ibus_data_vld;

//exception service routine request change flow after
//ibus transcmplt data valid
//if access error, vector will not change flow and vector
//state machine is back to IDLE, the normal instruction 
//after exception instruction will pipedown after vector
//stall clear
assign vector_pcgen_chgflw_vld = vector_cur_pc_vld;
assign vector_pcgen_reset_vld  = cur_state == RESET;
assign iu_ifu_reset_vld        = cur_state == RESET;

assign vector_ctrl_stall       = (cur_state!=IDLE);
assign vector_cp0_vec_err      = (cur_state == VEC_ERR);      
assign vector_cp0_vec_err_epc[29:0] = cp0_iu_vbr[29:0];
assign vector_cp0_vec_succeed   = (cur_state == WAIT_DATA)
                                 && bmu_xx_ibus_data_vld;
// &Force("ouput","vector_pcgen_cur_pc_vld"); @227

// &ModuleEnd; @229
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @26
module cr_iu_wb(
  branch_wb_cmp,
  branch_wb_jmp_reg,
  cp0_yy_clk_en,
  cp0_yy_priv_mode,
  cpurst_b,
  ctrl_alu_ex_data_sel,
  ctrl_mad_ex_data_sel,
  decd_wb_tval,
  decd_xx_inst_32bit,
  decd_xx_unit_special_sel,
  forever_cpuclk,
  ifu_iu_ex_inst_vld,
  ifu_iu_ex_int_spcu_mask,
  ifu_iu_ex_int_spcu_vld,
  ifu_iu_ex_split_on,
  iu_cp0_expt_tval,
  iu_had_flush,
  iu_had_xx_data,
  iu_had_xx_data_vld,
  iu_ifu_wb_ldst,
  iu_lsu_stall_without_hready,
  iu_lsu_wb_ldst,
  iu_lsu_wb_load,
  iu_lsu_wb_store,
  iu_pad_gpr_data,
  iu_pad_gpr_index,
  iu_pad_gpr_we,
  iu_yy_xx_dbgon,
  iu_yy_xx_flush,
  lsu_iu_addr,
  lsu_iu_addr_vld,
  lsu_iu_fast_retire,
  lsu_iu_wb_acc_err,
  lsu_iu_wb_bstack_chk_fail,
  lsu_iu_wb_cmplt,
  lsu_iu_wb_data_vld,
  lsu_iu_wb_load_data,
  misc_clk,
  oper_wb_rs1_equal_to_dst,
  oper_wb_rs2_equal_to_dst,
  pad_yy_gate_clk_en_b,
  pcgen_xx_cur_pc,
  randclk_wb_buf_mod_en_w32,
  randclk_wb_ctrl_mod_en_w2,
  randclk_wb_idx_mod_en_w5,
  rbus_wb_cmplt,
  rbus_wb_data,
  rbus_wb_dst_reg,
  rbus_wb_inst_cmplt,
  rbus_wb_load,
  rbus_wb_store,
  retire_wb_dbg_in_ack,
  retire_wb_hs_err_epc_sel,
  retire_wb_mem_bkpt_fast_retire,
  wb_branch_dep_ld,
  wb_ctrl_stall,
  wb_ctrl_stall_without_hready,
  wb_oper_fwd_data_no_load,
  wb_oper_fwd_en,
  wb_oper_write_data,
  wb_oper_write_en,
  wb_oper_write_idx,
  wb_oper_write_idx_for_dep,
  wb_pcgen_ldst_stall,
  wb_pcgen_pc_updt_val,
  wb_pcgen_switch_ld_pc,
  wb_rbus_lsu_vec,
  wb_rbus_st_aft_load,
  wb_retire_fast_retire_load_pc,
  wb_special_st_uncmplt,
  wb_top_machine_mode_clk_en,
  wb_top_machine_sp_en_clk_en,
  wb_top_secu_mode_clk_en,
  wb_top_sp_adjust_clk_en,
  wb_vector_ldst_wait_cmplt,
  wb_xx_acc_err_after_retire,
  wb_xx_lsu_check_fail_after_retire
);

// &Ports; @27
input           branch_wb_cmp;                            
input           branch_wb_jmp_reg;                        
input           cp0_yy_clk_en;                            
input   [1 :0]  cp0_yy_priv_mode;                         
input           cpurst_b;                                 
input           ctrl_alu_ex_data_sel;                     
input           ctrl_mad_ex_data_sel;                     
input   [31:0]  decd_wb_tval;                             
input           decd_xx_inst_32bit;                       
input           decd_xx_unit_special_sel;                 
input           forever_cpuclk;                           
input           ifu_iu_ex_inst_vld;                       
input           ifu_iu_ex_int_spcu_mask;                  
input           ifu_iu_ex_int_spcu_vld;                   
input           ifu_iu_ex_split_on;                       
input           iu_yy_xx_dbgon;                           
input           iu_yy_xx_flush;                           
input   [31:0]  lsu_iu_addr;                              
input           lsu_iu_addr_vld;                          
input           lsu_iu_fast_retire;                       
input           lsu_iu_wb_acc_err;                        
input           lsu_iu_wb_bstack_chk_fail;                
input           lsu_iu_wb_cmplt;                          
input           lsu_iu_wb_data_vld;                       
input   [31:0]  lsu_iu_wb_load_data;                      
input           misc_clk;                                 
input           oper_wb_rs1_equal_to_dst;                 
input           oper_wb_rs2_equal_to_dst;                 
input           pad_yy_gate_clk_en_b;                     
input   [30:0]  pcgen_xx_cur_pc;                          
input           randclk_wb_buf_mod_en_w32;                
input           randclk_wb_ctrl_mod_en_w2;                
input           randclk_wb_idx_mod_en_w5;                 
input           rbus_wb_cmplt;                            
input   [31:0]  rbus_wb_data;                             
input   [4 :0]  rbus_wb_dst_reg;                          
input           rbus_wb_inst_cmplt;                       
input           rbus_wb_load;                             
input           rbus_wb_store;                            
input           retire_wb_dbg_in_ack;                     
input           retire_wb_hs_err_epc_sel;                 
input           retire_wb_mem_bkpt_fast_retire;           
output  [31:0]  iu_cp0_expt_tval;                         
output          iu_had_flush;                             
output  [31:0]  iu_had_xx_data;                           
output          iu_had_xx_data_vld;                       
output          iu_ifu_wb_ldst;                           
output          iu_lsu_stall_without_hready;              
output          iu_lsu_wb_ldst;                           
output          iu_lsu_wb_load;                           
output          iu_lsu_wb_store;                          
output  [31:0]  iu_pad_gpr_data;                          
output  [4 :0]  iu_pad_gpr_index;                         
output          iu_pad_gpr_we;                            
output          wb_branch_dep_ld;                         
output          wb_ctrl_stall;                            
output          wb_ctrl_stall_without_hready;             
output  [31:0]  wb_oper_fwd_data_no_load;                 
output          wb_oper_fwd_en;                           
output  [31:0]  wb_oper_write_data;                       
output          wb_oper_write_en;                         
output  [4 :0]  wb_oper_write_idx;                        
output  [4 :0]  wb_oper_write_idx_for_dep;                
output          wb_pcgen_ldst_stall;                      
output  [30:0]  wb_pcgen_pc_updt_val;                     
output          wb_pcgen_switch_ld_pc;                    
output  [4 :0]  wb_rbus_lsu_vec;                          
output          wb_rbus_st_aft_load;                      
output  [30:0]  wb_retire_fast_retire_load_pc;            
output          wb_special_st_uncmplt;                    
output          wb_top_machine_mode_clk_en;               
output          wb_top_machine_sp_en_clk_en;              
output          wb_top_secu_mode_clk_en;                  
output          wb_top_sp_adjust_clk_en;                  
output          wb_vector_ldst_wait_cmplt;                
output          wb_xx_acc_err_after_retire;               
output          wb_xx_lsu_check_fail_after_retire;        

// &Regs; @28
reg     [1 :0]  cur_state;                                
reg             ex_wb_split_on;                           
reg     [1 :0]  next_state;                               
reg     [31:0]  wb_data_buffer;                           
reg     [4 :0]  wb_idx_buffer;                            
reg             wb_inst_32;                               
reg             wb_int_spcu_inst;                         
reg             wb_int_spcu_mask;                         

// &Wires; @29
wire            branch_wb_cmp;                            
wire            cp0_yy_clk_en;                            
wire            cp0_yy_machine_mode;                      
wire            cp0_yy_machine_mode_post;                 
wire    [1 :0]  cp0_yy_priv_mode;                         
wire            cpurst_b;                                 
wire            ctrl_alu_ex_data_sel;                     
wire            ctrl_mad_ex_data_sel;                     
wire    [31:0]  decd_wb_tval;                             
wire            decd_xx_inst_32bit;                       
wire            decd_xx_unit_special_sel;                 
wire            forever_cpuclk;                           
wire            ifu_iu_ex_inst_vld;                       
wire            ifu_iu_ex_int_spcu_mask;                  
wire            ifu_iu_ex_int_spcu_vld;                   
wire            ifu_iu_ex_split_on;                       
wire    [31:0]  iu_cp0_expt_tval;                         
wire            iu_had_flush;                             
wire    [31:0]  iu_had_xx_data;                           
wire            iu_had_xx_data_vld;                       
wire            iu_ifu_wb_ldst;                           
wire            iu_lsu_stall_without_hready;              
wire            iu_lsu_wb_ldst;                           
wire            iu_lsu_wb_load;                           
wire            iu_lsu_wb_store;                          
wire    [31:0]  iu_pad_gpr_data;                          
wire    [4 :0]  iu_pad_gpr_index;                         
wire            iu_pad_gpr_we;                            
wire            iu_yy_xx_dbgon;                           
wire            iu_yy_xx_flush;                           
wire            ldst_stall;                               
wire    [31:0]  lsu_iu_addr;                              
wire            lsu_iu_addr_vld;                          
wire            lsu_iu_fast_retire;                       
wire            lsu_iu_wb_acc_err;                        
wire            lsu_iu_wb_bstack_chk_fail;                
wire            lsu_iu_wb_cmplt;                          
wire            lsu_iu_wb_data_vld;                       
wire    [31:0]  lsu_iu_wb_load_data;                      
wire            misc_clk;                                 
wire    [1 :0]  next_cmplt_state;                         
wire            oper_wb_rs1_equal_to_dst;                 
wire            oper_wb_rs2_equal_to_dst;                 
wire            pad_yy_gate_clk_en_b;                     
wire    [30:0]  pcgen_xx_cur_pc;                          
wire    [30:0]  pcgen_xx_cur_pc_mask;                     
wire            randclk_wb_buf_mod_en_w32;                
wire            randclk_wb_ctrl_mod_en_w2;                
wire            randclk_wb_idx_mod_en_w5;                 
wire            rbus_wb_cmplt;                            
wire    [31:0]  rbus_wb_data;                             
wire    [4 :0]  rbus_wb_dst_reg;                          
wire            rbus_wb_inst_cmplt;                       
wire            rbus_wb_load;                             
wire            rbus_wb_store;                            
wire            retire_wb_dbg_in_ack;                     
wire            retire_wb_hs_err_epc_sel;                 
wire            retire_wb_mem_bkpt_fast_retire;           
wire            wb_acc_err_after_retire;                  
wire            wb_alu_or_load_wen;                       
wire            wb_branch_dep_ld;                         
wire            wb_buf_stall;                             
wire            wb_buf_stall_without_hready;              
wire            wb_check_fail_after_retire;               
wire            wb_clk;                                   
wire            wb_clk_en;                                
wire            wb_cmplt_write_back;                      
wire            wb_ctrl_load_fwd_non_alu;                 
wire            wb_ctrl_stall;                            
wire            wb_ctrl_stall_without_bctm;               
wire            wb_ctrl_stall_without_bctm_without_hready; 
wire            wb_ctrl_stall_without_hready;             
wire            wb_data_buf_0_16_update;                  
wire            wb_data_buf_16_0_clk;                     
wire            wb_data_buf_16_0_clk_en;                  
wire    [31:0]  wb_data_buffer_post;                      
wire            wb_data_buffer_update;                    
wire            wb_dst_reg_22;                            
wire            wb_dst_reg_23;                            
wire            wb_dst_reg_24;                            
wire            wb_dst_reg_25;                            
wire            wb_dst_reg_30;                            
wire            wb_dst_reg_high_16;                       
wire            wb_dst_reg_valid;                         
wire            wb_ex_cmplt;                              
wire            wb_fast_retire_pc_mask;                   
wire    [1 :0]  wb_fast_retire_pc_offset;                 
wire            wb_idx_buf_3_0_clk;                       
wire            wb_idx_buf_3_0_clk_en;                    
wire            wb_idx_buf_3_0_update;                    
wire            wb_idx_buf_update;                        
wire    [4 :0]  wb_idx_for_dep;                           
wire            wb_int_spcu_epc_mask;                     
wire            wb_int_spcu_expt_mask;                    
wire            wb_ldst;                                  
wire            wb_load_fwd_mad;                          
wire    [31:0]  wb_oper_fwd_data_no_load;                 
wire            wb_oper_fwd_en;                           
wire            wb_oper_machine_mode;                     
wire    [31:0]  wb_oper_write_data;                       
wire            wb_oper_write_en;                         
wire    [4 :0]  wb_oper_write_idx;                        
wire    [4 :0]  wb_oper_write_idx_for_dep;                
wire            wb_pcgen_ldst_stall;                      
wire    [30:0]  wb_pcgen_pc_updt_val;                     
wire            wb_pcgen_switch_ld_pc;                    
wire    [4 :0]  wb_rbus_lsu_vec;                          
wire            wb_rbus_st_aft_load;                      
wire    [30:0]  wb_retire_fast_retire_load_pc;            
wire            wb_sp_wen_stall;                          
wire            wb_special_st_uncmplt;                    
wire            wb_store_aft_load;                        
wire            wb_top_machine_mode_clk_en;               
wire            wb_top_machine_sp_en_clk_en;              
wire            wb_top_secu_mode_clk_en;                  
wire            wb_top_sp_adjust_clk_en;                  
wire            wb_uncmplt_load;                          
wire            wb_uncmplt_store;                         
wire            wb_vector_ldst_wait_cmplt;                
wire            wb_write_back;                            
wire    [31:0]  wb_write_back_data;                       
wire    [31:0]  wb_write_back_data_without_pol;           
wire            wb_write_back_en;                         
wire            wb_xx_acc_err_after_retire;               
wire            wb_xx_lsu_check_fail_after_retire;        



// &Force("bus","rbus_wb_dst_reg",4,0); @52
// //&Force("input", "cp0_yy_intsp_sel_post"); @97
// &Force("input", "ifu_iu_ex_int_spcu_vld"); @98
// &Force("input", "retire_wb_mem_bkpt_fast_retire"); @99
// //&Force("input", "retire_wb_acked_int"); @100
// //&Force("input", "cp0_yy_machine_sp_en"); @101
// &Force("input", "lsu_iu_addr_vld"); @119



//==========================================================
//             With Load Fast Retire Implement
//==========================================================

parameter IDLE  = 2'b00;
parameter LOAD  = 2'b11;
parameter STORE = 2'b10;
parameter ALU   = 2'b01;

//==========================================================
//                 Instance of Gated Cell  
//==========================================================
//1.wb_data_buffer[4:0] is reused by uncompleted load inst to buffer data size,
//  this kind of situation seldom happens.So we can sepearate wb_data_buffer[31:0]
//  into two parts:wb_data_buffer[4:0] and wb_data_buffer[31:5] to reduce power
//2.Depending on principle of locality ,data for a certain program varies in certain
//  range, so we can separate wb_data_buffer[31:5] into two part to reduce power

assign wb_clk_en = (cur_state != IDLE) || wb_ex_cmplt;
// &Instance("gated_clk_cell", "x_wb_gated_clk"); @149
gated_clk_cell  x_wb_gated_clk (
  .clk_in                    (forever_cpuclk           ),
  .clk_out                   (wb_clk                   ),
  .external_en               (1'b0                     ),
  .global_en                 (cp0_yy_clk_en            ),
  .local_en                  (wb_clk_en                ),
  .module_en                 (randclk_wb_ctrl_mod_en_w2),
  .pad_yy_gate_clk_en_b      (pad_yy_gate_clk_en_b     )
);

// &Connect(.clk_in      (forever_cpuclk), @150
//          .external_en (1'b0), @151
//          .global_en   (cp0_yy_clk_en), @152
//          .module_en   (randclk_wb_ctrl_mod_en_w2), @153
//          .local_en    (wb_clk_en), @154
//          .clk_out     (wb_clk)); @155

assign wb_data_buf_16_0_clk_en = wb_data_buf_0_16_update;
// &Instance("gated_clk_cell", "x_wb_data_buf_16_0_gated_clk"); @158
gated_clk_cell  x_wb_data_buf_16_0_gated_clk (
  .clk_in                    (forever_cpuclk           ),
  .clk_out                   (wb_data_buf_16_0_clk     ),
  .external_en               (1'b0                     ),
  .global_en                 (cp0_yy_clk_en            ),
  .local_en                  (wb_data_buf_16_0_clk_en  ),
  .module_en                 (randclk_wb_buf_mod_en_w32),
  .pad_yy_gate_clk_en_b      (pad_yy_gate_clk_en_b     )
);

// &Connect(.clk_in      (forever_cpuclk), @159
//          .external_en (1'b0), @160
//          .global_en   (cp0_yy_clk_en), @161
//          .module_en   (randclk_wb_buf_mod_en_w32), @162
//          .local_en    (wb_data_buf_16_0_clk_en), @163
//          .clk_out     (wb_data_buf_16_0_clk)); @164

assign wb_idx_buf_update     = wb_cmplt_write_back || wb_uncmplt_load;
assign wb_idx_buf_3_0_update = wb_idx_buf_update;
assign wb_idx_buf_3_0_clk_en = wb_idx_buf_3_0_update;
// &Instance("gated_clk_cell", "x_idx_buf_3_0_gated_clk"); @169
gated_clk_cell  x_idx_buf_3_0_gated_clk (
  .clk_in                   (forever_cpuclk          ),
  .clk_out                  (wb_idx_buf_3_0_clk      ),
  .external_en              (1'b0                    ),
  .global_en                (cp0_yy_clk_en           ),
  .local_en                 (wb_idx_buf_3_0_clk_en   ),
  .module_en                (randclk_wb_idx_mod_en_w5),
  .pad_yy_gate_clk_en_b     (pad_yy_gate_clk_en_b    )
);

// &Connect(.clk_in      (forever_cpuclk), @170
//          .external_en (1'b0), @171
//          .global_en   (cp0_yy_clk_en), @172
//          .module_en   (randclk_wb_idx_mod_en_w5), @173
//          .local_en    (wb_idx_buf_3_0_clk_en), @174
//          .clk_out     (wb_idx_buf_3_0_clk)); @175

//==========================================================
//       Write Buffer Control State Machine
//==========================================================

//-----------------------------------------------------
// buffer the write back data for retired instruction
//-----------------------------------------------------

//-------------------FSM of wb logic------------------
// State Description:
// IDLE  : there is no retired instruction needs write back
// LOAD  : there is load instruction waiting for data
// STORE : buffer store instruction write data
// ALU   : buffer other instruction needs to write back
//-----------------------------------------------------

always @(posedge wb_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    cur_state[1:0] <= IDLE;
  else
    cur_state[1:0] <= next_state[1:0];
end

//-----------------------------------------------------
// State change signals
//-----------------------------------------------------
assign wb_uncmplt_load     = rbus_wb_load;
assign wb_uncmplt_store    = rbus_wb_store;
assign wb_cmplt_write_back = rbus_wb_cmplt;

assign wb_ex_cmplt         = wb_uncmplt_load
                             || wb_uncmplt_store
                             || wb_cmplt_write_back;

assign next_cmplt_state[1:0] = {2{wb_uncmplt_load}}     & LOAD
                             | {2{wb_uncmplt_store}}    & STORE
                             | {2{wb_cmplt_write_back}} & ALU;

// &CombBeg; @216
always @( cur_state
       or wb_ex_cmplt
       or next_cmplt_state
       or lsu_iu_wb_cmplt)
begin
  case(cur_state)
  IDLE       : if(wb_ex_cmplt)
                 next_state = next_cmplt_state;
               else
                 next_state = IDLE;
  LOAD       : if(lsu_iu_wb_cmplt && wb_ex_cmplt)
                 next_state = next_cmplt_state;
               else if(lsu_iu_wb_cmplt && !wb_ex_cmplt)
                 next_state = IDLE;
               else
                 next_state = LOAD;
  STORE      : if(lsu_iu_wb_cmplt && wb_ex_cmplt)
                 next_state = next_cmplt_state;
               else if(lsu_iu_wb_cmplt && !wb_ex_cmplt)
                 next_state = IDLE;
               else
                 next_state = STORE;
  ALU        : if(wb_ex_cmplt)
                 next_state = next_cmplt_state;
               else
                 next_state = IDLE;
  default    :   next_state = IDLE;
  endcase
// &CombEnd; @240
end

//-----------------------------------------------------
//                  Control Signals
//-----------------------------------------------------
//in ALU state write back data, and in LOAD state, write
//back data when complete
assign wb_alu_or_load_wen = ((cur_state == LOAD)
                               && lsu_iu_wb_cmplt
                               && lsu_iu_wb_data_vld
                          || (cur_state == ALU));
assign wb_write_back_en   = wb_alu_or_load_wen 
                            && wb_dst_reg_valid;
//ALU and LOAD need to write back
assign wb_write_back      = ((cur_state == ALU)
                             || (cur_state == LOAD))
                            && wb_dst_reg_valid;
//when wb is load, it takes lsu load data process logic
//assign iu_lsu_wb_load_vld = (cur_state == LOAD);

//when the ld or st is fast retired, the expt signal maybe come
//back after the inst retire
assign wb_acc_err_after_retire = ((cur_state == LOAD) || (cur_state == STORE)) 
                                  && lsu_iu_wb_cmplt
                                  && lsu_iu_wb_acc_err
                                  && !wb_int_spcu_expt_mask;

assign wb_xx_acc_err_after_retire = wb_acc_err_after_retire;

assign wb_ldst = ((cur_state == LOAD) || (cur_state == STORE));
assign iu_lsu_wb_ldst = wb_ldst;

assign iu_ifu_wb_ldst = wb_ldst;

assign iu_lsu_wb_load  = cur_state == LOAD;
assign iu_lsu_wb_store = cur_state == STORE;

//assign wb_special_store = cur_state == STORE;
assign wb_special_st_uncmplt = cur_state == STORE && !lsu_iu_wb_cmplt;

// &Force("output","wb_oper_machine_mode"); @286
assign wb_oper_machine_mode = 1'b0;

assign cp0_yy_machine_mode_post   = cp0_yy_machine_mode;
assign wb_top_machine_mode_clk_en = cp0_yy_machine_mode_post ^ wb_oper_machine_mode;
assign cp0_yy_machine_mode        = cp0_yy_priv_mode[1:0] == 2'b11;
// //&Force("output","wb_intsp_sel"); @305
//always @(posedge misc_clk or negedge cpurst_b)
//begin
//  if(!cpurst_b)
//    wb_intsp_sel <= 1'b1;
//  else if(rbus_wb_inst_cmplt)
//    wb_intsp_sel <= cp0_yy_intsp_sel_post;
//end 
//
//assign wb_top_sp_sel_clk_en = cp0_yy_intsp_sel_post  ^  wb_intsp_sel ;

// &Force("output","wb_oper_secu_mode"); @317
assign wb_top_secu_mode_clk_en = 1'b0;
assign wb_top_machine_sp_en_clk_en = 1'b0;
// &Force("output","wb_oper_machine_sp_en"); @342
always @(posedge misc_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    wb_int_spcu_inst <= 1'b0;
  else if(rbus_wb_inst_cmplt)
    wb_int_spcu_inst <= ifu_iu_ex_int_spcu_vld;
end

always @(posedge misc_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    wb_int_spcu_mask <= 1'b0;
  else if(rbus_wb_inst_cmplt)
    wb_int_spcu_mask <= ifu_iu_ex_int_spcu_mask;
end

assign wb_int_spcu_epc_mask  = wb_int_spcu_inst;
assign wb_int_spcu_expt_mask = wb_int_spcu_mask;

assign wb_top_sp_adjust_clk_en = (ifu_iu_ex_int_spcu_vld ^ wb_int_spcu_inst)
                              || (ifu_iu_ex_int_spcu_mask ^ wb_int_spcu_mask);


always @(posedge wb_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    wb_inst_32 <= 1'b0;
  else if(lsu_iu_fast_retire)
    wb_inst_32 <= decd_xx_inst_32bit;
end

always @(posedge wb_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    ex_wb_split_on <= 1'b0;
  else if(lsu_iu_fast_retire)
    ex_wb_split_on <= ifu_iu_ex_split_on;
end

//for check fail of fast retired ld st
assign wb_check_fail_after_retire = ((cur_state == LOAD) || (cur_state == STORE))
                                     && lsu_iu_wb_bstack_chk_fail;
assign wb_xx_lsu_check_fail_after_retire = wb_check_fail_after_retire;


//==========================================================
//          Interface with IU EX stage modules
//==========================================================

//-----------------------------------------------------
//                    stall signal
//-----------------------------------------------------
//write buffer will stall when load/store not complete
assign wb_buf_stall  = ((cur_state == LOAD) || (cur_state == STORE))
                         && !(lsu_iu_wb_cmplt
                              && !lsu_iu_wb_acc_err 
                              && !lsu_iu_wb_bstack_chk_fail)
                    || retire_wb_dbg_in_ack;

assign wb_buf_stall_without_hready = ((cur_state == LOAD)    || (cur_state == STORE))
                                       && (lsu_iu_wb_acc_err || lsu_iu_wb_bstack_chk_fail)
                                  || retire_wb_dbg_in_ack;

assign ldst_stall = ((cur_state == LOAD) || (cur_state == STORE))
                             && !lsu_iu_wb_cmplt;
assign wb_pcgen_ldst_stall = ldst_stall;
//==========================================================
//              Write Back Buffer Implement
//==========================================================

//-----------------------------------------------------
//                  Write Back Buffer
//-----------------------------------------------------
assign wb_data_buffer_post[31:0]  = lsu_iu_addr_vld ? lsu_iu_addr[31:0]
                                                    : rbus_wb_data[31:0];
assign wb_data_buffer_update = wb_cmplt_write_back
                            || rbus_wb_inst_cmplt
                            || lsu_iu_addr_vld && !ldst_stall;
assign wb_store_aft_load     = (cur_state == LOAD)
                               && (wb_uncmplt_store || (next_state == IDLE));
assign wb_rbus_st_aft_load   = wb_store_aft_load;
assign wb_rbus_lsu_vec[4:0] = cur_state == LOAD ? 5'b00101 : 5'b00111;

assign wb_data_buf_0_16_update = wb_data_buffer_update || wb_store_aft_load;
always @(posedge wb_data_buf_16_0_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    wb_data_buffer[31:0] <= 32'b0;
  else if(wb_data_buf_0_16_update)
    wb_data_buffer[31:0] <= wb_data_buffer_post[31:0];
  else
    wb_data_buffer[31:0] <= wb_data_buffer[31:0];
end 



//-----------------------------------------------------
//              Buffer info of fast retire ld st
//-----------------------------------------------------
//when ld st is fast retired, the size and split info need to be buffered
assign wb_fast_retire_pc_mask = !ex_wb_split_on && lsu_iu_wb_acc_err
                             && !wb_int_spcu_epc_mask;
assign wb_fast_retire_pc_offset[1:0] = {2{wb_fast_retire_pc_mask}}
                                     & {wb_inst_32,!wb_inst_32} | {retire_wb_hs_err_epc_sel,1'b0};// this is for wsc, when wsc with hs-err
assign pcgen_xx_cur_pc_mask[30:8] = pcgen_xx_cur_pc[30:8];
assign pcgen_xx_cur_pc_mask[7:0]  = pcgen_xx_cur_pc[7:0]
                                  & {8{lsu_iu_wb_acc_err || retire_wb_hs_err_epc_sel}};
assign wb_retire_fast_retire_load_pc[30:0] = pcgen_xx_cur_pc_mask[30:0] 
                                              - {29'b0, wb_fast_retire_pc_offset[1:0]};

//when int is vld when ld st is fast retired, the expt SM needs to wait for
//the cmplt from dbus
assign wb_vector_ldst_wait_cmplt = ((cur_state == LOAD) || (cur_state == STORE))
                                   && !lsu_iu_wb_cmplt;

//-----------------------------------------------------
//              Write Back Index Buffer
//-----------------------------------------------------
always @(posedge wb_idx_buf_3_0_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    wb_idx_buffer[4:0] <= 5'b0;
  else if(wb_idx_buf_3_0_update)
    wb_idx_buffer[4:0] <= rbus_wb_dst_reg[4:0];
  else
    wb_idx_buffer[4:0] <= wb_idx_buffer[4:0];
end
//assign wb_cr_oper = 1'b0;

//if write back to undefined register, the write buffer should
//perform no write back, to avoid incorrect forward
assign wb_dst_reg_30            = 1'b0;
assign wb_dst_reg_25            = 1'b0;
assign wb_dst_reg_24            = 1'b0;
assign wb_dst_reg_23            = 1'b0;
assign wb_dst_reg_22            = 1'b0;

assign wb_dst_reg_high_16       = wb_idx_buffer[4]
                               && !wb_dst_reg_30
                               && !wb_dst_reg_25
                               && !wb_dst_reg_24
                               && !wb_dst_reg_23
                               && !wb_dst_reg_22;
assign wb_dst_reg_valid         = !wb_dst_reg_high_16 && wb_idx_buffer[4:0] != 5'd0;

//==========================================================
//              Write Back Data Selection
//==========================================================
assign wb_write_back_data[31:0] = (cur_state == LOAD)
                                  ? lsu_iu_wb_load_data[31:0]
                                  : wb_data_buffer[31:0];
assign wb_write_back_data_without_pol[31:0] = wb_write_back_data[31:0];

//==========================================================
//              Write Back Signal for GPR
//==========================================================
assign wb_oper_write_en         = wb_write_back_en;

//assign iu_cp0_epsr_wen_for_nir  = 1'b0;
//assign iu_cp0_epc_wen_for_nir   = 1'b0;
//assign iu_cp0_updt_val[31:0]    = 32'b0;

assign wb_pcgen_switch_ld_pc      = 1'b0;
assign wb_pcgen_pc_updt_val[30:0] = 31'b0;


assign wb_oper_write_idx[4:0]   = wb_idx_buffer[4:0];
assign wb_idx_for_dep[4:0] = wb_idx_buffer[4:0];
assign wb_oper_write_idx_for_dep[4:0] = wb_idx_for_dep[4:0];
assign wb_oper_write_data[31:0] = wb_write_back_data[31:0];

//for operand forward without load value
assign wb_oper_fwd_en           = wb_write_back;
assign wb_oper_fwd_data_no_load[31:0] = wb_data_buffer[31:0];

//for pad signal
assign iu_pad_gpr_we            = wb_write_back_en;
assign iu_pad_gpr_index[4:0]    = wb_idx_buffer[4:0];
assign iu_pad_gpr_data[31:0]    = wb_write_back_data_without_pol[31:0];

//for had signal
assign iu_had_xx_data_vld       = wb_write_back_en && iu_yy_xx_dbgon;
assign iu_had_xx_data[31:0]     = wb_write_back_data_without_pol[31:0];
assign iu_had_flush             = iu_yy_xx_flush;

//==========================================================
//                Invalid Forward Path
//==========================================================
//-----------------------------------------------------
//      Forward from load to EX unit expt ALU/MAD
//-----------------------------------------------------
//indicate control logic that EX stage following sources
//should not forward from load:
//1.jump register expcept jmp x1
//2.load/store base register
//3.cp0
//4.jmpix rx

// &Force("input", "branch_wb_jmp_reg"); @624
assign wb_ctrl_load_fwd_non_alu = (cur_state == LOAD)
                               && (oper_wb_rs1_equal_to_dst && ifu_iu_ex_inst_vld
                               || (oper_wb_rs2_equal_to_dst 
                               && (ctrl_alu_ex_data_sel || ctrl_mad_ex_data_sel || branch_wb_cmp))
                                     );

assign wb_branch_dep_ld = wb_ctrl_load_fwd_non_alu;
assign wb_load_fwd_mad = 1'b0;

assign wb_sp_wen_stall = 1'b0;
//==========================================================
//                  Control stall signal
//==========================================================
//1.write buffer will stall when load/store not complete
//2.jump register source cannot forward from load value
//  set stall in this condition
//3.svbr source cannot forward from all instructon to bctm
//  (ifdef BCTM)
assign wb_ctrl_stall_without_bctm = wb_buf_stall
                       || wb_ctrl_load_fwd_non_alu
                       || wb_load_fwd_mad
                       || wb_sp_wen_stall;
assign wb_ctrl_stall_without_bctm_without_hready = wb_buf_stall_without_hready
                                                || wb_ctrl_load_fwd_non_alu
                                                || wb_load_fwd_mad
                                                || wb_sp_wen_stall;

assign wb_ctrl_stall = wb_ctrl_stall_without_bctm;
assign wb_ctrl_stall_without_hready = wb_ctrl_stall_without_bctm_without_hready;

// &Force("output","wb_ctrl_stall_without_hready"); @656
assign iu_lsu_stall_without_hready = wb_ctrl_stall_without_hready;

// for exception tval to CP0
assign iu_cp0_expt_tval[31:0] = wb_acc_err_after_retire ? wb_data_buffer[31:0]:
                                decd_xx_unit_special_sel ? decd_wb_tval[31:0]:
                                retire_wb_mem_bkpt_fast_retire ? wb_data_buffer[31:0]:
                                                                 lsu_iu_addr[31:0];


// &ModuleEnd; @667
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @22
module cr_lsu_ctrl(
  bmu_lsu_acc_err,
  bmu_lsu_bstack_chk_fail,
  bmu_lsu_data_vld,
  bmu_lsu_grnt,
  bmu_lsu_trans_cmplt,
  cpurst_b,
  ctrl_dp_ldst_info_buf_reuse,
  ctrl_dp_ldst_req_grnt,
  ctrl_dp_store_buffer_updt,
  ctrl_top_req_en,
  dp_ctrl_misalign,
  iu_lsu_ex_data_sel,
  iu_lsu_ex_sel,
  iu_lsu_ex_store,
  iu_lsu_oper_mux_en,
  iu_lsu_stall_without_hready,
  iu_lsu_wb_ldst,
  iu_lsu_wb_load,
  iu_lsu_wb_store,
  iu_yy_xx_flush,
  lsu_bmu_addr_check_fail,
  lsu_bmu_idle,
  lsu_bmu_req,
  lsu_bmu_req_without_cmplt,
  lsu_bmu_sg_chk_fail,
  lsu_bmu_wfd1,
  lsu_had_addr_vld,
  lsu_had_ex_cmplt,
  lsu_inst_store,
  lsu_iu_data_vld,
  lsu_iu_expt_vec,
  lsu_iu_expt_vld,
  lsu_iu_fast_retire,
  lsu_iu_req,
  lsu_iu_stall,
  lsu_iu_stall_noinput,
  lsu_iu_wb_acc_err,
  lsu_iu_wb_bstack_chk_fail,
  lsu_iu_wb_cmplt,
  lsu_iu_wb_data_vld,
  lsu_iu_wfd,
  sm_clk,
  unalign_ctrl_not_last_beat,
  unalign_ctrl_stall,
  unalign_xx_split_on
);

// &Ports; @23
input          bmu_lsu_acc_err;            
input          bmu_lsu_bstack_chk_fail;    
input          bmu_lsu_data_vld;           
input          bmu_lsu_grnt;               
input          bmu_lsu_trans_cmplt;        
input          cpurst_b;                   
input          dp_ctrl_misalign;           
input          iu_lsu_ex_data_sel;         
input          iu_lsu_ex_sel;              
input          iu_lsu_ex_store;            
input          iu_lsu_oper_mux_en;         
input          iu_lsu_stall_without_hready; 
input          iu_lsu_wb_ldst;             
input          iu_lsu_wb_load;             
input          iu_lsu_wb_store;            
input          iu_yy_xx_flush;             
input          sm_clk;                     
input          unalign_ctrl_not_last_beat; 
input          unalign_ctrl_stall;         
input          unalign_xx_split_on;        
output         ctrl_dp_ldst_info_buf_reuse; 
output         ctrl_dp_ldst_req_grnt;      
output         ctrl_dp_store_buffer_updt;  
output         ctrl_top_req_en;            
output         lsu_bmu_addr_check_fail;    
output         lsu_bmu_idle;               
output         lsu_bmu_req;                
output         lsu_bmu_req_without_cmplt;  
output         lsu_bmu_sg_chk_fail;        
output         lsu_bmu_wfd1;               
output         lsu_had_addr_vld;           
output         lsu_had_ex_cmplt;           
output         lsu_inst_store;             
output         lsu_iu_data_vld;            
output  [4:0]  lsu_iu_expt_vec;            
output         lsu_iu_expt_vld;            
output         lsu_iu_fast_retire;         
output         lsu_iu_req;                 
output         lsu_iu_stall;               
output         lsu_iu_stall_noinput;       
output         lsu_iu_wb_acc_err;          
output         lsu_iu_wb_bstack_chk_fail;  
output         lsu_iu_wb_cmplt;            
output         lsu_iu_wb_data_vld;         
output         lsu_iu_wfd;                 

// &Regs; @24
reg            cur_state;                  
reg            next_state;                 

// &Wires; @25
wire           bmu_lsu_acc_err;            
wire           bmu_lsu_bstack_chk_fail;    
wire           bmu_lsu_data_vld;           
wire           bmu_lsu_grnt;               
wire           bmu_lsu_trans_cmplt;        
wire           cpurst_b;                   
wire           ctrl_dp_ldst_info_buf_reuse; 
wire           ctrl_dp_ldst_req_grnt;      
wire           ctrl_dp_store_buffer_updt;  
wire           ctrl_top_req_en;            
wire           dp_ctrl_misalign;           
wire           fast_retire_grnt;           
wire           idle_retire;                
wire           iu_lsu_ex_data_sel;         
wire           iu_lsu_ex_sel;              
wire           iu_lsu_ex_store;            
wire           iu_lsu_oper_mux_en;         
wire           iu_lsu_stall_without_hready; 
wire           iu_lsu_wb_ldst;             
wire           iu_lsu_wb_load;             
wire           iu_lsu_wb_store;            
wire           iu_yy_xx_flush;             
wire           lsu_addr_chk_fail;          
wire           lsu_bmu_addr_check_fail;    
wire           lsu_bmu_idle;               
wire           lsu_bmu_req;                
wire           lsu_bmu_req_without_cmplt;  
wire           lsu_bmu_sg_chk_fail;        
wire           lsu_bmu_wfd1;               
wire           lsu_dbus_req;               
wire           lsu_fast_retire;            
wire           lsu_had_addr_vld;           
wire           lsu_had_ex_cmplt;           
wire           lsu_inst_store;             
wire           lsu_iu_data_vld;            
wire    [4:0]  lsu_iu_expt_vec;            
wire           lsu_iu_expt_vld;            
wire           lsu_iu_fast_retire;         
wire           lsu_iu_req;                 
wire           lsu_iu_req_wait_data;       
wire           lsu_iu_stall;               
wire           lsu_iu_stall_noinput;       
wire           lsu_iu_wb_acc_err;          
wire           lsu_iu_wb_bstack_chk_fail;  
wire           lsu_iu_wb_cmplt;            
wire           lsu_iu_wb_data_vld;         
wire           lsu_iu_wfd;                 
wire           lsu_sel_without_cmplt;      
wire           lsu_sel_without_hready;     
wire           lsu_trans_cmplt;            
wire           lsu_wb_acc_err;             
wire           sm_clk;                     
wire           unalign_ctrl_not_last_beat; 
wire           unalign_ctrl_stall;         
wire           unalign_xx_split_on;        


parameter IDLE       = 1'b0;
parameter WAIT_DATA  = 1'b1;

//==========================================================
//                 Instance of Gated Cell  
//==========================================================
assign ctrl_top_req_en = (cur_state == IDLE) && (next_state == WAIT_DATA)
                      || (cur_state != IDLE);
//&Instance("gated_clk_cell", "x_req_gated_clk");
// //&Connect(.clk_in      (forever_cpuclk), @36
// //         .external_en (1'b0), @37
// //         .global_en   (cp0_yy_clk_en), @38
// //         .module_en   (randclk_ctrl_req_mod_en_w2), @39
// //         .local_en    (req_en), @40
// //         .clk_out     (reqclk)); @41

// &Instance("gated_clk_cell", "x_bsp_gated_clk"); @48
// &Connect(.clk_in      (forever_cpuclk), @49
//          .external_en (1'b0), @50
//          .global_en   (cp0_yy_clk_en), @51
//          .module_en   (randclk_ctrl_bsp_mod_en_w2), @52
//          .local_en    (bsp_en), @53
//          .clk_out     (bspclk)); @54

parameter MISL_VEC=5'b00100, MISS_VEC=5'b00110,
          ACCL_VEC=5'b00101, ACCS_VEC=5'b00111;

//==========================================================
//               request to d-bus
//==========================================================

//-----------------------------------------------
// address check before request
//-----------------------------------------------
assign lsu_addr_chk_fail = 1'b0;

//-----------------------------------------------
// request control flow signals
//-----------------------------------------------
//assign lsu_sel = iu_lsu_ex_sel && !dp_ctrl_misalign;
assign lsu_sel_without_hready = iu_lsu_ex_data_sel && !dp_ctrl_misalign
                                && !iu_lsu_stall_without_hready;
assign lsu_bmu_addr_check_fail = lsu_addr_chk_fail;

assign lsu_sel_without_cmplt = iu_lsu_ex_data_sel && !dp_ctrl_misalign;

// &Force("output","lsu_inst_store"); @85
assign lsu_inst_store = iu_lsu_oper_mux_en && iu_lsu_ex_store;

assign lsu_fast_retire = !unalign_xx_split_on;

assign fast_retire_grnt = lsu_fast_retire && bmu_lsu_grnt;


//-----------------------------------------------
//   Handling the dbus request signals
//-----------------------------------------------

//-----------------------------------------------------
// Request the dbus until dbus acknowledge grant
//-----------------------------------------------------

//-------------------FSM of req logic-----------------
// State Description:
// IDLE       : no load/instruction or misalign
// WAIT_DATA  : wait transcmplt of dbus
//-----------------------------------------------------

always @(posedge sm_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    cur_state <= IDLE;
  else if(iu_yy_xx_flush)
    cur_state <= IDLE;
  else
    cur_state <= next_state;
end

// &CombBeg; @132
always @( cur_state
       or bmu_lsu_grnt
       or lsu_sel_without_hready
       or iu_lsu_ex_sel
       or lsu_fast_retire
       or iu_lsu_wb_ldst
       or lsu_trans_cmplt)
begin
  case(cur_state)
  IDLE       : if(lsu_sel_without_hready)
                 begin
                   if(bmu_lsu_grnt)
                     begin
                       if(!iu_lsu_ex_sel || !lsu_fast_retire)
                         next_state = WAIT_DATA;
                       else
                         next_state = IDLE;
                     end
                   else
                     next_state = IDLE;
                 end
               else
                 next_state = IDLE;
  WAIT_DATA  : if(lsu_trans_cmplt)
                 begin
                   if(!iu_lsu_wb_ldst || lsu_fast_retire)
                     next_state = IDLE;
                   else
                     next_state = WAIT_DATA;
                 end
               else
                 next_state = WAIT_DATA;
  default    :   next_state = IDLE;
  endcase
// &CombEnd; @159
end

//-------------------control signal by lpmd FSM-------------
assign lsu_trans_cmplt      = bmu_lsu_trans_cmplt;
//request signal will hold from LSU is selected without misalign
//in IDLE state, to bmu signal grant
assign lsu_dbus_req     = (cur_state == IDLE) && lsu_sel_without_hready;
assign lsu_bmu_req = lsu_dbus_req;
assign lsu_bmu_req_without_cmplt = (cur_state == IDLE) && lsu_sel_without_cmplt;
// &Force("output","lsu_bmu_idle"); @168
assign lsu_bmu_idle = !iu_lsu_wb_ldst || (cur_state == IDLE) && lsu_trans_cmplt;
assign lsu_bmu_wfd1 = iu_lsu_wb_ldst ^ (cur_state == WAIT_DATA);
// &Force("output","lsu_iu_expt_vec"); @175

//cmplt signal in IDLE state
assign idle_retire          = fast_retire_grnt || dp_ctrl_misalign;
//rbus request signal
// &Force("output","lsu_iu_req"); @181
assign lsu_iu_req           =    (cur_state == IDLE)
                                   && iu_lsu_ex_sel && idle_retire
                              || lsu_iu_req_wait_data;

//when WB has ldst and acc err happens, the ldst in EX will be invalid
assign lsu_wb_acc_err = iu_lsu_wb_ldst && bmu_lsu_acc_err; 
assign lsu_iu_req_wait_data  =   (cur_state == WAIT_DATA)
                                   && lsu_trans_cmplt 
                                   && !lsu_wb_acc_err
                                   && (lsu_fast_retire 
                                       || !iu_lsu_wb_ldst
                                          && (!unalign_ctrl_not_last_beat
                                              || bmu_lsu_acc_err
                                              || bmu_lsu_bstack_chk_fail)
                                      );

//the fast retire signal used to indicate lsu fast retire
// &Force("output","lsu_iu_fast_retire"); @200
assign lsu_iu_fast_retire   =   (cur_state == IDLE)
                                   && iu_lsu_ex_sel
                                   && fast_retire_grnt
                                   && !dp_ctrl_misalign
                             || (cur_state == WAIT_DATA)
                                   && lsu_trans_cmplt
                                   && !lsu_wb_acc_err
                                   && lsu_fast_retire;

//the buf reuse signal indicate the store buffer reuse which cannot fast retire
//unlike fast retire store, in this condition, the wb state machine does not
//wait for store transcmplt
assign ctrl_dp_store_buffer_updt   = lsu_dbus_req
                                     && lsu_inst_store 
                                     && bmu_lsu_grnt;
// &Force("output","ctrl_dp_ldst_info_buf_reuse"); @218
assign ctrl_dp_ldst_info_buf_reuse = lsu_dbus_req
                                       && bmu_lsu_grnt
                                       && lsu_bmu_idle
                                  || (cur_state == WAIT_DATA)
                                       && iu_lsu_wb_ldst
                                       && lsu_trans_cmplt
                                       && !bmu_lsu_acc_err;
assign ctrl_dp_ldst_req_grnt = 1'b0;

// &Force("output","ctrl_dp_ldst_info_buf_reuse"); @238



assign lsu_iu_stall         = (cur_state == IDLE)
                                 && iu_lsu_ex_sel && !idle_retire
//                           || (cur_state == WAIT_GRNT)
//                                 && !(bmu_lsu_grnt
//                                      && iu_lsu_ex_sel
//                                      && lsu_fast_retire)
                           || (cur_state == WAIT_DATA)
                                 && (!lsu_trans_cmplt
                                     || iu_lsu_wb_ldst && !lsu_fast_retire)
                           || unalign_ctrl_stall;
assign lsu_iu_stall_noinput = (cur_state == IDLE)
                                 && iu_lsu_ex_data_sel
                           || unalign_ctrl_stall;

assign lsu_iu_data_vld      = (cur_state == WAIT_DATA) 
                              && bmu_lsu_data_vld
                              && !iu_lsu_wb_ldst
                              && !lsu_fast_retire;

assign lsu_iu_expt_vld      = (cur_state == WAIT_DATA)
                              && bmu_lsu_acc_err
                              && !iu_lsu_wb_ldst
                              && !lsu_fast_retire
                           || dp_ctrl_misalign;

assign lsu_iu_expt_vec[4:0] = {5{dp_ctrl_misalign && !lsu_inst_store}} & MISL_VEC 
                            | {5{dp_ctrl_misalign &&  lsu_inst_store}} & MISS_VEC
                            | {5{cur_state && iu_lsu_wb_load}}         & ACCL_VEC 
                            | {5{cur_state && iu_lsu_wb_store}}        & ACCS_VEC;

assign lsu_iu_wfd = (cur_state == WAIT_DATA);


//==========================================================
//                    interface to had
//==========================================================
assign lsu_had_addr_vld   = lsu_dbus_req && bmu_lsu_grnt;
assign lsu_had_ex_cmplt   = lsu_iu_req;

//==========================================================
//          Complete signals for Write Back Buffer
//==========================================================
assign lsu_iu_wb_cmplt    = bmu_lsu_trans_cmplt;
assign lsu_iu_wb_data_vld = bmu_lsu_data_vld;
assign lsu_iu_wb_acc_err  = bmu_lsu_acc_err;
assign lsu_iu_wb_bstack_chk_fail = bmu_lsu_bstack_chk_fail;

assign lsu_bmu_sg_chk_fail  = 1'b0;

// &ModuleEnd; @344
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_lsu_dp(
  bmu_lsu_data,
  cp0_yy_be_v1,
  cp0_yy_be_v2,
  cp0_yy_clk_en,
  cp0_yy_machine_mode_aft_dbg,
  cpurst_b,
  ctrl_dp_ldst_info_buf_reuse,
  ctrl_dp_ldst_req_grnt,
  ctrl_dp_store_buffer_updt,
  dp_ctrl_misalign,
  forever_cpuclk,
  iu_lsu_adder_rst,
  iu_lsu_base,
  iu_lsu_data,
  iu_lsu_ex_byte,
  iu_lsu_ex_data_sel,
  iu_lsu_ex_half,
  iu_lsu_ex_uns,
  iu_lsu_imm_data,
  iu_lsu_imm_write_en,
  iu_lsu_offset,
  iu_lsu_oper_mux_en,
  iu_lsu_rs2,
  lsu_bmu_addr,
  lsu_bmu_prot,
  lsu_bmu_size,
  lsu_bmu_store_error,
  lsu_bmu_wdata,
  lsu_bmu_write,
  lsu_had_addr,
  lsu_had_st,
  lsu_inst_store,
  lsu_iu_addr,
  lsu_iu_addr_vld,
  lsu_iu_alu_sel,
  lsu_iu_data,
  lsu_iu_mad_buf,
  lsu_iu_store,
  lsu_iu_wb_load_data,
  pad_yy_gate_clk_en_b,
  pmp_lsu_acc_scu,
  randclk_dp_size_buf_mod_en_w5,
  sysmap_lsu_acc_ca,
  unalign_dp_first_req,
  unalign_dp_load_data_byte1_to_byte1,
  unalign_dp_load_data_byte1_to_byte2,
  unalign_dp_load_data_byte1_to_byte3,
  unalign_dp_load_data_byte1_to_byte4,
  unalign_dp_load_data_byte2_to_byte1,
  unalign_dp_load_data_byte2_to_byte2,
  unalign_dp_load_data_byte2_to_byte3,
  unalign_dp_load_data_byte2_to_byte4,
  unalign_dp_load_data_byte3_to_byte1,
  unalign_dp_load_data_byte3_to_byte2,
  unalign_dp_load_data_byte3_to_byte3,
  unalign_dp_load_data_byte3_to_byte4,
  unalign_dp_load_data_byte4_to_byte1,
  unalign_dp_load_data_byte4_to_byte2,
  unalign_dp_load_data_byte4_to_byte3,
  unalign_dp_load_data_byte4_to_byte4,
  unalign_dp_store_data_byte1_to_byte1,
  unalign_dp_store_data_byte1_to_byte2,
  unalign_dp_store_data_byte1_to_byte3,
  unalign_dp_store_data_byte1_to_byte4,
  unalign_dp_store_data_byte2_to_byte1,
  unalign_dp_store_data_byte2_to_byte2,
  unalign_dp_store_data_byte2_to_byte3,
  unalign_dp_store_data_byte2_to_byte4,
  unalign_dp_store_data_byte3_to_byte1,
  unalign_dp_store_data_byte3_to_byte2,
  unalign_dp_store_data_byte3_to_byte3,
  unalign_dp_store_data_byte3_to_byte4,
  unalign_dp_store_data_byte4_to_byte1,
  unalign_dp_store_data_byte4_to_byte2,
  unalign_dp_store_data_byte4_to_byte3,
  unalign_dp_store_data_byte4_to_byte4
);

// &Ports; @24
input   [31:0]  bmu_lsu_data;                        
input           cp0_yy_be_v1;                        
input           cp0_yy_be_v2;                        
input           cp0_yy_clk_en;                       
input           cp0_yy_machine_mode_aft_dbg;         
input           cpurst_b;                            
input           ctrl_dp_ldst_info_buf_reuse;         
input           ctrl_dp_ldst_req_grnt;               
input           ctrl_dp_store_buffer_updt;           
input           forever_cpuclk;                      
input   [31:0]  iu_lsu_adder_rst;                    
input   [31:0]  iu_lsu_base;                         
input   [31:0]  iu_lsu_data;                         
input           iu_lsu_ex_byte;                      
input           iu_lsu_ex_data_sel;                  
input           iu_lsu_ex_half;                      
input           iu_lsu_ex_uns;                       
input   [31:0]  iu_lsu_imm_data;                     
input           iu_lsu_imm_write_en;                 
input   [31:0]  iu_lsu_offset;                       
input           iu_lsu_oper_mux_en;                  
input   [31:0]  iu_lsu_rs2;                          
input           lsu_inst_store;                      
input           pad_yy_gate_clk_en_b;                
input           pmp_lsu_acc_scu;                     
input           randclk_dp_size_buf_mod_en_w5;       
input           sysmap_lsu_acc_ca;                   
input           unalign_dp_first_req;                
input           unalign_dp_load_data_byte1_to_byte1; 
input           unalign_dp_load_data_byte1_to_byte2; 
input           unalign_dp_load_data_byte1_to_byte3; 
input           unalign_dp_load_data_byte1_to_byte4; 
input           unalign_dp_load_data_byte2_to_byte1; 
input           unalign_dp_load_data_byte2_to_byte2; 
input           unalign_dp_load_data_byte2_to_byte3; 
input           unalign_dp_load_data_byte2_to_byte4; 
input           unalign_dp_load_data_byte3_to_byte1; 
input           unalign_dp_load_data_byte3_to_byte2; 
input           unalign_dp_load_data_byte3_to_byte3; 
input           unalign_dp_load_data_byte3_to_byte4; 
input           unalign_dp_load_data_byte4_to_byte1; 
input           unalign_dp_load_data_byte4_to_byte2; 
input           unalign_dp_load_data_byte4_to_byte3; 
input           unalign_dp_load_data_byte4_to_byte4; 
input           unalign_dp_store_data_byte1_to_byte1; 
input           unalign_dp_store_data_byte1_to_byte2; 
input           unalign_dp_store_data_byte1_to_byte3; 
input           unalign_dp_store_data_byte1_to_byte4; 
input           unalign_dp_store_data_byte2_to_byte1; 
input           unalign_dp_store_data_byte2_to_byte2; 
input           unalign_dp_store_data_byte2_to_byte3; 
input           unalign_dp_store_data_byte2_to_byte4; 
input           unalign_dp_store_data_byte3_to_byte1; 
input           unalign_dp_store_data_byte3_to_byte2; 
input           unalign_dp_store_data_byte3_to_byte3; 
input           unalign_dp_store_data_byte3_to_byte4; 
input           unalign_dp_store_data_byte4_to_byte1; 
input           unalign_dp_store_data_byte4_to_byte2; 
input           unalign_dp_store_data_byte4_to_byte3; 
input           unalign_dp_store_data_byte4_to_byte4; 
output          dp_ctrl_misalign;                    
output  [31:0]  lsu_bmu_addr;                        
output  [3 :0]  lsu_bmu_prot;                        
output  [1 :0]  lsu_bmu_size;                        
output          lsu_bmu_store_error;                 
output  [31:0]  lsu_bmu_wdata;                       
output          lsu_bmu_write;                       
output  [31:0]  lsu_had_addr;                        
output          lsu_had_st;                          
output  [31:0]  lsu_iu_addr;                         
output          lsu_iu_addr_vld;                     
output          lsu_iu_alu_sel;                      
output  [31:0]  lsu_iu_data;                         
output  [31:0]  lsu_iu_mad_buf;                      
output          lsu_iu_store;                        
output  [31:0]  lsu_iu_wb_load_data;                 

// &Regs; @25
reg     [4 :0]  ldst_size_buffer;                    
reg     [1 :0]  lsu_addr_mask;                       
reg     [31:0]  lsu_data_sign_extd;                  
reg             lsu_misalign;                        
reg     [31:0]  lsu_sized_data;                      
reg     [31:0]  lsu_store_wdata;                     
reg     [31:0]  store_data_buffer;                   
reg     [31:0]  store_data_buffer_updt_val;          

// &Wires; @26
wire    [31:0]  bmu_lsu_data;                        
wire    [4 :0]  buffer_ldst_info;                    
wire            cp0_yy_be_v1;                        
wire            cp0_yy_be_v2;                        
wire            cp0_yy_clk_en;                       
wire            cp0_yy_machine_mode_aft_dbg;         
wire            cpurst_b;                            
wire            ctrl_dp_ldst_info_buf_reuse;         
wire            ctrl_dp_ldst_req_grnt;               
wire            ctrl_dp_store_buffer_updt;           
wire            dp_ctrl_misalign;                    
wire            forever_cpuclk;                      
wire    [31:0]  iu_lsu_adder_rst;                    
wire    [31:0]  iu_lsu_data;                         
wire            iu_lsu_ex_byte;                      
wire            iu_lsu_ex_data_sel;                  
wire            iu_lsu_ex_half;                      
wire            iu_lsu_ex_uns;                       
wire    [31:0]  iu_lsu_imm_data;                     
wire            iu_lsu_imm_write_en;                 
wire            iu_lsu_oper_mux_en;                  
wire    [1 :0]  iu_lsu_size;                         
wire    [31:0]  lsu_addr;                            
wire    [1 :0]  lsu_addr_1_0;                        
wire    [1 :0]  lsu_addr_1_0_pre_mux;                
wire    [31:0]  lsu_addr_post;                       
wire    [31:0]  lsu_bmu_addr;                        
wire    [3 :0]  lsu_bmu_prot;                        
wire    [1 :0]  lsu_bmu_size;                        
wire            lsu_bmu_store_error;                 
wire    [31:0]  lsu_bmu_wdata;                       
wire            lsu_bmu_write;                       
wire    [31:0]  lsu_data;                            
wire    [31:0]  lsu_had_addr;                        
wire            lsu_had_st;                          
wire            lsu_inst_store;                      
wire    [31:0]  lsu_iu_addr;                         
wire            lsu_iu_addr_vld;                     
wire            lsu_iu_alu_sel;                      
wire    [31:0]  lsu_iu_data;                         
wire    [31:0]  lsu_iu_mad_buf;                      
wire            lsu_iu_store;                        
wire    [31:0]  lsu_iu_wb_load_data;                 
wire            lsu_sign_exten;                      
wire    [1 :0]  lsu_size;                            
wire    [1 :0]  lsu_size_post;                       
wire    [7 :0]  lsu_sized_data_default;              
wire    [7 :0]  lsu_store_wdata_default;             
wire    [1 :0]  lsu_wb_addr_1_0;                     
wire            lsu_wb_sign_exten;                   
wire    [1 :0]  lsu_wb_size;                         
wire    [31:0]  lsu_wdata;                           
wire            pad_yy_gate_clk_en_b;                
wire            pmp_lsu_acc_scu;                     
wire            randclk_dp_size_buf_mod_en_w5;       
wire            size_buf_clk;                        
wire            size_buf_clk_en;                     
wire            size_buf_en;                         
wire            size_buf_vld;                        
wire            store_buffer_clk;                    
wire            store_buffer_clk_en;                 
wire            store_buffer_updt;                   
wire    [31:0]  store_buffer_updt_data;              
wire            sysmap_lsu_acc_ca;                   
wire            unalign_dp_first_req;                
wire            unalign_dp_load_data_byte1_to_byte1; 
wire            unalign_dp_load_data_byte1_to_byte2; 
wire            unalign_dp_load_data_byte1_to_byte3; 
wire            unalign_dp_load_data_byte1_to_byte4; 
wire            unalign_dp_load_data_byte2_to_byte1; 
wire            unalign_dp_load_data_byte2_to_byte2; 
wire            unalign_dp_load_data_byte2_to_byte3; 
wire            unalign_dp_load_data_byte2_to_byte4; 
wire            unalign_dp_load_data_byte3_to_byte1; 
wire            unalign_dp_load_data_byte3_to_byte2; 
wire            unalign_dp_load_data_byte3_to_byte3; 
wire            unalign_dp_load_data_byte3_to_byte4; 
wire            unalign_dp_load_data_byte4_to_byte1; 
wire            unalign_dp_load_data_byte4_to_byte2; 
wire            unalign_dp_load_data_byte4_to_byte3; 
wire            unalign_dp_load_data_byte4_to_byte4; 
wire            unalign_dp_store_data_byte1_to_byte1; 
wire            unalign_dp_store_data_byte1_to_byte2; 
wire            unalign_dp_store_data_byte1_to_byte3; 
wire            unalign_dp_store_data_byte1_to_byte4; 
wire            unalign_dp_store_data_byte2_to_byte1; 
wire            unalign_dp_store_data_byte2_to_byte2; 
wire            unalign_dp_store_data_byte2_to_byte3; 
wire            unalign_dp_store_data_byte2_to_byte4; 
wire            unalign_dp_store_data_byte3_to_byte1; 
wire            unalign_dp_store_data_byte3_to_byte2; 
wire            unalign_dp_store_data_byte3_to_byte3; 
wire            unalign_dp_store_data_byte3_to_byte4; 
wire            unalign_dp_store_data_byte4_to_byte1; 
wire            unalign_dp_store_data_byte4_to_byte2; 
wire            unalign_dp_store_data_byte4_to_byte3; 
wire            unalign_dp_store_data_byte4_to_byte4; 
wire    [3 :0]  unalign_ld_byte1_sel;                
wire    [3 :0]  unalign_ld_byte2_sel;                
wire    [3 :0]  unalign_ld_byte3_sel;                
wire    [3 :0]  unalign_ld_byte4_sel;                
wire    [3 :0]  unalign_st_byte1_sel;                
wire    [3 :0]  unalign_st_byte2_sel;                
wire    [3 :0]  unalign_st_byte3_sel;                
wire    [3 :0]  unalign_st_byte4_sel;                


//==========================================================
//                 Instance of Gated Cell  
//==========================================================
// &Instance("gated_clk_cell", "x_unalign_buf_gated_clk"); @33
// &Connect(.clk_in      (forever_cpuclk), @34
//          .external_en (1'b0), @35
//          .global_en   (cp0_yy_clk_en), @36
//          .module_en   (randclk_dp_unalign_buf_mod_en_w24), @37
//          .local_en    (unalign_buf_en), @38
//          .clk_out     (unalign_buf_clk)); @39

assign size_buf_vld = !lsu_inst_store;
assign size_buf_en = ctrl_dp_ldst_info_buf_reuse
                     && unalign_dp_first_req
                     && size_buf_vld;
assign size_buf_clk_en = (ctrl_dp_ldst_info_buf_reuse || ctrl_dp_ldst_req_grnt)
                     && unalign_dp_first_req
                     && size_buf_vld;
// &Instance("gated_clk_cell", "x_size_buf_gated_clk"); @54
gated_clk_cell  x_size_buf_gated_clk (
  .clk_in                        (forever_cpuclk               ),
  .clk_out                       (size_buf_clk                 ),
  .external_en                   (1'b0                         ),
  .global_en                     (cp0_yy_clk_en                ),
  .local_en                      (size_buf_clk_en              ),
  .module_en                     (randclk_dp_size_buf_mod_en_w5),
  .pad_yy_gate_clk_en_b          (pad_yy_gate_clk_en_b         )
);

// &Connect(.clk_in      (forever_cpuclk), @55
//          .external_en (1'b0), @56
//          .global_en   (cp0_yy_clk_en), @57
//          .module_en   (randclk_dp_size_buf_mod_en_w5), @58
//          .local_en    (size_buf_clk_en), @59
//          .clk_out     (size_buf_clk)); @60
// &Instance("gated_clk_cell", "x_size_buf_gated_clk"); @67
// &Connect(.clk_in      (forever_cpuclk), @68
//          .external_en (1'b0), @69
//          .global_en   (cp0_yy_clk_en), @70
//          .module_en   (randclk_dp_size_buf_mod_en_w5), @71
//          .local_en    (size_buf_en), @72
//          .clk_out     (size_buf_clk)); @73

// &Instance("gated_clk_cell", "x_bspval_gated_clk"); @80
// &Connect(.clk_in      (forever_cpuclk), @81
//          .external_en (1'b0), @82
//          .global_en   (cp0_yy_clk_en), @83
//          .module_en   (randclk_dp_bspval_mod_en_w32), @84
//          .local_en    (bspval_en), @85
//          .clk_out     (bspval_clk)); @86

//==========================================================
//                    Operands Mux
//==========================================================
// &Force("bus","iu_lsu_ldr_shift",3,0); @93
//Mask critical logic operands to reduce combinational logic
//power
assign iu_lsu_size[1:0]   = iu_lsu_ex_byte ? 2'b00 : iu_lsu_ex_half ? 2'b01 : 2'b10;
assign lsu_wdata[31:0]    = {32{iu_lsu_oper_mux_en}} & iu_lsu_data[31:0];
assign lsu_size[1:0]      = iu_lsu_size[1:0];
assign lsu_addr_1_0[1:0]  = lsu_addr_1_0_pre_mux[1:0];
assign lsu_sign_exten     = !iu_lsu_ex_uns;

assign lsu_data[31:0]     = bmu_lsu_data[31:0];

//==========================================================
//                address prepare
//==========================================================
parameter BYTE = 2'b00, HALF = 2'b01, WORD = 2'b10;
parameter LE = 2'b00;
parameter BE_V1 = 2'b10, BE_V2 = 2'b01;

//assign lsu_addr_offset[31:0] = lsu_offset[31:0];

// &Force("input", "iu_lsu_base"); @135
// &Force("bus", "iu_lsu_base", 31, 0); @136
// &Force("input", "iu_lsu_rs2"); @137
// &Force("bus", "iu_lsu_rs2", 31, 0); @138
// &Force("input", "iu_lsu_offset"); @139
// &Force("bus", "iu_lsu_offset", 31, 0); @140
assign lsu_iu_alu_sel = iu_lsu_oper_mux_en;
assign lsu_addr[31:0] = {32{iu_lsu_oper_mux_en}} & iu_lsu_adder_rst[31:0];


assign lsu_bmu_store_error = 1'b0;

// &Force("output", "lsu_bmu_addr"); @148
// &Force("bus","lsu_bmu_addr",31,0); @149
assign lsu_bmu_addr[31:0]      = lsu_addr_post[31:0];
assign lsu_bmu_size[1:0]       = lsu_size_post[1:0];
assign lsu_bmu_prot[3:0]       = {sysmap_lsu_acc_ca,
                                  pmp_lsu_acc_scu,
                                  cp0_yy_machine_mode_aft_dbg,
                                  1'b1};

// &CombBeg; @171
// &CombEnd; @177
// &CombBeg; @218
always @( lsu_size[1:0])
begin
  case(lsu_size[1:0])
    WORD : lsu_addr_mask[1:0] = 2'b00;
    HALF : lsu_addr_mask[1:0] = 2'b10;
    default     : lsu_addr_mask[1:0] = 2'b11;
  endcase
// &CombEnd; @224
end

assign lsu_addr_1_0_pre_mux[1:0]  = lsu_addr_mask[1:0] & lsu_addr[1:0];

// &CombBeg; @228
always @( lsu_addr[1:0]
       or lsu_size[1:0])
begin
  case(lsu_size[1:0])
    WORD    : lsu_misalign = | lsu_addr[1:0];
    HALF    : lsu_misalign = lsu_addr[0];
    default : lsu_misalign = 1'b0;
  endcase
// &CombEnd; @234
end

assign dp_ctrl_misalign = lsu_misalign;
assign lsu_size_post[1:0] = lsu_size[1:0];
//when not UNALIGN_LOAD_STORE, the addr of ld st is from ALU adder
assign lsu_addr_post[31:0] = {lsu_addr[31:2], lsu_addr_1_0[1:0]};



//==========================================================
//               write data and write valid
//==========================================================
assign lsu_bmu_write = lsu_inst_store && iu_lsu_ex_data_sel;
assign lsu_iu_store  = lsu_inst_store;

assign unalign_st_byte1_sel[3:0] = {unalign_dp_store_data_byte1_to_byte1,
                                    unalign_dp_store_data_byte2_to_byte1,
                                    unalign_dp_store_data_byte3_to_byte1,
                                    unalign_dp_store_data_byte4_to_byte1};

assign lsu_store_wdata_default[7:0] = 8'b0;

// &CombBeg; @263
always @( lsu_addr_1_0[1:0]
       or unalign_st_byte1_sel[3:0]
       or cp0_yy_be_v2
       or lsu_size[1:0]
       or lsu_wdata[7:0]
       or lsu_wdata[31:8]
       or lsu_store_wdata_default[7:0]
       or cp0_yy_be_v1)
begin
  lsu_store_wdata[7:0]  = lsu_store_wdata_default[7:0];
  casez({unalign_st_byte1_sel[3:0],cp0_yy_be_v1,cp0_yy_be_v2,lsu_size[1:0],lsu_addr_1_0[1:0]})
    {4'b1000,2'b??,2'b??,2'b??} : lsu_store_wdata[7:0]  = lsu_wdata[7:0];
    {4'b0100,2'b??,2'b??,2'b??} : lsu_store_wdata[7:0]  = lsu_wdata[15:8];
    {4'b0010,2'b??,2'b??,2'b??} : lsu_store_wdata[7:0]  = lsu_wdata[23:16];
    {4'b0001,2'b??,2'b??,2'b??} : lsu_store_wdata[7:0]  = lsu_wdata[31:24];
    {4'b0000,BE_V1,BYTE, 2'b11} : lsu_store_wdata[7:0]  = lsu_wdata[7:0];
    {4'b0000,BE_V1,HALF, 2'b1?} : lsu_store_wdata[7:0]  = lsu_wdata[7:0];
    {4'b0000,BE_V1,WORD, 2'b??} : lsu_store_wdata[7:0]  = lsu_wdata[7:0];
    {4'b0000,BE_V2,BYTE, 2'b00} : lsu_store_wdata[7:0]  = lsu_wdata[7:0];
    {4'b0000,BE_V2,HALF, 2'b0?} : lsu_store_wdata[7:0]  = lsu_wdata[15:8];
    {4'b0000,BE_V2,WORD, 2'b??} : lsu_store_wdata[7:0]  = lsu_wdata[31:24];
    {4'b0000,LE   ,BYTE, 2'b00} : lsu_store_wdata[7:0]  = lsu_wdata[7:0];
    {4'b0000,LE   ,HALF, 2'b0?} : lsu_store_wdata[7:0]  = lsu_wdata[7:0];
    {4'b0000,LE   ,WORD, 2'b??} : lsu_store_wdata[7:0]  = lsu_wdata[7:0];
  endcase
// &CombEnd; @280
end


assign unalign_st_byte2_sel[3:0] = {unalign_dp_store_data_byte1_to_byte2,
                                    unalign_dp_store_data_byte2_to_byte2,
                                    unalign_dp_store_data_byte3_to_byte2,
                                    unalign_dp_store_data_byte4_to_byte2};

// &CombBeg; @288
always @( lsu_addr_1_0[1:0]
       or cp0_yy_be_v2
       or lsu_size[1:0]
       or lsu_wdata[7:0]
       or lsu_wdata[31:8]
       or lsu_store_wdata_default[7:0]
       or cp0_yy_be_v1
       or unalign_st_byte2_sel[3:0])
begin
  lsu_store_wdata[15:8]  = lsu_store_wdata_default[7:0];
  casez({unalign_st_byte2_sel[3:0],cp0_yy_be_v1,cp0_yy_be_v2,lsu_size[1:0],lsu_addr_1_0[1:0]})
    {4'b1000,2'b??,2'b??,2'b??} : lsu_store_wdata[15:8]  = lsu_wdata[7:0];
    {4'b0100,2'b??,2'b??,2'b??} : lsu_store_wdata[15:8]  = lsu_wdata[15:8];
    {4'b0010,2'b??,2'b??,2'b??} : lsu_store_wdata[15:8]  = lsu_wdata[23:16];
    {4'b0001,2'b??,2'b??,2'b??} : lsu_store_wdata[15:8]  = lsu_wdata[31:24];
    {4'b0000,BE_V1,BYTE, 2'b10} : lsu_store_wdata[15:8]  = lsu_wdata[7:0];
    {4'b0000,BE_V1,HALF, 2'b1?} : lsu_store_wdata[15:8]  = lsu_wdata[15:8];
    {4'b0000,BE_V1,WORD, 2'b??} : lsu_store_wdata[15:8]  = lsu_wdata[15:8];
    {4'b0000,BE_V2,BYTE, 2'b01} : lsu_store_wdata[15:8]  = lsu_wdata[7:0];
    {4'b0000,BE_V2,HALF, 2'b0?} : lsu_store_wdata[15:8]  = lsu_wdata[7:0];
    {4'b0000,BE_V2,WORD, 2'b??} : lsu_store_wdata[15:8]  = lsu_wdata[23:16];
    {4'b0000,LE   ,BYTE, 2'b01} : lsu_store_wdata[15:8]  = lsu_wdata[7:0];
    {4'b0000,LE   ,HALF, 2'b0?} : lsu_store_wdata[15:8]  = lsu_wdata[15:8];
    {4'b0000,LE   ,WORD, 2'b??} : lsu_store_wdata[15:8]  = lsu_wdata[15:8];
  endcase
// &CombEnd; @305
end


assign unalign_st_byte3_sel[3:0] = {unalign_dp_store_data_byte1_to_byte3,
                                    unalign_dp_store_data_byte2_to_byte3,
                                    unalign_dp_store_data_byte3_to_byte3,
                                    unalign_dp_store_data_byte4_to_byte3};

// &CombBeg; @313
always @( lsu_addr_1_0[1:0]
       or cp0_yy_be_v2
       or unalign_st_byte3_sel[3:0]
       or lsu_size[1:0]
       or lsu_wdata[7:0]
       or lsu_wdata[31:8]
       or lsu_store_wdata_default[7:0]
       or cp0_yy_be_v1)
begin
  lsu_store_wdata[23:16]  = lsu_store_wdata_default[7:0];
  casez({unalign_st_byte3_sel[3:0],cp0_yy_be_v1,cp0_yy_be_v2,lsu_size[1:0],lsu_addr_1_0[1:0]})
    {4'b1000,2'b??,2'b??,2'b??} : lsu_store_wdata[23:16] = lsu_wdata[7:0];
    {4'b0100,2'b??,2'b??,2'b??} : lsu_store_wdata[23:16] = lsu_wdata[15:8];
    {4'b0010,2'b??,2'b??,2'b??} : lsu_store_wdata[23:16] = lsu_wdata[23:16];
    {4'b0001,2'b??,2'b??,2'b??} : lsu_store_wdata[23:16] = lsu_wdata[31:24];
    {4'b0000,BE_V1,BYTE, 2'b01} : lsu_store_wdata[23:16] = lsu_wdata[7:0];
    {4'b0000,BE_V1,HALF, 2'b0?} : lsu_store_wdata[23:16] = lsu_wdata[7:0];
    {4'b0000,BE_V1,WORD, 2'b??} : lsu_store_wdata[23:16] = lsu_wdata[23:16];
    {4'b0000,BE_V2,BYTE, 2'b10} : lsu_store_wdata[23:16] = lsu_wdata[7:0];
    {4'b0000,BE_V2,HALF, 2'b1?} : lsu_store_wdata[23:16] = lsu_wdata[15:8];
    {4'b0000,BE_V2,WORD, 2'b??} : lsu_store_wdata[23:16] = lsu_wdata[15:8];
    {4'b0000,LE   ,BYTE, 2'b10} : lsu_store_wdata[23:16] = lsu_wdata[7:0];
    {4'b0000,LE   ,HALF, 2'b1?} : lsu_store_wdata[23:16] = lsu_wdata[7:0];
    {4'b0000,LE   ,WORD, 2'b??} : lsu_store_wdata[23:16] = lsu_wdata[23:16];
  endcase
// &CombEnd; @330
end


assign unalign_st_byte4_sel[3:0] = {unalign_dp_store_data_byte1_to_byte4,
                                    unalign_dp_store_data_byte2_to_byte4,
                                    unalign_dp_store_data_byte3_to_byte4,
                                    unalign_dp_store_data_byte4_to_byte4};

// &CombBeg; @338
always @( lsu_addr_1_0[1:0]
       or cp0_yy_be_v2
       or lsu_size[1:0]
       or lsu_wdata[7:0]
       or lsu_wdata[31:8]
       or lsu_store_wdata_default[7:0]
       or cp0_yy_be_v1
       or unalign_st_byte4_sel[3:0])
begin
  lsu_store_wdata[31:24]  = lsu_store_wdata_default[7:0];
  casez({unalign_st_byte4_sel[3:0],cp0_yy_be_v1,cp0_yy_be_v2,lsu_size[1:0],lsu_addr_1_0[1:0]})
    {4'b1000,2'b??,2'b??,2'b??} : lsu_store_wdata[31:24] = lsu_wdata[7:0];
    {4'b0100,2'b??,2'b??,2'b??} : lsu_store_wdata[31:24] = lsu_wdata[15:8];
    {4'b0010,2'b??,2'b??,2'b??} : lsu_store_wdata[31:24] = lsu_wdata[23:16];
    {4'b0001,2'b??,2'b??,2'b??} : lsu_store_wdata[31:24] = lsu_wdata[31:24];
    {4'b0000,BE_V1,BYTE, 2'b00} : lsu_store_wdata[31:24] = lsu_wdata[7:0];
    {4'b0000,BE_V1,HALF, 2'b0?} : lsu_store_wdata[31:24] = lsu_wdata[15:8];
    {4'b0000,BE_V1,WORD, 2'b??} : lsu_store_wdata[31:24] = lsu_wdata[31:24];
    {4'b0000,BE_V2,BYTE, 2'b11} : lsu_store_wdata[31:24] = lsu_wdata[7:0];
    {4'b0000,BE_V2,HALF, 2'b1?} : lsu_store_wdata[31:24] = lsu_wdata[7:0];
    {4'b0000,BE_V2,WORD, 2'b??} : lsu_store_wdata[31:24] = lsu_wdata[7:0];
    {4'b0000,LE   ,BYTE, 2'b11} : lsu_store_wdata[31:24] = lsu_wdata[7:0];
    {4'b0000,LE   ,HALF, 2'b1?} : lsu_store_wdata[31:24] = lsu_wdata[15:8];
    {4'b0000,LE   ,WORD, 2'b??} : lsu_store_wdata[31:24] = lsu_wdata[31:24];
  endcase
// &CombEnd; @355
end

//==========================================================
//                     Write Buffer
//==========================================================
//the write data should be buffered, to make store fast retire
//pre buffer:
assign store_buffer_clk_en = store_buffer_updt;
// &Instance("gated_clk_cell", "x_store_buffer_clk"); @364
gated_clk_cell  x_store_buffer_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (store_buffer_clk    ),
  .external_en          (1'b0                ),
  .global_en            (cp0_yy_clk_en       ),
  .local_en             (store_buffer_clk_en ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk), @365
//          .external_en (1'b0), @366
//          .global_en   (cp0_yy_clk_en), @367
//          .module_en   (1'b0), @368
//          .local_en    (store_buffer_clk_en), @369
//          .clk_out     (store_buffer_clk)); @370

assign store_buffer_updt = ctrl_dp_store_buffer_updt
                        || iu_lsu_imm_write_en;
assign store_buffer_updt_data[31:0] = 
                       {32{ctrl_dp_store_buffer_updt}} & lsu_store_wdata[31:0]
                     | {32{iu_lsu_imm_write_en}}       & iu_lsu_imm_data[31:0];          
// &CombBeg; @377
always @( store_buffer_updt_data[31:0]
       or store_buffer_updt
       or store_data_buffer[31:0])
begin
  if(store_buffer_updt)
    store_data_buffer_updt_val[31:0] = store_buffer_updt_data[31:0];
  else
    store_data_buffer_updt_val[31:0] = store_data_buffer[31:0];
// &CombEnd; @382
end

always @(posedge store_buffer_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    store_data_buffer[31:0] <= 32'b0;
  else 
    store_data_buffer[31:0] <= store_data_buffer_updt_val[31:0];
end

assign lsu_bmu_wdata[31:0] = store_data_buffer[31:0];
assign lsu_iu_mad_buf[31:0] = store_data_buffer[31:0];

// &Force("input", "ctrl_dp_store_buffer_updt"); @401

//==========================================================
//               Load data process
//==========================================================
//buffer the size information of load instruction, used for
//size and endian adjust
assign buffer_ldst_info[4:0] = {lsu_sign_exten,
                                lsu_size[1:0],
                                lsu_addr_1_0[1:0]};

always @(posedge size_buf_clk)
begin
  if(size_buf_en)
    ldst_size_buffer[4:0] <= buffer_ldst_info[4:0];
end

//wb size information
assign lsu_wb_addr_1_0[1:0] = ldst_size_buffer[1:0];
assign lsu_wb_size[1:0]     = ldst_size_buffer[3:2];
assign lsu_wb_sign_exten    = ldst_size_buffer[4];



assign unalign_ld_byte1_sel[3:0] = {unalign_dp_load_data_byte1_to_byte1,
                                    unalign_dp_load_data_byte2_to_byte1, 
                                    unalign_dp_load_data_byte3_to_byte1,
                                    unalign_dp_load_data_byte4_to_byte1};

assign lsu_sized_data_default[7:0] = 8'b0;

//endian transfer
// &CombBeg; @477
always @( lsu_wb_size[1:0]
       or unalign_ld_byte1_sel[3:0]
       or lsu_wb_addr_1_0[1:0]
       or cp0_yy_be_v2
       or lsu_data[31:16]
       or cp0_yy_be_v1
       or lsu_sized_data_default[7:0]
       or lsu_data[15:0])
begin
  lsu_sized_data[7:0]  = lsu_sized_data_default[7:0];
  casez({unalign_ld_byte1_sel[3:0],cp0_yy_be_v1,cp0_yy_be_v2,lsu_wb_size[1:0],lsu_wb_addr_1_0[1:0]})
    {4'b1000,2'b??,2'b??,2'b??} : lsu_sized_data[7:0]  = lsu_data[7:0];
    {4'b0100,2'b??,2'b??,2'b??} : lsu_sized_data[7:0]  = lsu_data[15:8];
    {4'b0010,2'b??,2'b??,2'b??} : lsu_sized_data[7:0]  = lsu_data[23:16];
    {4'b0001,2'b??,2'b??,2'b??} : lsu_sized_data[7:0]  = lsu_data[31:24];
    {4'b0000,BE_V1,BYTE, 2'b00} : lsu_sized_data[7:0]  = lsu_data[31:24];
    {4'b0000,BE_V1,BYTE, 2'b01} : lsu_sized_data[7:0]  = lsu_data[23:16];
    {4'b0000,BE_V1,BYTE, 2'b10} : lsu_sized_data[7:0]  = lsu_data[15:8];
    {4'b0000,BE_V1,BYTE, 2'b11} : lsu_sized_data[7:0]  = lsu_data[7:0];
    {4'b0000,BE_V1,HALF, 2'b0?} : lsu_sized_data[7:0]  = lsu_data[23:16];
    {4'b0000,BE_V1,HALF, 2'b1?} : lsu_sized_data[7:0]  = lsu_data[7:0];
    {4'b0000,BE_V1,WORD, 2'b??} : lsu_sized_data[7:0]  = lsu_data[7:0];
    {4'b0000,BE_V2,BYTE, 2'b00} : lsu_sized_data[7:0]  = lsu_data[7:0];
    {4'b0000,BE_V2,BYTE, 2'b01} : lsu_sized_data[7:0]  = lsu_data[15:8];
    {4'b0000,BE_V2,BYTE, 2'b10} : lsu_sized_data[7:0]  = lsu_data[23:16];
    {4'b0000,BE_V2,BYTE, 2'b11} : lsu_sized_data[7:0]  = lsu_data[31:24];
    {4'b0000,BE_V2,HALF, 2'b0?} : lsu_sized_data[7:0]  = lsu_data[15:8];
    {4'b0000,BE_V2,HALF, 2'b1?} : lsu_sized_data[7:0]  = lsu_data[31:24];
    {4'b0000,BE_V2,WORD, 2'b??} : lsu_sized_data[7:0]  = lsu_data[31:24];
    {4'b0000,LE   ,BYTE, 2'b00} : lsu_sized_data[7:0]  = lsu_data[7:0];
    {4'b0000,LE   ,BYTE, 2'b01} : lsu_sized_data[7:0]  = lsu_data[15:8];
    {4'b0000,LE   ,BYTE, 2'b10} : lsu_sized_data[7:0]  = lsu_data[23:16];
    {4'b0000,LE   ,BYTE, 2'b11} : lsu_sized_data[7:0]  = lsu_data[31:24];
    {4'b0000,LE   ,HALF, 2'b0?} : lsu_sized_data[7:0]  = lsu_data[7:0];
    {4'b0000,LE   ,HALF, 2'b1?} : lsu_sized_data[7:0]  = lsu_data[23:16];
    {4'b0000,LE   ,WORD, 2'b??} : lsu_sized_data[7:0]  = lsu_data[7:0];
  endcase
// &CombEnd; @506
end


assign unalign_ld_byte2_sel[3:0] = {unalign_dp_load_data_byte1_to_byte2,
                                    unalign_dp_load_data_byte2_to_byte2,
                                    unalign_dp_load_data_byte3_to_byte2,
                                    unalign_dp_load_data_byte4_to_byte2};
//endian transfer
// &CombBeg; @514
always @( lsu_wb_size[1:0]
       or lsu_wb_addr_1_0[1:0]
       or cp0_yy_be_v2
       or lsu_data[31:16]
       or cp0_yy_be_v1
       or lsu_sized_data_default[7:0]
       or lsu_data[15:0]
       or unalign_ld_byte2_sel[3:0])
begin
  lsu_sized_data[15:8]  = lsu_sized_data_default[7:0];
  casez({unalign_ld_byte2_sel[3:0],cp0_yy_be_v1,cp0_yy_be_v2,lsu_wb_size[1:0],lsu_wb_addr_1_0[1:0]})
    {4'b1000,2'b??,2'b??,2'b??} : lsu_sized_data[15:8] = lsu_data[7:0];
    {4'b0100,2'b??,2'b??,2'b??} : lsu_sized_data[15:8] = lsu_data[15:8];
    {4'b0010,2'b??,2'b??,2'b??} : lsu_sized_data[15:8] = lsu_data[23:16];
    {4'b0001,2'b??,2'b??,2'b??} : lsu_sized_data[15:8] = lsu_data[31:24];
    {4'b0000,BE_V1,HALF, 2'b0?} : lsu_sized_data[15:8] = lsu_data[31:24];
    {4'b0000,BE_V1,HALF, 2'b1?} : lsu_sized_data[15:8] = lsu_data[15:8];
    {4'b0000,BE_V1,WORD, 2'b??} : lsu_sized_data[15:8] = lsu_data[15:8];
    {4'b0000,BE_V2,HALF, 2'b0?} : lsu_sized_data[15:8] = lsu_data[7:0];
    {4'b0000,BE_V2,HALF, 2'b1?} : lsu_sized_data[15:8] = lsu_data[23:16];
    {4'b0000,BE_V2,WORD, 2'b??} : lsu_sized_data[15:8] = lsu_data[23:16];
    {4'b0000,LE   ,HALF, 2'b0?} : lsu_sized_data[15:8] = lsu_data[15:8];
    {4'b0000,LE   ,HALF, 2'b1?} : lsu_sized_data[15:8] = lsu_data[31:24];
    {4'b0000,LE   ,WORD, 2'b??} : lsu_sized_data[15:8] = lsu_data[15:8];
  endcase
// &CombEnd; @531
end


assign unalign_ld_byte3_sel[3:0] = {unalign_dp_load_data_byte1_to_byte3,
                                    unalign_dp_load_data_byte2_to_byte3,
                                    unalign_dp_load_data_byte3_to_byte3,
                                    unalign_dp_load_data_byte4_to_byte3};
//endian transfer
// &CombBeg; @539
always @( lsu_wb_size[1:0]
       or lsu_wb_addr_1_0[1:0]
       or cp0_yy_be_v2
       or lsu_data[31:16]
       or cp0_yy_be_v1
       or lsu_sized_data_default[7:0]
       or unalign_ld_byte3_sel[3:0]
       or lsu_data[15:0])
begin
  lsu_sized_data[23:16]  = lsu_sized_data_default[7:0];
  casez({unalign_ld_byte3_sel[3:0],cp0_yy_be_v1,cp0_yy_be_v2,lsu_wb_size[1:0],lsu_wb_addr_1_0[1:0]})
    {4'b1000,2'b??,2'b??,2'b??} : lsu_sized_data[23:16] = lsu_data[7:0];
    {4'b0100,2'b??,2'b??,2'b??} : lsu_sized_data[23:16] = lsu_data[15:8];
    {4'b0010,2'b??,2'b??,2'b??} : lsu_sized_data[23:16] = lsu_data[23:16];
    {4'b0001,2'b??,2'b??,2'b??} : lsu_sized_data[23:16] = lsu_data[31:24];
    {4'b0000,BE_V1,WORD ,2'b??} : lsu_sized_data[23:16] = lsu_data[23:16];
    {4'b0000,BE_V2,WORD ,2'b??} : lsu_sized_data[23:16] = lsu_data[15:8];
    {4'b0000,LE   ,WORD ,2'b??} : lsu_sized_data[23:16] = lsu_data[23:16];
  endcase
// &CombEnd; @550
end


assign unalign_ld_byte4_sel[3:0] = {unalign_dp_load_data_byte1_to_byte4,
                                    unalign_dp_load_data_byte2_to_byte4,
                                    unalign_dp_load_data_byte3_to_byte4, 
                                    unalign_dp_load_data_byte4_to_byte4};
//endian transfer
// &CombBeg; @558
always @( lsu_wb_size[1:0]
       or lsu_wb_addr_1_0[1:0]
       or cp0_yy_be_v2
       or lsu_data[31:16]
       or cp0_yy_be_v1
       or lsu_sized_data_default[7:0]
       or unalign_ld_byte4_sel[3:0]
       or lsu_data[15:0])
begin
  lsu_sized_data[31:24]  = lsu_sized_data_default[7:0];
  casez({unalign_ld_byte4_sel[3:0],cp0_yy_be_v1,cp0_yy_be_v2,lsu_wb_size[1:0],lsu_wb_addr_1_0[1:0]})
    {4'b1000,2'b??,2'b??,2'b??} : lsu_sized_data[31:24] = lsu_data[7:0];
    {4'b0100,2'b??,2'b??,2'b??} : lsu_sized_data[31:24] = lsu_data[15:8];
    {4'b0010,2'b??,2'b??,2'b??} : lsu_sized_data[31:24] = lsu_data[23:16];
    {4'b0001,2'b??,2'b??,2'b??} : lsu_sized_data[31:24] = lsu_data[31:24];
    {4'b0000,BE_V1,WORD ,2'b??} : lsu_sized_data[31:24] = lsu_data[31:24];
    {4'b0000,BE_V2,WORD ,2'b??} : lsu_sized_data[31:24] = lsu_data[7:0];
    {4'b0000,LE   ,WORD ,2'b??} : lsu_sized_data[31:24] = lsu_data[31:24];
  endcase
// &CombEnd; @569
end

//sign extension
// &CombBeg; @572
always @( lsu_wb_size[1:0]
       or lsu_sized_data[31:0]
       or lsu_wb_sign_exten)
begin
  case({lsu_wb_sign_exten,lsu_wb_size[1:0]})
    {1'b1,BYTE} : lsu_data_sign_extd[31:0] = {{24{lsu_sized_data[7]}},lsu_sized_data[7:0]};
    {1'b1,HALF} : lsu_data_sign_extd[31:0] = {{16{lsu_sized_data[15]}},lsu_sized_data[15:0]};
    default     : lsu_data_sign_extd[31:0] = lsu_sized_data[31:0];
  endcase
// &CombEnd; @578
end


// &CombBeg; @622
// &CombEnd; @632
//the dbus data at EX stage to RBUS
assign lsu_iu_data[31:0] = lsu_data_sign_extd[31:0];

//when LOAD_FAST_RETIRE, the data from dbus at WB stage will be sent to WB to
//write back
assign lsu_iu_wb_load_data[31:0] = lsu_data_sign_extd[31:0];

assign lsu_iu_addr_vld   = iu_lsu_ex_data_sel;
assign lsu_iu_addr[31:0] = lsu_addr[31:0];

//==========================================================
//               interface to had
//==========================================================
assign lsu_had_st         = lsu_inst_store;
assign lsu_had_addr[31:0] = lsu_bmu_addr[31:0];

// &ModuleEnd; @677
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @24
module cr_lsu_randclk(
  randclk_dp_size_buf_mod_en_w5
);

// &Ports; @25
output       randclk_dp_size_buf_mod_en_w5; 

// &Regs; @26

// &Wires; @27
wire         randclk_dp_size_buf_mod_en_w5; 


// &Force("input","seu_lsu_randclk_mod_en"); @31
// &Force("bus","seu_lsu_randclk_mod_en",31,0); @32
//assign randclk_ctrl_req_mod_en_w2 = 1'b0;

assign randclk_dp_size_buf_mod_en_w5 = 1'b0;


// &ModuleEnd; @76
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @23
module cr_lsu_top(
  bmu_lsu_acc_err,
  bmu_lsu_bstack_chk_fail,
  bmu_lsu_data,
  bmu_lsu_data_vld,
  bmu_lsu_grnt,
  bmu_lsu_trans_cmplt,
  cp0_yy_be_v1,
  cp0_yy_be_v2,
  cp0_yy_clk_en,
  cp0_yy_machine_mode_aft_dbg,
  cpurst_b,
  forever_cpuclk,
  iu_lsu_adder_rst,
  iu_lsu_base,
  iu_lsu_data,
  iu_lsu_ex_byte,
  iu_lsu_ex_data_sel,
  iu_lsu_ex_half,
  iu_lsu_ex_sel,
  iu_lsu_ex_store,
  iu_lsu_ex_uns,
  iu_lsu_imm_data,
  iu_lsu_imm_write_en,
  iu_lsu_offset,
  iu_lsu_oper_mux_en,
  iu_lsu_rs2,
  iu_lsu_stall_without_hready,
  iu_lsu_wb_ldst,
  iu_lsu_wb_load,
  iu_lsu_wb_store,
  iu_yy_xx_flush,
  lsu_bmu_addr,
  lsu_bmu_addr_check_fail,
  lsu_bmu_idle,
  lsu_bmu_prot,
  lsu_bmu_req,
  lsu_bmu_req_without_cmplt,
  lsu_bmu_sg_chk_fail,
  lsu_bmu_size,
  lsu_bmu_store_error,
  lsu_bmu_wdata,
  lsu_bmu_wfd1,
  lsu_bmu_write,
  lsu_had_addr,
  lsu_had_addr_vld,
  lsu_had_ex_cmplt,
  lsu_had_st,
  lsu_iu_addr,
  lsu_iu_addr_vld,
  lsu_iu_alu_sel,
  lsu_iu_data,
  lsu_iu_data_vld,
  lsu_iu_expt_vec,
  lsu_iu_expt_vld,
  lsu_iu_fast_retire,
  lsu_iu_mad_buf,
  lsu_iu_req,
  lsu_iu_stall,
  lsu_iu_stall_noinput,
  lsu_iu_store,
  lsu_iu_wb_acc_err,
  lsu_iu_wb_bstack_chk_fail,
  lsu_iu_wb_cmplt,
  lsu_iu_wb_data_vld,
  lsu_iu_wb_load_data,
  lsu_iu_wfd,
  pad_yy_gate_clk_en_b,
  pmp_lsu_acc_scu,
  sysmap_lsu_acc_ca
);

// &Ports; @24
input           bmu_lsu_acc_err;                     
input           bmu_lsu_bstack_chk_fail;             
input   [31:0]  bmu_lsu_data;                        
input           bmu_lsu_data_vld;                    
input           bmu_lsu_grnt;                        
input           bmu_lsu_trans_cmplt;                 
input           cp0_yy_be_v1;                        
input           cp0_yy_be_v2;                        
input           cp0_yy_clk_en;                       
input           cp0_yy_machine_mode_aft_dbg;         
input           cpurst_b;                            
input           forever_cpuclk;                      
input   [31:0]  iu_lsu_adder_rst;                    
input   [31:0]  iu_lsu_base;                         
input   [31:0]  iu_lsu_data;                         
input           iu_lsu_ex_byte;                      
input           iu_lsu_ex_data_sel;                  
input           iu_lsu_ex_half;                      
input           iu_lsu_ex_sel;                       
input           iu_lsu_ex_store;                     
input           iu_lsu_ex_uns;                       
input   [31:0]  iu_lsu_imm_data;                     
input           iu_lsu_imm_write_en;                 
input   [31:0]  iu_lsu_offset;                       
input           iu_lsu_oper_mux_en;                  
input   [31:0]  iu_lsu_rs2;                          
input           iu_lsu_stall_without_hready;         
input           iu_lsu_wb_ldst;                      
input           iu_lsu_wb_load;                      
input           iu_lsu_wb_store;                     
input           iu_yy_xx_flush;                      
input           pad_yy_gate_clk_en_b;                
input           pmp_lsu_acc_scu;                     
input           sysmap_lsu_acc_ca;                   
output  [31:0]  lsu_bmu_addr;                        
output          lsu_bmu_addr_check_fail;             
output          lsu_bmu_idle;                        
output  [3 :0]  lsu_bmu_prot;                        
output          lsu_bmu_req;                         
output          lsu_bmu_req_without_cmplt;           
output          lsu_bmu_sg_chk_fail;                 
output  [1 :0]  lsu_bmu_size;                        
output          lsu_bmu_store_error;                 
output  [31:0]  lsu_bmu_wdata;                       
output          lsu_bmu_wfd1;                        
output          lsu_bmu_write;                       
output  [31:0]  lsu_had_addr;                        
output          lsu_had_addr_vld;                    
output          lsu_had_ex_cmplt;                    
output          lsu_had_st;                          
output  [31:0]  lsu_iu_addr;                         
output          lsu_iu_addr_vld;                     
output          lsu_iu_alu_sel;                      
output  [31:0]  lsu_iu_data;                         
output          lsu_iu_data_vld;                     
output  [4 :0]  lsu_iu_expt_vec;                     
output          lsu_iu_expt_vld;                     
output          lsu_iu_fast_retire;                  
output  [31:0]  lsu_iu_mad_buf;                      
output          lsu_iu_req;                          
output          lsu_iu_stall;                        
output          lsu_iu_stall_noinput;                
output          lsu_iu_store;                        
output          lsu_iu_wb_acc_err;                   
output          lsu_iu_wb_bstack_chk_fail;           
output          lsu_iu_wb_cmplt;                     
output          lsu_iu_wb_data_vld;                  
output  [31:0]  lsu_iu_wb_load_data;                 
output          lsu_iu_wfd;                          

// &Regs; @25

// &Wires; @26
wire            bmu_lsu_acc_err;                     
wire            bmu_lsu_bstack_chk_fail;             
wire    [31:0]  bmu_lsu_data;                        
wire            bmu_lsu_data_vld;                    
wire            bmu_lsu_grnt;                        
wire            bmu_lsu_trans_cmplt;                 
wire            cp0_yy_be_v1;                        
wire            cp0_yy_be_v2;                        
wire            cp0_yy_clk_en;                       
wire            cp0_yy_machine_mode_aft_dbg;         
wire            cpurst_b;                            
wire            ctrl_dp_ldst_info_buf_reuse;         
wire            ctrl_dp_ldst_req_grnt;               
wire            ctrl_dp_store_buffer_updt;           
wire            ctrl_top_req_en;                     
wire            dp_ctrl_misalign;                    
wire            forever_cpuclk;                      
wire    [31:0]  iu_lsu_adder_rst;                    
wire    [31:0]  iu_lsu_base;                         
wire    [31:0]  iu_lsu_data;                         
wire            iu_lsu_ex_byte;                      
wire            iu_lsu_ex_data_sel;                  
wire            iu_lsu_ex_half;                      
wire            iu_lsu_ex_sel;                       
wire            iu_lsu_ex_store;                     
wire            iu_lsu_ex_uns;                       
wire    [31:0]  iu_lsu_imm_data;                     
wire            iu_lsu_imm_write_en;                 
wire    [31:0]  iu_lsu_offset;                       
wire            iu_lsu_oper_mux_en;                  
wire    [31:0]  iu_lsu_rs2;                          
wire            iu_lsu_stall_without_hready;         
wire            iu_lsu_wb_ldst;                      
wire            iu_lsu_wb_load;                      
wire            iu_lsu_wb_store;                     
wire            iu_yy_xx_flush;                      
wire    [31:0]  lsu_bmu_addr;                        
wire            lsu_bmu_addr_check_fail;             
wire            lsu_bmu_idle;                        
wire    [3 :0]  lsu_bmu_prot;                        
wire            lsu_bmu_req;                         
wire            lsu_bmu_req_without_cmplt;           
wire            lsu_bmu_sg_chk_fail;                 
wire    [1 :0]  lsu_bmu_size;                        
wire            lsu_bmu_store_error;                 
wire    [31:0]  lsu_bmu_wdata;                       
wire            lsu_bmu_wfd1;                        
wire            lsu_bmu_write;                       
wire    [31:0]  lsu_had_addr;                        
wire            lsu_had_addr_vld;                    
wire            lsu_had_ex_cmplt;                    
wire            lsu_had_st;                          
wire            lsu_inst_store;                      
wire    [31:0]  lsu_iu_addr;                         
wire            lsu_iu_addr_vld;                     
wire            lsu_iu_alu_sel;                      
wire    [31:0]  lsu_iu_data;                         
wire            lsu_iu_data_vld;                     
wire    [4 :0]  lsu_iu_expt_vec;                     
wire            lsu_iu_expt_vld;                     
wire            lsu_iu_fast_retire;                  
wire    [31:0]  lsu_iu_mad_buf;                      
wire            lsu_iu_req;                          
wire            lsu_iu_stall;                        
wire            lsu_iu_stall_noinput;                
wire            lsu_iu_store;                        
wire            lsu_iu_wb_acc_err;                   
wire            lsu_iu_wb_bstack_chk_fail;           
wire            lsu_iu_wb_cmplt;                     
wire            lsu_iu_wb_data_vld;                  
wire    [31:0]  lsu_iu_wb_load_data;                 
wire            lsu_iu_wfd;                          
wire            pad_yy_gate_clk_en_b;                
wire            pmp_lsu_acc_scu;                     
wire            randclk_dp_size_buf_mod_en_w5;       
wire            sysmap_lsu_acc_ca;                   
wire            top_sm_clk_en;                       
wire            unalign_ctrl_not_last_beat;          
wire            unalign_ctrl_stall;                  
wire            unalign_dp_first_req;                
wire            unalign_dp_load_data_byte1_to_byte1; 
wire            unalign_dp_load_data_byte1_to_byte2; 
wire            unalign_dp_load_data_byte1_to_byte3; 
wire            unalign_dp_load_data_byte1_to_byte4; 
wire            unalign_dp_load_data_byte2_to_byte1; 
wire            unalign_dp_load_data_byte2_to_byte2; 
wire            unalign_dp_load_data_byte2_to_byte3; 
wire            unalign_dp_load_data_byte2_to_byte4; 
wire            unalign_dp_load_data_byte3_to_byte1; 
wire            unalign_dp_load_data_byte3_to_byte2; 
wire            unalign_dp_load_data_byte3_to_byte3; 
wire            unalign_dp_load_data_byte3_to_byte4; 
wire            unalign_dp_load_data_byte4_to_byte1; 
wire            unalign_dp_load_data_byte4_to_byte2; 
wire            unalign_dp_load_data_byte4_to_byte3; 
wire            unalign_dp_load_data_byte4_to_byte4; 
wire            unalign_dp_store_data_byte1_to_byte1; 
wire            unalign_dp_store_data_byte1_to_byte2; 
wire            unalign_dp_store_data_byte1_to_byte3; 
wire            unalign_dp_store_data_byte1_to_byte4; 
wire            unalign_dp_store_data_byte2_to_byte1; 
wire            unalign_dp_store_data_byte2_to_byte2; 
wire            unalign_dp_store_data_byte2_to_byte3; 
wire            unalign_dp_store_data_byte2_to_byte4; 
wire            unalign_dp_store_data_byte3_to_byte1; 
wire            unalign_dp_store_data_byte3_to_byte2; 
wire            unalign_dp_store_data_byte3_to_byte3; 
wire            unalign_dp_store_data_byte3_to_byte4; 
wire            unalign_dp_store_data_byte4_to_byte1; 
wire            unalign_dp_store_data_byte4_to_byte2; 
wire            unalign_dp_store_data_byte4_to_byte3; 
wire            unalign_dp_store_data_byte4_to_byte4; 
wire            unalign_top_clk_en;                  
wire            unalign_xx_split_on;                 


assign top_sm_clk_en = ctrl_top_req_en || unalign_top_clk_en;
// &Instance("gated_clk_cell", "x_sm_gated_clk"); @31
// &Connect(.clk_in      (forever_cpuclk), @32
//          .external_en (1'b0), @33
//          .global_en   (cp0_yy_clk_en), @34
//          .module_en   (1'b0), @35
//          .local_en    (top_sm_clk_en), @36
//          .clk_out     (sm_clk));  @37
// &Force("nonport","top_sm_clk_en"); @39
// &Instance("gated_clk_cell", "x_sm_gated_clk"); @42
// &Connect(.clk_in      (forever_cpuclk), @43
//          .external_en (1'b0), @44
//          .global_en   (cp0_yy_clk_en), @45
//          .module_en   (1'b0), @46
//          .local_en    (top_sm_clk_en), @47
//          .clk_out     (sm_clk)); @48


// &Instance("cr_lsu_dp","x_cr_lsu_dp"); @52
cr_lsu_dp  x_cr_lsu_dp (
  .bmu_lsu_data                         (bmu_lsu_data                        ),
  .cp0_yy_be_v1                         (cp0_yy_be_v1                        ),
  .cp0_yy_be_v2                         (cp0_yy_be_v2                        ),
  .cp0_yy_clk_en                        (cp0_yy_clk_en                       ),
  .cp0_yy_machine_mode_aft_dbg          (cp0_yy_machine_mode_aft_dbg         ),
  .cpurst_b                             (cpurst_b                            ),
  .ctrl_dp_ldst_info_buf_reuse          (ctrl_dp_ldst_info_buf_reuse         ),
  .ctrl_dp_ldst_req_grnt                (ctrl_dp_ldst_req_grnt               ),
  .ctrl_dp_store_buffer_updt            (ctrl_dp_store_buffer_updt           ),
  .dp_ctrl_misalign                     (dp_ctrl_misalign                    ),
  .forever_cpuclk                       (forever_cpuclk                      ),
  .iu_lsu_adder_rst                     (iu_lsu_adder_rst                    ),
  .iu_lsu_base                          (iu_lsu_base                         ),
  .iu_lsu_data                          (iu_lsu_data                         ),
  .iu_lsu_ex_byte                       (iu_lsu_ex_byte                      ),
  .iu_lsu_ex_data_sel                   (iu_lsu_ex_data_sel                  ),
  .iu_lsu_ex_half                       (iu_lsu_ex_half                      ),
  .iu_lsu_ex_uns                        (iu_lsu_ex_uns                       ),
  .iu_lsu_imm_data                      (iu_lsu_imm_data                     ),
  .iu_lsu_imm_write_en                  (iu_lsu_imm_write_en                 ),
  .iu_lsu_offset                        (iu_lsu_offset                       ),
  .iu_lsu_oper_mux_en                   (iu_lsu_oper_mux_en                  ),
  .iu_lsu_rs2                           (iu_lsu_rs2                          ),
  .lsu_bmu_addr                         (lsu_bmu_addr                        ),
  .lsu_bmu_prot                         (lsu_bmu_prot                        ),
  .lsu_bmu_size                         (lsu_bmu_size                        ),
  .lsu_bmu_store_error                  (lsu_bmu_store_error                 ),
  .lsu_bmu_wdata                        (lsu_bmu_wdata                       ),
  .lsu_bmu_write                        (lsu_bmu_write                       ),
  .lsu_had_addr                         (lsu_had_addr                        ),
  .lsu_had_st                           (lsu_had_st                          ),
  .lsu_inst_store                       (lsu_inst_store                      ),
  .lsu_iu_addr                          (lsu_iu_addr                         ),
  .lsu_iu_addr_vld                      (lsu_iu_addr_vld                     ),
  .lsu_iu_alu_sel                       (lsu_iu_alu_sel                      ),
  .lsu_iu_data                          (lsu_iu_data                         ),
  .lsu_iu_mad_buf                       (lsu_iu_mad_buf                      ),
  .lsu_iu_store                         (lsu_iu_store                        ),
  .lsu_iu_wb_load_data                  (lsu_iu_wb_load_data                 ),
  .pad_yy_gate_clk_en_b                 (pad_yy_gate_clk_en_b                ),
  .pmp_lsu_acc_scu                      (pmp_lsu_acc_scu                     ),
  .randclk_dp_size_buf_mod_en_w5        (randclk_dp_size_buf_mod_en_w5       ),
  .sysmap_lsu_acc_ca                    (sysmap_lsu_acc_ca                   ),
  .unalign_dp_first_req                 (unalign_dp_first_req                ),
  .unalign_dp_load_data_byte1_to_byte1  (unalign_dp_load_data_byte1_to_byte1 ),
  .unalign_dp_load_data_byte1_to_byte2  (unalign_dp_load_data_byte1_to_byte2 ),
  .unalign_dp_load_data_byte1_to_byte3  (unalign_dp_load_data_byte1_to_byte3 ),
  .unalign_dp_load_data_byte1_to_byte4  (unalign_dp_load_data_byte1_to_byte4 ),
  .unalign_dp_load_data_byte2_to_byte1  (unalign_dp_load_data_byte2_to_byte1 ),
  .unalign_dp_load_data_byte2_to_byte2  (unalign_dp_load_data_byte2_to_byte2 ),
  .unalign_dp_load_data_byte2_to_byte3  (unalign_dp_load_data_byte2_to_byte3 ),
  .unalign_dp_load_data_byte2_to_byte4  (unalign_dp_load_data_byte2_to_byte4 ),
  .unalign_dp_load_data_byte3_to_byte1  (unalign_dp_load_data_byte3_to_byte1 ),
  .unalign_dp_load_data_byte3_to_byte2  (unalign_dp_load_data_byte3_to_byte2 ),
  .unalign_dp_load_data_byte3_to_byte3  (unalign_dp_load_data_byte3_to_byte3 ),
  .unalign_dp_load_data_byte3_to_byte4  (unalign_dp_load_data_byte3_to_byte4 ),
  .unalign_dp_load_data_byte4_to_byte1  (unalign_dp_load_data_byte4_to_byte1 ),
  .unalign_dp_load_data_byte4_to_byte2  (unalign_dp_load_data_byte4_to_byte2 ),
  .unalign_dp_load_data_byte4_to_byte3  (unalign_dp_load_data_byte4_to_byte3 ),
  .unalign_dp_load_data_byte4_to_byte4  (unalign_dp_load_data_byte4_to_byte4 ),
  .unalign_dp_store_data_byte1_to_byte1 (unalign_dp_store_data_byte1_to_byte1),
  .unalign_dp_store_data_byte1_to_byte2 (unalign_dp_store_data_byte1_to_byte2),
  .unalign_dp_store_data_byte1_to_byte3 (unalign_dp_store_data_byte1_to_byte3),
  .unalign_dp_store_data_byte1_to_byte4 (unalign_dp_store_data_byte1_to_byte4),
  .unalign_dp_store_data_byte2_to_byte1 (unalign_dp_store_data_byte2_to_byte1),
  .unalign_dp_store_data_byte2_to_byte2 (unalign_dp_store_data_byte2_to_byte2),
  .unalign_dp_store_data_byte2_to_byte3 (unalign_dp_store_data_byte2_to_byte3),
  .unalign_dp_store_data_byte2_to_byte4 (unalign_dp_store_data_byte2_to_byte4),
  .unalign_dp_store_data_byte3_to_byte1 (unalign_dp_store_data_byte3_to_byte1),
  .unalign_dp_store_data_byte3_to_byte2 (unalign_dp_store_data_byte3_to_byte2),
  .unalign_dp_store_data_byte3_to_byte3 (unalign_dp_store_data_byte3_to_byte3),
  .unalign_dp_store_data_byte3_to_byte4 (unalign_dp_store_data_byte3_to_byte4),
  .unalign_dp_store_data_byte4_to_byte1 (unalign_dp_store_data_byte4_to_byte1),
  .unalign_dp_store_data_byte4_to_byte2 (unalign_dp_store_data_byte4_to_byte2),
  .unalign_dp_store_data_byte4_to_byte3 (unalign_dp_store_data_byte4_to_byte3),
  .unalign_dp_store_data_byte4_to_byte4 (unalign_dp_store_data_byte4_to_byte4)
);


// &Connect(.pmp_lsu_acc_scu (1'b0)); @58


// &Connect(.cru_lsu_acc_ca (1'b0)); @65


// &Instance("cr_lsu_ctrl","x_cr_lsu_ctrl"); @69
cr_lsu_ctrl  x_cr_lsu_ctrl (
  .bmu_lsu_acc_err             (bmu_lsu_acc_err            ),
  .bmu_lsu_bstack_chk_fail     (bmu_lsu_bstack_chk_fail    ),
  .bmu_lsu_data_vld            (bmu_lsu_data_vld           ),
  .bmu_lsu_grnt                (bmu_lsu_grnt               ),
  .bmu_lsu_trans_cmplt         (bmu_lsu_trans_cmplt        ),
  .cpurst_b                    (cpurst_b                   ),
  .ctrl_dp_ldst_info_buf_reuse (ctrl_dp_ldst_info_buf_reuse),
  .ctrl_dp_ldst_req_grnt       (ctrl_dp_ldst_req_grnt      ),
  .ctrl_dp_store_buffer_updt   (ctrl_dp_store_buffer_updt  ),
  .ctrl_top_req_en             (ctrl_top_req_en            ),
  .dp_ctrl_misalign            (dp_ctrl_misalign           ),
  .iu_lsu_ex_data_sel          (iu_lsu_ex_data_sel         ),
  .iu_lsu_ex_sel               (iu_lsu_ex_sel              ),
  .iu_lsu_ex_store             (iu_lsu_ex_store            ),
  .iu_lsu_oper_mux_en          (iu_lsu_oper_mux_en         ),
  .iu_lsu_stall_without_hready (iu_lsu_stall_without_hready),
  .iu_lsu_wb_ldst              (iu_lsu_wb_ldst             ),
  .iu_lsu_wb_load              (iu_lsu_wb_load             ),
  .iu_lsu_wb_store             (iu_lsu_wb_store            ),
  .iu_yy_xx_flush              (iu_yy_xx_flush             ),
  .lsu_bmu_addr_check_fail     (lsu_bmu_addr_check_fail    ),
  .lsu_bmu_idle                (lsu_bmu_idle               ),
  .lsu_bmu_req                 (lsu_bmu_req                ),
  .lsu_bmu_req_without_cmplt   (lsu_bmu_req_without_cmplt  ),
  .lsu_bmu_sg_chk_fail         (lsu_bmu_sg_chk_fail        ),
  .lsu_bmu_wfd1                (lsu_bmu_wfd1               ),
  .lsu_had_addr_vld            (lsu_had_addr_vld           ),
  .lsu_had_ex_cmplt            (lsu_had_ex_cmplt           ),
  .lsu_inst_store              (lsu_inst_store             ),
  .lsu_iu_data_vld             (lsu_iu_data_vld            ),
  .lsu_iu_expt_vec             (lsu_iu_expt_vec            ),
  .lsu_iu_expt_vld             (lsu_iu_expt_vld            ),
  .lsu_iu_fast_retire          (lsu_iu_fast_retire         ),
  .lsu_iu_req                  (lsu_iu_req                 ),
  .lsu_iu_stall                (lsu_iu_stall               ),
  .lsu_iu_stall_noinput        (lsu_iu_stall_noinput       ),
  .lsu_iu_wb_acc_err           (lsu_iu_wb_acc_err          ),
  .lsu_iu_wb_bstack_chk_fail   (lsu_iu_wb_bstack_chk_fail  ),
  .lsu_iu_wb_cmplt             (lsu_iu_wb_cmplt            ),
  .lsu_iu_wb_data_vld          (lsu_iu_wb_data_vld         ),
  .lsu_iu_wfd                  (lsu_iu_wfd                 ),
  .sm_clk                      (forever_cpuclk             ),
  .unalign_ctrl_not_last_beat  (unalign_ctrl_not_last_beat ),
  .unalign_ctrl_stall          (unalign_ctrl_stall         ),
  .unalign_xx_split_on         (unalign_xx_split_on        )
);

// &Connect(.sm_clk   (forever_cpuclk)); @73
// &Instance("cr_lsu_randclk","x_randclk"); @75
cr_lsu_randclk  x_randclk (
  .randclk_dp_size_buf_mod_en_w5 (randclk_dp_size_buf_mod_en_w5)
);


// &Instance("cr_lsu_unalign","x_cr_lsu_unalign"); @78
cr_lsu_unalign  x_cr_lsu_unalign (
  .unalign_ctrl_not_last_beat           (unalign_ctrl_not_last_beat          ),
  .unalign_ctrl_stall                   (unalign_ctrl_stall                  ),
  .unalign_dp_first_req                 (unalign_dp_first_req                ),
  .unalign_dp_load_data_byte1_to_byte1  (unalign_dp_load_data_byte1_to_byte1 ),
  .unalign_dp_load_data_byte1_to_byte2  (unalign_dp_load_data_byte1_to_byte2 ),
  .unalign_dp_load_data_byte1_to_byte3  (unalign_dp_load_data_byte1_to_byte3 ),
  .unalign_dp_load_data_byte1_to_byte4  (unalign_dp_load_data_byte1_to_byte4 ),
  .unalign_dp_load_data_byte2_to_byte1  (unalign_dp_load_data_byte2_to_byte1 ),
  .unalign_dp_load_data_byte2_to_byte2  (unalign_dp_load_data_byte2_to_byte2 ),
  .unalign_dp_load_data_byte2_to_byte3  (unalign_dp_load_data_byte2_to_byte3 ),
  .unalign_dp_load_data_byte2_to_byte4  (unalign_dp_load_data_byte2_to_byte4 ),
  .unalign_dp_load_data_byte3_to_byte1  (unalign_dp_load_data_byte3_to_byte1 ),
  .unalign_dp_load_data_byte3_to_byte2  (unalign_dp_load_data_byte3_to_byte2 ),
  .unalign_dp_load_data_byte3_to_byte3  (unalign_dp_load_data_byte3_to_byte3 ),
  .unalign_dp_load_data_byte3_to_byte4  (unalign_dp_load_data_byte3_to_byte4 ),
  .unalign_dp_load_data_byte4_to_byte1  (unalign_dp_load_data_byte4_to_byte1 ),
  .unalign_dp_load_data_byte4_to_byte2  (unalign_dp_load_data_byte4_to_byte2 ),
  .unalign_dp_load_data_byte4_to_byte3  (unalign_dp_load_data_byte4_to_byte3 ),
  .unalign_dp_load_data_byte4_to_byte4  (unalign_dp_load_data_byte4_to_byte4 ),
  .unalign_dp_store_data_byte1_to_byte1 (unalign_dp_store_data_byte1_to_byte1),
  .unalign_dp_store_data_byte1_to_byte2 (unalign_dp_store_data_byte1_to_byte2),
  .unalign_dp_store_data_byte1_to_byte3 (unalign_dp_store_data_byte1_to_byte3),
  .unalign_dp_store_data_byte1_to_byte4 (unalign_dp_store_data_byte1_to_byte4),
  .unalign_dp_store_data_byte2_to_byte1 (unalign_dp_store_data_byte2_to_byte1),
  .unalign_dp_store_data_byte2_to_byte2 (unalign_dp_store_data_byte2_to_byte2),
  .unalign_dp_store_data_byte2_to_byte3 (unalign_dp_store_data_byte2_to_byte3),
  .unalign_dp_store_data_byte2_to_byte4 (unalign_dp_store_data_byte2_to_byte4),
  .unalign_dp_store_data_byte3_to_byte1 (unalign_dp_store_data_byte3_to_byte1),
  .unalign_dp_store_data_byte3_to_byte2 (unalign_dp_store_data_byte3_to_byte2),
  .unalign_dp_store_data_byte3_to_byte3 (unalign_dp_store_data_byte3_to_byte3),
  .unalign_dp_store_data_byte3_to_byte4 (unalign_dp_store_data_byte3_to_byte4),
  .unalign_dp_store_data_byte4_to_byte1 (unalign_dp_store_data_byte4_to_byte1),
  .unalign_dp_store_data_byte4_to_byte2 (unalign_dp_store_data_byte4_to_byte2),
  .unalign_dp_store_data_byte4_to_byte3 (unalign_dp_store_data_byte4_to_byte3),
  .unalign_dp_store_data_byte4_to_byte4 (unalign_dp_store_data_byte4_to_byte4),
  .unalign_top_clk_en                   (unalign_top_clk_en                  ),
  .unalign_xx_split_on                  (unalign_xx_split_on                 )
);



// &ModuleEnd; @81
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @22
module cr_lsu_unalign(
  unalign_ctrl_not_last_beat,
  unalign_ctrl_stall,
  unalign_dp_first_req,
  unalign_dp_load_data_byte1_to_byte1,
  unalign_dp_load_data_byte1_to_byte2,
  unalign_dp_load_data_byte1_to_byte3,
  unalign_dp_load_data_byte1_to_byte4,
  unalign_dp_load_data_byte2_to_byte1,
  unalign_dp_load_data_byte2_to_byte2,
  unalign_dp_load_data_byte2_to_byte3,
  unalign_dp_load_data_byte2_to_byte4,
  unalign_dp_load_data_byte3_to_byte1,
  unalign_dp_load_data_byte3_to_byte2,
  unalign_dp_load_data_byte3_to_byte3,
  unalign_dp_load_data_byte3_to_byte4,
  unalign_dp_load_data_byte4_to_byte1,
  unalign_dp_load_data_byte4_to_byte2,
  unalign_dp_load_data_byte4_to_byte3,
  unalign_dp_load_data_byte4_to_byte4,
  unalign_dp_store_data_byte1_to_byte1,
  unalign_dp_store_data_byte1_to_byte2,
  unalign_dp_store_data_byte1_to_byte3,
  unalign_dp_store_data_byte1_to_byte4,
  unalign_dp_store_data_byte2_to_byte1,
  unalign_dp_store_data_byte2_to_byte2,
  unalign_dp_store_data_byte2_to_byte3,
  unalign_dp_store_data_byte2_to_byte4,
  unalign_dp_store_data_byte3_to_byte1,
  unalign_dp_store_data_byte3_to_byte2,
  unalign_dp_store_data_byte3_to_byte3,
  unalign_dp_store_data_byte3_to_byte4,
  unalign_dp_store_data_byte4_to_byte1,
  unalign_dp_store_data_byte4_to_byte2,
  unalign_dp_store_data_byte4_to_byte3,
  unalign_dp_store_data_byte4_to_byte4,
  unalign_top_clk_en,
  unalign_xx_split_on
);

// &Ports; @23
output       unalign_ctrl_not_last_beat;          
output       unalign_ctrl_stall;                  
output       unalign_dp_first_req;                
output       unalign_dp_load_data_byte1_to_byte1; 
output       unalign_dp_load_data_byte1_to_byte2; 
output       unalign_dp_load_data_byte1_to_byte3; 
output       unalign_dp_load_data_byte1_to_byte4; 
output       unalign_dp_load_data_byte2_to_byte1; 
output       unalign_dp_load_data_byte2_to_byte2; 
output       unalign_dp_load_data_byte2_to_byte3; 
output       unalign_dp_load_data_byte2_to_byte4; 
output       unalign_dp_load_data_byte3_to_byte1; 
output       unalign_dp_load_data_byte3_to_byte2; 
output       unalign_dp_load_data_byte3_to_byte3; 
output       unalign_dp_load_data_byte3_to_byte4; 
output       unalign_dp_load_data_byte4_to_byte1; 
output       unalign_dp_load_data_byte4_to_byte2; 
output       unalign_dp_load_data_byte4_to_byte3; 
output       unalign_dp_load_data_byte4_to_byte4; 
output       unalign_dp_store_data_byte1_to_byte1; 
output       unalign_dp_store_data_byte1_to_byte2; 
output       unalign_dp_store_data_byte1_to_byte3; 
output       unalign_dp_store_data_byte1_to_byte4; 
output       unalign_dp_store_data_byte2_to_byte1; 
output       unalign_dp_store_data_byte2_to_byte2; 
output       unalign_dp_store_data_byte2_to_byte3; 
output       unalign_dp_store_data_byte2_to_byte4; 
output       unalign_dp_store_data_byte3_to_byte1; 
output       unalign_dp_store_data_byte3_to_byte2; 
output       unalign_dp_store_data_byte3_to_byte3; 
output       unalign_dp_store_data_byte3_to_byte4; 
output       unalign_dp_store_data_byte4_to_byte1; 
output       unalign_dp_store_data_byte4_to_byte2; 
output       unalign_dp_store_data_byte4_to_byte3; 
output       unalign_dp_store_data_byte4_to_byte4; 
output       unalign_top_clk_en;                  
output       unalign_xx_split_on;                 

// &Regs; @24

// &Wires; @25
wire         unalign_ctrl_not_last_beat;          
wire         unalign_ctrl_stall;                  
wire         unalign_dp_first_req;                
wire         unalign_dp_load_data_byte1_to_byte1; 
wire         unalign_dp_load_data_byte1_to_byte2; 
wire         unalign_dp_load_data_byte1_to_byte3; 
wire         unalign_dp_load_data_byte1_to_byte4; 
wire         unalign_dp_load_data_byte2_to_byte1; 
wire         unalign_dp_load_data_byte2_to_byte2; 
wire         unalign_dp_load_data_byte2_to_byte3; 
wire         unalign_dp_load_data_byte2_to_byte4; 
wire         unalign_dp_load_data_byte3_to_byte1; 
wire         unalign_dp_load_data_byte3_to_byte2; 
wire         unalign_dp_load_data_byte3_to_byte3; 
wire         unalign_dp_load_data_byte3_to_byte4; 
wire         unalign_dp_load_data_byte4_to_byte1; 
wire         unalign_dp_load_data_byte4_to_byte2; 
wire         unalign_dp_load_data_byte4_to_byte3; 
wire         unalign_dp_load_data_byte4_to_byte4; 
wire         unalign_dp_store_data_byte1_to_byte1; 
wire         unalign_dp_store_data_byte1_to_byte2; 
wire         unalign_dp_store_data_byte1_to_byte3; 
wire         unalign_dp_store_data_byte1_to_byte4; 
wire         unalign_dp_store_data_byte2_to_byte1; 
wire         unalign_dp_store_data_byte2_to_byte2; 
wire         unalign_dp_store_data_byte2_to_byte3; 
wire         unalign_dp_store_data_byte2_to_byte4; 
wire         unalign_dp_store_data_byte3_to_byte1; 
wire         unalign_dp_store_data_byte3_to_byte2; 
wire         unalign_dp_store_data_byte3_to_byte3; 
wire         unalign_dp_store_data_byte3_to_byte4; 
wire         unalign_dp_store_data_byte4_to_byte1; 
wire         unalign_dp_store_data_byte4_to_byte2; 
wire         unalign_dp_store_data_byte4_to_byte3; 
wire         unalign_dp_store_data_byte4_to_byte4; 
wire         unalign_top_clk_en;                  
wire         unalign_xx_split_on;                 


// //&Connect(.clk_in      (forever_cpuclk), @39
// //         .external_en (1'b0), @40
// //         .global_en   (cp0_yy_clk_en), @41
// //         .module_en   (randclk_unalign_mod_en_w2), @42
// //         .local_en    (unalign_en), @43
// //         .clk_out     (unalign_clk)); @44
// &CombBeg; @91
// &CombEnd; @125
assign unalign_top_clk_en = 1'b0;
//assign lsu_iu_unalign_split_stall = 1'b0;
assign unalign_ctrl_not_last_beat = 1'b0;
assign unalign_ctrl_stall = 1'b0;
assign unalign_dp_first_req = 1'b1;
assign unalign_xx_split_on = 1'b0;


//assign unalign_ctrl_load_mask = 1'b0;
assign unalign_dp_load_data_byte1_to_byte1 = 1'b0;
assign unalign_dp_load_data_byte1_to_byte2 = 1'b0;
assign unalign_dp_load_data_byte1_to_byte3 = 1'b0;
assign unalign_dp_load_data_byte1_to_byte4 = 1'b0;
assign unalign_dp_load_data_byte2_to_byte1 = 1'b0;
assign unalign_dp_load_data_byte2_to_byte2 = 1'b0;
assign unalign_dp_load_data_byte2_to_byte3 = 1'b0;
assign unalign_dp_load_data_byte2_to_byte4 = 1'b0;
assign unalign_dp_load_data_byte3_to_byte1 = 1'b0;
assign unalign_dp_load_data_byte3_to_byte2 = 1'b0;
assign unalign_dp_load_data_byte3_to_byte3 = 1'b0;
assign unalign_dp_load_data_byte3_to_byte4 = 1'b0;
assign unalign_dp_load_data_byte4_to_byte1 = 1'b0;
assign unalign_dp_load_data_byte4_to_byte2 = 1'b0;
assign unalign_dp_load_data_byte4_to_byte3 = 1'b0;
assign unalign_dp_load_data_byte4_to_byte4 = 1'b0;
//assign unalign_dp_plus1_addr;
//assign unalign_dp_plus2_addr;
//assign unalign_dp_plus3_addr;
//assign unalign_dp_size_half;
//assign unalign_dp_size_word;
assign unalign_dp_store_data_byte1_to_byte1 = 1'b0;
assign unalign_dp_store_data_byte1_to_byte2 = 1'b0;
assign unalign_dp_store_data_byte1_to_byte3 = 1'b0;
assign unalign_dp_store_data_byte1_to_byte4 = 1'b0;
assign unalign_dp_store_data_byte2_to_byte1 = 1'b0;
assign unalign_dp_store_data_byte2_to_byte2 = 1'b0;
assign unalign_dp_store_data_byte2_to_byte3 = 1'b0;
assign unalign_dp_store_data_byte2_to_byte4 = 1'b0;
assign unalign_dp_store_data_byte3_to_byte1 = 1'b0;
assign unalign_dp_store_data_byte3_to_byte2 = 1'b0;
assign unalign_dp_store_data_byte3_to_byte3 = 1'b0;
assign unalign_dp_store_data_byte3_to_byte4 = 1'b0;
assign unalign_dp_store_data_byte4_to_byte1 = 1'b0;
assign unalign_dp_store_data_byte4_to_byte2 = 1'b0;
assign unalign_dp_store_data_byte4_to_byte3 = 1'b0;
assign unalign_dp_store_data_byte4_to_byte4 = 1'b0;





// &ModuleEnd; @411
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_pmp_acc_arb(
  cp0_pmp_mstatus_mpp,
  cp0_pmp_mstatus_mprv,
  cp0_yy_machine_mode_aft_dbg,
  ifu_access_deny_region,
  ifu_access_no_hit_deny,
  ifu_bmu_prot,
  lsu_access_deny_region,
  lsu_access_no_hit_deny,
  lsu_pmp_is_st,
  regs_comp_excut0,
  regs_comp_excut1,
  regs_comp_excut2,
  regs_comp_excut3,
  regs_comp_excut4,
  regs_comp_excut5,
  regs_comp_excut6,
  regs_comp_excut7,
  regs_comp_lock0,
  regs_comp_lock1,
  regs_comp_lock2,
  regs_comp_lock3,
  regs_comp_lock4,
  regs_comp_lock5,
  regs_comp_lock6,
  regs_comp_lock7,
  regs_comp_read0,
  regs_comp_read1,
  regs_comp_read2,
  regs_comp_read3,
  regs_comp_read4,
  regs_comp_read5,
  regs_comp_read6,
  regs_comp_read7,
  regs_comp_write0,
  regs_comp_write1,
  regs_comp_write2,
  regs_comp_write3,
  regs_comp_write4,
  regs_comp_write5,
  regs_comp_write6,
  regs_comp_write7
);

// &Ports; @25
input   [1:0]  cp0_pmp_mstatus_mpp;        
input          cp0_pmp_mstatus_mprv;       
input          cp0_yy_machine_mode_aft_dbg; 
input   [3:0]  ifu_bmu_prot;               
input          lsu_pmp_is_st;              
input          regs_comp_excut0;           
input          regs_comp_excut1;           
input          regs_comp_excut2;           
input          regs_comp_excut3;           
input          regs_comp_excut4;           
input          regs_comp_excut5;           
input          regs_comp_excut6;           
input          regs_comp_excut7;           
input          regs_comp_lock0;            
input          regs_comp_lock1;            
input          regs_comp_lock2;            
input          regs_comp_lock3;            
input          regs_comp_lock4;            
input          regs_comp_lock5;            
input          regs_comp_lock6;            
input          regs_comp_lock7;            
input          regs_comp_read0;            
input          regs_comp_read1;            
input          regs_comp_read2;            
input          regs_comp_read3;            
input          regs_comp_read4;            
input          regs_comp_read5;            
input          regs_comp_read6;            
input          regs_comp_read7;            
input          regs_comp_write0;           
input          regs_comp_write1;           
input          regs_comp_write2;           
input          regs_comp_write3;           
input          regs_comp_write4;           
input          regs_comp_write5;           
input          regs_comp_write6;           
input          regs_comp_write7;           
output  [7:0]  ifu_access_deny_region;     
output         ifu_access_no_hit_deny;     
output  [7:0]  lsu_access_deny_region;     
output         lsu_access_no_hit_deny;     

// &Regs; @26

// &Wires; @27
wire    [1:0]  cp0_pmp_mstatus_mpp;        
wire           cp0_pmp_mstatus_mprv;       
wire           cp0_yy_machine_mode_aft_dbg; 
wire           ifu_acc_machine_mode;       
wire           ifu_acc_user_mode;          
wire           ifu_access_deny0;           
wire           ifu_access_deny1;           
wire           ifu_access_deny2;           
wire           ifu_access_deny3;           
wire           ifu_access_deny4;           
wire           ifu_access_deny5;           
wire           ifu_access_deny6;           
wire           ifu_access_deny7;           
wire    [7:0]  ifu_access_deny_region;     
wire           ifu_access_no_hit_deny;     
wire    [3:0]  ifu_bmu_prot;               
wire           lsu_acc_machine_mode;       
wire           lsu_acc_user_mode;          
wire           lsu_access_deny0;           
wire           lsu_access_deny1;           
wire           lsu_access_deny2;           
wire           lsu_access_deny3;           
wire           lsu_access_deny4;           
wire           lsu_access_deny5;           
wire           lsu_access_deny6;           
wire           lsu_access_deny7;           
wire    [7:0]  lsu_access_deny_region;     
wire           lsu_access_no_hit_deny;     
wire           lsu_pmp_is_st;              
wire           regs_comp_excut0;           
wire           regs_comp_excut1;           
wire           regs_comp_excut2;           
wire           regs_comp_excut3;           
wire           regs_comp_excut4;           
wire           regs_comp_excut5;           
wire           regs_comp_excut6;           
wire           regs_comp_excut7;           
wire           regs_comp_lock0;            
wire           regs_comp_lock1;            
wire           regs_comp_lock2;            
wire           regs_comp_lock3;            
wire           regs_comp_lock4;            
wire           regs_comp_lock5;            
wire           regs_comp_lock6;            
wire           regs_comp_lock7;            
wire           regs_comp_read0;            
wire           regs_comp_read1;            
wire           regs_comp_read2;            
wire           regs_comp_read3;            
wire           regs_comp_read4;            
wire           regs_comp_read5;            
wire           regs_comp_read6;            
wire           regs_comp_read7;            
wire           regs_comp_write0;           
wire           regs_comp_write1;           
wire           regs_comp_write2;           
wire           regs_comp_write3;           
wire           regs_comp_write4;           
wire           regs_comp_write5;           
wire           regs_comp_write6;           
wire           regs_comp_write7;           


// &Force("bus","ifu_bmu_prot",3,0); @29
//==========================================================
//                Attribute Matching Logic
//==========================================================
//-------------------------------------------
// Check the access attribute of each region
//-------------------------------------------
assign lsu_acc_machine_mode = cp0_yy_machine_mode_aft_dbg && !cp0_pmp_mstatus_mprv
                           || (cp0_pmp_mstatus_mpp[1:0] == 2'b11) && cp0_pmp_mstatus_mprv;
                     
assign lsu_acc_user_mode    = !cp0_yy_machine_mode_aft_dbg && !cp0_pmp_mstatus_mprv
                           || (cp0_pmp_mstatus_mpp[1:0] == 2'b00)  && cp0_pmp_mstatus_mprv;

//when bmu not grant,acc machine mode and secure mode should not change
assign ifu_acc_machine_mode = ifu_bmu_prot[1]; 
assign ifu_acc_user_mode    = !ifu_bmu_prot[1];


//-----------------------------------------
// Checks the access attribute with no entry hit
//-----------------------------------------
assign ifu_access_no_hit_deny = ifu_acc_user_mode;
assign lsu_access_no_hit_deny = lsu_acc_user_mode;

//-----------------------------------------
// Checks the access attribute of region 0
//-----------------------------------------
//IFU deny will be generated when:
//1. ifu access in machine mode:
//(1) PMP entry is locked 
//(2) PMP entry is not executeable
//2. ifu access in user mode:
//(2) PMP entry is not executeable
assign ifu_access_deny_region[0] = ifu_access_deny0;
assign ifu_access_deny0          = ifu_acc_machine_mode && regs_comp_lock0 && !regs_comp_excut0
                                || ifu_acc_user_mode && !regs_comp_excut0;

//LSU deny will be generated when:
//1.lsu access in machine mode:
//(1) PMP entry is locked
//(2) access is load and PMP entry is not readable
//    access is store and PMP entry is not writeable
//2.lsu access in user mode:
//(1) access is load and PMP entry is not readable
//    access is store and PMP entry is not writeable
assign lsu_access_deny_region[0] = lsu_access_deny0;
assign lsu_access_deny0          = lsu_acc_machine_mode && regs_comp_lock0 
                                   && (lsu_pmp_is_st && !regs_comp_write0 
                                       || !lsu_pmp_is_st && !regs_comp_read0)
                                || lsu_acc_user_mode                              
                                   && (lsu_pmp_is_st && !regs_comp_write0 
                                       || !lsu_pmp_is_st && !regs_comp_read0);

//-----------------------------------------
// Checks the access attribute of region 1
//-----------------------------------------
assign ifu_access_deny_region[1] = ifu_access_deny1;
assign lsu_access_deny_region[1] = lsu_access_deny1;
assign ifu_access_deny1          = ifu_acc_machine_mode && regs_comp_lock1 && !regs_comp_excut1
                                || ifu_acc_user_mode && !regs_comp_excut1;

assign lsu_access_deny1          = lsu_acc_machine_mode && regs_comp_lock1 
                                   && (lsu_pmp_is_st && !regs_comp_write1 
                                       || !lsu_pmp_is_st && !regs_comp_read1)
                                || lsu_acc_user_mode                              
                                   && (lsu_pmp_is_st && !regs_comp_write1 
                                       || !lsu_pmp_is_st && !regs_comp_read1);

//-----------------------------------------
// Checks the access attribute of region 2
//-----------------------------------------
assign ifu_access_deny_region[2] = ifu_access_deny2;
assign lsu_access_deny_region[2] = lsu_access_deny2;
assign ifu_access_deny2          = ifu_acc_machine_mode && regs_comp_lock2 && !regs_comp_excut2
                                || ifu_acc_user_mode && !regs_comp_excut2;

assign lsu_access_deny2          = lsu_acc_machine_mode && regs_comp_lock2 
                                   && (lsu_pmp_is_st && !regs_comp_write2 
                                       || !lsu_pmp_is_st && !regs_comp_read2)
                                || lsu_acc_user_mode                              
                                   && (lsu_pmp_is_st && !regs_comp_write2 
                                       || !lsu_pmp_is_st && !regs_comp_read2);

//-----------------------------------------
// Checks the access attribute of region 3
//-----------------------------------------
assign ifu_access_deny_region[3] = ifu_access_deny3;
assign lsu_access_deny_region[3] = lsu_access_deny3;

assign ifu_access_deny3          = ifu_acc_machine_mode && regs_comp_lock3 && !regs_comp_excut3
                                || ifu_acc_user_mode && !regs_comp_excut3;

assign lsu_access_deny3          = lsu_acc_machine_mode && regs_comp_lock3 
                                   && (lsu_pmp_is_st && !regs_comp_write3 
                                       || !lsu_pmp_is_st && !regs_comp_read3)
                                || lsu_acc_user_mode                              
                                   && (lsu_pmp_is_st && !regs_comp_write3 
                                       || !lsu_pmp_is_st && !regs_comp_read3);

//-----------------------------------------
// Checks the access attribute of region 4
//-----------------------------------------
assign ifu_access_deny_region[4] = ifu_access_deny4;
assign lsu_access_deny_region[4] = lsu_access_deny4;

assign ifu_access_deny4          = ifu_acc_machine_mode && regs_comp_lock4 && !regs_comp_excut4
                                || ifu_acc_user_mode && !regs_comp_excut4;

assign lsu_access_deny4          = lsu_acc_machine_mode && regs_comp_lock4 
                                   && (lsu_pmp_is_st && !regs_comp_write4 
                                       || !lsu_pmp_is_st && !regs_comp_read4)
                                || lsu_acc_user_mode                              
                                   && (lsu_pmp_is_st && !regs_comp_write4 
                                       || !lsu_pmp_is_st && !regs_comp_read4);

//-----------------------------------------
// Checks the access attribute of region 5
//-----------------------------------------
assign ifu_access_deny_region[5] = ifu_access_deny5;
assign lsu_access_deny_region[5] = lsu_access_deny5;

assign ifu_access_deny5          = ifu_acc_machine_mode && regs_comp_lock5 && !regs_comp_excut5
                                || ifu_acc_user_mode && !regs_comp_excut5;

assign lsu_access_deny5          = lsu_acc_machine_mode && regs_comp_lock5 
                                   && (lsu_pmp_is_st && !regs_comp_write5 
                                       || !lsu_pmp_is_st && !regs_comp_read5)
                                || lsu_acc_user_mode                              
                                   && (lsu_pmp_is_st && !regs_comp_write5 
                                       || !lsu_pmp_is_st && !regs_comp_read5);                

//-----------------------------------------
// Checks the access attribute of region 6
//-----------------------------------------
assign ifu_access_deny_region[6] = ifu_access_deny6;
assign lsu_access_deny_region[6] = lsu_access_deny6;

assign ifu_access_deny6          = ifu_acc_machine_mode && regs_comp_lock6 && !regs_comp_excut6
                                || ifu_acc_user_mode && !regs_comp_excut6;

assign lsu_access_deny6          = lsu_acc_machine_mode && regs_comp_lock6 
                                   && (lsu_pmp_is_st && !regs_comp_write6 
                                       || !lsu_pmp_is_st && !regs_comp_read6)
                                || lsu_acc_user_mode                              
                                   && (lsu_pmp_is_st && !regs_comp_write6 
                                       || !lsu_pmp_is_st && !regs_comp_read6);
                                       
//-----------------------------------------
// Checks the access attribute of region 7
//-----------------------------------------
assign ifu_access_deny_region[7] = ifu_access_deny7;
assign lsu_access_deny_region[7] = lsu_access_deny7;

assign ifu_access_deny7          = ifu_acc_machine_mode && regs_comp_lock7 && !regs_comp_excut7
                                || ifu_acc_user_mode && !regs_comp_excut7;

assign lsu_access_deny7          = lsu_acc_machine_mode && regs_comp_lock7 
                                   && (lsu_pmp_is_st && !regs_comp_write7 
                                       || !lsu_pmp_is_st && !regs_comp_read7)
                                || lsu_acc_user_mode                              
                                   && (lsu_pmp_is_st && !regs_comp_write7 
                                       || !lsu_pmp_is_st && !regs_comp_read7);









// &ModuleEnd; @524
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_pmp_comp_hit(
  addr_match_mode,
  ifu_acc_addr,
  ifu_addr_ge_bottom,
  ifu_addr_ge_pmpaddr,
  lsu_acc_addr,
  lsu_addr_ge_bottom,
  lsu_addr_ge_pmpaddr,
  pmp_ifu_hit,
  pmp_lsu_hit,
  pmpaddr
);

// &Ports; @25
input   [1 :0]  addr_match_mode;     
input   [31:0]  ifu_acc_addr;        
input           ifu_addr_ge_bottom;  
input   [31:0]  lsu_acc_addr;        
input           lsu_addr_ge_bottom;  
input   [31:0]  pmpaddr;             
output          ifu_addr_ge_pmpaddr; 
output          lsu_addr_ge_pmpaddr; 
output          pmp_ifu_hit;         
output          pmp_lsu_hit;         

// &Regs; @26
reg     [31:0]  addr_mask;           
reg             pmp_ifu_hit;         
reg             pmp_lsu_hit;         

// &Wires; @27
wire    [1 :0]  addr_match_mode;     
wire    [31:0]  ifu_acc_addr;        
wire            ifu_addr_ge_bottom;  
wire            ifu_addr_ge_pmpaddr; 
wire            ifu_addr_ls_top;     
wire    [32:0]  ifu_comp_adder;      
wire            ifu_na4_addr_match;  
wire            ifu_napot_addr_match; 
wire            ifu_tor_addr_match;  
wire    [31:0]  lsu_acc_addr;        
wire            lsu_addr_ge_bottom;  
wire            lsu_addr_ge_pmpaddr; 
wire            lsu_addr_ls_top;     
wire    [32:0]  lsu_comp_adder;      
wire            lsu_na4_addr_match;  
wire            lsu_napot_addr_match; 
wire            lsu_tor_addr_match;  
wire    [31:0]  pmpaddr;             


// &Force("bus","pmpaddr",31,0); @29
//==========================================================
//                Address Matching Logic
//==========================================================
//Compare access address by four address-matching mode,and 
//generate address hit information
// &CombBeg; @35
always @( ifu_na4_addr_match
       or ifu_tor_addr_match
       or addr_match_mode[1:0]
       or ifu_napot_addr_match)
begin
  case(addr_match_mode[1:0])
    2'b00:   pmp_ifu_hit = 1'b0;                 //OFF
    2'b01:   pmp_ifu_hit = ifu_tor_addr_match;   //TOR 
    2'b10:   pmp_ifu_hit = ifu_na4_addr_match;   //NA4
    2'b11:   pmp_ifu_hit = ifu_napot_addr_match; //NAPOT
    default: pmp_ifu_hit = 1'b0; 
  endcase
// &CombEnd; @43
end

// &CombBeg; @45
always @( lsu_tor_addr_match
       or addr_match_mode[1:0]
       or lsu_na4_addr_match
       or lsu_napot_addr_match)
begin
  case(addr_match_mode[1:0])
    2'b00:   pmp_lsu_hit = 1'b0;                 //OFF
    2'b01:   pmp_lsu_hit = lsu_tor_addr_match;   //TOR 
    2'b10:   pmp_lsu_hit = lsu_na4_addr_match;   //NA4
    2'b11:   pmp_lsu_hit = lsu_napot_addr_match; //NAPOT
    default: pmp_lsu_hit = 1'b0; 
  endcase
// &CombEnd; @53
end

//1. TOR mode : pmpaddr[i-1]<= addr < pmpaddr[i]
assign ifu_comp_adder[32:0] = {1'b0,ifu_acc_addr[31:0]} - {1'b0,pmpaddr[29:0],2'b0};
assign ifu_addr_ls_top      = ifu_comp_adder[32];
assign ifu_addr_ge_pmpaddr  = !ifu_comp_adder[32];
assign ifu_tor_addr_match   = ifu_addr_ge_bottom && ifu_addr_ls_top;

assign lsu_comp_adder[32:0] = {1'b0,lsu_acc_addr[31:0]} - {1'b0,pmpaddr[29:0],2'b0};
assign lsu_addr_ls_top      = lsu_comp_adder[32];
assign lsu_addr_ge_pmpaddr  = !lsu_comp_adder[32];
assign lsu_tor_addr_match   = lsu_addr_ge_bottom && lsu_addr_ls_top;

//2. NAPOT : addr &addr_mask == pmpaddr & addr_mask
assign ifu_napot_addr_match = (addr_mask[31:0] & ifu_acc_addr[31:0]) == (addr_mask[31:0] &{pmpaddr[29:0],2'b0});
assign lsu_napot_addr_match = (addr_mask[31:0] & lsu_acc_addr[31:0]) == (addr_mask[31:0] &{pmpaddr[29:0],2'b0});

//3. NA4 : addr[31:2] == pmpaddr[29:0]
assign ifu_na4_addr_match   = (ifu_acc_addr[31:2] == pmpaddr[29:0]);
assign lsu_na4_addr_match   = (lsu_acc_addr[31:2] == pmpaddr[29:0]);

//----------------------------------------------------------
//Generate the address mask for the addr come from ifu or iu
//register the addr mask signal to avoid timing violation
//----------------------------------------------------------
// &CombBeg; @78
always @( pmpaddr[29:0])
begin
  casez(pmpaddr[29:0])
    30'b??_????_????_????_????_????_????_???0 : addr_mask[31:0] = 32'hfffffff8; //8B
    30'b??_????_????_????_????_????_????_??01 : addr_mask[31:0] = 32'hfffffff0; //16B
    30'b??_????_????_????_????_????_????_?011 : addr_mask[31:0] = 32'hffffffe0; //32B
    30'b??_????_????_????_????_????_????_0111 : addr_mask[31:0] = 32'hffffffc0; //64B
    30'b??_????_????_????_????_????_???0_1111 : addr_mask[31:0] = 32'hffffff80; //128B
    30'b??_????_????_????_????_????_??01_1111 : addr_mask[31:0] = 32'hffffff00; //256B
    30'b??_????_????_????_????_????_?011_1111 : addr_mask[31:0] = 32'hfffffe00; //512B
    30'b??_????_????_????_????_????_0111_1111 : addr_mask[31:0] = 32'hfffffc00; //1KB
    30'b??_????_????_????_????_???0_1111_1111 : addr_mask[31:0] = 32'hfffff800; //2KB
    30'b??_????_????_????_????_??01_1111_1111 : addr_mask[31:0] = 32'hfffff000; //4KB
    30'b??_????_????_????_????_?011_1111_1111 : addr_mask[31:0] = 32'hffffe000; //8KB
    30'b??_????_????_????_????_0111_1111_1111 : addr_mask[31:0] = 32'hffffc000; //16KB
    30'b??_????_????_????_???0_1111_1111_1111 : addr_mask[31:0] = 32'hffff8000; //32KB
    30'b??_????_????_????_??01_1111_1111_1111 : addr_mask[31:0] = 32'hffff0000; //64KB
    30'b??_????_????_????_?011_1111_1111_1111 : addr_mask[31:0] = 32'hfffe0000; //128KB
    30'b??_????_????_????_0111_1111_1111_1111 : addr_mask[31:0] = 32'hfffc0000; //256KB
    30'b??_????_????_???0_1111_1111_1111_1111 : addr_mask[31:0] = 32'hfff80000; //512KB
    30'b??_????_????_??01_1111_1111_1111_1111 : addr_mask[31:0] = 32'hfff00000; //1M
    30'b??_????_????_?011_1111_1111_1111_1111 : addr_mask[31:0] = 32'hffe00000; //2M
    30'b??_????_????_0111_1111_1111_1111_1111 : addr_mask[31:0] = 32'hffc00000; //4M
    30'b??_????_???0_1111_1111_1111_1111_1111 : addr_mask[31:0] = 32'hff800000; //8M
    30'b??_????_??01_1111_1111_1111_1111_1111 : addr_mask[31:0] = 32'hff000000; //16M
    30'b??_????_?011_1111_1111_1111_1111_1111 : addr_mask[31:0] = 32'hfe000000; //32M
    30'b??_????_0111_1111_1111_1111_1111_1111 : addr_mask[31:0] = 32'hfc000000; //64M
    30'b??_???0_1111_1111_1111_1111_1111_1111 : addr_mask[31:0] = 32'hf8000000; //128M
    30'b??_??01_1111_1111_1111_1111_1111_1111 : addr_mask[31:0] = 32'hf0000000; //256M
    30'b??_?011_1111_1111_1111_1111_1111_1111 : addr_mask[31:0] = 32'he0000000; //512M
    30'b??_0111_1111_1111_1111_1111_1111_1111 : addr_mask[31:0] = 32'hc0000000; //1G
    30'b?0_1111_1111_1111_1111_1111_1111_1111 : addr_mask[31:0] = 32'h80000000; //2G
    30'b01_1111_1111_1111_1111_1111_1111_1111 : addr_mask[31:0] = 32'h00000000; //4G
    default:                                    addr_mask[31:0] = 32'b0;
  endcase
// &CombEnd; @112
end

// &ModuleEnd; @114
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_pmp_enc(
  cp0_pmp_mstatus_mpp,
  cp0_pmp_mstatus_mprv,
  cp0_yy_machine_mode_aft_dbg,
  ifu_bmu_prot,
  lsu_bmu_write,
  pmp_bmu_dbus_acc_deny,
  pmp_bmu_ibus_acc_deny,
  pmp_ifu_acc_scu,
  pmp_ifu_hit,
  pmp_lsu_acc_scu,
  pmp_lsu_hit,
  regs_comp_excut0,
  regs_comp_excut1,
  regs_comp_excut2,
  regs_comp_excut3,
  regs_comp_excut4,
  regs_comp_excut5,
  regs_comp_excut6,
  regs_comp_excut7,
  regs_comp_lock0,
  regs_comp_lock1,
  regs_comp_lock2,
  regs_comp_lock3,
  regs_comp_lock4,
  regs_comp_lock5,
  regs_comp_lock6,
  regs_comp_lock7,
  regs_comp_read0,
  regs_comp_read1,
  regs_comp_read2,
  regs_comp_read3,
  regs_comp_read4,
  regs_comp_read5,
  regs_comp_read6,
  regs_comp_read7,
  regs_comp_write0,
  regs_comp_write1,
  regs_comp_write2,
  regs_comp_write3,
  regs_comp_write4,
  regs_comp_write5,
  regs_comp_write6,
  regs_comp_write7
);

// &Ports; @24
input   [1:0]  cp0_pmp_mstatus_mpp;        
input          cp0_pmp_mstatus_mprv;       
input          cp0_yy_machine_mode_aft_dbg; 
input   [3:0]  ifu_bmu_prot;               
input          lsu_bmu_write;              
input   [7:0]  pmp_ifu_hit;                
input   [7:0]  pmp_lsu_hit;                
input          regs_comp_excut0;           
input          regs_comp_excut1;           
input          regs_comp_excut2;           
input          regs_comp_excut3;           
input          regs_comp_excut4;           
input          regs_comp_excut5;           
input          regs_comp_excut6;           
input          regs_comp_excut7;           
input          regs_comp_lock0;            
input          regs_comp_lock1;            
input          regs_comp_lock2;            
input          regs_comp_lock3;            
input          regs_comp_lock4;            
input          regs_comp_lock5;            
input          regs_comp_lock6;            
input          regs_comp_lock7;            
input          regs_comp_read0;            
input          regs_comp_read1;            
input          regs_comp_read2;            
input          regs_comp_read3;            
input          regs_comp_read4;            
input          regs_comp_read5;            
input          regs_comp_read6;            
input          regs_comp_read7;            
input          regs_comp_write0;           
input          regs_comp_write1;           
input          regs_comp_write2;           
input          regs_comp_write3;           
input          regs_comp_write4;           
input          regs_comp_write5;           
input          regs_comp_write6;           
input          regs_comp_write7;           
output         pmp_bmu_dbus_acc_deny;      
output         pmp_bmu_ibus_acc_deny;      
output         pmp_ifu_acc_scu;            
output         pmp_lsu_acc_scu;            

// &Regs; @25
reg            ifu_access_deny;            
reg            lsu_access_deny;            

// &Wires; @26
wire    [1:0]  cp0_pmp_mstatus_mpp;        
wire           cp0_pmp_mstatus_mprv;       
wire           cp0_yy_machine_mode_aft_dbg; 
wire    [7:0]  ifu_access_deny_region;     
wire           ifu_access_no_hit_deny;     
wire    [3:0]  ifu_bmu_prot;               
wire    [7:0]  lsu_access_deny_region;     
wire           lsu_access_no_hit_deny;     
wire           lsu_bmu_write;              
wire           pmp_bmu_dbus_acc_deny;      
wire           pmp_bmu_ibus_acc_deny;      
wire           pmp_ifu_acc_scu;            
wire    [7:0]  pmp_ifu_hit;                
wire           pmp_lsu_acc_scu;            
wire    [7:0]  pmp_lsu_hit;                
wire           regs_comp_excut0;           
wire           regs_comp_excut1;           
wire           regs_comp_excut2;           
wire           regs_comp_excut3;           
wire           regs_comp_excut4;           
wire           regs_comp_excut5;           
wire           regs_comp_excut6;           
wire           regs_comp_excut7;           
wire           regs_comp_lock0;            
wire           regs_comp_lock1;            
wire           regs_comp_lock2;            
wire           regs_comp_lock3;            
wire           regs_comp_lock4;            
wire           regs_comp_lock5;            
wire           regs_comp_lock6;            
wire           regs_comp_lock7;            
wire           regs_comp_read0;            
wire           regs_comp_read1;            
wire           regs_comp_read2;            
wire           regs_comp_read3;            
wire           regs_comp_read4;            
wire           regs_comp_read5;            
wire           regs_comp_read6;            
wire           regs_comp_read7;            
wire           regs_comp_write0;           
wire           regs_comp_write1;           
wire           regs_comp_write2;           
wire           regs_comp_write3;           
wire           regs_comp_write4;           
wire           regs_comp_write5;           
wire           regs_comp_write6;           
wire           regs_comp_write7;           


//----------------------------------------------------------
// region access arbitor
//----------------------------------------------------------
// &Instance("cr_pmp_acc_arb","x_cr_pmp_acc_arb"); @31
cr_pmp_acc_arb  x_cr_pmp_acc_arb (
  .cp0_pmp_mstatus_mpp         (cp0_pmp_mstatus_mpp        ),
  .cp0_pmp_mstatus_mprv        (cp0_pmp_mstatus_mprv       ),
  .cp0_yy_machine_mode_aft_dbg (cp0_yy_machine_mode_aft_dbg),
  .ifu_access_deny_region      (ifu_access_deny_region     ),
  .ifu_access_no_hit_deny      (ifu_access_no_hit_deny     ),
  .ifu_bmu_prot                (ifu_bmu_prot               ),
  .lsu_access_deny_region      (lsu_access_deny_region     ),
  .lsu_access_no_hit_deny      (lsu_access_no_hit_deny     ),
  .lsu_pmp_is_st               (lsu_bmu_write              ),
  .regs_comp_excut0            (regs_comp_excut0           ),
  .regs_comp_excut1            (regs_comp_excut1           ),
  .regs_comp_excut2            (regs_comp_excut2           ),
  .regs_comp_excut3            (regs_comp_excut3           ),
  .regs_comp_excut4            (regs_comp_excut4           ),
  .regs_comp_excut5            (regs_comp_excut5           ),
  .regs_comp_excut6            (regs_comp_excut6           ),
  .regs_comp_excut7            (regs_comp_excut7           ),
  .regs_comp_lock0             (regs_comp_lock0            ),
  .regs_comp_lock1             (regs_comp_lock1            ),
  .regs_comp_lock2             (regs_comp_lock2            ),
  .regs_comp_lock3             (regs_comp_lock3            ),
  .regs_comp_lock4             (regs_comp_lock4            ),
  .regs_comp_lock5             (regs_comp_lock5            ),
  .regs_comp_lock6             (regs_comp_lock6            ),
  .regs_comp_lock7             (regs_comp_lock7            ),
  .regs_comp_read0             (regs_comp_read0            ),
  .regs_comp_read1             (regs_comp_read1            ),
  .regs_comp_read2             (regs_comp_read2            ),
  .regs_comp_read3             (regs_comp_read3            ),
  .regs_comp_read4             (regs_comp_read4            ),
  .regs_comp_read5             (regs_comp_read5            ),
  .regs_comp_read6             (regs_comp_read6            ),
  .regs_comp_read7             (regs_comp_read7            ),
  .regs_comp_write0            (regs_comp_write0           ),
  .regs_comp_write1            (regs_comp_write1           ),
  .regs_comp_write2            (regs_comp_write2           ),
  .regs_comp_write3            (regs_comp_write3           ),
  .regs_comp_write4            (regs_comp_write4           ),
  .regs_comp_write5            (regs_comp_write5           ),
  .regs_comp_write6            (regs_comp_write6           ),
  .regs_comp_write7            (regs_comp_write7           )
);

// &Connect( @32
//          .lsu_pmp_is_st (lsu_bmu_write) @33
//         ); @34

// &CombBeg; @40
// &CombEnd; @47
// &CombBeg; @49
// &CombEnd; @56

// &CombBeg; @63
// &CombEnd; @72
// &CombBeg; @74
// &CombEnd; @83

//----------------------------------------------------------
//priority encoder for access_deny
//----------------------------------------------------------
// &CombBeg; @90
always @( ifu_access_deny_region[7:4]
       or ifu_access_no_hit_deny
       or ifu_access_deny_region[3:0]
       or pmp_ifu_hit[7:0])
begin
  casez(pmp_ifu_hit[7:0])
    8'b???????1  : ifu_access_deny = ifu_access_deny_region[0];
    8'b??????10  : ifu_access_deny = ifu_access_deny_region[1];
    8'b?????100  : ifu_access_deny = ifu_access_deny_region[2];
    8'b????1000  : ifu_access_deny = ifu_access_deny_region[3];
    8'b???10000  : ifu_access_deny = ifu_access_deny_region[4];
    8'b??100000  : ifu_access_deny = ifu_access_deny_region[5];
    8'b?1000000  : ifu_access_deny = ifu_access_deny_region[6];
    8'b10000000  : ifu_access_deny = ifu_access_deny_region[7];
    8'b00000000  : ifu_access_deny = ifu_access_no_hit_deny;
    default      : ifu_access_deny = 1'bx;
endcase
// &CombEnd; @103
end

// &CombBeg; @105
always @( lsu_access_deny_region[7:4]
       or pmp_lsu_hit[7:0]
       or lsu_access_no_hit_deny
       or lsu_access_deny_region[3:0])
begin
  casez(pmp_lsu_hit[7:0])
    8'b???????1  : lsu_access_deny = lsu_access_deny_region[0];
    8'b??????10  : lsu_access_deny = lsu_access_deny_region[1];
    8'b?????100  : lsu_access_deny = lsu_access_deny_region[2];
    8'b????1000  : lsu_access_deny = lsu_access_deny_region[3];
    8'b???10000  : lsu_access_deny = lsu_access_deny_region[4];
    8'b??100000  : lsu_access_deny = lsu_access_deny_region[5];
    8'b?1000000  : lsu_access_deny = lsu_access_deny_region[6];
    8'b10000000  : lsu_access_deny = lsu_access_deny_region[7];
    8'b00000000  : lsu_access_deny = lsu_access_no_hit_deny;
    default      : lsu_access_deny = 1'bx;
endcase
// &CombEnd; @118
end

// &CombBeg; @125
// &CombEnd; @146
// &CombBeg; @148
// &CombEnd; @169

//----------------------------------------------------------
//  Interface to Bus Matrix Unit
//----------------------------------------------------------
assign pmp_ifu_acc_scu       = 1'b0;
assign pmp_lsu_acc_scu       = 1'b0;
assign pmp_bmu_ibus_acc_deny = ifu_access_deny;
assign pmp_bmu_dbus_acc_deny = lsu_access_deny;


// &ModuleEnd;     @184
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_pmp_regs(
  cp0_pmp_updt_data,
  cp0_yy_secu_mode_aft_dbg,
  cpuclk,
  cpurst_b,
  pmp_cp0_data,
  pmp_csr_sel,
  pmp_csr_wen,
  pmpaddr0_value,
  pmpaddr1_value,
  pmpaddr2_value,
  pmpaddr3_value,
  pmpaddr4_value,
  pmpaddr5_value,
  pmpaddr6_value,
  pmpaddr7_value,
  regs_comp_addr_mode0,
  regs_comp_addr_mode1,
  regs_comp_addr_mode2,
  regs_comp_addr_mode3,
  regs_comp_addr_mode4,
  regs_comp_addr_mode5,
  regs_comp_addr_mode6,
  regs_comp_addr_mode7,
  regs_comp_excut0,
  regs_comp_excut1,
  regs_comp_excut2,
  regs_comp_excut3,
  regs_comp_excut4,
  regs_comp_excut5,
  regs_comp_excut6,
  regs_comp_excut7,
  regs_comp_lock0,
  regs_comp_lock1,
  regs_comp_lock2,
  regs_comp_lock3,
  regs_comp_lock4,
  regs_comp_lock5,
  regs_comp_lock6,
  regs_comp_lock7,
  regs_comp_read0,
  regs_comp_read1,
  regs_comp_read2,
  regs_comp_read3,
  regs_comp_read4,
  regs_comp_read5,
  regs_comp_read6,
  regs_comp_read7,
  regs_comp_write0,
  regs_comp_write1,
  regs_comp_write2,
  regs_comp_write3,
  regs_comp_write4,
  regs_comp_write5,
  regs_comp_write6,
  regs_comp_write7
);

// &Ports; @24
input   [31:0]  cp0_pmp_updt_data;       
input           cp0_yy_secu_mode_aft_dbg; 
input           cpuclk;                  
input           cpurst_b;                
input   [19:0]  pmp_csr_sel;             
input   [19:0]  pmp_csr_wen;             
output  [31:0]  pmp_cp0_data;            
output  [31:0]  pmpaddr0_value;          
output  [31:0]  pmpaddr1_value;          
output  [31:0]  pmpaddr2_value;          
output  [31:0]  pmpaddr3_value;          
output  [31:0]  pmpaddr4_value;          
output  [31:0]  pmpaddr5_value;          
output  [31:0]  pmpaddr6_value;          
output  [31:0]  pmpaddr7_value;          
output  [1 :0]  regs_comp_addr_mode0;    
output  [1 :0]  regs_comp_addr_mode1;    
output  [1 :0]  regs_comp_addr_mode2;    
output  [1 :0]  regs_comp_addr_mode3;    
output  [1 :0]  regs_comp_addr_mode4;    
output  [1 :0]  regs_comp_addr_mode5;    
output  [1 :0]  regs_comp_addr_mode6;    
output  [1 :0]  regs_comp_addr_mode7;    
output          regs_comp_excut0;        
output          regs_comp_excut1;        
output          regs_comp_excut2;        
output          regs_comp_excut3;        
output          regs_comp_excut4;        
output          regs_comp_excut5;        
output          regs_comp_excut6;        
output          regs_comp_excut7;        
output          regs_comp_lock0;         
output          regs_comp_lock1;         
output          regs_comp_lock2;         
output          regs_comp_lock3;         
output          regs_comp_lock4;         
output          regs_comp_lock5;         
output          regs_comp_lock6;         
output          regs_comp_lock7;         
output          regs_comp_read0;         
output          regs_comp_read1;         
output          regs_comp_read2;         
output          regs_comp_read3;         
output          regs_comp_read4;         
output          regs_comp_read5;         
output          regs_comp_read6;         
output          regs_comp_read7;         
output          regs_comp_write0;        
output          regs_comp_write1;        
output          regs_comp_write2;        
output          regs_comp_write3;        
output          regs_comp_write4;        
output          regs_comp_write5;        
output          regs_comp_write6;        
output          regs_comp_write7;        

// &Regs; @25
reg     [1 :0]  pmp0cfg_addr_mode;       
reg             pmp0cfg_executeable;     
reg             pmp0cfg_lock;            
reg             pmp0cfg_readable;        
reg             pmp0cfg_writable;        
reg     [1 :0]  pmp1cfg_addr_mode;       
reg             pmp1cfg_executeable;     
reg             pmp1cfg_lock;            
reg             pmp1cfg_readable;        
reg             pmp1cfg_writable;        
reg     [1 :0]  pmp2cfg_addr_mode;       
reg             pmp2cfg_executeable;     
reg             pmp2cfg_lock;            
reg             pmp2cfg_readable;        
reg             pmp2cfg_writable;        
reg     [1 :0]  pmp3cfg_addr_mode;       
reg             pmp3cfg_executeable;     
reg             pmp3cfg_lock;            
reg             pmp3cfg_readable;        
reg             pmp3cfg_writable;        
reg     [1 :0]  pmp4cfg_addr_mode;       
reg             pmp4cfg_executeable;     
reg             pmp4cfg_lock;            
reg             pmp4cfg_readable;        
reg             pmp4cfg_writable;        
reg     [1 :0]  pmp5cfg_addr_mode;       
reg             pmp5cfg_executeable;     
reg             pmp5cfg_lock;            
reg             pmp5cfg_readable;        
reg             pmp5cfg_writable;        
reg     [1 :0]  pmp6cfg_addr_mode;       
reg             pmp6cfg_executeable;     
reg             pmp6cfg_lock;            
reg             pmp6cfg_readable;        
reg             pmp6cfg_writable;        
reg     [1 :0]  pmp7cfg_addr_mode;       
reg             pmp7cfg_executeable;     
reg             pmp7cfg_lock;            
reg             pmp7cfg_readable;        
reg             pmp7cfg_writable;        
reg     [31:0]  pmpaddr0_value;          
reg     [31:0]  pmpaddr1_value;          
reg     [31:0]  pmpaddr2_value;          
reg     [31:0]  pmpaddr3_value;          
reg     [31:0]  pmpaddr4_value;          
reg     [31:0]  pmpaddr5_value;          
reg     [31:0]  pmpaddr6_value;          
reg     [31:0]  pmpaddr7_value;          

// &Wires; @26
wire    [31:0]  cp0_pmp_updt_data;       
wire            cp0_yy_secu_mode_aft_dbg; 
wire            cpuclk;                  
wire            cpurst_b;                
wire    [31:0]  pmp_cp0_data;            
wire    [19:0]  pmp_csr_sel;             
wire    [19:0]  pmp_csr_wen;             
wire            pmp_updt_pmp0cfg;        
wire            pmp_updt_pmp1cfg;        
wire            pmp_updt_pmp2cfg;        
wire            pmp_updt_pmp3cfg;        
wire            pmp_updt_pmp4cfg;        
wire            pmp_updt_pmp5cfg;        
wire            pmp_updt_pmp6cfg;        
wire            pmp_updt_pmp7cfg;        
wire            pmp_updt_pmpaddr0;       
wire            pmp_updt_pmpaddr1;       
wire            pmp_updt_pmpaddr2;       
wire            pmp_updt_pmpaddr3;       
wire            pmp_updt_pmpaddr4;       
wire            pmp_updt_pmpaddr5;       
wire            pmp_updt_pmpaddr6;       
wire            pmp_updt_pmpaddr7;       
wire    [31:0]  pmpaddr10_value;         
wire    [31:0]  pmpaddr11_value;         
wire    [31:0]  pmpaddr12_value;         
wire    [31:0]  pmpaddr13_value;         
wire    [31:0]  pmpaddr14_value;         
wire    [31:0]  pmpaddr15_value;         
wire    [31:0]  pmpaddr8_value;          
wire    [31:0]  pmpaddr9_value;          
wire    [31:0]  pmpcfg0_value;           
wire    [31:0]  pmpcfg1_value;           
wire    [31:0]  pmpcfg2_value;           
wire    [31:0]  pmpcfg3_value;           
wire            pmpteecfg_s0;            
wire            pmpteecfg_s1;            
wire            pmpteecfg_s2;            
wire            pmpteecfg_s3;            
wire            pmpteecfg_s4;            
wire            pmpteecfg_s5;            
wire            pmpteecfg_s6;            
wire            pmpteecfg_s7;            
wire    [1 :0]  regs_comp_addr_mode0;    
wire    [1 :0]  regs_comp_addr_mode1;    
wire    [1 :0]  regs_comp_addr_mode2;    
wire    [1 :0]  regs_comp_addr_mode3;    
wire    [1 :0]  regs_comp_addr_mode4;    
wire    [1 :0]  regs_comp_addr_mode5;    
wire    [1 :0]  regs_comp_addr_mode6;    
wire    [1 :0]  regs_comp_addr_mode7;    
wire            regs_comp_excut0;        
wire            regs_comp_excut1;        
wire            regs_comp_excut2;        
wire            regs_comp_excut3;        
wire            regs_comp_excut4;        
wire            regs_comp_excut5;        
wire            regs_comp_excut6;        
wire            regs_comp_excut7;        
wire            regs_comp_lock0;         
wire            regs_comp_lock1;         
wire            regs_comp_lock2;         
wire            regs_comp_lock3;         
wire            regs_comp_lock4;         
wire            regs_comp_lock5;         
wire            regs_comp_lock6;         
wire            regs_comp_lock7;         
wire            regs_comp_read0;         
wire            regs_comp_read1;         
wire            regs_comp_read2;         
wire            regs_comp_read3;         
wire            regs_comp_read4;         
wire            regs_comp_read5;         
wire            regs_comp_read6;         
wire            regs_comp_read7;         
wire            regs_comp_write0;        
wire            regs_comp_write1;        
wire            regs_comp_write2;        
wire            regs_comp_write3;        
wire            regs_comp_write4;        
wire            regs_comp_write5;        
wire            regs_comp_write6;        
wire            regs_comp_write7;        


// &Force("bus","pmp_csr_wen",20,0); @29
// &Force("bus","pmp_csr_wen",19,0); @31

assign regs_comp_read0           = pmp0cfg_readable;
assign regs_comp_write0          = pmp0cfg_writable;
assign regs_comp_excut0          = pmp0cfg_executeable;
assign regs_comp_addr_mode0[1:0] = pmp0cfg_addr_mode[1:0];
assign regs_comp_lock0           = pmp0cfg_lock;

assign regs_comp_read1           = pmp1cfg_readable;
assign regs_comp_write1          = pmp1cfg_writable;
assign regs_comp_excut1          = pmp1cfg_executeable;
assign regs_comp_addr_mode1[1:0] = pmp1cfg_addr_mode[1:0];
assign regs_comp_lock1           = pmp1cfg_lock;

assign regs_comp_read2           = pmp2cfg_readable;
assign regs_comp_write2          = pmp2cfg_writable;
assign regs_comp_excut2          = pmp2cfg_executeable;
assign regs_comp_addr_mode2[1:0] = pmp2cfg_addr_mode[1:0];
assign regs_comp_lock2           = pmp2cfg_lock;

assign regs_comp_read3           = pmp3cfg_readable;
assign regs_comp_write3          = pmp3cfg_writable;
assign regs_comp_excut3          = pmp3cfg_executeable;
assign regs_comp_addr_mode3[1:0] = pmp3cfg_addr_mode[1:0];
assign regs_comp_lock3           = pmp3cfg_lock;

assign regs_comp_read4           = pmp4cfg_readable;
assign regs_comp_write4          = pmp4cfg_writable;
assign regs_comp_excut4          = pmp4cfg_executeable;
assign regs_comp_addr_mode4[1:0] = pmp4cfg_addr_mode[1:0];
assign regs_comp_lock4           = pmp4cfg_lock;

assign regs_comp_read5           = pmp5cfg_readable;
assign regs_comp_write5          = pmp5cfg_writable;
assign regs_comp_excut5          = pmp5cfg_executeable;
assign regs_comp_addr_mode5[1:0] = pmp5cfg_addr_mode[1:0];
assign regs_comp_lock5           = pmp5cfg_lock;

assign regs_comp_read6           = pmp6cfg_readable;
assign regs_comp_write6          = pmp6cfg_writable;
assign regs_comp_excut6          = pmp6cfg_executeable;
assign regs_comp_addr_mode6[1:0] = pmp6cfg_addr_mode[1:0];
assign regs_comp_lock6           = pmp6cfg_lock;

assign regs_comp_read7           = pmp7cfg_readable;
assign regs_comp_write7          = pmp7cfg_writable;
assign regs_comp_excut7          = pmp7cfg_executeable;
assign regs_comp_addr_mode7[1:0] = pmp7cfg_addr_mode[1:0];
assign regs_comp_lock7           = pmp7cfg_lock;









//==========================================================
//                PMP Entry Configuration Register
//==========================================================
//------------------------------------------------
//pmpcfg0 register
//------------------------------------------------
assign pmp_updt_pmp0cfg = pmp_csr_wen[0] && !pmp0cfg_lock;
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
  begin
    pmp0cfg_readable       <= 1'b0;
    pmp0cfg_writable       <= 1'b0;
    pmp0cfg_executeable    <= 1'b0;
    pmp0cfg_addr_mode[1:0] <= 2'b0;
    pmp0cfg_lock           <= 1'b0;
  end
  else if(pmp_updt_pmp0cfg && (!pmpteecfg_s0 || cp0_yy_secu_mode_aft_dbg))
  begin
    pmp0cfg_readable        <= cp0_pmp_updt_data[0];
    pmp0cfg_writable        <= cp0_pmp_updt_data[1];
    pmp0cfg_executeable     <= cp0_pmp_updt_data[2];
    pmp0cfg_addr_mode[1:0]  <= cp0_pmp_updt_data[4:3];
    pmp0cfg_lock            <= cp0_pmp_updt_data[7];
  end
  else
  begin
    pmp0cfg_readable       <= pmp0cfg_readable;     
    pmp0cfg_writable       <= pmp0cfg_writable;     
    pmp0cfg_executeable    <= pmp0cfg_executeable;     
    pmp0cfg_addr_mode[1:0] <= pmp0cfg_addr_mode[1:0];
    pmp0cfg_lock           <= pmp0cfg_lock;     
  end
end

assign pmp_updt_pmp1cfg = pmp_csr_wen[0] && !pmp1cfg_lock;
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
  begin
    pmp1cfg_readable       <= 1'b0;
    pmp1cfg_writable       <= 1'b0;
    pmp1cfg_executeable    <= 1'b0;
    pmp1cfg_addr_mode[1:0] <= 2'b0;
    pmp1cfg_lock           <= 1'b0;
  end
  else if(pmp_updt_pmp1cfg && (!pmpteecfg_s1 || cp0_yy_secu_mode_aft_dbg))
  begin
    pmp1cfg_readable       <= cp0_pmp_updt_data[8];
    pmp1cfg_writable       <= cp0_pmp_updt_data[9];
    pmp1cfg_executeable    <= cp0_pmp_updt_data[10];
    pmp1cfg_addr_mode[1:0] <= cp0_pmp_updt_data[12:11];
    pmp1cfg_lock           <= cp0_pmp_updt_data[15];
  end
  else
  begin
    pmp1cfg_readable       <= pmp1cfg_readable;     
    pmp1cfg_writable       <= pmp1cfg_writable;     
    pmp1cfg_executeable    <= pmp1cfg_executeable;     
    pmp1cfg_addr_mode[1:0] <= pmp1cfg_addr_mode[1:0];
    pmp1cfg_lock           <= pmp1cfg_lock;     
  end
end

assign pmp_updt_pmp2cfg = pmp_csr_wen[0] && !pmp2cfg_lock;
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
  begin
    pmp2cfg_readable       <= 1'b0;
    pmp2cfg_writable       <= 1'b0;
    pmp2cfg_executeable    <= 1'b0;
    pmp2cfg_addr_mode[1:0] <= 2'b0;
    pmp2cfg_lock           <= 1'b0;
  end
  else if(pmp_updt_pmp2cfg && (!pmpteecfg_s2 || cp0_yy_secu_mode_aft_dbg))
  begin
    pmp2cfg_readable       <= cp0_pmp_updt_data[16];
    pmp2cfg_writable       <= cp0_pmp_updt_data[17];
    pmp2cfg_executeable    <= cp0_pmp_updt_data[18];
    pmp2cfg_addr_mode[1:0] <= cp0_pmp_updt_data[20:19];
    pmp2cfg_lock           <= cp0_pmp_updt_data[23];
  end
  else
  begin
    pmp2cfg_readable       <= pmp2cfg_readable;     
    pmp2cfg_writable       <= pmp2cfg_writable;     
    pmp2cfg_executeable    <= pmp2cfg_executeable;     
    pmp2cfg_addr_mode[1:0] <= pmp2cfg_addr_mode[1:0];
    pmp2cfg_lock           <= pmp2cfg_lock;     
  end
end

assign pmp_updt_pmp3cfg = pmp_csr_wen[0] && !pmp3cfg_lock;
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
  begin
    pmp3cfg_readable       <= 1'b0;
    pmp3cfg_writable       <= 1'b0;
    pmp3cfg_executeable    <= 1'b0;
    pmp3cfg_addr_mode[1:0] <= 2'b0;
    pmp3cfg_lock           <= 1'b0;
  end
  else if(pmp_updt_pmp3cfg && (!pmpteecfg_s3 || cp0_yy_secu_mode_aft_dbg))
  begin
    pmp3cfg_readable       <= cp0_pmp_updt_data[24];
    pmp3cfg_writable       <= cp0_pmp_updt_data[25];
    pmp3cfg_executeable    <= cp0_pmp_updt_data[26];
    pmp3cfg_addr_mode[1:0] <= cp0_pmp_updt_data[28:27];
    pmp3cfg_lock           <= cp0_pmp_updt_data[31];
  end
  else
  begin
    pmp3cfg_readable       <= pmp3cfg_readable;     
    pmp3cfg_writable       <= pmp3cfg_writable;     
    pmp3cfg_executeable    <= pmp3cfg_executeable;     
    pmp3cfg_addr_mode[1:0] <= pmp3cfg_addr_mode[1:0];
    pmp3cfg_lock           <= pmp3cfg_lock;     
  end
end

//------------------------------------------------
//pmpcfg1 register
//------------------------------------------------
assign pmp_updt_pmp4cfg = pmp_csr_wen[1] && !pmp4cfg_lock;
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
  begin
    pmp4cfg_readable       <= 1'b0;
    pmp4cfg_writable       <= 1'b0;
    pmp4cfg_executeable    <= 1'b0;
    pmp4cfg_addr_mode[1:0] <= 2'b0;
    pmp4cfg_lock           <= 1'b0;
  end
  else if(pmp_updt_pmp4cfg && (!pmpteecfg_s4 || cp0_yy_secu_mode_aft_dbg))
  begin
    pmp4cfg_readable        <= cp0_pmp_updt_data[0];
    pmp4cfg_writable        <= cp0_pmp_updt_data[1];
    pmp4cfg_executeable     <= cp0_pmp_updt_data[2];
    pmp4cfg_addr_mode[1:0]  <= cp0_pmp_updt_data[4:3];
    pmp4cfg_lock            <= cp0_pmp_updt_data[7];
  end
  else
  begin
    pmp4cfg_readable       <= pmp4cfg_readable;     
    pmp4cfg_writable       <= pmp4cfg_writable;     
    pmp4cfg_executeable    <= pmp4cfg_executeable;     
    pmp4cfg_addr_mode[1:0] <= pmp4cfg_addr_mode[1:0];
    pmp4cfg_lock           <= pmp4cfg_lock;     
  end
end

assign pmp_updt_pmp5cfg = pmp_csr_wen[1] && !pmp5cfg_lock;
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
  begin
    pmp5cfg_readable       <= 1'b0;
    pmp5cfg_writable       <= 1'b0;
    pmp5cfg_executeable    <= 1'b0;
    pmp5cfg_addr_mode[1:0] <= 2'b0;
    pmp5cfg_lock           <= 1'b0;
  end
  else if(pmp_updt_pmp5cfg && (!pmpteecfg_s5 || cp0_yy_secu_mode_aft_dbg))
  begin
    pmp5cfg_readable       <= cp0_pmp_updt_data[8];
    pmp5cfg_writable       <= cp0_pmp_updt_data[9];
    pmp5cfg_executeable    <= cp0_pmp_updt_data[10];
    pmp5cfg_addr_mode[1:0] <= cp0_pmp_updt_data[12:11];
    pmp5cfg_lock           <= cp0_pmp_updt_data[15];
  end
  else
  begin
    pmp5cfg_readable       <= pmp5cfg_readable;     
    pmp5cfg_writable       <= pmp5cfg_writable;     
    pmp5cfg_executeable    <= pmp5cfg_executeable;     
    pmp5cfg_addr_mode[1:0] <= pmp5cfg_addr_mode[1:0];
    pmp5cfg_lock           <= pmp5cfg_lock;     
  end
end

assign pmp_updt_pmp6cfg = pmp_csr_wen[1] && !pmp6cfg_lock;
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
  begin
    pmp6cfg_readable       <= 1'b0;
    pmp6cfg_writable       <= 1'b0;
    pmp6cfg_executeable    <= 1'b0;
    pmp6cfg_addr_mode[1:0] <= 2'b0;
    pmp6cfg_lock           <= 1'b0;
  end
  else if(pmp_updt_pmp6cfg && (!pmpteecfg_s6 || cp0_yy_secu_mode_aft_dbg))
  begin
    pmp6cfg_readable       <= cp0_pmp_updt_data[16];
    pmp6cfg_writable       <= cp0_pmp_updt_data[17];
    pmp6cfg_executeable    <= cp0_pmp_updt_data[18];
    pmp6cfg_addr_mode[1:0] <= cp0_pmp_updt_data[20:19];
    pmp6cfg_lock           <= cp0_pmp_updt_data[23];
  end
  else
  begin
    pmp6cfg_readable       <= pmp6cfg_readable;     
    pmp6cfg_writable       <= pmp6cfg_writable;     
    pmp6cfg_executeable    <= pmp6cfg_executeable;     
    pmp6cfg_addr_mode[1:0] <= pmp6cfg_addr_mode[1:0];
    pmp6cfg_lock           <= pmp6cfg_lock;     
  end
end

assign pmp_updt_pmp7cfg = pmp_csr_wen[1] && !pmp7cfg_lock;
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
  begin
    pmp7cfg_readable       <= 1'b0;
    pmp7cfg_writable       <= 1'b0;
    pmp7cfg_executeable    <= 1'b0;
    pmp7cfg_addr_mode[1:0] <= 2'b0;
    pmp7cfg_lock           <= 1'b0;
  end
  else if(pmp_updt_pmp7cfg && (!pmpteecfg_s7 || cp0_yy_secu_mode_aft_dbg))
  begin
    pmp7cfg_readable       <= cp0_pmp_updt_data[24];
    pmp7cfg_writable       <= cp0_pmp_updt_data[25];
    pmp7cfg_executeable    <= cp0_pmp_updt_data[26];
    pmp7cfg_addr_mode[1:0] <= cp0_pmp_updt_data[28:27];
    pmp7cfg_lock           <= cp0_pmp_updt_data[31];
  end
  else
  begin
    pmp7cfg_readable       <= pmp7cfg_readable;     
    pmp7cfg_writable       <= pmp7cfg_writable;     
    pmp7cfg_executeable    <= pmp7cfg_executeable;     
    pmp7cfg_addr_mode[1:0] <= pmp7cfg_addr_mode[1:0];
    pmp7cfg_lock           <= pmp7cfg_lock;     
  end
end

//------------------------------------------------
//pmpcfg2 register
//------------------------------------------------




//------------------------------------------------
//pmpcfg3 register
//------------------------------------------------






assign pmpcfg0_value[31:0] = {pmp3cfg_lock,2'b0,pmp3cfg_addr_mode[1:0],pmp3cfg_executeable,pmp3cfg_writable,pmp3cfg_readable,
                              pmp2cfg_lock,2'b0,pmp2cfg_addr_mode[1:0],pmp2cfg_executeable,pmp2cfg_writable,pmp2cfg_readable,
                              pmp1cfg_lock,2'b0,pmp1cfg_addr_mode[1:0],pmp1cfg_executeable,pmp1cfg_writable,pmp1cfg_readable,
                              pmp0cfg_lock,2'b0,pmp0cfg_addr_mode[1:0],pmp0cfg_executeable,pmp0cfg_writable,pmp0cfg_readable};
assign pmpcfg1_value[31:0] = {pmp7cfg_lock,2'b0,pmp7cfg_addr_mode[1:0],pmp7cfg_executeable,pmp7cfg_writable,pmp7cfg_readable,
                              pmp6cfg_lock,2'b0,pmp6cfg_addr_mode[1:0],pmp6cfg_executeable,pmp6cfg_writable,pmp6cfg_readable,
                              pmp5cfg_lock,2'b0,pmp5cfg_addr_mode[1:0],pmp5cfg_executeable,pmp5cfg_writable,pmp5cfg_readable,
                              pmp4cfg_lock,2'b0,pmp4cfg_addr_mode[1:0],pmp4cfg_executeable,pmp4cfg_writable,pmp4cfg_readable};
assign pmpcfg2_value[31:0] = 32'b0;
assign pmpcfg3_value[31:0] = 32'b0;




//==========================================================
//                PMP Entry Address Register
//==========================================================
//------------------------------------------------
//pmpaddr0 register
//------------------------------------------------
assign pmp_updt_pmpaddr0 = pmp_csr_wen[4] && !pmpcfg0_value[7] && !(pmpcfg0_value[15] && (pmpcfg0_value[12:11] == 2'b01)) ;
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    pmpaddr0_value[31:0] <= 32'b0;
  else if(pmp_updt_pmpaddr0 && (!pmpteecfg_s0 || cp0_yy_secu_mode_aft_dbg))
    pmpaddr0_value[31:0] <= cp0_pmp_updt_data[31:0];
  else
    pmpaddr0_value[31:0] <= pmpaddr0_value[31:0];
end
// &Force("output","pmpaddr0_value"); @790

assign pmp_updt_pmpaddr1 = pmp_csr_wen[5] && !pmpcfg0_value[15] && !(pmpcfg0_value[23] && (pmpcfg0_value[20:19] == 2'b01));
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    pmpaddr1_value[31:0] <= 32'b0;
  else if(pmp_updt_pmpaddr1 && (!pmpteecfg_s1 || cp0_yy_secu_mode_aft_dbg))
    pmpaddr1_value[31:0] <= cp0_pmp_updt_data[31:0];
  else
    pmpaddr1_value[31:0] <= pmpaddr1_value[31:0];
end
// &Force("output","pmpaddr1_value"); @806

assign pmp_updt_pmpaddr2 = pmp_csr_wen[6] && !pmpcfg0_value[23] && !(pmpcfg0_value[31] && (pmpcfg0_value[28:27] == 2'b01));
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    pmpaddr2_value[31:0] <= 32'b0;
  else if(pmp_updt_pmpaddr2 && (!pmpteecfg_s2 || cp0_yy_secu_mode_aft_dbg))
    pmpaddr2_value[31:0] <= cp0_pmp_updt_data[31:0];
  else
    pmpaddr2_value[31:0] <= pmpaddr2_value[31:0];
end
// &Force("output","pmpaddr2_value"); @822

assign pmp_updt_pmpaddr3 = pmp_csr_wen[7] && !pmpcfg0_value[31] && !(pmpcfg1_value[7] && (pmpcfg1_value[4:3] == 2'b01));
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    pmpaddr3_value[31:0] <= 32'b0;
  else if(pmp_updt_pmpaddr3 && (!pmpteecfg_s3 || cp0_yy_secu_mode_aft_dbg))
    pmpaddr3_value[31:0] <= cp0_pmp_updt_data[31:0];
  else
    pmpaddr3_value[31:0] <= pmpaddr3_value[31:0];
end
// &Force("output","pmpaddr3_value"); @838

assign pmp_updt_pmpaddr4 = pmp_csr_wen[8] && !pmpcfg1_value[7] && !(pmpcfg1_value[15] && (pmpcfg1_value[12:11] == 2'b01));
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    pmpaddr4_value[31:0] <= 32'b0;
  else if(pmp_updt_pmpaddr4 && (!pmpteecfg_s4 || cp0_yy_secu_mode_aft_dbg))
    pmpaddr4_value[31:0] <= cp0_pmp_updt_data[31:0];
  else
    pmpaddr4_value[31:0] <= pmpaddr4_value[31:0];
end
// &Force("output","pmpaddr4_value"); @854

assign pmp_updt_pmpaddr5 = pmp_csr_wen[9] && !pmpcfg1_value[15] && !(pmpcfg1_value[23] && (pmpcfg1_value[20:19] == 2'b01));
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    pmpaddr5_value[31:0] <= 32'b0;
  else if(pmp_updt_pmpaddr5 && (!pmpteecfg_s5 || cp0_yy_secu_mode_aft_dbg))
    pmpaddr5_value[31:0] <= cp0_pmp_updt_data[31:0];
  else
    pmpaddr5_value[31:0] <= pmpaddr5_value[31:0];
end
// &Force("output","pmpaddr5_value"); @870

assign pmp_updt_pmpaddr6 = pmp_csr_wen[10] && !pmpcfg1_value[23] && !(pmpcfg1_value[31] && (pmpcfg1_value[28:27] == 2'b01));
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    pmpaddr6_value[31:0] <= 32'b0;
  else if(pmp_updt_pmpaddr6 && (!pmpteecfg_s6 || cp0_yy_secu_mode_aft_dbg))
    pmpaddr6_value[31:0] <= cp0_pmp_updt_data[31:0];
  else
    pmpaddr6_value[31:0] <= pmpaddr6_value[31:0];
end
// &Force("output","pmpaddr6_value"); @886

assign pmp_updt_pmpaddr7 = pmp_csr_wen[11] && !pmpcfg1_value[31] && !(pmpcfg2_value[7] && (pmpcfg2_value[4:3] == 2'b01));
always @(posedge cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    pmpaddr7_value[31:0] <= 32'b0;
  else if(pmp_updt_pmpaddr7 && (!pmpteecfg_s7 || cp0_yy_secu_mode_aft_dbg))
    pmpaddr7_value[31:0] <= cp0_pmp_updt_data[31:0];
  else
    pmpaddr7_value[31:0] <= pmpaddr7_value[31:0];
end
// &Force("output","pmpaddr7_value"); @902

// &Force("output","pmpaddr8_value"); @918
assign pmpaddr8_value[31:0] = 32'b0;

// &Force("output","pmpaddr9_value"); @934
assign pmpaddr9_value[31:0] = 32'b0;

// &Force("output","pmpaddr10_value"); @950
assign pmpaddr10_value[31:0] = 32'b0;

// &Force("output","pmpaddr11_value"); @966
assign pmpaddr11_value[31:0] = 32'b0;


// &Force("output","pmpaddr12_value"); @983
assign pmpaddr12_value[31:0] = 32'b0;

// &Force("output","pmpaddr13_value"); @999
assign pmpaddr13_value[31:0] = 32'b0;

// &Force("output","pmpaddr14_value"); @1015
assign pmpaddr14_value[31:0] = 32'b0;

// &Force("output","pmpaddr15_value"); @1031
assign pmpaddr15_value[31:0] = 32'b0;

//==========================================================
//          PMP Entry TEE Configuration Register
//==========================================================
//------------------------------------------------
//pmpteecfg[0] register
//------------------------------------------------
assign pmpteecfg_s0 = 1'b0;

//------------------------------------------------
//pmpteecfg[1] register
//------------------------------------------------
assign pmpteecfg_s1 = 1'b0;

//------------------------------------------------
//pmpteecfg[2] register
//------------------------------------------------
assign pmpteecfg_s2 = 1'b0;

//------------------------------------------------
//pmpteecfg[3] register
//------------------------------------------------
assign pmpteecfg_s3 = 1'b0;

//------------------------------------------------
//pmpteecfg[4] register
//------------------------------------------------
assign pmpteecfg_s4 = 1'b0;

//------------------------------------------------
//pmpteecfg[5] register
//------------------------------------------------
assign pmpteecfg_s5 = 1'b0;

//------------------------------------------------
//pmpteecfg[6] register
//------------------------------------------------
assign pmpteecfg_s6 = 1'b0;

//------------------------------------------------
//pmpteecfg[7] register
//------------------------------------------------
assign pmpteecfg_s7 = 1'b0;

//------------------------------------------------
//pmpteecfg[8] register
//------------------------------------------------

//------------------------------------------------
//pmpteecfg[9] register
//------------------------------------------------

//------------------------------------------------
//pmpteecfg[10] register
//------------------------------------------------

//------------------------------------------------
//pmpteecfg[11] register
//------------------------------------------------

//------------------------------------------------
//pmpteecfg[12] register
//------------------------------------------------

//------------------------------------------------
//pmpteecfg[13] register
//------------------------------------------------

//------------------------------------------------
//pmpteecfg[14] register
//------------------------------------------------

//------------------------------------------------
//pmpteecfg[15] register
//------------------------------------------------

// &Force("nonport","pmpteecfg_value"); @1428
assign pmp_cp0_data[31:0]  = {32{pmp_csr_sel[0]}} & pmpcfg0_value[31:0] 
                           | {32{pmp_csr_sel[1]}} & pmpcfg1_value[31:0]
                           | {32{pmp_csr_sel[2]}} & pmpcfg2_value[31:0]
                           | {32{pmp_csr_sel[3]}} & pmpcfg3_value[31:0]
                           | {32{pmp_csr_sel[4]}} & pmpaddr0_value[31:0]
                           | {32{pmp_csr_sel[5]}} & pmpaddr1_value[31:0]
                           | {32{pmp_csr_sel[6]}} & pmpaddr2_value[31:0]
                           | {32{pmp_csr_sel[7]}} & pmpaddr3_value[31:0]
                           | {32{pmp_csr_sel[8]}} & pmpaddr4_value[31:0]
                           | {32{pmp_csr_sel[9]}} & pmpaddr5_value[31:0]
                           | {32{pmp_csr_sel[10]}} & pmpaddr6_value[31:0]
                           | {32{pmp_csr_sel[11]}} & pmpaddr7_value[31:0]
                           | {32{pmp_csr_sel[12]}} & pmpaddr8_value[31:0]
                           | {32{pmp_csr_sel[13]}} & pmpaddr9_value[31:0]
                           | {32{pmp_csr_sel[14]}} & pmpaddr10_value[31:0]
                           | {32{pmp_csr_sel[15]}} & pmpaddr11_value[31:0]
                           | {32{pmp_csr_sel[16]}} & pmpaddr12_value[31:0]
                           | {32{pmp_csr_sel[17]}} & pmpaddr13_value[31:0]
                           | {32{pmp_csr_sel[18]}} & pmpaddr14_value[31:0]
                           | {32{pmp_csr_sel[19]}} & pmpaddr15_value[31:0];


// &ModuleEnd; @1549
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_pmp_top(
  cp0_pmp_csr_sel,
  cp0_pmp_csr_wen,
  cp0_pmp_mstatus_mpp,
  cp0_pmp_mstatus_mprv,
  cp0_pmp_updt_data,
  cp0_yy_clk_en,
  cp0_yy_machine_mode_aft_dbg,
  cpurst_b,
  forever_cpuclk,
  ifu_bmu_addr,
  ifu_bmu_prot,
  lsu_bmu_addr,
  lsu_bmu_write,
  pad_yy_gate_clk_en_b,
  pmp_bmu_dbus_acc_deny,
  pmp_bmu_ibus_acc_deny,
  pmp_cp0_data,
  pmp_ifu_acc_scu,
  pmp_lsu_acc_scu
);

// &Ports; @25
input   [11:0]  cp0_pmp_csr_sel;            
input           cp0_pmp_csr_wen;            
input   [1 :0]  cp0_pmp_mstatus_mpp;        
input           cp0_pmp_mstatus_mprv;       
input   [31:0]  cp0_pmp_updt_data;          
input           cp0_yy_clk_en;              
input           cp0_yy_machine_mode_aft_dbg; 
input           cpurst_b;                   
input           forever_cpuclk;             
input   [31:0]  ifu_bmu_addr;               
input   [3 :0]  ifu_bmu_prot;               
input   [31:0]  lsu_bmu_addr;               
input           lsu_bmu_write;              
input           pad_yy_gate_clk_en_b;       
output          pmp_bmu_dbus_acc_deny;      
output          pmp_bmu_ibus_acc_deny;      
output  [31:0]  pmp_cp0_data;               
output          pmp_ifu_acc_scu;            
output          pmp_lsu_acc_scu;            

// &Regs; @26

// &Wires; @27
wire    [11:0]  cp0_pmp_csr_sel;            
wire            cp0_pmp_csr_wen;            
wire    [1 :0]  cp0_pmp_mstatus_mpp;        
wire            cp0_pmp_mstatus_mprv;       
wire    [31:0]  cp0_pmp_updt_data;          
wire            cp0_yy_clk_en;              
wire            cp0_yy_machine_mode_aft_dbg; 
wire            cp0_yy_secu_mode_aft_dbg;   
wire            cpuclk;                     
wire            cpurst_b;                   
wire            forever_cpuclk;             
wire    [7 :0]  ifu_addr_ge_bottom;         
wire    [31:0]  ifu_bmu_addr;               
wire    [3 :0]  ifu_bmu_prot;               
wire    [7 :0]  lsu_addr_ge_bottom;         
wire    [31:0]  lsu_bmu_addr;               
wire            lsu_bmu_write;              
wire            pad_yy_gate_clk_en_b;       
wire            pmp_bmu_dbus_acc_deny;      
wire            pmp_bmu_ibus_acc_deny;      
wire    [31:0]  pmp_cp0_data;               
wire    [19:0]  pmp_csr_sel;                
wire    [19:0]  pmp_csr_wen;                
wire            pmp_ifu_acc_scu;            
wire    [7 :0]  pmp_ifu_hit;                
wire            pmp_lsu_acc_scu;            
wire    [7 :0]  pmp_lsu_hit;                
wire    [31:0]  pmpaddr0_value;             
wire    [31:0]  pmpaddr1_value;             
wire    [31:0]  pmpaddr2_value;             
wire    [31:0]  pmpaddr3_value;             
wire    [31:0]  pmpaddr4_value;             
wire    [31:0]  pmpaddr5_value;             
wire    [31:0]  pmpaddr6_value;             
wire    [31:0]  pmpaddr7_value;             
wire    [1 :0]  regs_comp_addr_mode0;       
wire    [1 :0]  regs_comp_addr_mode1;       
wire    [1 :0]  regs_comp_addr_mode2;       
wire    [1 :0]  regs_comp_addr_mode3;       
wire    [1 :0]  regs_comp_addr_mode4;       
wire    [1 :0]  regs_comp_addr_mode5;       
wire    [1 :0]  regs_comp_addr_mode6;       
wire    [1 :0]  regs_comp_addr_mode7;       
wire            regs_comp_excut0;           
wire            regs_comp_excut1;           
wire            regs_comp_excut2;           
wire            regs_comp_excut3;           
wire            regs_comp_excut4;           
wire            regs_comp_excut5;           
wire            regs_comp_excut6;           
wire            regs_comp_excut7;           
wire            regs_comp_lock0;            
wire            regs_comp_lock1;            
wire            regs_comp_lock2;            
wire            regs_comp_lock3;            
wire            regs_comp_lock4;            
wire            regs_comp_lock5;            
wire            regs_comp_lock6;            
wire            regs_comp_lock7;            
wire            regs_comp_read0;            
wire            regs_comp_read1;            
wire            regs_comp_read2;            
wire            regs_comp_read3;            
wire            regs_comp_read4;            
wire            regs_comp_read5;            
wire            regs_comp_read6;            
wire            regs_comp_read7;            
wire            regs_comp_write0;           
wire            regs_comp_write1;           
wire            regs_comp_write2;           
wire            regs_comp_write3;           
wire            regs_comp_write4;           
wire            regs_comp_write5;           
wire            regs_comp_write6;           
wire            regs_comp_write7;           
wire            wr_pmp_regs;                



parameter PMPCFG0   = 12'h3A0;
parameter PMPCFG1   = 12'h3A1;
parameter PMPCFG2   = 12'h3A2;
parameter PMPCFG3   = 12'h3A3;
parameter PMPADDR0  = 12'h3B0;
parameter PMPADDR1  = 12'h3B1;
parameter PMPADDR2  = 12'h3B2;
parameter PMPADDR3  = 12'h3B3;
parameter PMPADDR4  = 12'h3B4;
parameter PMPADDR5  = 12'h3B5;
parameter PMPADDR6  = 12'h3B6;
parameter PMPADDR7  = 12'h3B7;
parameter PMPADDR8  = 12'h3B8;
parameter PMPADDR9  = 12'h3B9;
parameter PMPADDR10 = 12'h3BA;
parameter PMPADDR11 = 12'h3BB;
parameter PMPADDR12 = 12'h3BC;
parameter PMPADDR13 = 12'h3BD;
parameter PMPADDR14 = 12'h3BE;
parameter PMPADDR15 = 12'h3BF;
parameter PMPTEECFG = 12'hBEF;

assign pmp_csr_sel[0]  = cp0_pmp_csr_sel[11:0] == PMPCFG0; 
assign pmp_csr_sel[1]  = cp0_pmp_csr_sel[11:0] == PMPCFG1; 
assign pmp_csr_sel[2]  = cp0_pmp_csr_sel[11:0] == PMPCFG2; 
assign pmp_csr_sel[3]  = cp0_pmp_csr_sel[11:0] == PMPCFG3; 
assign pmp_csr_sel[4]  = cp0_pmp_csr_sel[11:0] == PMPADDR0; 
assign pmp_csr_sel[5]  = cp0_pmp_csr_sel[11:0] == PMPADDR1; 
assign pmp_csr_sel[6]  = cp0_pmp_csr_sel[11:0] == PMPADDR2; 
assign pmp_csr_sel[7]  = cp0_pmp_csr_sel[11:0] == PMPADDR3; 
assign pmp_csr_sel[8]  = cp0_pmp_csr_sel[11:0] == PMPADDR4; 
assign pmp_csr_sel[9]  = cp0_pmp_csr_sel[11:0] == PMPADDR5; 
assign pmp_csr_sel[10] = cp0_pmp_csr_sel[11:0] == PMPADDR6; 
assign pmp_csr_sel[11] = cp0_pmp_csr_sel[11:0] == PMPADDR7; 
assign pmp_csr_sel[12] = cp0_pmp_csr_sel[11:0] == PMPADDR8; 
assign pmp_csr_sel[13] = cp0_pmp_csr_sel[11:0] == PMPADDR9; 
assign pmp_csr_sel[14] = cp0_pmp_csr_sel[11:0] == PMPADDR10; 
assign pmp_csr_sel[15] = cp0_pmp_csr_sel[11:0] == PMPADDR11; 
assign pmp_csr_sel[16] = cp0_pmp_csr_sel[11:0] == PMPADDR12; 
assign pmp_csr_sel[17] = cp0_pmp_csr_sel[11:0] == PMPADDR13; 
assign pmp_csr_sel[18] = cp0_pmp_csr_sel[11:0] == PMPADDR14; 
assign pmp_csr_sel[19] = cp0_pmp_csr_sel[11:0] == PMPADDR15;

assign pmp_csr_wen[19:0] = pmp_csr_sel[19:0] & {20{cp0_pmp_csr_wen}};

assign cp0_yy_secu_mode_aft_dbg = 1'b0;

assign wr_pmp_regs = |pmp_csr_wen[19:0];
// &Instance("gated_clk_cell", "x_pmp_gated_clk"); @91
gated_clk_cell  x_pmp_gated_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (cpuclk              ),
  .external_en          (1'b0                ),
  .global_en            (cp0_yy_clk_en       ),
  .local_en             (1'b0                ),
  .module_en            (wr_pmp_regs         ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect( @92
//          .clk_in      (forever_cpuclk), @93
//          .global_en   (cp0_yy_clk_en ), @94
//          .module_en   (wr_pmp_regs   ), @95
//          .local_en    (1'b0          ), @96
//          .external_en (1'b0          ), @97
//          .clk_out     (cpuclk        ), @98
//         ); @99

// &Instance("cr_pmp_enc"); @101
cr_pmp_enc  x_cr_pmp_enc (
  .cp0_pmp_mstatus_mpp         (cp0_pmp_mstatus_mpp        ),
  .cp0_pmp_mstatus_mprv        (cp0_pmp_mstatus_mprv       ),
  .cp0_yy_machine_mode_aft_dbg (cp0_yy_machine_mode_aft_dbg),
  .ifu_bmu_prot                (ifu_bmu_prot               ),
  .lsu_bmu_write               (lsu_bmu_write              ),
  .pmp_bmu_dbus_acc_deny       (pmp_bmu_dbus_acc_deny      ),
  .pmp_bmu_ibus_acc_deny       (pmp_bmu_ibus_acc_deny      ),
  .pmp_ifu_acc_scu             (pmp_ifu_acc_scu            ),
  .pmp_ifu_hit                 (pmp_ifu_hit                ),
  .pmp_lsu_acc_scu             (pmp_lsu_acc_scu            ),
  .pmp_lsu_hit                 (pmp_lsu_hit                ),
  .regs_comp_excut0            (regs_comp_excut0           ),
  .regs_comp_excut1            (regs_comp_excut1           ),
  .regs_comp_excut2            (regs_comp_excut2           ),
  .regs_comp_excut3            (regs_comp_excut3           ),
  .regs_comp_excut4            (regs_comp_excut4           ),
  .regs_comp_excut5            (regs_comp_excut5           ),
  .regs_comp_excut6            (regs_comp_excut6           ),
  .regs_comp_excut7            (regs_comp_excut7           ),
  .regs_comp_lock0             (regs_comp_lock0            ),
  .regs_comp_lock1             (regs_comp_lock1            ),
  .regs_comp_lock2             (regs_comp_lock2            ),
  .regs_comp_lock3             (regs_comp_lock3            ),
  .regs_comp_lock4             (regs_comp_lock4            ),
  .regs_comp_lock5             (regs_comp_lock5            ),
  .regs_comp_lock6             (regs_comp_lock6            ),
  .regs_comp_lock7             (regs_comp_lock7            ),
  .regs_comp_read0             (regs_comp_read0            ),
  .regs_comp_read1             (regs_comp_read1            ),
  .regs_comp_read2             (regs_comp_read2            ),
  .regs_comp_read3             (regs_comp_read3            ),
  .regs_comp_read4             (regs_comp_read4            ),
  .regs_comp_read5             (regs_comp_read5            ),
  .regs_comp_read6             (regs_comp_read6            ),
  .regs_comp_read7             (regs_comp_read7            ),
  .regs_comp_write0            (regs_comp_write0           ),
  .regs_comp_write1            (regs_comp_write1           ),
  .regs_comp_write2            (regs_comp_write2           ),
  .regs_comp_write3            (regs_comp_write3           ),
  .regs_comp_write4            (regs_comp_write4           ),
  .regs_comp_write5            (regs_comp_write5           ),
  .regs_comp_write6            (regs_comp_write6           ),
  .regs_comp_write7            (regs_comp_write7           )
);

// &Instance("cr_pmp_regs"); @102
cr_pmp_regs  x_cr_pmp_regs (
  .cp0_pmp_updt_data        (cp0_pmp_updt_data       ),
  .cp0_yy_secu_mode_aft_dbg (cp0_yy_secu_mode_aft_dbg),
  .cpuclk                   (cpuclk                  ),
  .cpurst_b                 (cpurst_b                ),
  .pmp_cp0_data             (pmp_cp0_data            ),
  .pmp_csr_sel              (pmp_csr_sel             ),
  .pmp_csr_wen              (pmp_csr_wen             ),
  .pmpaddr0_value           (pmpaddr0_value          ),
  .pmpaddr1_value           (pmpaddr1_value          ),
  .pmpaddr2_value           (pmpaddr2_value          ),
  .pmpaddr3_value           (pmpaddr3_value          ),
  .pmpaddr4_value           (pmpaddr4_value          ),
  .pmpaddr5_value           (pmpaddr5_value          ),
  .pmpaddr6_value           (pmpaddr6_value          ),
  .pmpaddr7_value           (pmpaddr7_value          ),
  .regs_comp_addr_mode0     (regs_comp_addr_mode0    ),
  .regs_comp_addr_mode1     (regs_comp_addr_mode1    ),
  .regs_comp_addr_mode2     (regs_comp_addr_mode2    ),
  .regs_comp_addr_mode3     (regs_comp_addr_mode3    ),
  .regs_comp_addr_mode4     (regs_comp_addr_mode4    ),
  .regs_comp_addr_mode5     (regs_comp_addr_mode5    ),
  .regs_comp_addr_mode6     (regs_comp_addr_mode6    ),
  .regs_comp_addr_mode7     (regs_comp_addr_mode7    ),
  .regs_comp_excut0         (regs_comp_excut0        ),
  .regs_comp_excut1         (regs_comp_excut1        ),
  .regs_comp_excut2         (regs_comp_excut2        ),
  .regs_comp_excut3         (regs_comp_excut3        ),
  .regs_comp_excut4         (regs_comp_excut4        ),
  .regs_comp_excut5         (regs_comp_excut5        ),
  .regs_comp_excut6         (regs_comp_excut6        ),
  .regs_comp_excut7         (regs_comp_excut7        ),
  .regs_comp_lock0          (regs_comp_lock0         ),
  .regs_comp_lock1          (regs_comp_lock1         ),
  .regs_comp_lock2          (regs_comp_lock2         ),
  .regs_comp_lock3          (regs_comp_lock3         ),
  .regs_comp_lock4          (regs_comp_lock4         ),
  .regs_comp_lock5          (regs_comp_lock5         ),
  .regs_comp_lock6          (regs_comp_lock6         ),
  .regs_comp_lock7          (regs_comp_lock7         ),
  .regs_comp_read0          (regs_comp_read0         ),
  .regs_comp_read1          (regs_comp_read1         ),
  .regs_comp_read2          (regs_comp_read2         ),
  .regs_comp_read3          (regs_comp_read3         ),
  .regs_comp_read4          (regs_comp_read4         ),
  .regs_comp_read5          (regs_comp_read5         ),
  .regs_comp_read6          (regs_comp_read6         ),
  .regs_comp_read7          (regs_comp_read7         ),
  .regs_comp_write0         (regs_comp_write0        ),
  .regs_comp_write1         (regs_comp_write1        ),
  .regs_comp_write2         (regs_comp_write2        ),
  .regs_comp_write3         (regs_comp_write3        ),
  .regs_comp_write4         (regs_comp_write4        ),
  .regs_comp_write5         (regs_comp_write5        ),
  .regs_comp_write6         (regs_comp_write6        ),
  .regs_comp_write7         (regs_comp_write7        )
);


// &Force("bus","ifu_bmu_addr",31,0); @104
// &Force("bus","lsu_bmu_addr",31,0); @105

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_0"); @108
cr_pmp_comp_hit  x_cr_pmp_comp_hit_0 (
  .addr_match_mode           (regs_comp_addr_mode0[1:0]),
  .ifu_acc_addr              (ifu_bmu_addr[31:0]       ),
  .ifu_addr_ge_bottom        (1'b1                     ),
  .ifu_addr_ge_pmpaddr       (ifu_addr_ge_bottom[0]    ),
  .lsu_acc_addr              (lsu_bmu_addr[31:0]       ),
  .lsu_addr_ge_bottom        (1'b1                     ),
  .lsu_addr_ge_pmpaddr       (lsu_addr_ge_bottom[0]    ),
  .pmp_ifu_hit               (pmp_ifu_hit[0]           ),
  .pmp_lsu_hit               (pmp_lsu_hit[0]           ),
  .pmpaddr                   (pmpaddr0_value[31:0]     )
);

// &Connect(.addr_match_mode     (regs_comp_addr_mode0[1:0]), @109
//          .pmpaddr             (pmpaddr0_value[31:0]     ), @110
//          .ifu_addr_ge_bottom  (1'b1                     ), @111
//          .lsu_addr_ge_bottom  (1'b1                     ), @112
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]       ), @113
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]       ),  @114
//          .pmp_ifu_hit         (pmp_ifu_hit[0]           ), @115
//          .pmp_lsu_hit         (pmp_lsu_hit[0]           ), @116
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[0]    ), @117
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[0]    ) @118
//         ); @119

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_1"); @123
cr_pmp_comp_hit  x_cr_pmp_comp_hit_1 (
  .addr_match_mode           (regs_comp_addr_mode1[1:0]),
  .ifu_acc_addr              (ifu_bmu_addr[31:0]       ),
  .ifu_addr_ge_bottom        (ifu_addr_ge_bottom[0]    ),
  .ifu_addr_ge_pmpaddr       (ifu_addr_ge_bottom[1]    ),
  .lsu_acc_addr              (lsu_bmu_addr[31:0]       ),
  .lsu_addr_ge_bottom        (lsu_addr_ge_bottom[0]    ),
  .lsu_addr_ge_pmpaddr       (lsu_addr_ge_bottom[1]    ),
  .pmp_ifu_hit               (pmp_ifu_hit[1]           ),
  .pmp_lsu_hit               (pmp_lsu_hit[1]           ),
  .pmpaddr                   (pmpaddr1_value[31:0]     )
);

// &Connect(.addr_match_mode     (regs_comp_addr_mode1[1:0]), @124
//          .pmpaddr             (pmpaddr1_value[31:0]     ), @125
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[0]    ), @126
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[0]    ), @127
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]       ), @128
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]       ),  @129
//          .pmp_ifu_hit         (pmp_ifu_hit[1]           ), @130
//          .pmp_lsu_hit         (pmp_lsu_hit[1]           ), @131
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[1]    ), @132
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[1]    ) @133
//         ); @134

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_2"); @138
cr_pmp_comp_hit  x_cr_pmp_comp_hit_2 (
  .addr_match_mode           (regs_comp_addr_mode2[1:0]),
  .ifu_acc_addr              (ifu_bmu_addr[31:0]       ),
  .ifu_addr_ge_bottom        (ifu_addr_ge_bottom[1]    ),
  .ifu_addr_ge_pmpaddr       (ifu_addr_ge_bottom[2]    ),
  .lsu_acc_addr              (lsu_bmu_addr[31:0]       ),
  .lsu_addr_ge_bottom        (lsu_addr_ge_bottom[1]    ),
  .lsu_addr_ge_pmpaddr       (lsu_addr_ge_bottom[2]    ),
  .pmp_ifu_hit               (pmp_ifu_hit[2]           ),
  .pmp_lsu_hit               (pmp_lsu_hit[2]           ),
  .pmpaddr                   (pmpaddr2_value[31:0]     )
);

// &Connect(.addr_match_mode     (regs_comp_addr_mode2[1:0]), @139
//          .pmpaddr             (pmpaddr2_value[31:0]     ), @140
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[1]    ), @141
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[1]    ), @142
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]       ), @143
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]       ),  @144
//          .pmp_ifu_hit         (pmp_ifu_hit[2]           ), @145
//          .pmp_lsu_hit         (pmp_lsu_hit[2]           ), @146
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[2]    ), @147
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[2]    ) @148
//         ); @149

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_3"); @153
cr_pmp_comp_hit  x_cr_pmp_comp_hit_3 (
  .addr_match_mode           (regs_comp_addr_mode3[1:0]),
  .ifu_acc_addr              (ifu_bmu_addr[31:0]       ),
  .ifu_addr_ge_bottom        (ifu_addr_ge_bottom[2]    ),
  .ifu_addr_ge_pmpaddr       (ifu_addr_ge_bottom[3]    ),
  .lsu_acc_addr              (lsu_bmu_addr[31:0]       ),
  .lsu_addr_ge_bottom        (lsu_addr_ge_bottom[2]    ),
  .lsu_addr_ge_pmpaddr       (lsu_addr_ge_bottom[3]    ),
  .pmp_ifu_hit               (pmp_ifu_hit[3]           ),
  .pmp_lsu_hit               (pmp_lsu_hit[3]           ),
  .pmpaddr                   (pmpaddr3_value[31:0]     )
);

// &Connect(.addr_match_mode     (regs_comp_addr_mode3[1:0]), @154
//          .pmpaddr             (pmpaddr3_value[31:0]     ), @155
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[2]    ), @156
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[2]    ), @157
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]       ), @158
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]       ),  @159
//          .pmp_ifu_hit         (pmp_ifu_hit[3]           ), @160
//          .pmp_lsu_hit         (pmp_lsu_hit[3]           ), @161
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[3]    ), @162
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[3]    ) @163
//         ); @164

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_4"); @168
cr_pmp_comp_hit  x_cr_pmp_comp_hit_4 (
  .addr_match_mode           (regs_comp_addr_mode4[1:0]),
  .ifu_acc_addr              (ifu_bmu_addr[31:0]       ),
  .ifu_addr_ge_bottom        (ifu_addr_ge_bottom[3]    ),
  .ifu_addr_ge_pmpaddr       (ifu_addr_ge_bottom[4]    ),
  .lsu_acc_addr              (lsu_bmu_addr[31:0]       ),
  .lsu_addr_ge_bottom        (lsu_addr_ge_bottom[3]    ),
  .lsu_addr_ge_pmpaddr       (lsu_addr_ge_bottom[4]    ),
  .pmp_ifu_hit               (pmp_ifu_hit[4]           ),
  .pmp_lsu_hit               (pmp_lsu_hit[4]           ),
  .pmpaddr                   (pmpaddr4_value[31:0]     )
);

// &Connect(.addr_match_mode     (regs_comp_addr_mode4[1:0]), @169
//          .pmpaddr             (pmpaddr4_value[31:0]     ), @170
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[3]    ), @171
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[3]    ), @172
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]       ), @173
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]       ),  @174
//          .pmp_ifu_hit         (pmp_ifu_hit[4]           ), @175
//          .pmp_lsu_hit         (pmp_lsu_hit[4]           ), @176
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[4]    ), @177
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[4]    ) @178
//         ); @179

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_5"); @183
cr_pmp_comp_hit  x_cr_pmp_comp_hit_5 (
  .addr_match_mode           (regs_comp_addr_mode5[1:0]),
  .ifu_acc_addr              (ifu_bmu_addr[31:0]       ),
  .ifu_addr_ge_bottom        (ifu_addr_ge_bottom[4]    ),
  .ifu_addr_ge_pmpaddr       (ifu_addr_ge_bottom[5]    ),
  .lsu_acc_addr              (lsu_bmu_addr[31:0]       ),
  .lsu_addr_ge_bottom        (lsu_addr_ge_bottom[4]    ),
  .lsu_addr_ge_pmpaddr       (lsu_addr_ge_bottom[5]    ),
  .pmp_ifu_hit               (pmp_ifu_hit[5]           ),
  .pmp_lsu_hit               (pmp_lsu_hit[5]           ),
  .pmpaddr                   (pmpaddr5_value[31:0]     )
);

// &Connect(.addr_match_mode     (regs_comp_addr_mode5[1:0]), @184
//          .pmpaddr             (pmpaddr5_value[31:0]     ), @185
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[4]    ), @186
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[4]    ), @187
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]       ), @188
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]       ),  @189
//          .pmp_ifu_hit         (pmp_ifu_hit[5]           ), @190
//          .pmp_lsu_hit         (pmp_lsu_hit[5]           ), @191
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[5]    ), @192
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[5]    ) @193
//         ); @194

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_6"); @198
cr_pmp_comp_hit  x_cr_pmp_comp_hit_6 (
  .addr_match_mode           (regs_comp_addr_mode6[1:0]),
  .ifu_acc_addr              (ifu_bmu_addr[31:0]       ),
  .ifu_addr_ge_bottom        (ifu_addr_ge_bottom[5]    ),
  .ifu_addr_ge_pmpaddr       (ifu_addr_ge_bottom[6]    ),
  .lsu_acc_addr              (lsu_bmu_addr[31:0]       ),
  .lsu_addr_ge_bottom        (lsu_addr_ge_bottom[5]    ),
  .lsu_addr_ge_pmpaddr       (lsu_addr_ge_bottom[6]    ),
  .pmp_ifu_hit               (pmp_ifu_hit[6]           ),
  .pmp_lsu_hit               (pmp_lsu_hit[6]           ),
  .pmpaddr                   (pmpaddr6_value[31:0]     )
);

// &Connect(.addr_match_mode     (regs_comp_addr_mode6[1:0]), @199
//          .pmpaddr             (pmpaddr6_value[31:0]     ), @200
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[5]    ), @201
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[5]    ), @202
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]       ), @203
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]       ),  @204
//          .pmp_ifu_hit         (pmp_ifu_hit[6]           ), @205
//          .pmp_lsu_hit         (pmp_lsu_hit[6]           ), @206
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[6]    ), @207
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[6]    ) @208
//         ); @209

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_7"); @213
cr_pmp_comp_hit  x_cr_pmp_comp_hit_7 (
  .addr_match_mode           (regs_comp_addr_mode7[1:0]),
  .ifu_acc_addr              (ifu_bmu_addr[31:0]       ),
  .ifu_addr_ge_bottom        (ifu_addr_ge_bottom[6]    ),
  .ifu_addr_ge_pmpaddr       (ifu_addr_ge_bottom[7]    ),
  .lsu_acc_addr              (lsu_bmu_addr[31:0]       ),
  .lsu_addr_ge_bottom        (lsu_addr_ge_bottom[6]    ),
  .lsu_addr_ge_pmpaddr       (lsu_addr_ge_bottom[7]    ),
  .pmp_ifu_hit               (pmp_ifu_hit[7]           ),
  .pmp_lsu_hit               (pmp_lsu_hit[7]           ),
  .pmpaddr                   (pmpaddr7_value[31:0]     )
);

// &Connect(.addr_match_mode     (regs_comp_addr_mode7[1:0]), @214
//          .pmpaddr             (pmpaddr7_value[31:0]     ), @215
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[6]    ), @216
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[6]    ), @217
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]       ), @218
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]       ),  @219
//          .pmp_ifu_hit         (pmp_ifu_hit[7]           ), @220
//          .pmp_lsu_hit         (pmp_lsu_hit[7]           ), @221
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[7]    ), @222
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[7]    ) @223
//         ); @224

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_8"); @228
// &Connect(.addr_match_mode     (regs_comp_addr_mode8[1:0]), @229
//          .pmpaddr             (pmpaddr8_value[31:0]     ), @230
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[7]    ), @231
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[7]    ), @232
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]       ), @233
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]       ),  @234
//          .pmp_ifu_hit         (pmp_ifu_hit[8]           ), @235
//          .pmp_lsu_hit         (pmp_lsu_hit[8]           ), @236
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[8]    ), @237
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[8]    ) @238
//         ); @239

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_9"); @243
// &Connect(.addr_match_mode     (regs_comp_addr_mode9[1:0]), @244
//          .pmpaddr             (pmpaddr9_value[31:0]     ), @245
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[8]    ), @246
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[8]    ), @247
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]       ), @248
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]       ),  @249
//          .pmp_ifu_hit         (pmp_ifu_hit[9]           ), @250
//          .pmp_lsu_hit         (pmp_lsu_hit[9]           ), @251
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[9]    ), @252
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[9]    ) @253
//         ); @254

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_10"); @258
// &Connect(.addr_match_mode     (regs_comp_addr_mode10[1:0]), @259
//          .pmpaddr             (pmpaddr10_value[31:0]     ), @260
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[9]     ), @261
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[9]     ), @262
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]        ), @263
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]        ),  @264
//          .pmp_ifu_hit         (pmp_ifu_hit[10]           ), @265
//          .pmp_lsu_hit         (pmp_lsu_hit[10]           ), @266
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[10]    ), @267
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[10]    ) @268
//         ); @269

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_11"); @273
// &Connect(.addr_match_mode     (regs_comp_addr_mode11[1:0]), @274
//          .pmpaddr             (pmpaddr11_value[31:0]     ), @275
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[10]    ), @276
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[10]    ), @277
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]        ), @278
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]        ),  @279
//          .pmp_ifu_hit         (pmp_ifu_hit[11]           ), @280
//          .pmp_lsu_hit         (pmp_lsu_hit[11]           ), @281
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[11]    ), @282
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[11]    ) @283
//         ); @284

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_12"); @288
// &Connect(.addr_match_mode     (regs_comp_addr_mode12[1:0]), @289
//          .pmpaddr             (pmpaddr12_value[31:0]     ), @290
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[11]    ), @291
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[11]    ), @292
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]        ), @293
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]        ),  @294
//          .pmp_ifu_hit         (pmp_ifu_hit[12]           ), @295
//          .pmp_lsu_hit         (pmp_lsu_hit[12]           ), @296
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[12]    ), @297
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[12]    ) @298
//         ); @299

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_13"); @303
// &Connect(.addr_match_mode     (regs_comp_addr_mode13[1:0]), @304
//          .pmpaddr             (pmpaddr13_value[31:0]     ), @305
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[12]    ), @306
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[12]    ), @307
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]        ), @308
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]        ),  @309
//          .pmp_ifu_hit         (pmp_ifu_hit[13]           ), @310
//          .pmp_lsu_hit         (pmp_lsu_hit[13]           ), @311
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[13]    ), @312
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[13]    ) @313
//         ); @314

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_14"); @318
// &Connect(.addr_match_mode     (regs_comp_addr_mode14[1:0]), @319
//          .pmpaddr             (pmpaddr14_value[31:0]     ), @320
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[13]    ), @321
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[13]    ), @322
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]        ), @323
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]        ),  @324
//          .pmp_ifu_hit         (pmp_ifu_hit[14]           ), @325
//          .pmp_lsu_hit         (pmp_lsu_hit[14]           ), @326
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[14]    ), @327
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[14]    ) @328
//         ); @329

// &Instance("cr_pmp_comp_hit", "x_cr_pmp_comp_hit_15"); @333
// &Connect(.addr_match_mode     (regs_comp_addr_mode15[1:0]), @334
//          .pmpaddr             (pmpaddr15_value[31:0]     ), @335
//          .ifu_addr_ge_bottom  (ifu_addr_ge_bottom[14]    ), @336
//          .lsu_addr_ge_bottom  (lsu_addr_ge_bottom[14]    ), @337
//          .ifu_acc_addr        (ifu_bmu_addr[31:0]        ), @338
//          .lsu_acc_addr        (lsu_bmu_addr[31:0]        ),  @339
//          .pmp_ifu_hit         (pmp_ifu_hit[15]           ), @340
//          .pmp_lsu_hit         (pmp_lsu_hit[15]           ), @341
//          .ifu_addr_ge_pmpaddr (ifu_addr_ge_bottom[15]    ), @342
//          .lsu_addr_ge_pmpaddr (lsu_addr_ge_bottom[15]    ) @343
//         ); @344



// &ModuleEnd; @349
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_pwrm_top_dummy(
  pwrm_cpu_bus_peak_power_limit_en
);

// &Ports; @23
output       pwrm_cpu_bus_peak_power_limit_en; 

// &Regs; @24

// &Wires; @25
wire         pwrm_cpu_bus_peak_power_limit_en; 


//assign pwrm_cpu_avrg_power_inst_issue = 1'b1;
//assign pwrm_cpu_peak_power_limit_en   = 1'b0;

assign pwrm_cpu_bus_peak_power_limit_en = 1'b0;
//assign pwrm_cpu_inst_peak_power_limit_en = 1'b0;

// &ModuleEnd; @33
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// &ModuleBeg; @22
module cr_rst_top(
  cpurst_b,
  hadrst_b,
  pad_cpu_rst_b,
  pad_had_jtg_trst_b,
  pad_had_rst_b,
  pad_yy_test_mode,
  trst_b
);

// &Ports; @23
input        pad_cpu_rst_b;     
input        pad_had_jtg_trst_b; 
input        pad_had_rst_b;     
input        pad_yy_test_mode;  
output       cpurst_b;          
output       hadrst_b;          
output       trst_b;            

// &Regs; @24

// &Wires; @25
wire         cpurst_b;          
wire         hadrst_b;          
wire         pad_cpu_rst_b;     
wire         pad_had_jtg_trst_b; 
wire         pad_had_rst_b;     
wire         pad_yy_test_mode;  
wire         trst_b;            


//cpu reset 
assign cpurst_b = pad_yy_test_mode ? pad_had_jtg_trst_b : pad_cpu_rst_b;

//had reset
//signal for reset cpuclk domain reg in HAD
assign hadrst_b = pad_yy_test_mode ? pad_had_jtg_trst_b : pad_had_rst_b;
//signal for reset JTAG in HAD
assign trst_b = pad_had_jtg_trst_b;

// &ModuleEnd; @36
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_sahbl_top(
  ahblif_idle,
  biu_bmu_dbus_acc_err,
  biu_bmu_dbus_data,
  biu_bmu_dbus_data_vld,
  biu_bmu_dbus_grnt,
  biu_bmu_dbus_trans_cmplt,
  biu_bmu_ibus_acc_err,
  biu_bmu_ibus_data,
  biu_bmu_ibus_data_vld,
  biu_bmu_ibus_grnt,
  biu_bmu_ibus_trans_cmplt,
  biu_pad_haddr,
  biu_pad_hburst,
  biu_pad_hprot,
  biu_pad_hsize,
  biu_pad_htrans,
  biu_pad_hwdata,
  biu_pad_hwrite,
  bmu_biu_dbus_acc_deny,
  bmu_biu_dbus_addr,
  bmu_biu_dbus_chk_fail,
  bmu_biu_dbus_prot,
  bmu_biu_dbus_req,
  bmu_biu_dbus_req_without_cmplt,
  bmu_biu_dbus_size,
  bmu_biu_dbus_wdata,
  bmu_biu_dbus_write,
  bmu_biu_ibus_acc_deny,
  bmu_biu_ibus_addr,
  bmu_biu_ibus_hit,
  bmu_biu_ibus_prot,
  bmu_biu_ibus_req,
  bmu_biu_ibus_req_no_hit,
  bmu_biu_ibus_size,
  bmu_biu_ibus_vec_redirect,
  cpurst_b,
  dahblif_other_mask,
  forever_cpuclk,
  iahblif_other_mask,
  pad_biu_hrdata,
  pad_biu_hready,
  pad_biu_hresp,
  pad_cpu_halt_ff2,
  pad_yy_gate_clk_en_b,
  pwrm_cpu_bus_peak_power_limit_en,
  sahblif_iahblif_mask
);

// &Ports; @23
input           bmu_biu_dbus_acc_deny;           
input   [31:0]  bmu_biu_dbus_addr;               
input           bmu_biu_dbus_chk_fail;           
input   [3 :0]  bmu_biu_dbus_prot;               
input           bmu_biu_dbus_req;                
input           bmu_biu_dbus_req_without_cmplt;  
input   [1 :0]  bmu_biu_dbus_size;               
input   [31:0]  bmu_biu_dbus_wdata;              
input           bmu_biu_dbus_write;              
input           bmu_biu_ibus_acc_deny;           
input   [31:0]  bmu_biu_ibus_addr;               
input           bmu_biu_ibus_hit;                
input   [3 :0]  bmu_biu_ibus_prot;               
input           bmu_biu_ibus_req;                
input           bmu_biu_ibus_req_no_hit;         
input   [1 :0]  bmu_biu_ibus_size;               
input           bmu_biu_ibus_vec_redirect;       
input           cpurst_b;                        
input           dahblif_other_mask;              
input           forever_cpuclk;                  
input           iahblif_other_mask;              
input   [31:0]  pad_biu_hrdata;                  
input           pad_biu_hready;                  
input           pad_biu_hresp;                   
input           pad_cpu_halt_ff2;                
input           pad_yy_gate_clk_en_b;            
input           pwrm_cpu_bus_peak_power_limit_en; 
output          ahblif_idle;                     
output          biu_bmu_dbus_acc_err;            
output  [31:0]  biu_bmu_dbus_data;               
output          biu_bmu_dbus_data_vld;           
output          biu_bmu_dbus_grnt;               
output          biu_bmu_dbus_trans_cmplt;        
output          biu_bmu_ibus_acc_err;            
output  [31:0]  biu_bmu_ibus_data;               
output          biu_bmu_ibus_data_vld;           
output          biu_bmu_ibus_grnt;               
output          biu_bmu_ibus_trans_cmplt;        
output  [31:0]  biu_pad_haddr;                   
output  [2 :0]  biu_pad_hburst;                  
output  [3 :0]  biu_pad_hprot;                   
output  [2 :0]  biu_pad_hsize;                   
output  [1 :0]  biu_pad_htrans;                  
output  [31:0]  biu_pad_hwdata;                  
output          biu_pad_hwrite;                  
output          sahblif_iahblif_mask;            

// &Regs; @24

// &Wires; @25
wire            ahbl_clk_en;                     
wire            ahbl_gated_clk;                  
wire            ahblif_busy;                     
wire            ahblif_idle;                     
wire            ahblif_power_mask;               
wire            biu_bmu_dbus_acc_err;            
wire    [31:0]  biu_bmu_dbus_data;               
wire            biu_bmu_dbus_data_vld;           
wire            biu_bmu_dbus_grnt;               
wire            biu_bmu_dbus_trans_cmplt;        
wire            biu_bmu_ibus_acc_err;            
wire    [31:0]  biu_bmu_ibus_data;               
wire            biu_bmu_ibus_data_vld;           
wire            biu_bmu_ibus_grnt;               
wire            biu_bmu_ibus_trans_cmplt;        
wire    [31:0]  biu_pad_haddr;                   
wire    [2 :0]  biu_pad_hburst;                  
wire    [3 :0]  biu_pad_hprot;                   
wire    [2 :0]  biu_pad_hsize;                   
wire    [1 :0]  biu_pad_htrans;                  
wire    [31:0]  biu_pad_hwdata;                  
wire            biu_pad_hwrite;                  
wire            bmu_biu_dbus_acc_deny;           
wire    [31:0]  bmu_biu_dbus_addr;               
wire            bmu_biu_dbus_chk_fail;           
wire    [3 :0]  bmu_biu_dbus_prot;               
wire            bmu_biu_dbus_req;                
wire            bmu_biu_dbus_req_without_cmplt;  
wire    [1 :0]  bmu_biu_dbus_size;               
wire    [31:0]  bmu_biu_dbus_wdata;              
wire            bmu_biu_dbus_write;              
wire            bmu_biu_ibus_acc_deny;           
wire    [31:0]  bmu_biu_ibus_addr;               
wire            bmu_biu_ibus_hit;                
wire    [3 :0]  bmu_biu_ibus_prot;               
wire            bmu_biu_ibus_req;                
wire            bmu_biu_ibus_req_no_hit;         
wire    [1 :0]  bmu_biu_ibus_size;               
wire            bmu_biu_ibus_vec_redirect;       
wire            cpu_acc_err;                     
wire    [31:0]  cpu_addr;                        
wire            cpu_data_vld;                    
wire    [3 :0]  cpu_prot;                        
wire    [31:0]  cpu_rdata;                       
wire            cpu_req;                         
wire            cpu_req_for_grnt;                
wire            cpu_req_for_peak_power;          
wire            cpu_req_grnt;                    
wire            cpu_req_power_masked;            
wire            cpu_sec;                         
wire    [1 :0]  cpu_size;                        
wire            cpu_trans_cmplt;                 
wire            cpu_vec_redirect;                
wire    [31:0]  cpu_wdata;                       
wire            cpu_wdata_sel;                   
wire            cpu_write;                       
wire            cpurst_b;                        
wire            dahblif_other_mask;              
wire            dbus_mask;                       
wire            forever_cpuclk;                  
wire            iahblif_other_mask;              
wire            ibus_not_granted;                
wire    [31:0]  pad_biu_hrdata;                  
wire            pad_biu_hready;                  
wire            pad_biu_hresp;                   
wire            pad_cpu_halt_ff2;                
wire            pad_yy_gate_clk_en_b;            
wire            pwrm_cpu_bus_peak_power_limit_en; 
wire            sahblif_iahblif_mask;            


//==========================================================
//  Instance Gated Cell for Most Common Use
//==========================================================
// &Instance("gated_clk_cell", "x_gated_ahbl_cpuclk_cell"); @30
gated_clk_cell  x_gated_ahbl_cpuclk_cell (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (ahbl_gated_clk      ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (dbus_mask           ),
  .module_en            (ahbl_clk_en         ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in     (forever_cpuclk), @31
//          .global_en  (1'b1          ), @32
//          .module_en  (ahbl_clk_en   ), @33
//          .local_en   (dbus_mask     ), @34
//          .external_en(1'b0          ), @35
//          .clk_out    (ahbl_gated_clk)); @36

//==========================================================
//  Instance Request Arbiter module 
//==========================================================
// &Instance("cr_ahbl_req_arb_fo"); @42
// &Connect(.cpu_req_bus_sel (cpu_req_bus_grnt)); @43
// &Force("nonport", "cpu_req_bus_ff"); @44
// &Force("nonport", "cpu_req_for_peak_power"); @45
// &Force("input", "bmu_biu_ibus_req_no_hit"); @46
// &Force("nonport", "uncmplt_mask"); @52
// &Instance("cr_ahbl_req_arb"); @56
cr_ahbl_req_arb  x_cr_ahbl_req_arb (
  .ahbl_bmu_dbus_acc_err                   (biu_bmu_dbus_acc_err                   ),
  .ahbl_bmu_dbus_data                      (biu_bmu_dbus_data                      ),
  .ahbl_bmu_dbus_data_vld                  (biu_bmu_dbus_data_vld                  ),
  .ahbl_bmu_dbus_grnt                      (biu_bmu_dbus_grnt                      ),
  .ahbl_bmu_dbus_trans_cmplt               (biu_bmu_dbus_trans_cmplt               ),
  .ahbl_bmu_ibus_acc_err                   (biu_bmu_ibus_acc_err                   ),
  .ahbl_bmu_ibus_data                      (biu_bmu_ibus_data                      ),
  .ahbl_bmu_ibus_data_vld                  (biu_bmu_ibus_data_vld                  ),
  .ahbl_bmu_ibus_grnt                      (biu_bmu_ibus_grnt                      ),
  .ahbl_bmu_ibus_trans_cmplt               (biu_bmu_ibus_trans_cmplt               ),
  .ahbl_gated_clk                          (ahbl_gated_clk                         ),
  .bmu_ahbl_dbus_acc_deny                  (bmu_biu_dbus_acc_deny                  ),
  .bmu_ahbl_dbus_addr                      (bmu_biu_dbus_addr                      ),
  .bmu_ahbl_dbus_chk_fail                  (bmu_biu_dbus_chk_fail                  ),
  .bmu_ahbl_dbus_prot                      (bmu_biu_dbus_prot                      ),
  .bmu_ahbl_dbus_req                       (bmu_biu_dbus_req                       ),
  .bmu_ahbl_dbus_req_without_cmplt         (bmu_biu_dbus_req_without_cmplt         ),
  .bmu_ahbl_dbus_req_without_deny_chk_fail (bmu_biu_dbus_req                       ),
  .bmu_ahbl_dbus_size                      (bmu_biu_dbus_size                      ),
  .bmu_ahbl_dbus_write                     (bmu_biu_dbus_write                     ),
  .bmu_ahbl_ibus_acc_deny                  (bmu_biu_ibus_acc_deny                  ),
  .bmu_ahbl_ibus_addr                      (bmu_biu_ibus_addr                      ),
  .bmu_ahbl_ibus_hit                       (bmu_biu_ibus_hit                       ),
  .bmu_ahbl_ibus_prot                      (bmu_biu_ibus_prot                      ),
  .bmu_ahbl_ibus_req                       (bmu_biu_ibus_req                       ),
  .bmu_ahbl_ibus_req_no_hit                (bmu_biu_ibus_req_no_hit                ),
  .bmu_ahbl_ibus_size                      (bmu_biu_ibus_size                      ),
  .bmu_ahbl_ibus_vec_redirect              (bmu_biu_ibus_vec_redirect              ),
  .bmu_ahbl_ibus_write                     (1'b0                                   ),
  .bmu_ahbl_wdata                          (bmu_biu_dbus_wdata                     ),
  .cpu_acc_err                             (cpu_acc_err                            ),
  .cpu_addr                                (cpu_addr                               ),
  .cpu_data_vld                            (cpu_data_vld                           ),
  .cpu_prot                                (cpu_prot                               ),
  .cpu_rdata                               (cpu_rdata                              ),
  .cpu_req                                 (cpu_req                                ),
  .cpu_req_for_grnt                        (cpu_req_for_grnt                       ),
  .cpu_req_for_peak_power                  (cpu_req_for_peak_power                 ),
  .cpu_req_grnt                            (cpu_req_grnt                           ),
  .cpu_sec                                 (cpu_sec                                ),
  .cpu_size                                (cpu_size                               ),
  .cpu_trans_cmplt                         (cpu_trans_cmplt                        ),
  .cpu_vec_redirect                        (cpu_vec_redirect                       ),
  .cpu_wdata                               (cpu_wdata                              ),
  .cpu_write                               (cpu_write                              ),
  .cpurst_b                                (cpurst_b                               ),
  .ibus_not_granted                        (ibus_not_granted                       )
);

assign dbus_mask = ibus_not_granted;
// &Connect( .ahbl_bmu_bus_check_fail   (biu_bmu_bus_check_fail   ), @61
//           .ahbl_bmu_dbus_acc_err     (biu_bmu_dbus_acc_err     ), @62
//           .ahbl_bmu_dbus_data        (biu_bmu_dbus_data        ), @63
//           .ahbl_bmu_dbus_data_vld    (biu_bmu_dbus_data_vld    ), @64
//           .ahbl_bmu_dbus_grnt        (biu_bmu_dbus_grnt        ), @65
//           .ahbl_bmu_dbus_trans_cmplt (biu_bmu_dbus_trans_cmplt ), @66
//           .ahbl_bmu_ibus_acc_err     (biu_bmu_ibus_acc_err     ), @67
//           .ahbl_bmu_ibus_data        (biu_bmu_ibus_data        ), @68
//           .ahbl_bmu_ibus_data_vld    (biu_bmu_ibus_data_vld    ), @69
//           .ahbl_bmu_ibus_grnt        (biu_bmu_ibus_grnt        ), @70
//           .ahbl_bmu_ibus_trans_cmplt (biu_bmu_ibus_trans_cmplt ), @71
//           .bmu_ahbl_dbus_acc_deny    (bmu_biu_dbus_acc_deny    ), @72
//           .bmu_ahbl_dbus_chk_fail    (bmu_biu_dbus_chk_fail    ), @73
//           .bmu_ahbl_dbus_addr        (bmu_biu_dbus_addr        ), @74
//           .bmu_ahbl_dbus_prot        (bmu_biu_dbus_prot        ), @75
//           .bmu_ahbl_dbus_req         (bmu_biu_dbus_req         ), @76
//           .bmu_ahbl_dbus_req_without_deny_chk_fail(bmu_biu_dbus_req), @77
//           .bmu_ahbl_dbus_req_without_cmplt (bmu_biu_dbus_req_without_cmplt), @78
//           .bmu_ahbl_dbus_size        (bmu_biu_dbus_size        ), @79
//           .bmu_ahbl_wdata            (bmu_biu_dbus_wdata       ), @80
//           .bmu_ahbl_dbus_write       (bmu_biu_dbus_write       ), @81
//           .bmu_ahbl_ibus_acc_deny    (bmu_biu_ibus_acc_deny    ), @82
//           .bmu_ahbl_ibus_addr        (bmu_biu_ibus_addr        ), @83
//           .bmu_ahbl_ibus_prot        (bmu_biu_ibus_prot        ), @84
//           .bmu_ahbl_ibus_req         (bmu_biu_ibus_req         ), @85
//           .bmu_ahbl_ibus_req_no_hit  (bmu_biu_ibus_req_no_hit  ), @86
//           .bmu_ahbl_ibus_size        (bmu_biu_ibus_size        ), @87
//           .bmu_ahbl_ibus_vec_redirect (bmu_biu_ibus_vec_redirect), @88
//           .bmu_ahbl_ibus_write       (1'b0                     )); @89
// &Connect( .ahbl_bmu_dbus_data_pol    (biu_bmu_dbus_data_pol    ), @91
//           .ahbl_bmu_ibus_data_pol    (biu_bmu_ibus_data_pol    ), @92
//           .bmu_ahbl_wdata_pol        (bmu_biu_dbus_wdata_pol   )); @93
// &Connect( .bmu_ahbl_had_addr         (bmu_biu_had_addr         ),   @96
//           .bmu_ahbl_had_prot         (bmu_biu_had_prot         ),   @97
//           .bmu_ahbl_had_req          (bmu_biu_had_req          ),   @98
//           .bmu_ahbl_had_req_without_cmplt (bmu_biu_had_req_without_cmplt), @99
//           .bmu_ahbl_had_size         (bmu_biu_had_size         ),   @100
//           .bmu_ahbl_had_wdata        (bmu_biu_had_wdata        ),   @101
//           .bmu_ahbl_had_write        (bmu_biu_had_write        ),   @102
//           .ahbl_bmu_had_acc_err      (biu_bmu_had_acc_err      ),   @103
//           .ahbl_bmu_had_data         (biu_bmu_had_data         ),   @104
//           .ahbl_bmu_had_data_vld     (biu_bmu_had_data_vld     ),   @105
//           .ahbl_bmu_had_grnt         (biu_bmu_had_grnt         ),   @106
//           .ahbl_bmu_had_trans_cmplt  (biu_bmu_had_trans_cmplt  ));  @107
// &Force("bus", "bmu_biu_ibus_source_pc", 31, 0); @110
// &Force("bus", "bmu_biu_dbus_source_pc", 31, 0); @111
// &Connect( .bmu_ahbl_ibus_source_pc   (bmu_biu_ibus_source_pc[29:8]), @112
//           .bmu_ahbl_ibus_load        (1'b0                        ), @113
//           .bmu_ahbl_ibus_store       (1'b0                        ), @114
//           .bmu_ahbl_ibus_inst_fetch_chk (bmu_biu_ibus_inst_fetch_chk )); @115
// &Connect( .bmu_ahbl_dbus_source_pc   (bmu_biu_dbus_source_pc[29:8]), @116
//           .bmu_ahbl_dbus_load        (bmu_biu_dbus_load        ), @117
//           .bmu_ahbl_dbus_store       (bmu_biu_dbus_store       ), @118
//           .bmu_ahbl_dbus_inst_fetch_chk (bmu_biu_dbus_inst_fetch_chk )); @119
// &Connect( .ahbl_bmu_ibus_inst_dbg_disable (biu_bmu_ibus_inst_dbg_disable )); @124
// &Connect( .bmu_ahbl_ibus_hit (bmu_biu_ibus_hit)); @126
// &Force("nonport", "cpu_sec"); @127
// &Force("nonport", "ahbl_bmu_ibus_sec"); @128
// &Force("nonport", "ahb_ahbif_hsec"); @131
// &Force("nonport", "ahbl_ahbLif_hsec"); @135
// &Connect( .ahbl_bmu_bus_check_fail   (ahbl_cache_bus_check_fail), @139
//           .ahbl_bmu_ibus_acc_err     (ahbl_cache_lf_acc_err    ), @140
//           .ahbl_bmu_ibus_sec         (ahbl_cache_lf_sec        ), @141
//           .ahbl_bmu_ibus_data        (ahbl_cache_lf_data       ), @142
//           .ahbl_bmu_ibus_data_vld    (ahbl_cache_lf_data_vld   ), @143
//           .ahbl_bmu_ibus_grnt        (ahbl_cache_lf_grnt       ), @144
//           .ahbl_bmu_ibus_trans_cmplt (ahbl_cache_lf_trans_cmplt), @145
//           .ahbl_bmu_dbus_acc_err     (ahbl_cache_uc_acc_err    ), @146
//           .ahbl_bmu_dbus_data        (ahbl_cache_uc_data       ), @147
//           .ahbl_bmu_dbus_data_vld    (ahbl_cache_uc_data_vld   ), @148
//           .ahbl_bmu_dbus_trans_cmplt (ahbl_cache_uc_trans_cmplt), @149
//           .ahbl_bmu_dbus_grnt        (ahbl_cache_uc_grnt       ), @150
//           .bmu_ahbl_ibus_acc_deny    (1'b0                     ), @151
//           .bmu_ahbl_ibus_addr        (cache_ahbl_lf_addr       ), @152
//           .bmu_ahbl_ibus_prot        (cache_ahbl_lf_prot       ), @153
//           .bmu_ahbl_ibus_req         (cache_ahbl_lf_req        ), @154
//           .bmu_ahbl_ibus_req_no_hit  (cache_ahbl_lf_req        ), @155
//           .bmu_ahbl_ibus_size        (cache_ahbl_lf_size       ), @156
//           .bmu_ahbl_ibus_write       (1'b0                     ), @157
//           .bmu_ahbl_wdata            (cache_ahbl_uc_wdata      ), @158
//           .bmu_ahbl_dbus_acc_deny    (1'b0                     ), @159
//           .bmu_ahbl_dbus_chk_fail    (1'b0                     ), @160
//           .bmu_ahbl_dbus_addr        (cache_ahbl_uc_addr       ), @161
//           .bmu_ahbl_dbus_prot        (cache_ahbl_uc_prot       ), @162
//           .bmu_ahbl_dbus_req         (cache_ahbl_uc_req        ), @163
//           .bmu_ahbl_dbus_req_without_deny_chk_fail(cache_ahbl_uc_req_without_cmplt), @164
//           .bmu_ahbl_dbus_req_without_cmplt (cache_ahbl_uc_req_without_cmplt), @165
//           .bmu_ahbl_dbus_size        (cache_ahbl_uc_size       ), @166
//           .bmu_ahbl_ibus_vec_redirect (cache_ahbl_uc_vec_redirect), @167
//           .bmu_ahbl_dbus_write       (cache_ahbl_uc_write      )); @168
// &Connect( .ahbl_bmu_ibus_data_pol    (ahbl_cache_lf_data_pol   ), @170
//           .ahbl_bmu_dbus_data_pol    (ahbl_cache_uc_data_pol   ), @171
//           .bmu_ahbl_wdata_pol        (cache_ahbl_uc_wdata_pol  )); @172
// &Connect( .bmu_ahbl_dbus_source_pc   (cache_ahbl_uc_source_pc  ), @175
//           .bmu_ahbl_dbus_load        (cache_ahbl_uc_load       ), @176
//           .bmu_ahbl_dbus_store       (cache_ahbl_uc_store      ), @177
//           .bmu_ahbl_dbus_inst_fetch_chk (cache_ahbl_uc_inst_fetch_chk)); @178
// &Connect( .bmu_ahbl_ibus_source_pc   (cache_ahbl_lf_source_pc  ), @179
//           .bmu_ahbl_ibus_load        (1'b0                     ), @180
//           .bmu_ahbl_ibus_store       (1'b0                     ), @181
//           .bmu_ahbl_ibus_inst_fetch_chk (cache_ahbl_lf_inst_fetch_chk)); @182
// &Connect( .ahbl_bmu_ibus_inst_dbg_disable (ahbl_cache_bus_inst_dbg_disable )); @185
// &Connect( .bmu_ahbl_ibus_hit (1'b1)); @187
// &Connect( .ahbl_bmu_bus_check_fail   (biu_bmu_bus_check_fail   ), @190
//           .ahbl_bmu_dbus_acc_err     (biu_bmu_dbus_acc_err     ), @191
//           .ahbl_bmu_dbus_data        (biu_bmu_dbus_data        ), @192
//           .ahbl_bmu_dbus_data_vld    (biu_bmu_dbus_data_vld    ), @193
//           .ahbl_bmu_dbus_grnt        (biu_bmu_dbus_grnt        ), @194
//           .ahbl_bmu_dbus_trans_cmplt (biu_bmu_dbus_trans_cmplt ), @195
//           .ahbl_bmu_ibus_acc_err     (biu_bmu_ibus_acc_err     ), @196
//           .ahbl_bmu_ibus_data        (biu_bmu_ibus_data        ), @197
//           .ahbl_bmu_ibus_data_vld    (biu_bmu_ibus_data_vld    ), @198
//           .ahbl_bmu_ibus_grnt        (biu_bmu_ibus_grnt        ), @199
//           .ahbl_bmu_ibus_trans_cmplt (biu_bmu_ibus_trans_cmplt ), @200
//           .bmu_ahbl_dbus_acc_deny    (bmu_biu_dbus_acc_deny    ), @201
//           .bmu_ahbl_dbus_chk_fail    (bmu_biu_dbus_chk_fail    ), @202
//           .bmu_ahbl_dbus_addr        (bmu_biu_dbus_addr        ), @203
//           .bmu_ahbl_dbus_prot        (bmu_biu_dbus_prot        ), @204
//           .bmu_ahbl_dbus_req         (bmu_biu_dbus_req         ), @205
//           .bmu_ahbl_dbus_req_without_deny_chk_fail(bmu_biu_dbus_req), @206
//           .bmu_ahbl_dbus_req_without_cmplt (bmu_biu_dbus_req_without_cmplt), @207
//           .bmu_ahbl_dbus_size        (bmu_biu_dbus_size        ), @208
//           .bmu_ahbl_wdata            (bmu_biu_dbus_wdata       ), @209
//           .bmu_ahbl_dbus_write       (bmu_biu_dbus_write       ), @210
//           .bmu_ahbl_ibus_acc_deny    (bmu_biu_ibus_acc_deny    ), @211
//           .bmu_ahbl_ibus_addr        (bmu_biu_ibus_addr        ), @212
//           .bmu_ahbl_ibus_prot        (bmu_biu_ibus_prot        ), @213
//           .bmu_ahbl_ibus_req         (bmu_biu_ibus_req         ), @214
//           .bmu_ahbl_ibus_req_no_hit  (bmu_biu_ibus_req_no_hit  ), @215
//           .bmu_ahbl_ibus_size        (bmu_biu_ibus_size        ), @216
//           .bmu_ahbl_ibus_vec_redirect (bmu_biu_ibus_vec_redirect), @217
//           .bmu_ahbl_ibus_write       (1'b0                     )); @218
// &Connect( .ahbl_bmu_dbus_data_pol    (biu_bmu_dbus_data_pol    ), @220
//           .ahbl_bmu_ibus_data_pol    (biu_bmu_ibus_data_pol    ), @221
//           .bmu_ahbl_wdata_pol        (bmu_biu_dbus_wdata_pol   )); @222
// &Connect( .bmu_ahbl_had_addr         (bmu_biu_had_addr         ), @225
//           .bmu_ahbl_had_prot         (bmu_biu_had_prot         ), @226
//           .bmu_ahbl_had_req          (bmu_biu_had_req          ), @227
//           .bmu_ahbl_had_req_without_cmplt (bmu_biu_had_req_without_cmplt), @228
//           .bmu_ahbl_had_size         (bmu_biu_had_size         ), @229
//           .bmu_ahbl_had_wdata        (bmu_biu_had_wdata        ), @230
//           .bmu_ahbl_had_write        (bmu_biu_had_write        ), @231
//           .ahbl_bmu_had_acc_err      (biu_bmu_had_acc_err      ), @232
//           .ahbl_bmu_had_data         (biu_bmu_had_data         ), @233
//           .ahbl_bmu_had_data_vld     (biu_bmu_had_data_vld     ), @234
//           .ahbl_bmu_had_grnt         (biu_bmu_had_grnt         ), @235
//           .ahbl_bmu_had_trans_cmplt  (biu_bmu_had_trans_cmplt  )); @236
// &Force("bus", "bmu_biu_ibus_source_pc", 31, 0); @239
// &Force("bus", "bmu_biu_dbus_source_pc", 31, 0); @240
// &Connect( .bmu_ahbl_ibus_source_pc   (bmu_biu_ibus_source_pc[29:8]), @241
//           .bmu_ahbl_ibus_load        (1'b0                        ), @242
//           .bmu_ahbl_ibus_store       (1'b0                        ), @243
//           .bmu_ahbl_ibus_inst_fetch_chk (bmu_biu_ibus_inst_fetch_chk )); @244
// &Connect( .bmu_ahbl_dbus_source_pc   (bmu_biu_dbus_source_pc[29:8]), @245
//           .bmu_ahbl_dbus_load        (bmu_biu_dbus_load        ), @246
//           .bmu_ahbl_dbus_store       (bmu_biu_dbus_store       ), @247
//           .bmu_ahbl_dbus_inst_fetch_chk (bmu_biu_dbus_inst_fetch_chk )); @248
// &Connect( .ahbl_bmu_ibus_inst_dbg_disable (biu_bmu_ibus_inst_dbg_disable )); @253
// &Connect( .bmu_ahbl_ibus_hit (bmu_biu_ibus_hit)); @255

//==========================================================
//  Instance Bus Interface module
//  Width Adjust Module is needed for 16-bits BUS 
//==========================================================
// &Instance("cr_ahbl_wid_adj_fo"); @264
// &Instance("cr_ahbl_if_fo_hw"); @265
// &Connect(.cpu_addr        (cpu_addr_raw       ), @266
//          .cpu_prot        (cpu_prot_raw       ), @267
//          .cpu_req         (cpu_req_raw        ), @268
//          .cpu_size        (cpu_size_raw       ), @269
//          .cpu_wdata       (cpu_wdata_raw      ), @270
//          .cpu_write       (cpu_write_raw      ), @271
//          .cpu_acc_err     (cpu_acc_err_raw    ), @272
//          .cpu_data_vld    (cpu_data_vld_raw   ), @273
//          .cpu_rdata       (cpu_rdata_raw      ), @274
//          .cpu_req_grnt    (cpu_req_grnt_raw   ), @275
//          .cpu_trans_cmplt (cpu_trans_cmplt_raw) @276
// ); @277
// &Connect(.ahbLif_ahbl_haddr      (biu_pad_haddr         ), @278
//          .ahbLif_ahbl_hburst     (biu_pad_hburst        ), @279
//          .ahbLif_ahbl_hprot      (biu_pad_hprot         ), @280
//          .ahbLif_ahbl_hsize      (biu_pad_hsize         ), @281
//          .ahbLif_ahbl_htrans     (biu_pad_htrans        ), @282
//          .ahbLif_ahbl_hwdata     (biu_pad_hwdata        ), @283
//          .ahbLif_ahbl_hwrite     (biu_pad_hwrite        ), @284
//          .ahbl_ahbLif_hrdata     (pad_biu_hrdata        ), @285
//          .ahbl_ahbLif_hready     (pad_biu_hready        ), @286
//          .ahbl_ahbLif_hresp      (pad_biu_hresp         )); @287
// &Connect(.ahbLif_ahbl_haddr_pol  (biu_pad_haddr_pol     ), @289
//          .ahbLif_ahbl_hwdata_pol (biu_pad_hwdata_pol    ), @290
//          .ahbl_ahbLif_hrdata_pol (pad_biu_hrdata_pol    )); @291
// &Connect(.ahbLif_ahbl_hwdata_par (biu_pad_hwdata_par    ), @294
//          .ahbl_ahbLif_hrdata_par (pad_biu_hrdata_par    )); @295
// &Connect(.ahbl_ahbLif_inst_dbg_disable (pad_biu_inst_dbg_disable )); @298
// &Instance("cr_ahbl_wid_adj"); @301
// &Instance("cr_ahbl_if_hw"); @302
// &Connect(.cpu_addr        (cpu_addr_raw       ), @303
//          .cpu_prot        (cpu_prot_raw       ), @304
//          .cpu_req         (cpu_req_raw        ), @305
//          .cpu_size        (cpu_size_raw       ), @306
//          .cpu_wdata       (cpu_wdata_raw      ), @307
//          .cpu_write       (cpu_write_raw      ), @308
//          .cpu_acc_err     (cpu_acc_err_raw    ), @309
//          .cpu_data_vld    (cpu_data_vld_raw   ), @310
//          .cpu_rdata       (cpu_rdata_raw      ), @311
//          .cpu_req_grnt    (cpu_req_grnt_raw   ), @312
//          .cpu_trans_cmplt (cpu_trans_cmplt_raw) @313
// ); @314
// &Connect(.ahbLif_ahbl_haddr      (biu_pad_haddr         ), @315
//          .ahbLif_ahbl_hburst     (biu_pad_hburst        ), @316
//          .ahbLif_ahbl_hprot      (biu_pad_hprot         ), @317
//          .ahbLif_ahbl_hsize      (biu_pad_hsize         ), @318
//          .ahbLif_ahbl_htrans     (biu_pad_htrans        ), @319
//          .ahbLif_ahbl_hwdata     (biu_pad_hwdata        ), @320
//          .ahbLif_ahbl_hwrite     (biu_pad_hwrite        ), @321
//          .ahbl_ahbLif_hrdata     (pad_biu_hrdata        ), @322
//          .ahbl_ahbLif_hready     (pad_biu_hready        ), @323
//          .ahbl_ahbLif_hresp      (pad_biu_hresp         )); @324
// &Connect(.ahbLif_ahbl_haddr_pol  (biu_pad_haddr_pol     ), @326
//          .ahbLif_ahbl_hwdata_pol (biu_pad_hwdata_pol    ), @327
//          .ahbl_ahbLif_hrdata_pol (pad_biu_hrdata_pol    )); @328
// &Connect(.ahbLif_ahbl_hwdata_par (biu_pad_hwdata_par    ), @331
//          .ahbl_ahbLif_hrdata_par (pad_biu_hrdata_par    )); @332
// &Connect(.ahbl_ahbLif_inst_dbg_disable (pad_biu_inst_dbg_disable )); @335

// &Instance("cr_ahb_if_fo", "x_cr_ahbl_if_fo"); @342
// &Force("input", "pwrm_cpu_bus_peak_power_limit_en"); @343
// &Force("input", "iahblif_other_mask"); @344
// &Force("input", "dahblif_other_mask"); @345
// &Instance("cr_ahb_if", "x_cr_ahbl_if"); @353
// &Connect(.ahbif_busy           (ahblif_busy           )); @354
// &Force("nonport", "cpu_req_for_peak_power"); @358
// &Force("nonport", "cpu_wdata_sel"); @360
// &Connect(.cpu_wr_data            (cpu_wdata             )); @361
// &Force("input", "pwrm_cpu_bus_peak_power_limit_en"); @364
// &Force("nonport", "cpu_req_for_peak_power"); @365
// &Force("nonport", "ahblif_busy"); @366
// &Connect(.ahb_gated_clk        (ahbl_gated_clk        )); @376
// &Connect(.ahb_clk_en           (ahbl_clk_en           )); @377
// &Connect(.ahbif_power_mask     (ahblif_power_mask     )); @378
// &Connect(.ahbif_ahb_haddr      (biu_ebmu_haddr         ), @379
//          .ahbif_ahb_hburst     (biu_ebmu_hburst        ), @380
//          .ahbif_ahb_hprot      (biu_ebmu_hprot         ), @381
//          .ahbif_ahb_hsize      (biu_ebmu_hsize         ), @382
//          .ahbif_ahb_htrans     (biu_ebmu_htrans        ), @383
//          .ahbif_ahb_hbusreq    (biu_ebmu_hbusreq       ), @384
//          .ahbif_ahb_hwdata     (biu_ebmu_hwdata        ), @385
//          .ahbif_ahb_hwrite     (biu_ebmu_hwrite        ), @386
//          .ahbif_wfd            (biu_ebmu_wfd        ), @387
//          .ahb_ahbif_hrdata     (ebmu_biu_hrdata        ), @388
//          .ahb_ahbif_hready     (ebmu_biu_hready        ), @389
//          .ahb_ahbif_hgrant     (ebmu_biu_hgrant        ), @390
//          .ahb_ahbif_hresp      (ebmu_biu_hresp         )); @391
// &Connect(.ahbif_ahb_haddr_pol  (biu_ebmu_haddr_pol     ), @393
//          .ahbif_ahb_hwdata_pol (biu_ebmu_hwdata_pol    ), @394
//          .ahb_ahbif_hrdata_pol (ebmu_biu_hrdata_pol    )); @395
// &Connect(.ahbif_ahb_hwdata_par (biu_ebmu_hwdata_par    ), @398
//          .ahb_ahbif_hrdata_par (ebmu_biu_hrdata_par    )); @399
// &Connect(.ahb_ahbif_inst_dbg_disable (ebmu_biu_inst_dbg_disable )); @402
// &Connect(.ahbif_ahb_source_pc   (biu_ebmu_source_pc    ), @405
//          .ahbif_ahb_load        (biu_ebmu_load         ), @406
//          .ahbif_ahb_store       (biu_ebmu_store        ), @407
//          .ahbif_ahb_inst_fetch_chk (biu_ebmu_inst_fetch_chk  )); @408
// &Connect(.ahbif_ahb_vec_redrct (biu_ebmu_vec_redrct)); @410
// &Connect(.uncmplt_mask (cache_uncmplt_mask)); @417
// &Force("nonport", "cpu_req_for_grnt"); @423
// &Instance("cr_ahbl_if_fo"); @426
// &Force("input", "pwrm_cpu_bus_peak_power_limit_en"); @427
// &Force("input", "iahblif_other_mask"); @428
// &Force("input", "dahblif_other_mask"); @429
// &Instance("cr_ahbl_if"); @437
cr_ahbl_if  x_cr_ahbl_if (
  .ahbLif_ahbl_haddr    (biu_pad_haddr       ),
  .ahbLif_ahbl_hburst   (biu_pad_hburst      ),
  .ahbLif_ahbl_hprot    (biu_pad_hprot       ),
  .ahbLif_ahbl_hsize    (biu_pad_hsize       ),
  .ahbLif_ahbl_htrans   (biu_pad_htrans      ),
  .ahbLif_ahbl_hwdata   (biu_pad_hwdata      ),
  .ahbLif_ahbl_hwrite   (biu_pad_hwrite      ),
  .ahbl_ahbLif_hrdata   (pad_biu_hrdata      ),
  .ahbl_ahbLif_hready   (pad_biu_hready      ),
  .ahbl_ahbLif_hresp    (pad_biu_hresp       ),
  .ahbl_clk_en          (ahbl_clk_en         ),
  .ahbl_gated_clk       (ahbl_gated_clk      ),
  .ahblif_busy          (ahblif_busy         ),
  .ahblif_idle          (ahblif_idle         ),
  .ahblif_power_mask    (ahblif_power_mask   ),
  .cpu_acc_err          (cpu_acc_err         ),
  .cpu_addr             (cpu_addr            ),
  .cpu_data_vld         (cpu_data_vld        ),
  .cpu_prot             (cpu_prot            ),
  .cpu_rdata            (cpu_rdata           ),
  .cpu_req              (cpu_req             ),
  .cpu_req_grnt         (cpu_req_grnt        ),
  .cpu_req_power_masked (cpu_req_power_masked),
  .cpu_sec              (cpu_sec             ),
  .cpu_size             (cpu_size            ),
  .cpu_trans_cmplt      (cpu_trans_cmplt     ),
  .cpu_vec_redirect     (cpu_vec_redirect    ),
  .cpu_wdata_sel        (cpu_wdata_sel       ),
  .cpu_wr_data          (cpu_wdata           ),
  .cpu_write            (cpu_write           ),
  .cpurst_b             (cpurst_b            ),
  .pad_cpu_halt_ff2     (pad_cpu_halt_ff2    )
);

// &Force("nonport", "cpu_req_for_peak_power"); @441
// &Force("nonport", "cpu_wdata_sel"); @443
// &Connect(.cpu_wr_data            (cpu_wdata             )); @444
// &Force("input", "pwrm_cpu_bus_peak_power_limit_en"); @447
// &Force("nonport", "cpu_req_for_peak_power"); @448
// &Force("nonport", "ahblif_busy"); @449
assign sahblif_iahblif_mask = (ahblif_busy || cpu_req_for_peak_power) && 
                               pwrm_cpu_bus_peak_power_limit_en;
assign ahblif_power_mask  = iahblif_other_mask || dahblif_other_mask;
assign cpu_req_power_masked = cpu_req && !ahblif_power_mask;
// &Connect(.ahbLif_ahbl_haddr      (biu_pad_haddr         ), @459
//          .ahbLif_ahbl_hburst     (biu_pad_hburst        ), @460
//          .ahbLif_ahbl_hprot      (biu_pad_hprot         ), @461
//          .ahbLif_ahbl_hsize      (biu_pad_hsize         ), @462
//          .ahbLif_ahbl_htrans     (biu_pad_htrans        ), @463
//          .ahbLif_ahbl_hwdata     (biu_pad_hwdata        ), @464
//          .ahbLif_ahbl_hwrite     (biu_pad_hwrite        ), @465
//          .ahbl_ahbLif_hrdata     (pad_biu_hrdata        ), @466
//          .ahbl_ahbLif_hready     (pad_biu_hready        ), @467
//          .ahbl_ahbLif_hresp      (pad_biu_hresp         )); @468
// &Connect(.ahbLif_ahbl_haddr_pol  (biu_pad_haddr_pol     ), @470
//          .ahbLif_ahbl_hwdata_pol (biu_pad_hwdata_pol    ), @471
//          .ahbl_ahbLif_hrdata_pol (pad_biu_hrdata_pol    )); @472
// &Connect(.ahbLif_ahbl_hwdata_par (biu_pad_hwdata_par    ), @475
//          .ahbl_ahbLif_hrdata_par (pad_biu_hrdata_par    )); @476
// &Connect(.ahbl_ahbLif_inst_dbg_disable (pad_biu_inst_dbg_disable )); @479
// &Connect(.ahbLif_ahbl_source_pc   (biu_pad_source_pc    ), @482
//          .ahbLif_ahbl_load        (biu_pad_load         ), @483
//          .ahbLif_ahbl_store       (biu_pad_store        ), @484
//          .ahbLif_ahbl_inst_fetch_chk (biu_pad_inst_fetch_chk  )); @485
// &Connect(.ahbLif_ahbl_vec_redrct (biu_pad_vec_redrct)); @487
// &Connect(.uncmplt_mask (cache_uncmplt_mask)); @495
// &Instance("cr_ahb_if_fo", "x_cr_ahbl_if_fo"); @503
// &Force("input", "pwrm_cpu_bus_peak_power_limit_en"); @504
// &Force("input", "iahblif_other_mask"); @505
// &Force("input", "dahblif_other_mask"); @506
// &Instance("cr_ahb_if", "x_cr_ahbl_if"); @514
// &Connect(.ahbif_busy           (ahblif_busy           )); @515
// &Force("nonport", "cpu_req_for_peak_power"); @519
// &Force("nonport", "cpu_wdata_sel"); @521
// &Connect(.cpu_wr_data            (cpu_wdata             )); @522
// &Force("input", "pwrm_cpu_bus_peak_power_limit_en"); @525
// &Force("nonport", "cpu_req_for_peak_power"); @526
// &Force("nonport", "ahblif_busy"); @527
// &Force("nonport", "ahbif_wfd"); @537
// &Connect(.ahb_gated_clk        (ahbl_gated_clk        )); @538
// &Connect(.ahb_clk_en           (ahbl_clk_en           )); @539
// &Connect(.ahbif_power_mask     (ahblif_power_mask     )); @540
// &Connect(.ahbif_ahb_haddr      (biu_pad_haddr         ), @541
//          .ahbif_ahb_hburst     (biu_pad_hburst        ), @542
//          .ahbif_ahb_hprot      (biu_pad_hprot         ), @543
//          .ahbif_ahb_hsize      (biu_pad_hsize         ), @544
//          .ahbif_ahb_htrans     (biu_pad_htrans        ), @545
//          .ahbif_ahb_hbusreq    (biu_pad_hbusreq       ), @546
//          .ahbif_ahb_hwdata     (biu_pad_hwdata        ), @547
//          .ahbif_ahb_hwrite     (biu_pad_hwrite        ), @548
//          .ahb_ahbif_hrdata     (pad_biu_hrdata        ), @549
//          .ahb_ahbif_hready     (pad_biu_hready        ), @550
//          .ahb_ahbif_hgrant     (pad_biu_hgrant        ), @551
//          .ahb_ahbif_hresp      (pad_biu_hresp         )); @552
// &Connect(.ahbif_ahb_haddr_pol  (biu_pad_haddr_pol     ), @554
//          .ahbif_ahb_hwdata_pol (biu_pad_hwdata_pol    ), @555
//          .ahb_ahbif_hrdata_pol (pad_biu_hrdata_pol    )); @556
// &Connect(.ahbif_ahb_hwdata_par (biu_pad_hwdata_par    ), @559
//          .ahb_ahbif_hrdata_par (pad_biu_hrdata_par    )); @560
// &Connect(.ahb_ahbif_inst_dbg_disable (pad_biu_inst_dbg_disable )); @563
// &Connect(.ahbif_ahb_source_pc   (biu_pad_source_pc    ), @566
//          .ahbif_ahb_load        (biu_pad_load         ), @567
//          .ahbif_ahb_store       (biu_pad_store        ), @568
//          .ahbif_ahb_inst_fetch_chk (biu_pad_inst_fetch_chk  )); @569
// &Connect(.ahbif_ahb_vec_redrct (biu_pad_vec_redrct)); @571
// &Connect(.uncmplt_mask (cache_uncmplt_mask)); @579

// &ModuleEnd; @587
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_sys_io(
  clk_en,
  cp0_sysio_ipend_b,
  cp0_sysio_lpmd_b,
  cp0_sysio_srst,
  cpu_pad_lockup,
  cpu_pad_soft_rst,
  cpurst_b,
  forever_cpuclk,
  had_yy_xx_dbg,
  iu_sys_lp_wk_int,
  iu_sysio_lockup_on,
  iu_yy_xx_dbgon,
  pad_cpu_ext_int_b,
  pad_cpu_nmi,
  pad_cpu_rst_addr,
  pad_cpu_sys_cnt,
  pad_cpu_wakeup_event,
  pad_sysio_dbgrq_b,
  pad_yy_gate_clk_en_b,
  sysio_clint_me_int,
  sysio_clint_mtime,
  sysio_cp0_bigend,
  sysio_cp0_clkratio,
  sysio_cp0_endian_v2,
  sysio_cp0_rst_addr,
  sysio_cp0_sys_view_lpmd_b,
  sysio_had_sdb_req_b,
  sysio_ifu_rst_addr,
  sysio_iu_nmi_int,
  sysio_iu_rst_addr,
  sysio_iu_wk_event,
  sysio_pad_lpmd_b
);

// &Ports; @24
input           clk_en;                   
input           cp0_sysio_ipend_b;        
input   [1 :0]  cp0_sysio_lpmd_b;         
input   [1 :0]  cp0_sysio_srst;           
input           cpurst_b;                 
input           forever_cpuclk;           
input           had_yy_xx_dbg;            
input           iu_sys_lp_wk_int;         
input           iu_sysio_lockup_on;       
input           iu_yy_xx_dbgon;           
input           pad_cpu_ext_int_b;        
input           pad_cpu_nmi;              
input   [31:0]  pad_cpu_rst_addr;         
input   [63:0]  pad_cpu_sys_cnt;          
input           pad_cpu_wakeup_event;     
input           pad_sysio_dbgrq_b;        
input           pad_yy_gate_clk_en_b;     
output          cpu_pad_lockup;           
output  [1 :0]  cpu_pad_soft_rst;         
output          sysio_clint_me_int;       
output  [63:0]  sysio_clint_mtime;        
output          sysio_cp0_bigend;         
output  [2 :0]  sysio_cp0_clkratio;       
output          sysio_cp0_endian_v2;      
output  [31:0]  sysio_cp0_rst_addr;       
output  [1 :0]  sysio_cp0_sys_view_lpmd_b; 
output          sysio_had_sdb_req_b;      
output  [31:0]  sysio_ifu_rst_addr;       
output          sysio_iu_nmi_int;         
output  [31:0]  sysio_iu_rst_addr;        
output          sysio_iu_wk_event;        
output  [1 :0]  sysio_pad_lpmd_b;         

// &Regs; @25
reg     [63:0]  ccvr;                     
reg             cpu_ext_int_b;            
reg             cpu_nmi;                  
reg             cpu_wk_event;             
reg             sdb_req_b_r;              
reg             sysio_pad_dbg_b;          
reg             sysio_pad_ipend_b;        
reg             sysio_pad_lockup;         
reg     [1 :0]  sysio_pad_lpmd_b;         
reg     [1 :0]  sysio_pad_soft_rst;       
reg             sysio_pad_wakeup_b;       

// &Wires; @26
wire            clk_en;                   
wire            cp0_sysio_ipend_b;        
wire    [1 :0]  cp0_sysio_lpmd_b;         
wire    [1 :0]  cp0_sysio_srst;           
wire            cpu_pad_lockup;           
wire    [1 :0]  cpu_pad_soft_rst;         
wire    [31:0]  cpu_rst_addr;             
wire            cpu_wake_up_b;            
wire            cpurst_b;                 
wire            forever_cpuclk;           
wire            had_yy_xx_dbg;            
wire            iu_sys_lp_wk_int;         
wire            iu_sysio_lockup_on;       
wire            iu_yy_xx_dbgon;           
wire            pad_cpu_ext_int_b;        
wire            pad_cpu_nmi;              
wire    [31:0]  pad_cpu_rst_addr;         
wire    [63:0]  pad_cpu_sys_cnt;          
wire            pad_cpu_wakeup_event;     
wire            pad_sysio_dbgrq_b;        
wire            pad_yy_gate_clk_en_b;     
wire            sample_clk;               
wire            sysio_clint_me_int;       
wire    [63:0]  sysio_clint_mtime;        
wire            sysio_cp0_bigend;         
wire    [2 :0]  sysio_cp0_clkratio;       
wire            sysio_cp0_endian_v2;      
wire    [31:0]  sysio_cp0_rst_addr;       
wire    [1 :0]  sysio_cp0_sys_view_lpmd_b; 
wire            sysio_had_sdb_req_b;      
wire    [31:0]  sysio_ifu_rst_addr;       
wire            sysio_iu_nmi_int;         
wire    [31:0]  sysio_iu_rst_addr;        
wire            sysio_iu_wk_event;        
wire            sysio_lpmd_gated_clk;     
wire            sysio_lpmd_gated_en;      


//If global_en is cp0_yy_clk_en, at the cycle the cpu is enterring debug mode,
//the clock of sysio_flops will be closed by cp0_yy_clk_en and these flops can
//not be updated .As a result ,the global_en should always be 1'b1.When the 
//sysio_flops are updated, the clock will be closed by local_en

// &Instance("gated_clk_cell", "x_gated_sysio_lpmd_cpuclk_cell"); @33
gated_clk_cell  x_gated_sysio_lpmd_cpuclk_cell (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (sysio_lpmd_gated_clk),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (sysio_lpmd_gated_en ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in     (forever_cpuclk               ), @34
//          .global_en  (1'b1                         ), @35
//          .module_en  (1'b0                         ), @36
//          .local_en   (sysio_lpmd_gated_en          ), @37
//          .external_en(1'b0                         ), @38
//          .clk_out    (sysio_lpmd_gated_clk         )); @39

assign sysio_lpmd_gated_en = ((sysio_pad_dbg_b     ^ (~iu_yy_xx_dbgon))   ||
                              (sysio_pad_lpmd_b[1] ^ cp0_sysio_lpmd_b[1]) ||
                              (sysio_pad_lpmd_b[0] ^ cp0_sysio_lpmd_b[0]) ||
                              (sysio_pad_ipend_b   ^ cp0_sysio_ipend_b)   ||
                              (sysio_pad_wakeup_b  ^ cpu_wake_up_b)       ||
                              (pad_cpu_ext_int_b  ^ cpu_ext_int_b )       ||
                              (pad_cpu_nmi ^ cpu_nmi)       ||
                              (pad_cpu_wakeup_event ^ cpu_wk_event)       ||
                              |(pad_cpu_rst_addr[31:0] ^ cpu_rst_addr[31:0])       ||
                              |(sysio_pad_soft_rst[1:0] ^ cp0_sysio_srst[1:0]) ||
                              (sysio_pad_lockup   ^ iu_sysio_lockup_on)     ||
                              (pad_sysio_dbgrq_b  ^ sdb_req_b_r))
                            && clk_en;

// &Instance("gated_clk_cell", "x_sample_clk_cell"); @55
gated_clk_cell  x_sample_clk_cell (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (sample_clk          ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (clk_en              ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in     (forever_cpuclk               ), @56
//          .global_en  (1'b1                         ), @57
//          .module_en  (1'b0                         ), @58
//          .local_en   (clk_en                       ), @59
//          .external_en(1'b0                         ), @60
//          .clk_out    (sample_clk                   )); @61

//=========================================
//             input port 
//=========================================
//synchronize signal
// assign  sysio_cp0_bigend         =!pad_sysio_bigend_b;
// assign  sysio_cp0_endian_v2      = pad_sysio_endian_v2;
// assign  sysio_cp0_clkratio[2:0]  = pad_sysio_clkratio[2:0];
assign  sysio_cp0_bigend         = 1'b0;
assign  sysio_cp0_endian_v2      = 1'b0;
assign  sysio_cp0_clkratio[2:0]  = 3'b0;

always @ (posedge sample_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
    ccvr[63:0] <= 64'b0;
  else if (clk_en)
    ccvr[63:0] <= pad_cpu_sys_cnt[63:0];
  else
    ccvr[63:0] <= ccvr[63:0];
end

assign sysio_clint_mtime[63:0] = ccvr[63:0];

assign cpu_rst_addr[31:0] = pad_cpu_rst_addr[31:0];

assign  sysio_cp0_rst_addr[31:0] = cpu_rst_addr[31:0];
assign  sysio_ifu_rst_addr[31:0] = cpu_rst_addr[31:0];
assign  sysio_iu_rst_addr[31:0]  = cpu_rst_addr[31:0];

always @ (posedge sysio_lpmd_gated_clk or negedge cpurst_b)
begin
  if (!cpurst_b) begin
    cpu_ext_int_b <= 1'b1;
    cpu_nmi       <= 1'b0;
    cpu_wk_event  <= 1'b0;
  end
  else if (clk_en) begin
    cpu_ext_int_b <= pad_cpu_ext_int_b;
    cpu_nmi       <= pad_cpu_nmi;
    cpu_wk_event  <= pad_cpu_wakeup_event;
  end
  else begin
    cpu_ext_int_b <= cpu_ext_int_b;
    cpu_nmi       <= cpu_nmi;
    cpu_wk_event  <= cpu_wk_event;
  end
end

assign sysio_clint_me_int = !cpu_ext_int_b;
assign sysio_iu_nmi_int   = cpu_nmi;
assign sysio_iu_wk_event  = cpu_wk_event;

always @ (posedge sysio_lpmd_gated_clk or negedge cpurst_b)
begin
  if (!cpurst_b)
    sdb_req_b_r <= 1'b1;
  else if (clk_en)
    sdb_req_b_r <= pad_sysio_dbgrq_b;
  else
    sdb_req_b_r <= sdb_req_b_r;
end

assign sysio_had_sdb_req_b = sdb_req_b_r;


//=========================================
//            output port
//=========================================
// //&Force("output","sysio_pad_ipend_b"); @143
// //&Force("output","sysio_pad_dbg_b"); @144
// &Force("output","sysio_pad_lpmd_b"); @145
// //&Force("output","sysio_pad_wakeup_b"); @146

assign cpu_wake_up_b = iu_sys_lp_wk_int && !had_yy_xx_dbg;

always @(posedge sysio_lpmd_gated_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
  begin
    sysio_pad_dbg_b       <= 1'b1;
    sysio_pad_lpmd_b[1:0] <= 2'b11;
    sysio_pad_ipend_b     <= 1'b0;
    sysio_pad_wakeup_b    <= 1'b0;
  end
  else if(clk_en) 
  begin
    sysio_pad_dbg_b       <= ~iu_yy_xx_dbgon;
    sysio_pad_lpmd_b[1:0] <= cp0_sysio_lpmd_b[1:0];
    sysio_pad_ipend_b     <= cp0_sysio_ipend_b;
    sysio_pad_wakeup_b    <= cpu_wake_up_b;
  end
end

always @(posedge sysio_lpmd_gated_clk or negedge cpurst_b)
begin
  if(!cpurst_b)
  begin
    sysio_pad_soft_rst[1:0] <= 2'b0;
    sysio_pad_lockup        <= 1'b0;
  end
  else if(clk_en) 
  begin
    sysio_pad_soft_rst[1:0] <= cp0_sysio_srst[1:0];
    sysio_pad_lockup        <= iu_sysio_lockup_on;
  end
end

assign sysio_cp0_sys_view_lpmd_b[1:0] = sysio_pad_lpmd_b[1:0];
// assign sysio_pad_srst = 1'b0;
assign cpu_pad_soft_rst[1:0] = sysio_pad_soft_rst[1:0];
assign cpu_pad_lockup        = sysio_pad_lockup;

// &ModuleEnd; @187
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_tcipif_behavior_bus(
  bmu_tcipif_dbus_acc_deny,
  bmu_tcipif_dbus_addr,
  bmu_tcipif_dbus_chk_fail,
  bmu_tcipif_dbus_req,
  bmu_tcipif_dbus_size,
  bmu_tcipif_dbus_supv_mode,
  bmu_tcipif_dbus_wdata,
  bmu_tcipif_dbus_write,
  clint_tcipif_cmplt,
  clint_tcipif_rdata,
  cp0_yy_be_v2,
  cpurst_b,
  forever_cpuclk,
  had_img_tcipif_cmplt,
  had_img_tcipif_rdata,
  iu_yy_xx_dbgon,
  pad_yy_gate_clk_en_b,
  tcip_cp0_clic_base,
  tcipif_bmu_dbus_acc_err,
  tcipif_bmu_dbus_data,
  tcipif_bmu_dbus_data_vld,
  tcipif_bmu_dbus_grnt,
  tcipif_bmu_dbus_trans_cmplt,
  tcipif_clint_sel,
  tcipif_had_img_sel,
  tcipif_vic_sel,
  tcipif_vic_size,
  tcipif_xx_dbus_addr,
  tcipif_xx_dbus_wdata,
  tcipif_xx_dbus_write,
  vic_tcipif_cmplt,
  vic_tcipif_rdata
);

// &Ports; @24
input           bmu_tcipif_dbus_acc_deny;   
input   [31:0]  bmu_tcipif_dbus_addr;       
input           bmu_tcipif_dbus_chk_fail;   
input           bmu_tcipif_dbus_req;        
input   [1 :0]  bmu_tcipif_dbus_size;       
input           bmu_tcipif_dbus_supv_mode;  
input   [31:0]  bmu_tcipif_dbus_wdata;      
input           bmu_tcipif_dbus_write;      
input           clint_tcipif_cmplt;         
input   [31:0]  clint_tcipif_rdata;         
input           cp0_yy_be_v2;               
input           cpurst_b;                   
input           forever_cpuclk;             
input           had_img_tcipif_cmplt;       
input   [31:0]  had_img_tcipif_rdata;       
input           iu_yy_xx_dbgon;             
input           pad_yy_gate_clk_en_b;       
input           vic_tcipif_cmplt;           
input   [31:0]  vic_tcipif_rdata;           
output  [31:0]  tcip_cp0_clic_base;         
output          tcipif_bmu_dbus_acc_err;    
output  [31:0]  tcipif_bmu_dbus_data;       
output          tcipif_bmu_dbus_data_vld;   
output          tcipif_bmu_dbus_grnt;       
output          tcipif_bmu_dbus_trans_cmplt; 
output          tcipif_clint_sel;           
output          tcipif_had_img_sel;         
output          tcipif_vic_sel;             
output  [1 :0]  tcipif_vic_size;            
output  [15:0]  tcipif_xx_dbus_addr;        
output  [31:0]  tcipif_xx_dbus_wdata;       
output          tcipif_xx_dbus_write;       

// &Regs; @25
reg             clint_sel_ff;               
reg             dummy_addr_cmplt;           
reg             had_img_sel_ff;             
reg             tcipif_acc_err;             
reg     [15:0]  tcipif_xx_dbus_addr;        
reg             vic_sel_ff;                 
reg     [1 :0]  vic_size_ff;                
reg             xx_dbus_write;              
reg             xx_tcip_grant;              

// &Wires; @26
wire            bmu_tcipif_dbus_acc_deny;   
wire    [31:0]  bmu_tcipif_dbus_addr;       
wire            bmu_tcipif_dbus_chk_fail;   
wire            bmu_tcipif_dbus_req;        
wire    [1 :0]  bmu_tcipif_dbus_size;       
wire            bmu_tcipif_dbus_supv_mode;  
wire    [31:0]  bmu_tcipif_dbus_wdata;      
wire            bmu_tcipif_dbus_write;      
wire    [31:0]  bmu_tcipif_had_addr;        
wire            bmu_tcipif_had_req;         
wire    [1 :0]  bmu_tcipif_had_size;        
wire            bmu_tcipif_had_supv_mode;   
wire    [31:0]  bmu_tcipif_had_wdata;       
wire            bmu_tcipif_had_write;       
wire            clint_req_mask;             
wire            clint_sel;                  
wire            clint_tcipif_cmplt;         
wire    [31:0]  clint_tcipif_rdata;         
wire            cmmu_req_mask;              
wire            cmmu_sel;                   
wire            cmmu_tcipif_cmplt;          
wire    [31:0]  cmmu_tcipif_rdata;          
wire            coretim_req_mask;           
wire            coretim_tcipif_cmplt;       
wire    [31:0]  coretim_tcipif_rdata;       
wire            cp0_yy_be_v2;               
wire            cpurst_b;                   
wire            cru_req_mask;               
wire            cru_sel;                    
wire            cru_tcipif_cmplt;           
wire    [31:0]  cru_tcipif_rdata;           
wire            ctim_sel;                   
wire            ctrl_cpuclk;                
wire            dbus_err;                   
wire            dbus_req;                   
wire            dbus_req_pre;               
wire            dbus_sel;                   
wire            dummy_addr_sel;             
wire            forever_cpuclk;             
wire            had_err;                    
wire            had_img_req_mask;           
wire            had_img_sel;                
wire            had_img_tcipif_cmplt;       
wire    [31:0]  had_img_tcipif_rdata;       
wire            had_req;                    
wire            had_req_pre;                
wire            had_sel;                    
wire            iu_yy_xx_dbgon;             
wire            pad_yy_gate_clk_en_b;       
wire            pwrm_req_mask;              
wire            pwrm_sel;                   
wire            pwrm_tcipif_cmplt;          
wire    [31:0]  pwrm_tcipif_rdata;          
wire            scram_req_mask;             
wire            scram_sel;                  
wire            scram_tcipif_cmplt;         
wire    [31:0]  scram_tcipif_rdata;         
wire            sel_clk_en;                 
wire            sel_cpuclk;                 
wire            seu_bist_req_mask;          
wire            seu_bist_sel;               
wire            seu_bist_tcipif_cmplt;      
wire    [31:0]  seu_bist_tcipif_rdata;      
wire            seu_req_mask;               
wire            seu_sel;                    
wire            seu_tcipif_cmplt;           
wire    [31:0]  seu_tcipif_rdata;           
wire    [31:0]  tcip_cp0_clic_base;         
wire            tcip_err;                   
wire            tcip_req;                   
wire    [31:0]  tcip_req_addr;              
wire            tcip_req_mask;              
wire            tcip_req_pre;               
wire            tcipif_bmu_dbus_acc_err;    
wire    [31:0]  tcipif_bmu_dbus_data;       
wire            tcipif_bmu_dbus_data_vld;   
wire            tcipif_bmu_dbus_grnt;       
wire            tcipif_bmu_dbus_trans_cmplt; 
wire            tcipif_clint_sel;           
wire            tcipif_data_vld;            
wire            tcipif_dbus_req;            
wire    [31:0]  tcipif_dbus_wdata;          
wire            tcipif_had_img_sel;         
wire            tcipif_had_req;             
wire    [31:0]  tcipif_rd_data;             
wire    [31:0]  tcipif_rdata;               
wire            tcipif_req_write;           
wire            tcipif_trans_cmplt;         
wire            tcipif_vic_sel;             
wire    [1 :0]  tcipif_vic_size;            
wire    [31:0]  tcipif_wdata;               
wire    [31:0]  tcipif_xx_dbus_wdata;       
wire            tcipif_xx_dbus_write;       
wire            vic_req_mask;               
wire            vic_sel;                    
wire    [1 :0]  vic_size;                   
wire            vic_tcipif_cmplt;           
wire    [31:0]  vic_tcipif_rdata;           
wire            xx_tcipif_cmplt;            


//==========================================================
//                Define address mapping
//==========================================================
//------------------------------------------------
// CLINT    0xE000 0000 - 0xE000 FFFF
//------------------------------------------------
parameter CLINT_IN    = 16'hE000;
//------------------------------------------------
// CLIC     0xE080 0000 - 0xE080 4FFF
//------------------------------------------------
parameter CLIC_IN     = 16'hE080;
//------------------------------------------------
// HAD IMAGE 0xE401 0000 - E401 0FFF
//------------------------------------------------
parameter HAD_IMG_IN  = 20'hE4010;

//fix port for no DDMA
assign bmu_tcipif_had_req         = 1'b0;
assign bmu_tcipif_had_addr[31:0]  = 32'b0;
assign bmu_tcipif_had_write       = 1'b0;
assign bmu_tcipif_had_wdata[31:0] = 32'b0;
assign bmu_tcipif_had_supv_mode   = 1'b0;
assign bmu_tcipif_had_size[1:0]   = 2'b0;


//==========================================================
//  Req Arb
//==========================================================
//for grnt
assign tcipif_dbus_req = bmu_tcipif_dbus_req && !tcip_req_mask
                         && !bmu_tcipif_had_req;
assign tcipif_had_req  = bmu_tcipif_had_req  && !tcip_req_mask;

//for data path sel
assign dbus_sel        = tcipif_dbus_req;
assign had_sel         = tcipif_had_req;

//for record err
assign dbus_req_pre    = tcipif_dbus_req
                     && !bmu_tcipif_dbus_acc_deny
                     && !bmu_tcipif_dbus_chk_fail;
assign had_req_pre     = tcipif_had_req;
assign tcip_req_pre    = dbus_req_pre || had_req_pre;

//for real req
assign dbus_req = dbus_req_pre && !dbus_err;
assign had_req  = had_req_pre  && !had_err;
assign tcip_req = dbus_req || had_req;

//data path
assign dbus_err = !bmu_tcipif_dbus_supv_mode && !iu_yy_xx_dbgon;
assign had_err  = !bmu_tcipif_had_supv_mode;
assign tcip_err = dbus_sel && dbus_err
               || had_sel  && had_err;

assign tcip_req_addr[31:0] = {32{dbus_sel}} & bmu_tcipif_dbus_addr[31:0]
                           | {32{had_sel}}  & bmu_tcipif_had_addr[31:0];

assign tcipif_req_write    = dbus_sel && bmu_tcipif_dbus_write
                          || had_sel  && bmu_tcipif_had_write;

//==========================================================
//  Addr Arb for IPs 
//==========================================================
assign ctim_sel  = 1'b0;

assign vic_sel   =  (tcip_req_addr[31:16] == CLIC_IN);
// assign vic_sel   =  (tcip_req_addr[31:12] == VIC_IN) 
//                 && !(tcip_req_addr[31:8]  == VIC_EX1) 
//                 && !(tcip_req_addr[31:8]  == VIC_EX2) 
//                 && !(tcip_req_addr[31:8]  == VIC_EX3) 
//                 && !(tcip_req_addr[31:8]  == VIC_EX4);

assign pwrm_sel  = 1'b0;

assign seu_sel   = 1'b0;

assign scram_sel = 1'b0;

assign cru_sel   = 1'b0;

assign cmmu_sel  = 1'b0;


assign seu_bist_sel   = 1'b0;

assign had_img_sel    = (tcip_req_addr[31:12] == HAD_IMG_IN);

assign clint_sel   = tcip_req_addr[31:16] == CLINT_IN;

assign dummy_addr_sel = !(ctim_sel     || vic_sel     || pwrm_sel 
                       || seu_sel      || scram_sel   || cru_sel
                       || seu_bist_sel || had_img_sel || cmmu_sel
                       || clint_sel);

assign sel_clk_en = xx_tcipif_cmplt || tcipif_acc_err || dummy_addr_cmplt;
// &Instance("gated_clk_cell", "x_tcipif_dbus_sel_clk"); @142
gated_clk_cell  x_tcipif_dbus_sel_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (sel_cpuclk          ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (tcip_req_pre        ),
  .module_en            (sel_clk_en          ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk     ), @143
//          .external_en (1'b0               ), @144
//          .global_en   (1'b1               ), @145
//          .module_en   (sel_clk_en         ), @146
//          .local_en    (tcip_req_pre       ), @147
//          .clk_out     (sel_cpuclk         ) @148
//         ); @149

always @(posedge sel_cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    tcipif_acc_err <= 1'b0;
  else if(tcip_req_pre)
    tcipif_acc_err <= tcip_err;
  else if(tcipif_acc_err)
    tcipif_acc_err <= 1'b0;
end

assign coretim_req_mask           = 1'b0;
assign coretim_tcipif_cmplt       = 1'b0;
assign coretim_tcipif_rdata[31:0] = 32'b0;

always @(posedge sel_cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    vic_sel_ff <= 1'b0;
  else if(tcip_req)
    vic_sel_ff <= vic_sel;
  else if(vic_tcipif_cmplt)
    vic_sel_ff <= 1'b0;
end
always @(posedge sel_cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    vic_size_ff[1:0] <= 2'b0;
  else if(tcip_req)
    vic_size_ff[1:0] <= vic_size[1:0];
end
assign tcipif_vic_sel = vic_sel_ff;
assign vic_req_mask   = vic_sel_ff && !vic_tcipif_cmplt;
assign vic_size[1:0]  = {2{dbus_sel}} & bmu_tcipif_dbus_size[1:0]
                       |{2{had_sel}} & bmu_tcipif_had_size[1:0];
assign tcipif_vic_size[1:0] = vic_size_ff[1:0];
// &Force("input", "bmu_tcipif_dbus_size"); @205
// &Force("bus", "bmu_tcipif_dbus_size", 1, 0); @206
// &Force("input", "bmu_tcipif_had_size"); @208
// &Force("bus", "bmu_tcipif_had_size", 1, 0); @209

assign pwrm_req_mask           = 1'b0;
assign pwrm_tcipif_cmplt       = 1'b0;
assign pwrm_tcipif_rdata[31:0] = 32'b0;

assign seu_req_mask           = 1'b0;
assign seu_tcipif_cmplt       = 1'b0;
assign seu_tcipif_rdata[31:0] = 32'b0;

assign scram_req_mask           = 1'b0;
assign scram_tcipif_cmplt       = 1'b0;
assign scram_tcipif_rdata[31:0] = 32'b0;

//always @(posedge sel_cpuclk or negedge cpurst_b)
//begin
//  if(!cpurst_b)
//    cru_sel_ff <= 1'b0;
//  else if(tcip_req)
//    cru_sel_ff <= cru_sel;
//  else if(cru_tcipif_cmplt)
//    cru_sel_ff <= 1'b0;
//end
//assign tcipif_cru_sel = cru_sel_ff;
//assign cru_req_mask   = cru_sel_ff && !cru_tcipif_cmplt;
assign cru_req_mask           = 1'b0;
assign cru_tcipif_cmplt       = 1'b0;
assign cru_tcipif_rdata[31:0] = 32'b0;

assign cmmu_req_mask           = 1'b0;
assign cmmu_tcipif_cmplt       = 1'b0;
assign cmmu_tcipif_rdata[31:0] = 32'b0;

assign seu_bist_req_mask           = 1'b0;
assign seu_bist_tcipif_cmplt       = 1'b0;
assign seu_bist_tcipif_rdata[31:0] = 32'b0;

always @(posedge sel_cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    had_img_sel_ff   <= 1'b0;
  else if(tcip_req)
    had_img_sel_ff   <= had_img_sel;
  else if(had_img_tcipif_cmplt)
    had_img_sel_ff   <= 1'b0;
end
assign tcipif_had_img_sel = had_img_sel_ff;
assign had_img_req_mask   = had_img_sel_ff && !had_img_tcipif_cmplt;

always @(posedge sel_cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    clint_sel_ff     <= 1'b0;
  else if(tcip_req)
    clint_sel_ff     <= clint_sel;
  else if(clint_tcipif_cmplt)
    clint_sel_ff     <= 1'b0;
end
assign tcipif_clint_sel = clint_sel_ff;
assign clint_req_mask   = clint_sel_ff && !clint_tcipif_cmplt;


always @(posedge sel_cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    dummy_addr_cmplt <= 1'b0;
  else if(tcip_req)
    dummy_addr_cmplt <= dummy_addr_sel;
  else if(dummy_addr_cmplt)
    dummy_addr_cmplt <= 1'b0;
end

assign tcip_req_mask  = (coretim_req_mask  || vic_req_mask   || pwrm_req_mask 
                      || seu_req_mask      || scram_req_mask || cru_req_mask   
                      || seu_bist_req_mask || had_img_req_mask || cmmu_req_mask
                      || clint_req_mask);



//==========================================================
//  Addr, Wdata to IPs
//==========================================================
// &Instance("gated_clk_cell", "x_tcipif_dbus_ctrl_clk"); @372
gated_clk_cell  x_tcipif_dbus_ctrl_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (ctrl_cpuclk         ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (tcip_req_pre        ),
  .module_en            (1'b0                ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk     ), @373
//          .external_en (1'b0               ), @374
//          .global_en   (1'b1               ), @375
//          .module_en   (1'b0               ), @376
//          .local_en    (tcip_req_pre       ), @377
//          .clk_out     (ctrl_cpuclk        ) @378
//         ); @379

//grnt info record for wdata and cmplt
always @(posedge ctrl_cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    xx_tcip_grant              <= 1'b0;
  else if(tcip_req_pre)
    xx_tcip_grant              <= had_req_pre;
end

//addr and write en
always @(posedge ctrl_cpuclk)
begin
  if(tcip_req)
  begin
    tcipif_xx_dbus_addr[15:0]  <= tcip_req_addr[15:0];
    xx_dbus_write              <= tcipif_req_write;
  end
end
assign tcipif_xx_dbus_write = xx_dbus_write;


//wdata
assign tcipif_wdata[31:0] = xx_tcip_grant ? bmu_tcipif_had_wdata[31:0]
                                          : bmu_tcipif_dbus_wdata[31:0];


assign tcipif_dbus_wdata[31:0]    = tcipif_wdata[31:0];

assign tcipif_xx_dbus_wdata[31:0] = cp0_yy_be_v2 ? 
      {tcipif_dbus_wdata[7:0],  tcipif_dbus_wdata[15:8],
       tcipif_dbus_wdata[23:16],tcipif_dbus_wdata[31:24]} :
       tcipif_dbus_wdata[31:0];

//             &Force("nonport", "tcipif_xx_dbus_wdata"); @446
//             &Force("nonport", "tcipif_xx_dbus_write"); @447
//             &Force("nonport", "tcipif_xx_dbus_addr"); @448

//==========================================================
//  Grant and Cmplt from IPs to BMU
//==========================================================
//grant to BMU
assign tcipif_bmu_dbus_grnt = tcipif_dbus_req ;

//cmplt to BMU
assign xx_tcipif_cmplt = coretim_tcipif_cmplt 
                      || vic_tcipif_cmplt     
                      || pwrm_tcipif_cmplt    
                      || seu_tcipif_cmplt     
                      || scram_tcipif_cmplt   
                      || cru_tcipif_cmplt     
                      || seu_bist_tcipif_cmplt
                      || had_img_tcipif_cmplt
                      || cmmu_tcipif_cmplt
                      || clint_tcipif_cmplt;
assign tcipif_trans_cmplt =  xx_tcipif_cmplt 
                          || dummy_addr_cmplt
                          || tcipif_acc_err;
assign tcipif_bmu_dbus_trans_cmplt = !xx_tcip_grant && tcipif_trans_cmplt;

//data vld
assign tcipif_data_vld    = (xx_tcipif_cmplt || dummy_addr_cmplt)
                         && !xx_dbus_write;
assign tcipif_bmu_dbus_data_vld    = !xx_tcip_grant && tcipif_data_vld;

//acc err
assign tcipif_bmu_dbus_acc_err = !xx_tcip_grant && tcipif_acc_err;

//rdata 
assign tcipif_rd_data[31:0]   = {32{coretim_tcipif_cmplt}}  & coretim_tcipif_rdata[31:0] 
                              | {32{vic_tcipif_cmplt}}      & vic_tcipif_rdata[31:0]     
                              | {32{pwrm_tcipif_cmplt}}     & pwrm_tcipif_rdata[31:0]    
                              | {32{seu_tcipif_cmplt}}      & seu_tcipif_rdata[31:0]     
                              | {32{scram_tcipif_cmplt}}    & scram_tcipif_rdata[31:0]   
                              | {32{cru_tcipif_cmplt}}      & cru_tcipif_rdata[31:0]     
                              | {32{seu_bist_tcipif_cmplt}} & seu_bist_tcipif_rdata[31:0]
                              | {32{had_img_tcipif_cmplt}}  & had_img_tcipif_rdata[31:0]
                              | {32{cmmu_tcipif_cmplt}}     & cmmu_tcipif_rdata[31:0]
                              | {32{clint_tcipif_cmplt}}    & clint_tcipif_rdata[31:0];
assign tcipif_rdata[31:0] = cp0_yy_be_v2 ? 
      {tcipif_rd_data[7:0],  tcipif_rd_data[15:8],
       tcipif_rd_data[23:16],tcipif_rd_data[31:24]} :
       tcipif_rd_data[31:0];
assign tcipif_bmu_dbus_data[31:0] = tcipif_rdata[31:0];


assign tcip_cp0_clic_base[31:0] = {CLIC_IN, 16'b0};

//For SEU CR CHK

// &ModuleEnd; @538
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_tcipif_dummy_bus(
  bmu_tcipif_ibus_acc_deny,
  bmu_tcipif_ibus_addr,
  bmu_tcipif_ibus_req,
  bmu_tcipif_ibus_write,
  cpurst_b,
  forever_cpuclk,
  pad_yy_gate_clk_en_b,
  tcipif_bmu_ibus_acc_err,
  tcipif_bmu_ibus_data,
  tcipif_bmu_ibus_data_vld,
  tcipif_bmu_ibus_grnt,
  tcipif_bmu_ibus_trans_cmplt
);

// &Ports; @23
input           bmu_tcipif_ibus_acc_deny;   
input   [31:0]  bmu_tcipif_ibus_addr;       
input           bmu_tcipif_ibus_req;        
input           bmu_tcipif_ibus_write;      
input           cpurst_b;                   
input           forever_cpuclk;             
input           pad_yy_gate_clk_en_b;       
output          tcipif_bmu_ibus_acc_err;    
output  [31:0]  tcipif_bmu_ibus_data;       
output          tcipif_bmu_ibus_data_vld;   
output          tcipif_bmu_ibus_grnt;       
output          tcipif_bmu_ibus_trans_cmplt; 

// &Regs; @24
reg             bus_next_state;             
reg             bus_state;                  

// &Wires; @25
wire            bmu_tcipif_ibus_acc_deny;   
wire            bmu_tcipif_ibus_req;        
wire            cpurst_b;                   
wire            forever_cpuclk;             
wire            ibus_acc_err;               
wire            ibus_busy;                  
wire            ibus_req;                   
wire            pad_yy_gate_clk_en_b;       
wire            sel_cpuclk;                 
wire            tcipif_bmu_ibus_acc_err;    
wire    [31:0]  tcipif_bmu_ibus_data;       
wire            tcipif_bmu_ibus_data_vld;   
wire            tcipif_bmu_ibus_grnt;       
wire            tcipif_bmu_ibus_trans_cmplt; 


//==========================================================
//  ACK to IBUS
//==========================================================
// &Force("input","bmu_tcipif_ibus_addr"); @30
// &Force("input","bmu_tcipif_ibus_write"); @31

// &Force("bus","bmu_tcipif_ibus_addr",31,0); @33

assign tcipif_bmu_ibus_grnt = bmu_tcipif_ibus_req;
assign ibus_req = bmu_tcipif_ibus_req && !bmu_tcipif_ibus_acc_deny;

parameter IDLE  = 1'b0,
          ERROR = 1'b1;

// &Instance("gated_clk_cell", "x_tcipif_ibus_sel_clk"); @41
gated_clk_cell  x_tcipif_ibus_sel_clk (
  .clk_in               (forever_cpuclk      ),
  .clk_out              (sel_cpuclk          ),
  .external_en          (1'b0                ),
  .global_en            (1'b1                ),
  .local_en             (bmu_tcipif_ibus_req ),
  .module_en            (ibus_busy           ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b)
);

// &Connect(.clk_in      (forever_cpuclk     ), @42
//          .external_en (1'b0               ), @43
//          .global_en   (1'b1               ), @44
//          .module_en   (ibus_busy          ), @45
//          .local_en    (bmu_tcipif_ibus_req), @46
//          .clk_out     (sel_cpuclk         ) @47
//         ); @48
assign ibus_busy  = (bus_state != IDLE);

always@(posedge sel_cpuclk or negedge cpurst_b)
begin
  if(!cpurst_b)
    bus_state <= IDLE;
  else
    bus_state <= bus_next_state;
end

// &CombBeg; @59
always @( bus_state
       or ibus_req)
begin
case(bus_state)
  IDLE:
    if(ibus_req)
      bus_next_state = ERROR;
    else
      bus_next_state = IDLE;
  ERROR:
    if(ibus_req)
      bus_next_state = ERROR;
    else
      bus_next_state = IDLE;
  default:
    bus_next_state = IDLE;
endcase
// &CombEnd; @74
end

assign ibus_acc_err = (bus_state == ERROR);

assign tcipif_bmu_ibus_trans_cmplt = ibus_acc_err;
assign tcipif_bmu_ibus_acc_err     = ibus_acc_err;
assign tcipif_bmu_ibus_data_vld    = 1'b0;
assign tcipif_bmu_ibus_data[31:0]  = 32'b0;
// &ModuleEnd; @85
endmodule



/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
module cr_tcipif_top(
  bmu_tcipif_dbus_acc_deny,
  bmu_tcipif_dbus_addr,
  bmu_tcipif_dbus_chk_fail,
  bmu_tcipif_dbus_req,
  bmu_tcipif_dbus_size,
  bmu_tcipif_dbus_supv_mode,
  bmu_tcipif_dbus_wdata,
  bmu_tcipif_dbus_write,
  bmu_tcipif_ibus_acc_deny,
  bmu_tcipif_ibus_addr,
  bmu_tcipif_ibus_req,
  bmu_tcipif_ibus_write,
  clic_cpu_int_hv,
  clic_cpu_int_id,
  clic_cpu_int_il,
  clic_cpu_int_priv,
  clint_cpu_me_int,
  cp0_yy_be_v2,
  cp0_yy_priv_mode,
  cpu_clic_curid,
  cpu_clic_int_exit,
  cpurst_b,
  forever_cpuclk,
  had_tcipif_cmplt,
  had_tcipif_rdata,
  iu_yy_xx_dbgon,
  pad_clic_int_vld,
  pad_yy_gate_clk_en_b,
  pwrm_cpu_bus_peak_power_limit_en,
  sysio_clint_me_int,
  sysio_clint_mtime,
  tcip_cp0_clic_base,
  tcipif_bmu_dbus_acc_err,
  tcipif_bmu_dbus_data,
  tcipif_bmu_dbus_data_vld,
  tcipif_bmu_dbus_grnt,
  tcipif_bmu_dbus_trans_cmplt,
  tcipif_bmu_ibus_acc_err,
  tcipif_bmu_ibus_data,
  tcipif_bmu_ibus_data_vld,
  tcipif_bmu_ibus_grnt,
  tcipif_bmu_ibus_trans_cmplt,
  tcipif_had_addr,
  tcipif_had_sel,
  tcipif_had_wdata,
  tcipif_had_write
);

// &Ports; @23
input           bmu_tcipif_dbus_acc_deny;        
input   [31:0]  bmu_tcipif_dbus_addr;            
input           bmu_tcipif_dbus_chk_fail;        
input           bmu_tcipif_dbus_req;             
input   [1 :0]  bmu_tcipif_dbus_size;            
input           bmu_tcipif_dbus_supv_mode;       
input   [31:0]  bmu_tcipif_dbus_wdata;           
input           bmu_tcipif_dbus_write;           
input           bmu_tcipif_ibus_acc_deny;        
input   [31:0]  bmu_tcipif_ibus_addr;            
input           bmu_tcipif_ibus_req;             
input           bmu_tcipif_ibus_write;           
input           cp0_yy_be_v2;                    
input   [1 :0]  cp0_yy_priv_mode;                
input   [11:0]  cpu_clic_curid;                  
input           cpu_clic_int_exit;               
input           cpurst_b;                        
input           forever_cpuclk;                  
input           had_tcipif_cmplt;                
input   [31:0]  had_tcipif_rdata;                
input           iu_yy_xx_dbgon;                  
input   [63:0]  pad_clic_int_vld;                
input           pad_yy_gate_clk_en_b;            
input           sysio_clint_me_int;              
input   [63:0]  sysio_clint_mtime;               
output          clic_cpu_int_hv;                 
output  [11:0]  clic_cpu_int_id;                 
output  [7 :0]  clic_cpu_int_il;                 
output  [1 :0]  clic_cpu_int_priv;               
output          clint_cpu_me_int;                
output          pwrm_cpu_bus_peak_power_limit_en; 
output  [31:0]  tcip_cp0_clic_base;              
output          tcipif_bmu_dbus_acc_err;         
output  [31:0]  tcipif_bmu_dbus_data;            
output          tcipif_bmu_dbus_data_vld;        
output          tcipif_bmu_dbus_grnt;            
output          tcipif_bmu_dbus_trans_cmplt;     
output          tcipif_bmu_ibus_acc_err;         
output  [31:0]  tcipif_bmu_ibus_data;            
output          tcipif_bmu_ibus_data_vld;        
output          tcipif_bmu_ibus_grnt;            
output          tcipif_bmu_ibus_trans_cmplt;     
output  [15:0]  tcipif_had_addr;                 
output          tcipif_had_sel;                  
output  [31:0]  tcipif_had_wdata;                
output          tcipif_had_write;                

// &Regs; @24

// &Wires; @25
wire            bmu_tcipif_dbus_acc_deny;        
wire    [31:0]  bmu_tcipif_dbus_addr;            
wire            bmu_tcipif_dbus_chk_fail;        
wire            bmu_tcipif_dbus_req;             
wire    [1 :0]  bmu_tcipif_dbus_size;            
wire            bmu_tcipif_dbus_supv_mode;       
wire    [31:0]  bmu_tcipif_dbus_wdata;           
wire            bmu_tcipif_dbus_write;           
wire            bmu_tcipif_ibus_acc_deny;        
wire    [31:0]  bmu_tcipif_ibus_addr;            
wire            bmu_tcipif_ibus_req;             
wire            bmu_tcipif_ibus_write;           
wire            clic_cpu_int_hv;                 
wire    [11:0]  clic_cpu_int_id;                 
wire    [7 :0]  clic_cpu_int_il;                 
wire    [1 :0]  clic_cpu_int_priv;               
wire            clint_cpu_me_int;                
wire            clint_cpu_ms_int;                
wire            clint_cpu_mt_int;                
wire            clint_tcipif_cmplt;              
wire    [31:0]  clint_tcipif_rdata;              
wire            cp0_yy_be_v2;                    
wire    [1 :0]  cp0_yy_priv_mode;                
wire    [11:0]  cpu_clic_curid;                  
wire            cpu_clic_int_exit;               
wire            cpurst_b;                        
wire            forever_cpuclk;                  
wire            had_img_tcipif_cmplt;            
wire    [31:0]  had_img_tcipif_rdata;            
wire            had_tcipif_cmplt;                
wire    [31:0]  had_tcipif_rdata;                
wire            iu_yy_xx_dbgon;                  
wire    [63:0]  pad_clic_int_vld;                
wire            pad_yy_gate_clk_en_b;            
wire            pwrm_cpu_bus_peak_power_limit_en; 
wire            sysio_clint_me_int;              
wire    [63:0]  sysio_clint_mtime;               
wire    [31:0]  tcip_cp0_clic_base;              
wire            tcipif_bmu_dbus_acc_err;         
wire    [31:0]  tcipif_bmu_dbus_data;            
wire            tcipif_bmu_dbus_data_vld;        
wire            tcipif_bmu_dbus_grnt;            
wire            tcipif_bmu_dbus_trans_cmplt;     
wire            tcipif_bmu_ibus_acc_err;         
wire    [31:0]  tcipif_bmu_ibus_data;            
wire            tcipif_bmu_ibus_data_vld;        
wire            tcipif_bmu_ibus_grnt;            
wire            tcipif_bmu_ibus_trans_cmplt;     
wire            tcipif_clint_sel;                
wire    [15:0]  tcipif_had_addr;                 
wire            tcipif_had_img_sel;              
wire            tcipif_had_sel;                  
wire    [31:0]  tcipif_had_wdata;                
wire            tcipif_had_write;                
wire            tcipif_vic_sel;                  
wire    [1 :0]  tcipif_vic_size;                 
wire    [15:0]  tcipif_xx_dbus_addr;             
wire    [31:0]  tcipif_xx_dbus_wdata;            
wire            tcipif_xx_dbus_write;            
wire            vic_tcipif_cmplt;                
wire    [31:0]  vic_tcipif_rdata;                


//---------------------------------------------------------
// TCIPIF Connecting with BMU
//---------------------------------------------------------
// &Instance("cr_tcipif_behavior_bus","x_cr_tcipif_dbus"); @30
cr_tcipif_behavior_bus  x_cr_tcipif_dbus (
  .bmu_tcipif_dbus_acc_deny    (bmu_tcipif_dbus_acc_deny   ),
  .bmu_tcipif_dbus_addr        (bmu_tcipif_dbus_addr       ),
  .bmu_tcipif_dbus_chk_fail    (bmu_tcipif_dbus_chk_fail   ),
  .bmu_tcipif_dbus_req         (bmu_tcipif_dbus_req        ),
  .bmu_tcipif_dbus_size        (bmu_tcipif_dbus_size       ),
  .bmu_tcipif_dbus_supv_mode   (bmu_tcipif_dbus_supv_mode  ),
  .bmu_tcipif_dbus_wdata       (bmu_tcipif_dbus_wdata      ),
  .bmu_tcipif_dbus_write       (bmu_tcipif_dbus_write      ),
  .clint_tcipif_cmplt          (clint_tcipif_cmplt         ),
  .clint_tcipif_rdata          (clint_tcipif_rdata         ),
  .cp0_yy_be_v2                (cp0_yy_be_v2               ),
  .cpurst_b                    (cpurst_b                   ),
  .forever_cpuclk              (forever_cpuclk             ),
  .had_img_tcipif_cmplt        (had_img_tcipif_cmplt       ),
  .had_img_tcipif_rdata        (had_img_tcipif_rdata       ),
  .iu_yy_xx_dbgon              (iu_yy_xx_dbgon             ),
  .pad_yy_gate_clk_en_b        (pad_yy_gate_clk_en_b       ),
  .tcip_cp0_clic_base          (tcip_cp0_clic_base         ),
  .tcipif_bmu_dbus_acc_err     (tcipif_bmu_dbus_acc_err    ),
  .tcipif_bmu_dbus_data        (tcipif_bmu_dbus_data       ),
  .tcipif_bmu_dbus_data_vld    (tcipif_bmu_dbus_data_vld   ),
  .tcipif_bmu_dbus_grnt        (tcipif_bmu_dbus_grnt       ),
  .tcipif_bmu_dbus_trans_cmplt (tcipif_bmu_dbus_trans_cmplt),
  .tcipif_clint_sel            (tcipif_clint_sel           ),
  .tcipif_had_img_sel          (tcipif_had_img_sel         ),
  .tcipif_vic_sel              (tcipif_vic_sel             ),
  .tcipif_vic_size             (tcipif_vic_size            ),
  .tcipif_xx_dbus_addr         (tcipif_xx_dbus_addr        ),
  .tcipif_xx_dbus_wdata        (tcipif_xx_dbus_wdata       ),
  .tcipif_xx_dbus_write        (tcipif_xx_dbus_write       ),
  .vic_tcipif_cmplt            (vic_tcipif_cmplt           ),
  .vic_tcipif_rdata            (vic_tcipif_rdata           )
);

// &Instance("cr_tcipif_dummy_bus","x_cr_tcipif_ibus"); @31
cr_tcipif_dummy_bus  x_cr_tcipif_ibus (
  .bmu_tcipif_ibus_acc_deny    (bmu_tcipif_ibus_acc_deny   ),
  .bmu_tcipif_ibus_addr        (bmu_tcipif_ibus_addr       ),
  .bmu_tcipif_ibus_req         (bmu_tcipif_ibus_req        ),
  .bmu_tcipif_ibus_write       (bmu_tcipif_ibus_write      ),
  .cpurst_b                    (cpurst_b                   ),
  .forever_cpuclk              (forever_cpuclk             ),
  .pad_yy_gate_clk_en_b        (pad_yy_gate_clk_en_b       ),
  .tcipif_bmu_ibus_acc_err     (tcipif_bmu_ibus_acc_err    ),
  .tcipif_bmu_ibus_data        (tcipif_bmu_ibus_data       ),
  .tcipif_bmu_ibus_data_vld    (tcipif_bmu_ibus_data_vld   ),
  .tcipif_bmu_ibus_grnt        (tcipif_bmu_ibus_grnt       ),
  .tcipif_bmu_ibus_trans_cmplt (tcipif_bmu_ibus_trans_cmplt)
);


//---------------------------------------------------------
// TCIPIF Connecting with Off-core IP
//---------------------------------------------------------
//--------------------------------------
//  Instance  interrupt controller module
//--------------------------------------
// &Instance("cr_clic_top"); @40
cr_clic_top  x_cr_clic_top (
  .clic_cpu_int_hv      (clic_cpu_int_hv     ),
  .clic_cpu_int_id      (clic_cpu_int_id     ),
  .clic_cpu_int_il      (clic_cpu_int_il     ),
  .clic_cpu_int_priv    (clic_cpu_int_priv   ),
  .clic_tcipif_cmplt    (vic_tcipif_cmplt    ),
  .clic_tcipif_rdata    (vic_tcipif_rdata    ),
  .clint_cpu_me_int     (clint_cpu_me_int    ),
  .clint_cpu_ms_int     (clint_cpu_ms_int    ),
  .clint_cpu_mt_int     (clint_cpu_mt_int    ),
  .cpu_clic_curid       (cpu_clic_curid      ),
  .cpu_clic_int_exit    (cpu_clic_int_exit   ),
  .cpu_clic_mode        (cp0_yy_priv_mode    ),
  .cpurst_b             (cpurst_b            ),
  .forever_cpuclk       (forever_cpuclk      ),
  .pad_clic_int_vld     (pad_clic_int_vld    ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b),
  .tcipif_clic_addr     (tcipif_xx_dbus_addr ),
  .tcipif_clic_sel      (tcipif_vic_sel      ),
  .tcipif_clic_size     (tcipif_vic_size     ),
  .tcipif_clic_wdata    (tcipif_xx_dbus_wdata),
  .tcipif_clic_write    (tcipif_xx_dbus_write)
);

// &Connect( @41
//          .tcipif_clic_addr     (tcipif_xx_dbus_addr  ), @42
//          .tcipif_clic_wdata    (tcipif_xx_dbus_wdata ), @43
//          .tcipif_clic_write    (tcipif_xx_dbus_write ), @44
//          .clic_pad_int_hv      (clic_cpu_int_hv       ), @45
//          .clic_pad_int_id      (clic_cpu_int_id     ), @46
//          .clic_pad_int_il      (clic_cpu_int_il       ), @47
//          .clic_pad_int_priv    (clic_cpu_int_priv       ), @48
//          .tcipif_clic_sel        (tcipif_vic_sel       ), @49
//          .tcipif_clic_size        (tcipif_vic_size       ), @50
//          .clic_tcipif_cmplt        (vic_tcipif_cmplt       ), @51
//          .clic_tcipif_rdata        (vic_tcipif_rdata       ), @52
//          .cpu_clic_mode          (cp0_yy_priv_mode       ), @53
//        ); @54
       
//  &Connect( @57
//     .clic_pad_int_sec    (clic_cpu_int_sec), @58
//   ); @59
//&Instance("cr_intc_top");
// //&Connect( @62
// //         .tcipif_vic_addr     (tcipif_xx_dbus_addr  ), @63
// //         .tcipif_vic_wdata    (tcipif_xx_dbus_wdata ), @64
// //         .tcipif_vic_write    (tcipif_xx_dbus_write ), @65
// //         .pad_vic_int_ack     (cpu_intc_int_ack     ), @66
// //         .pad_vic_intraw_ack  (cpu_intc_intraw_ack  ), @67
// //         .pad_vic_int_exit    (cpu_intc_int_exit    ), @68
// //         .pad_vic_int_vec     (cpu_intc_int_vec     ), @69
// //         .pad_vic_ack_vec     (cpu_intc_ack_vec     ), @70
// //         .vic_pad_int_b       (intc_cpu_int_b       ), @71
// //         .vic_pad_int_sec     (intc_cpu_int_sec     ), @72
// //         .vic_pad_int_vec_b   (intc_cpu_vec_b       ), @73
// //         .vic_pad_intraw_b    (intc_cpu_intraw_b    ), @74
// //        ); @75
// //&Connect( @77
// //         .pad_vic_int_pulse_0 (pad_vic_int_cfg      ), @78
// //         .pad_vic_int_src_0   (pad_vic_int_vld      ), @79
// //        ); @80
// //&Connect( @83
// //         .pad_vic_int_pulse_0 (pad_vic_int_cfg[0]   ), @84
// //         .pad_vic_int_pulse_1 (pad_vic_int_cfg[1]   ), @85
// //         .pad_vic_int_src_0   (pad_vic_int_vld[0]   ), @86
// //         .pad_vic_int_src_1   (pad_vic_int_vld[1]   ), @87
// //        ); @88
// //&Connect( @91
// //         .pad_vic_int_pulse_0 (pad_vic_int_cfg[0]   ), @92
// //         .pad_vic_int_pulse_1 (pad_vic_int_cfg[1]   ), @93
// //         .pad_vic_int_pulse_2 (pad_vic_int_cfg[2]   ), @94
// //         .pad_vic_int_pulse_3 (pad_vic_int_cfg[3]   ), @95
// //         .pad_vic_int_src_0   (pad_vic_int_vld[0]   ), @96
// //         .pad_vic_int_src_1   (pad_vic_int_vld[1]   ), @97
// //         .pad_vic_int_src_2   (pad_vic_int_vld[2]   ), @98
// //         .pad_vic_int_src_3   (pad_vic_int_vld[3]   ), @99
// //        ); @100
// //&Connect( @103
// //         .pad_vic_int_pulse_0 (pad_vic_int_cfg[0]   ), @104
// //         .pad_vic_int_pulse_1 (pad_vic_int_cfg[1]   ), @105
// //         .pad_vic_int_pulse_2 (pad_vic_int_cfg[2]   ), @106
// //         .pad_vic_int_pulse_3 (pad_vic_int_cfg[3]   ), @107
// //         .pad_vic_int_pulse_4 (pad_vic_int_cfg[4]   ), @108
// //         .pad_vic_int_pulse_5 (pad_vic_int_cfg[5]   ), @109
// //         .pad_vic_int_pulse_6 (pad_vic_int_cfg[6]   ), @110
// //         .pad_vic_int_pulse_7 (pad_vic_int_cfg[7]   ), @111
// //         .pad_vic_int_src_0   (pad_vic_int_vld[0]   ), @112
// //         .pad_vic_int_src_1   (pad_vic_int_vld[1]   ), @113
// //         .pad_vic_int_src_2   (pad_vic_int_vld[2]   ), @114
// //         .pad_vic_int_src_3   (pad_vic_int_vld[3]   ), @115
// //         .pad_vic_int_src_4   (pad_vic_int_vld[4]   ), @116
// //         .pad_vic_int_src_5   (pad_vic_int_vld[5]   ), @117
// //         .pad_vic_int_src_6   (pad_vic_int_vld[6]   ), @118
// //         .pad_vic_int_src_7   (pad_vic_int_vld[7]   ), @119
// //        ); @120
// //&Connect( @123
// //         .pad_vic_int_pulse_8 (pad_vic_int_cfg[8]   ), @124
// //         .pad_vic_int_pulse_9 (pad_vic_int_cfg[9]   ), @125
// //         .pad_vic_int_pulse_10(pad_vic_int_cfg[10]  ), @126
// //         .pad_vic_int_pulse_11(pad_vic_int_cfg[11]  ), @127
// //         .pad_vic_int_pulse_12(pad_vic_int_cfg[12]  ), @128
// //         .pad_vic_int_pulse_13(pad_vic_int_cfg[13]  ), @129
// //         .pad_vic_int_pulse_14(pad_vic_int_cfg[14]  ), @130
// //         .pad_vic_int_pulse_15(pad_vic_int_cfg[15]  ), @131
// //         .pad_vic_int_src_8   (pad_vic_int_vld[8]   ), @132
// //         .pad_vic_int_src_9   (pad_vic_int_vld[9]   ), @133
// //         .pad_vic_int_src_10  (pad_vic_int_vld[10]  ), @134
// //         .pad_vic_int_src_11  (pad_vic_int_vld[11]  ), @135
// //         .pad_vic_int_src_12  (pad_vic_int_vld[12]  ), @136
// //         .pad_vic_int_src_13  (pad_vic_int_vld[13]  ), @137
// //         .pad_vic_int_src_14  (pad_vic_int_vld[14]  ), @138
// //         .pad_vic_int_src_15  (pad_vic_int_vld[15]  ), @139
// //        ); @140
// //&Connect( @143
// //         .pad_vic_int_pulse_16(pad_vic_int_cfg[16]  ), @144
// //         .pad_vic_int_pulse_17(pad_vic_int_cfg[17]  ), @145
// //         .pad_vic_int_pulse_18(pad_vic_int_cfg[18]  ), @146
// //         .pad_vic_int_pulse_19(pad_vic_int_cfg[19]  ), @147
// //         .pad_vic_int_pulse_20(pad_vic_int_cfg[20]  ), @148
// //         .pad_vic_int_pulse_21(pad_vic_int_cfg[21]  ), @149
// //         .pad_vic_int_pulse_22(pad_vic_int_cfg[22]  ), @150
// //         .pad_vic_int_pulse_23(pad_vic_int_cfg[23]  ), @151
// //         .pad_vic_int_src_16  (pad_vic_int_vld[16]  ), @152
// //         .pad_vic_int_src_17  (pad_vic_int_vld[17]  ), @153
// //         .pad_vic_int_src_18  (pad_vic_int_vld[18]  ), @154
// //         .pad_vic_int_src_19  (pad_vic_int_vld[19]  ), @155
// //         .pad_vic_int_src_20  (pad_vic_int_vld[20]  ), @156
// //         .pad_vic_int_src_21  (pad_vic_int_vld[21]  ), @157
// //         .pad_vic_int_src_22  (pad_vic_int_vld[22]  ), @158
// //         .pad_vic_int_src_23  (pad_vic_int_vld[23]  ), @159
// //        ); @160
// //&Connect( @163
// //         .pad_vic_int_pulse_24(pad_vic_int_cfg[24]  ), @164
// //         .pad_vic_int_pulse_25(pad_vic_int_cfg[25]  ), @165
// //         .pad_vic_int_pulse_26(pad_vic_int_cfg[26]  ), @166
// //         .pad_vic_int_pulse_27(pad_vic_int_cfg[27]  ), @167
// //         .pad_vic_int_pulse_28(pad_vic_int_cfg[28]  ), @168
// //         .pad_vic_int_pulse_29(pad_vic_int_cfg[29]  ), @169
// //         .pad_vic_int_pulse_30(pad_vic_int_cfg[30]  ), @170
// //         .pad_vic_int_pulse_31(pad_vic_int_cfg[31]  ), @171
// //         .pad_vic_int_src_24  (pad_vic_int_vld[24]  ), @172
// //         .pad_vic_int_src_25  (pad_vic_int_vld[25]  ), @173
// //         .pad_vic_int_src_26  (pad_vic_int_vld[26]  ), @174
// //         .pad_vic_int_src_27  (pad_vic_int_vld[27]  ), @175
// //         .pad_vic_int_src_28  (pad_vic_int_vld[28]  ), @176
// //         .pad_vic_int_src_29  (pad_vic_int_vld[29]  ), @177
// //         .pad_vic_int_src_30  (pad_vic_int_vld[30]  ), @178
// //         .pad_vic_int_src_31  (pad_vic_int_vld[31]  ), @179
// //        ); @180
// &Instance("cr_clic_top_dummy"); @185
// &Connect(.cpuclk    (forever_cpuclk_nogated)); @186
// &Connect(.cpurst_b  (cpurst_b)); @187


// &Instance("cr_seu_top"); @204

// &Instance("cr_seu_bist_top"); @211

// &Instance("cr_pwrm_top"); @218
// &Connect( @219
//          .tcipif_pwrm_addr  (tcipif_xx_dbus_addr ), @220
//          .tcipif_pwrm_wdata (tcipif_xx_dbus_wdata), @221
//          .tcipif_pwrm_write (tcipif_xx_dbus_write) @222
//         ); @223
// &Instance("cr_pwrm_top_dummy"); @225
cr_pwrm_top_dummy  x_cr_pwrm_top_dummy (
  .pwrm_cpu_bus_peak_power_limit_en (pwrm_cpu_bus_peak_power_limit_en)
);


// // &Connect( @233
// //          .cpurst_b                  (cpurst_b               ), @234
// //          .forever_cpuclk            (forever_cpuclk         ), @235
// //          .forever_cpuclk_nogated    (forever_cpuclk_nogated ), @236
// //          .tcipif_coretim_addr       (tcipif_xx_dbus_addr    ), @237
// //          .tcipif_coretim_wdata      (tcipif_xx_dbus_wdata   ), @238
// //          .tcipif_coretim_write      (tcipif_xx_dbus_write   ), @239
// //          .ctim_pad_int_vld          (ctim_pad_int_vld       ), @240
// //          .pad_ctim_refclk           (pad_ctim_refclk        ), @241
// //          .core_dbgon                (iu_yy_xx_dbgon         ), @242
// //          .pad_ctim_calib            (pad_ctim_calib         ), @243
// //         ); @244
// &Instance("cr_coretim_top_dummy"); @245
// &Instance("cr_coretim_top_dummy"); @247
cr_coretim_top_dummy  x_cr_coretim_top_dummy (
  .iu_yy_xx_dbgon (iu_yy_xx_dbgon)
);




//to HAD
assign tcipif_had_sel             = tcipif_had_img_sel;
assign tcipif_had_addr[15:0]      = tcipif_xx_dbus_addr[15:0];
assign tcipif_had_write           = tcipif_xx_dbus_write;
assign tcipif_had_wdata[31:0]     = tcipif_xx_dbus_wdata[31:0];
//from HAD
assign had_img_tcipif_cmplt       = had_tcipif_cmplt;
assign had_img_tcipif_rdata[31:0] = had_tcipif_rdata[31:0];
// &Force("output","tcipif_xx_dbus_sec"); @268

// &Instance("cr_cmmu_top"); @276

//==========================================================
//  Instance CLINT module
//==========================================================
// &Instance("cr_clint_top"); @282
cr_clint_top  x_cr_clint_top (
  .clint_cpu_me_int     (clint_cpu_me_int    ),
  .clint_cpu_ms_int     (clint_cpu_ms_int    ),
  .clint_cpu_mt_int     (clint_cpu_mt_int    ),
  .clint_tcipif_cmplt   (clint_tcipif_cmplt  ),
  .clint_tcipif_rdata   (clint_tcipif_rdata  ),
  .cpu_clint_mode       (cp0_yy_priv_mode    ),
  .cpurst_b             (cpurst_b            ),
  .forever_cpuclk       (forever_cpuclk      ),
  .pad_yy_gate_clk_en_b (pad_yy_gate_clk_en_b),
  .sysio_clint_me_int   (sysio_clint_me_int  ),
  .sysio_clint_mtime    (sysio_clint_mtime   ),
  .tcipif_clint_addr    (tcipif_xx_dbus_addr ),
  .tcipif_clint_sel     (tcipif_clint_sel    ),
  .tcipif_clint_wdata   (tcipif_xx_dbus_wdata),
  .tcipif_clint_write   (tcipif_xx_dbus_write)
);

// &Connect( @283
//          .tcipif_clint_addr       (tcipif_xx_dbus_addr    ), @284
//          .tcipif_clint_wdata      (tcipif_xx_dbus_wdata   ), @285
//          .tcipif_clint_write      (tcipif_xx_dbus_write   ), @286
//          .cpu_clint_mode          (cp0_yy_priv_mode       ), @287
//         ); @288

// &Force("output", "clint_cpu_me_int"); @290

// &ModuleEnd; @292
endmodule


/*Copyright 2018-2021 T-Head Semiconductor Co., Ltd.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

module gated_clk_cell(
  clk_in,
  global_en,
  module_en,
  local_en,
  external_en,
  pad_yy_gate_clk_en_b,
  clk_out
);

input  clk_in;
input  global_en;
input  module_en;
input  local_en;
input  external_en;
input  pad_yy_gate_clk_en_b;
output clk_out;

wire   clk_en_bf_latch;
wire   SE;

assign clk_en_bf_latch = (global_en && (module_en || local_en)) || external_en ;

// SE driven from primary input, held constant
assign SE	       = pad_yy_gate_clk_en_b;
 
// //   &Connect(    .clk_in           (clk_in), @50
// //                .SE               (SE), @51
// //                .external_en      (clk_en_bf_latch), @52
// //                .clk_out          (clk_out) @53
// //                ) ; @54
assign clk_out = clk_in;

endmodule   
